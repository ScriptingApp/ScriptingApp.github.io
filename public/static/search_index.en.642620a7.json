[{"id":0,"title":"","content":"The Assistant module provides a powerful API that allows users to request\nstructured JSON data from the assistant. This functionality can be used for\nautomation tasks such as extracting bill details, categorizing expenses, or\nparsing text data.\n\n\nisAvailable Variable#\n\n\nDescription#\n\nIndicates whether the Assistant API is available.\n\n * This status depends on the selected AI provider and whether a valid API Key\n   is configured.\n * If the appropriate API Key is not provided, the Assistant API will be\n   unavailable.\n\n\nrequestStructuredData Method#\n\n\nDescription#\n\nrequestStructuredData allows users to send a text prompt to the assistant and\nreceive structured data in JSON format based on a defined schema.\n\n\nSyntax#\n\nfunction requestStructuredData<R>(prompt: string, schema: JSONSchemaArray | JSONSchemaObject): Promise<R>;\n\n\n\nParameters#\n\n * prompt (string): The input prompt describing the content to be parsed.\n * schema (JSONSchemaArray | JSONSchemaObject): The expected output JSON schema,\n   defining the structure of the returned data.\n\n\nReturn Value#\n\nReturns a Promise resolving to structured JSON data that matches the schema\ndefinition, with a type of R.\n\n--------------------------------------------------------------------------------\n\n\nJSON Schema Definition#\n\nThe schema parameter in the requestStructuredData method defines the structure\nof the returned JSON data, with the following types:\n\n\nJSONSchemaType#\n\ntype JSONSchemaType = JSONSchemaPrimitive | JSONSchemaArray | JSONSchemaObject;\n\n\nPrimitive data type definition:\n\ntype JSONSchemaPrimitive = {\n    type: \"string\" | \"number\" | \"boolean\";\n    required?: boolean;\n    description: string;\n};\n\n\nArray type definition:\n\ntype JSONSchemaArray = {\n    type: \"array\";\n    items: JSONSchemaType;\n    required?: boolean;\n    description: string;\n};\n\n\nObject type definition:\n\ntype JSONSchemaObject = {\n    type: \"object\";\n    properties: Record<string, JSONSchemaType>;\n    required?: boolean;\n    description: string;\n};\n\n\n\nExample#\n\nconst schema: JSONSchemaObject = {\n    type: \"object\",\n    properties: {\n        totalAmount: {\n            type: \"number\",\n            required: true,\n            description: \"Total bill amount\",\n        },\n        category: {\n            type: \"string\",\n            required: true,\n            description: \"Bill category\",\n        },\n        date: {\n            type: \"string\",\n            required: false,\n            description: \"Bill date\",\n        },\n        location: {\n            type: \"string\",\n            required: false,\n            description: \"Bill location\",\n        },\n    },\n};\n\n\n--------------------------------------------------------------------------------\n\n\nExample Usage#\n\n\nParsing Bill Information#\n\nSuppose we have a bill, and we need to extract its amount, date, category, and\nlocation.\n\nconst someBillDetails = `\n- Amount: $15.00\n- Date: 2024-03-11 14:30\n- Location: City Center Parking Lot\n- Category: Parking\n`;\n\nconst prompt = `Please parse the following bill and output the structured data: ${someBillDetails}`;\n\nconst data = await Assistant.requestStructuredData(prompt, schema);\nconsole.log(data);\n\n\n\nPossible Output#\n\n{\n    \"totalAmount\": 15.0,\n    \"category\": \"Parking\",\n    \"date\": \"2024-03-11 14:30\",\n    \"location\": \"City Center Parking Lot\"\n}\n\n\n--------------------------------------------------------------------------------\n\n\nUsage Considerations#\n\n 1. Ensure the schema is correctly defined: The JSON schema should match the\n    expected data format.\n 2. Use required attributes carefully: If a field is essential, set required:\n    true.\n 3. Provide a clear prompt: A detailed prompt improves the accuracy of the\n    assistant's response.\n 4. Error Handling: Since requestStructuredData returns a Promise, handle\n    potential errors using try-catch.\n\nExample error handling:\n\ntry {\n    const data = await Assistant.requestStructuredData(prompt, schema);\n    console.log(\"Parsed result:\", data);\n} catch (error) {\n    console.error(\"Parsing failed:\", error);\n}\n","routePath":"/en/guide/docs/assistant","lang":"en","toc":[{"text":"`isAvailable` Variable","id":"isavailable-variable","depth":2,"charIndex":-1},{"text":"Description","id":"description","depth":3,"charIndex":270},{"text":"`requestStructuredData` Method","id":"requeststructureddata-method","depth":2,"charIndex":-1},{"text":"Description","id":"description-1","depth":3,"charIndex":555},{"text":"Syntax","id":"syntax","depth":3,"charIndex":715},{"text":"Parameters","id":"parameters","depth":3,"charIndex":834},{"text":"Return Value","id":"return-value","depth":3,"charIndex":1052},{"text":"JSON Schema Definition","id":"json-schema-definition","depth":2,"charIndex":1257},{"text":"`JSONSchemaType`","id":"jsonschematype","depth":3,"charIndex":-1},{"text":"Example","id":"example","depth":3,"charIndex":1997},{"text":"Example Usage","id":"example-usage","depth":2,"charIndex":2692},{"text":"Parsing Bill Information","id":"parsing-bill-information","depth":3,"charIndex":2709},{"text":"Possible Output","id":"possible-output","depth":3,"charIndex":3146},{"text":"Usage Considerations","id":"usage-considerations","depth":2,"charIndex":3379}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"Assistant Tool","content":"#\n\nAssistant Tool is a system extension mechanism within the Scripting application\nthat enhances the capabilities of an intelligent assistant (Assistant). By\ndefining and implementing an Assistant Tool, developers can provide the\nAssistant with auxiliary functionalities such as device capability access, file\nreading/writing, and data analysis. This improves both the intelligence and\npracticality of the Assistant.\n\nThis document uses an example tool, \"Request Current Location\", to illustrate\nthe full implementation process, including tool creation, configuration file\nexplanation, execution logic, and detailed descriptions of various functions.\n\n--------------------------------------------------------------------------------\n\n\n1. Tool Creation Process#\n\n 1. Open any scripting project and click the “Add Assistant Tool” button in the\n    file manager interface.\n 2. Fill in the relevant information about the Assistant Tool in the\n    configuration popup window.\n 3. After clicking “Save,” the system will automatically generate two files in\n    the script:\n\n * assistant_tool.json: Describes the tool’s metadata and parameter information.\n * assistant_tool.tsx: Implements the tool’s execution logic.\n\n--------------------------------------------------------------------------------\n\n\n2. Configuration File: assistant_tool.json#\n\nThis file declares the basic information and behavior settings of the tool.\nBelow is a sample content and explanation of each field:\n\n{\n    \"displayName\": \"Request Current Location\",\n    \"id\": \"request_current_location\",\n    \"description\": \"This tool allows you to request the one-time delivery of the latitude and longitude of the user’s current location.\",\n    \"icon\": \"location.fill\",\n    \"color\": \"systemBlue\",\n    \"parameters\": [],\n    \"requireApproval\": true,\n    \"autoApprove\": true,\n    \"scriptEditorOnly\": false\n}\n\n\n\nField Descriptions:#\n\nFIELD              TYPE      DESCRIPTION\ndisplayName        string    Name displayed in the UI\nid                 string    Unique identifier for the tool (must be unique)\ndescription        string    Description of the tool’s functionality\nicon               string    Name of the SF Symbols icon used\ncolor              string    Primary color of the tool\nparameters         array     Parameters required by the tool (empty means no input)\nrequireApproval    boolean   Whether user approval is required\nautoApprove        boolean   Whether Assistant can auto-approve\nscriptEditorOnly   boolean   Whether the tool can only be used in the script editor\n\n--------------------------------------------------------------------------------\n\n\n3. Execution Logic Example: assistant_tool.tsx#\n\ntype RequestCurrentLocationParams = {};\n\nconst locationApprovalRequest: AssistantToolApprovalRequestFn<RequestCurrentLocationParams> = async (\n    params\n) => {\n    return {\n        message: \"The assistant wants to request your current location.\",\n        primaryButtonLabel: \"Allow\",\n    };\n};\n\nconst requestCurrentLocation: AssistantToolExecuteWithApprovalFn<RequestCurrentLocationParams> = async (\n    params,\n    { primaryConfirmed, secondaryConfirmed }\n) => {\n    try {\n        const location = await Location.requestCurrent();\n        if (location) {\n            return {\n                success: true,\n                message: [\n                    \"The user's current location info:\",\n                    `<latitude>${location.latitude}</latitude>`,\n                    `<longitude>${location.longitude}</longitude>`,\n                ].join(\"\\n\"),\n            };\n        }\n        return {\n            success: false,\n            message:\n                \"Failed to request user's current location, ask user to check the device's location permission.\",\n        };\n    } catch {\n        return {\n            success: false,\n            message:\n                \"Failed to request user's current location, ask user to check the device's location permission.\",\n        };\n    }\n};\n\nconst testRequestLocationApprovalFn = AssistantTool.registerApprovalRequest(locationApprovalRequest);\n\nconst testRequestLocationExecuteFn = AssistantTool.registerExecuteToolWithApproval(requestCurrentLocation);\n\n// Test the tool in the script editor:\ntestRequestLocationApprovalFn({});\ntestRequestLocationExecuteFn(\n    {},\n    {\n        primaryConfirmed: true,\n        secondaryConfirmed: false,\n    }\n);\n\n\n--------------------------------------------------------------------------------\n\n\n4. AssistantTool Registration Functions Explained#\n\n\n1. registerApprovalRequest#\n\nRegisters a function to request user approval before executing the tool.\n\nfunction registerApprovalRequest<P>(\n    requestFn: AssistantToolApprovalRequestFn<P>\n): AssistantToolApprovalRequestTestFn<P>;\n\n\nParameters:\n\n * requestFn(params, scriptEditorProvider?): Returns a prompt with messages and\n   button labels.\n * params: Input parameters for the tool.\n * scriptEditorProvider: Available only when scriptEditorOnly is set to true,\n   provides file access for the script.\n\nReturn Value:\n\nA test function for simulating approval requests in the script editor.\n\n--------------------------------------------------------------------------------\n\n\n2. registerExecuteToolWithApproval#\n\nRegisters an execution function that requires user approval.\n\nfunction registerExecuteToolWithApproval<P>(\n    executeFn: AssistantToolExecuteWithApprovalFn<P>\n): AssistantToolExecuteWithApprovalTestFn<P>;\n\n\nParameters:\n\n * params: Input parameters for execution.\n * userAction: User's choice in the approval prompt:\n\ntype UserActionForApprovalRequest = {\n    primaryConfirmed: boolean;\n    secondaryConfirmed: boolean;\n};\n\n\n * scriptEditorProvider: Same as above.\n\nReturn Value:\n\nReturns an object:\n\n{\n    success: boolean;\n    message: string;\n}\n\n\n * success: Whether execution succeeded.\n * message: Message returned to the Assistant.\n\n--------------------------------------------------------------------------------\n\n\n3. registerExecuteTool#\n\nRegisters a tool that does not require user approval.\n\nfunction registerExecuteTool<P>(executeFn: AssistantToolExecuteFn<P>): AssistantToolExecuteTestFn<P>;\n\n\nUse Case: Suitable for non-sensitive operations or those that don’t involve\ndevice permissions.\n\n--------------------------------------------------------------------------------\n\n\n4. Testing Functions#\n\nEach registration function returns a test function that can be used in the\nscript:\n\ntestApprovalRequestFn({ ...params });\ntestExecuteFn(\n    { ...params },\n    {\n        primaryConfirmed: true,\n        secondaryConfirmed: false,\n    }\n);\ntestExecuteToolFn({ ...params });\n\n\n--------------------------------------------------------------------------------\n\n\n5. ScriptEditorProvider Interface#\n\nWhen scriptEditorOnly: true is set, the system provides a ScriptEditorProvider\ninterface that allows access to the script project’s file system and syntax\ninfo.\n\nCapabilities include:\n\n * File read/write (read, update, write, insert, replace)\n * Diff comparison (openDiffEditor)\n * Linting results (getLintErrors)\n * List all files/folders in the project\n\nUseful for tools that edit scripts, perform formatting, or batch modifications.\n\n--------------------------------------------------------------------------------\n\n\n6. Execution and User Experience Flow#\n\n 1. The Assistant determines whether to invoke a tool during a conversation.\n 2. If the tool requires approval, a dialog box is displayed:\n    * The prompt is provided by registerApprovalRequest.\n    * Once the user clicks “Allow,” the tool logic is executed.\n 3. Execution results are returned to the Assistant through the message field,\n    and shown to the user.\n\n--------------------------------------------------------------------------------\n\n\n7. Tools That Don’t Require Approval#\n\nIf you don’t want to show an approval prompt, simply use registerExecuteTool and\nset requireApproval: false in assistant_tool.json.\n\nAssistantTool.registerExecuteTool<MyParams>(async (params) => {\n    return {\n        success: true,\n        message: \"Tool executed successfully.\",\n    };\n});\n\n\n--------------------------------------------------------------------------------\n\n\n8. Summary#\n\nAssistant Tool is an extensible module provided by the Scripting application,\nsupporting scenarios such as user authorization, file manipulation, and\nsystem-level access. The development process includes:\n\n 1. Creating the tool in a scripting project;\n 2. Configuring its metadata;\n 3. Implementing and registering the logic functions;\n 4. Testing tool behavior with test functions;\n 5. Triggering tool execution automatically or manually within Assistant\n    conversations.","routePath":"/en/guide/docs/assistant_tool","lang":"en","toc":[{"text":"1. Tool Creation Process","id":"1-tool-creation-process","depth":2,"charIndex":734},{"text":"2. Configuration File: `assistant_tool.json`","id":"2-configuration-file-assistant_tooljson","depth":2,"charIndex":-1},{"text":"Field Descriptions:","id":"field-descriptions","depth":3,"charIndex":1864},{"text":"3. Execution Logic Example: `assistant_tool.tsx`","id":"3-execution-logic-example-assistant_tooltsx","depth":2,"charIndex":-1},{"text":"4. AssistantTool Registration Functions Explained","id":"4-assistanttool-registration-functions-explained","depth":2,"charIndex":4450},{"text":"1. `registerApprovalRequest`","id":"1-registerapprovalrequest","depth":3,"charIndex":-1},{"text":"2. `registerExecuteToolWithApproval`","id":"2-registerexecutetoolwithapproval","depth":3,"charIndex":-1},{"text":"3. `registerExecuteTool`","id":"3-registerexecutetool","depth":3,"charIndex":-1},{"text":"4. Testing Functions","id":"4-testing-functions","depth":3,"charIndex":6301},{"text":"5. ScriptEditorProvider Interface","id":"5-scripteditorprovider-interface","depth":2,"charIndex":6681},{"text":"6. Execution and User Experience Flow","id":"6-execution-and-user-experience-flow","depth":2,"charIndex":7237},{"text":"7. Tools That Don’t Require Approval","id":"7-tools-that-dont-require-approval","depth":2,"charIndex":7727},{"text":"8. Summary","id":"8-summary","depth":2,"charIndex":8143}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"Overview","content":"","routePath":"/en/guide/docs/","lang":"en","toc":[],"domain":"","frontmatter":{"overview":true,"title":"Overview"},"version":""},{"id":3,"title":"Change Log","content":"#\n\n\n2024-09-11#\n\n\n新增#\n\n * 支持解析账单信息，提取金额、日期、分类和地点信息。\n * 新增示例用法，展示如何使用 Assistant.requestStructuredData 解析账单。","routePath":"/en/guide/start/changelog","lang":"en","toc":[{"text":"2024-09-11","id":"2024-09-11","depth":2,"charIndex":3},{"text":"新增","id":"新增","depth":3,"charIndex":17}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"Welcome to Scripting!","content":"#\n\n\n探索 Scripting 的强大功能#\n\n使用我们强大的 TypeScript 和 TSX 开发环境轻松创建和运行脚本。通过高级功能自定义您的体验，以提升生产力。\n\n\n主要功能#\n\n可自定义的编辑器主题和字体 高级调试工具 与 iOS 小组件无缝集成 支持 App Intents 和丰富通知\n\n查看文档\n\n\n开始使用#\n\n立即下载应用，开始构建令人惊叹的脚本。\n\n在 App Store 下载","routePath":"/en/guide/start/","lang":"en","toc":[{"text":"探索 Scripting 的强大功能","id":"探索-scripting-的强大功能","depth":2,"charIndex":3},{"text":"主要功能","id":"主要功能","depth":2,"charIndex":87},{"text":"开始使用","id":"开始使用","depth":2,"charIndex":158}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"Learn More","content":"#\n\n\n探索 Scripting 的强大功能#\n\n编写代码：支持 TypeScript","routePath":"/en/guide/start/more","lang":"en","toc":[{"text":"探索 Scripting 的强大功能","id":"探索-scripting-的强大功能","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""}]