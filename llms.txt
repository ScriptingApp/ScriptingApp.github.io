# Scripting

## Documentation

- [AppIntent](/doc/AppIntent.md): AppIntentManager is used to register and manage AppIntents in the Scripting app. It serves as the core mechanism for executing script logic behind controls in Widgets, Live Activities, and ControlWidgets. All AppIntents must be defined in the app_intents.tsx file. When an intent is executed, the script runs in the "app_intents" environment (Script.env === "app_intents"). Once registered, these intents can be triggered by Button and Toggle controls within Widgets, Live Activities, or ControlWidgets, allowing users to define interactive behavior via script.
- [Assistant Conversation APIs <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Assistant/Assistant Conversation APIs.md): The Conversation APIs are used to start, control, and present a system-hosted Assistant chat session.
A conversation corresponds to a fully managed chat page, where Scripting handles the UI, streaming output, provider selection, and message lifecycle. Key differences from other Assistant APIs: Conversation APIs are designed for interactive chat experiencesUI, streaming, and message handling are managed by the systemDevelopers control when the conversation starts, ends, and is shown
- [Assistant Quick Start <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Assistant/Assistant Quick Start.md): The Assistant API in Scripting provides three distinct capabilities, each designed for a different type of use case: structured data, streaming output, and interactive conversations. Before choosing an API, first decide what kind of result you need.
- [requestStreaming <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Assistant/requestStreaming.md): requestStreaming requests a streaming response from the Assistant.
Instead of returning a complete result at once, the Assistant emits chunks incrementally as the model generates output. This enables: Real-time UI updates (typing effect)Low-latency handling of long responsesProgressive rendering of resultsStreaming logs and intermediate output handling The API returns a ReadableStream<StreamChunk>, which can be consumed using for await ... of.
- [requestStructuredData <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Assistant/requestStructuredData.md): requestStructuredData requests structured JSON output from the assistant that conforms to a provided JSON schema.
This API is designed for workflows where you want a predictable, programmatically usable result rather than free-form text. Common use cases include: Extracting structured fields from natural languageParsing invoices, receipts, and ticketsGenerating configuration objectsNormalizing data across different AI providers/models
- [AssistantTool <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/AssistantTool.md): Assistant Tool is a system extension mechanism within the Scripting application that enhances the capabilities of an intelligent assistant (Assistant). By defining and implementing an Assistant Tool, developers can provide the Assistant with auxiliary functionalities such as device capability access, file reading/writing, and data analysis. This improves both the intelligence and practicality of the Assistant. This document uses an example tool, "Request Current Location", to illustrate the full implementation process, including tool creation, configuration file explanation, execution logic, and detailed descriptions of various functions.
- [Animation and Transition](/doc/Changelog/2.4.3/Animation and Transition.md): Scripting Animation & Transition System The Animation class describes how values animate in time.
- [EnvironmentValuesReader](/doc/Changelog/2.4.3/EnvironmentValuesReader.md): EnvironmentValuesReader is a Scripting component that allows you to read environment values from the current view hierarchy.
It serves a similar role to SwiftUI’s @Environment, but with a more explicit and controlled design:
You must specify which environment keys you want to read, and the component will inject only those values into the children callback. This makes environment access predictable, explicit, and optimized. Below are the descriptions of each field. 1. colorScheme Type: ColorScheme
The current system color appearance (light or dark). 2. colorSchemeContrast Type: ColorSchemeContrast
Represents contrast settings such as standard or increased. 3. displayScale Type: number
The display scale factor of the device (e.g., 2.0, 3.0). 4. horizontalSizeClass Type: UserInterfaceSizeClass | null
The horizontal size class of the current environment: compact or regular. 5. verticalSizeClass Type: UserInterfaceSizeClass | null
The vertical size class, same categories as above. 6. dismiss Type: () => void
A function to dismiss the currently presented view (equivalent to SwiftUI’s dismiss()). 7. dismissSearch Type: () => void
A function that dismisses the current searchable field, if active. 8. editMode Type: EditMode | null
Indicates whether the view is in editing mode (e.g., during List editing). 9. widgetRenderingMode Type: WidgetRenderingMode
The current widget rendering mode (e.g., fullColor, accented). 10. showsWidgetContainerBackground Type: boolean
Indicates whether the widget is showing the system-provided container background. 11. isSearching Type: boolean
Whether the view is currently in a searching state triggered by searchable. 12. isPresented Type: boolean
Whether the view is currently being shown, unlike onAppear which is called every time the view appears, isPresented is called only once when the view is first shown. 13. activityFamily Type: "small" | "medium"
The current LiveActivity size, similar to SwiftUI's activityFamily, used to determine the size of LiveActivity UI. 14. tabViewBottomAccessoryPlacement Type: 'expanded' | 'inline'
The current TabView bottom accessory placement, similar to SwiftUI's tabViewBottomAccessoryPlacement. keys Type: Array<keyof EnvironmentValues>
Specifies exactly which environment keys you want to read.
Only these keys will be retrieved and passed to the callback. children(values) Type: (values: EnvironmentValues) => VirtualNode
A rendering callback that receives the requested environment values and returns the corresponding view.
- [ForEach](/doc/Changelog/2.4.3/ForEach/index.md): The ForEach component renders a dynamic list of child views. It is used to display collections, create editable lists, and enable system-standard interactions such as swipe-to-delete. It is fully integrated with the Scripting app’s Observable state system and mirrors the design of SwiftUI’s ForEach. ForEach supports two usage modes: Deprecated mode: count + itemBuilderRecommended mode: data: Observable<T[]> + builder
- [Example](/doc/Changelog/2.4.3/ForEach/iterating.md)
- [GeometryReader](/doc/Changelog/2.4.3/GeometryReader.md): GeometryReader in Scripting is the equivalent of SwiftUI’s GeometryReader. It provides layout information about the container in which its content is placed, including size, safe-area insets, and (on supported systems) container corner insets. This component is essential for building responsive layouts that depend on the parent container’s geometry. When GeometryReader constructs its child content, it injects a GeometryProxy instance into the children callback. This proxy exposes real-time layout information about the container.
- [LiveActivity View Modifiers](/doc/Changelog/2.4.3/LiveActivity View Modifiers.md): Scripting provides two view modifiers that customize the appearance of Live Activities on the Lock Screen. These modifiers control the background tint color of the Live Activity and the foreground color of the system-provided action button. These properties are designed to match SwiftUI’s Live Activity customization options. These modifiers can only be applied to the content view of the Live Activity UI. They do not take effect when placed in: compactLeadingcompactTrailingminimal Only the full-size Lock Screen presentation (the content region) supports these appearance customizations.
- [LiveActivity](/doc/Changelog/2.4.3/LiveActivity.md): The LiveActivity API enables you to display real-time, dynamic information from your script on the Lock Screen and, where supported, in the Dynamic Island on iOS devices. It provides a structured interface to start, update, and end Live Activities, and observe their state throughout their lifecycle. This document provides a complete guide to using the LiveActivity API in the Scripting app, including: Core concepts and lifecycleHow to register a Live Activity UIHow to start, update, and end Live ActivitiesUI layout for Dynamic Island and Lock ScreenFull TypeScript/TSX examplesDetailed descriptions of every type and option The API wraps Apple’s ActivityKit and brings it into the Scripting environment with a React-style UI building approach. A Live Activity can appear in the following regions: Lock ScreenDynamic Island (iPhone 14 Pro and later)Banner-style presentation on devices without Dynamic Island Live Activities are used for time-based and progress-based information, such as: TimersFitness progressDelivery trackingCountdowns and remindersReal-time status updates In Scripting, each Live Activity consists of: contentState (a JSON-serializable object that updates over time)UI Builder (a function that produces TSX UI for each state) Represents a summary of each active Live Activity.
- [ReorderableForEach](/doc/Changelog/2.4.3/ReorderableForEach/index.md): ReorderableForEach is a high-level component in Scripting that provides built-in drag-to-reorder capability.
It preserves the familiar usage pattern of ForEach while adding native support for: Drag gesture recognitionActive item trackingManual reorder callbacks This allows developers to implement sortable lists and grids with minimal effort. Typical use cases include: Draggable card layoutsReorderable grids (LazyVGrid, LazyHGrid)User-defined module arrangements
- [Example](/doc/Changelog/2.4.3/ReorderableForEach/index_example.md)
- [SSH Client <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.3/SSH Client.md): The SSHClient class provides an interface for connecting to a remote SSH server, executing commands, opening TTY or PTY sessions, transferring files via SFTP, and performing multi-hop SSH jumps. It supports both command-based and interactive terminal-based workflows. This class is central to establishing and managing SSH sessions in your script.
- [ScrollViewReader](/doc/Changelog/2.4.3/ScrollViewReader.md): The ScrollViewReader component equivalent to SwiftUI’s ScrollViewReader, allowing scripts to programmatically control scrolling position within scrollable content such as List or ScrollView. ScrollViewProxy represents the programmatic interface for controlling scrolling. It is provided by ScrollViewReader during rendering.
- [Set environment values (environments)](/doc/Changelog/2.4.3/Set environment values (environments).md): The environments view modifier allows injecting specific environment values into the current view hierarchy.
It serves a role similar to SwiftUI’s .environment(), but with a more explicit and controlled design tailored for Scripting. Currently, the modifier supports: editMode — controls editing behavior in views such as ListopenURL — customizes how links are handled when tapped These environment values affect all descendants within the modified view subtree. The editMode environment value controls the editing state of views that support editing behavior, such as List with row deletion or movement. It must be provided as an Observable<EditMode> so views can reactively update when the editing state changes.
- [Thread](/doc/Changelog/2.4.3/Thread.md): Scripting’s UI rendering system and the vast majority of JavaScript execution run on the main thread by default. In normal usage, developers rarely need to manually switch threads. However, some system APIs or internal operations may occasionally execute on a background thread. To ensure UI updates are always safe, and to support running heavy work without blocking the main thread, Scripting provides the global Thread API. Thread is a global namespace and does not require imports.
- [useObservable](/doc/Changelog/2.4.3/useObservable.md): Scripting provides a reactive state system formed by Observable<T> and the useObservable<T> hook.
This system drives UI updates, interacts with the animation engine, and aligns closely with SwiftUI’s binding model—enabling future APIs such as List(selection:), NavigationStack(path:), TextField(text:), and more. Observable<T> is a reactive container that holds a mutable value.
Whenever the value changes, any UI components that read this value are automatically re-rendered.
- [ConcentricRectangle](/doc/Changelog/2.4.4/ConcentricRectangle.md): ConcentricRectangle is a concentric rectangle shape view introduced in iOS 26+. It is designed to create rectangles with progressively inset (concentric) corner geometry, which adapts naturally to modern UI designs. It is especially suitable for: Glass-style buttonsCard backgroundsInteractive clipping regionsGlass transition masksLayered container UI In Scripting, ConcentricRectangle can be used both as: A standalone Shape viewA specialized shape inside:clipShapebackgroundcontentShape
- [Glass Effect Transition](/doc/Changelog/2.4.4/Glass Effect Transition/index.md): This document provides a comprehensive explanation of Glass Effect Transitions in Scripting, including how Liquid Glass materials animate during view changes, how geometry matching works, and how to correctly use NamespaceReader to access SwiftUI’s @Namespace within TSX code. Contents include: Overview of Liquid Glass transitionsThe three transition typesRelationship among glassEffectTransition, glassEffectID, and namespaceRole of glassEffectUnionPurpose and behavior of GlassEffectContainerDesign and usage of NamespaceReaderDetailed walkthrough of the provided exampleBest practice recommendations A Glass Effect Transition defines how a Liquid Glass material animates when: A view is inserted or removedLayout changesViews switch between two states These transitions affect only the Liquid Glass material—not the rest of the view’s opacity or scale. A transition controls: How the glass material appears or disappearsWhether the shape of the glass participates in animationWhether the glass attempts to match geometry with other shapes
- [Example](/doc/Changelog/2.4.4/Glass Effect Transition/index_example.md)
- [Intent.continueInForeground <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.4/Intent.continueInForeground.md): Intent.continueInForeground is an API that leverages the iOS 26+ AppIntents framework to request the system to bring the Scripting app to the foreground while a Shortcut is running. This method is used when a script—invoked from Shortcuts—requires full UI interaction within the Scripting app (for example: presenting a form, editing content, picking files, showing a full screen navigation flow, etc.). When invoked: The system displays a dialog asking the user to continue the workflow in the app.If the user confirms, the system opens Scripting in the foreground and the script continues.If the user cancels, the script terminates immediately. Because this is a system-level capability of AppIntents: This API requires iOS 26 or later.
- [Intent.requestConfirmation <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.4/Intent.requestConfirmation.md): Intent.requestConfirmation pauses script execution and asks the user to confirm an action through a system-managed confirmation UI.
The confirmation interface consists of: A SnippetIntent UI (provided by you)Optional dialog text (system-generated or developer-defined) Behavior: If the user confirms, the script continues (Promise resolves).If the user cancels, the script terminates immediately.The UI is fully managed by the system.The presented UI is defined by the provided SnippetIntent’s perform() return. This API is only available on iOS 26 or later.
- [IntentMemoryStorage](/doc/Changelog/2.4.4/IntentMemoryStorage.md): IntentMemoryStorage is an in-memory storage mechanism used inside AppIntent execution environments.
It allows multiple AppIntents—such as multi-step workflows involving SnippetIntents—to share temporary data. However, its lifecycle does not follow the lifecycle of AppIntent execution or Script.exit().
It is controlled by the system’s management of the Extension process, which is unpredictable. This document describes its real behavior, its storage scopes, how the system manages JSContexts in Shortcuts, Widgets, and Live Activities, and how developers should use it safely. Each AppIntent in Scripting runs inside its own Script Execution Context (JSContext).
When: The AppIntent’s perform() finishes, orScript.exit() is called the execution ends. But this does not mean that IntentMemoryStorage (or the JSContext) is destroyed. Instead: IntentMemoryStorage persists as long as the system keeps the Extension process alive It will only be cleared when: The Extension process is terminated by the systemThe system decides to reclaim memoryThe environment hosting the Intent Extension or Widget Extension is destroyed Therefore: Running the same Shortcut again may read leftover values from the previous run.Widget or Live Activity AppIntent calls may reuse the same JSContext, preserving MemoryStorage.MemoryStorage can disappear at any time if the system kills the Extension process. This behavior is normal and inherent to the AppExtension lifecycle. IntentMemoryStorage is: A short-lived, extension-scoped, non-persistent memory store IntentMemoryStorage provides two scopes.
- [Liquid Glass Effect](/doc/Changelog/2.4.4/Liquid Glass Effect/index.md): Scripting provides full support for the new Liquid Glass visual system introduced in iOS 26. This includes glassEffect, GlassEffectContainer, UIGlass, and related geometry-matching and transition APIs. These APIs allow scripts to create rich translucent materials, fluid glass shapes, matched geometry animations, and unioned glass regions directly within TSX. This document explains how the Liquid Glass APIs are used in Scripting, including: Concepts and fundamentalsHow to apply glass effectsUIGlass configurationGeometry transitionsglassEffect identifiers and unionsGlassEffectContainer behaviorPractical examples and best practices Liquid Glass is a new material and animation system in iOS 26. Compared to earlier blur or material effects, Liquid Glass provides: Fluid, dynamic shapes that follow view geometryTintable and interactive glass materialsGeometry-matched transitionsGrouped “glass unions” to merge multiple regionsHigh-performance rendering inside containers Any view that adopts GlassProps can apply a Liquid Glass effect using the glassEffect property. Definition
- [Example](/doc/Changelog/2.4.4/Liquid Glass Effect/index_example.md)
- [NamespaceReader](/doc/Changelog/2.4.4/NamespaceReader.md): NamespaceReader is used to create and manage a geometry animation namespace (Namespace).
This namespace is the foundational requirement for enabling: matchedGeometryEffect (component-level geometry animation)matchedTransitionSource (page-level navigation transition)navigationTransition (such as zoom transitions) You can think of NamespaceReader as: A “geometry animation coordinate provider” that defines which views belong to the same animation scope.
- [New List View Modifiers](/doc/Changelog/2.4.4/New List View Modifiers.md): Description Controls whether the List shows the right-side section index (commonly used for A–Z navigation in contact lists). Possible values: "visible""hidden""automatic" (default system behavior) Example Description Customizes the margins of a section. When set, it fully replaces SwiftUI’s default section margin rules. Supported Formats 2.1 Single number Applies the same margin to all edges. 2.2 EdgeSets Applies the specified edges with the default margin. 2.3 Specific edges with length Applies a margin of length only to the specified edges. Equivalent to SwiftUI: Example Description Sets the character or text displayed in the right-side section index for this section. Typically a single letter. Example Description Adds custom UI elements such as buttons or menus to the section header’s trailing (accessory) area. Example: Refresh button Example: Menu with multiple actions
- [Notification](/doc/Changelog/2.4.4/Notification/index.md): The Notification module in the Scripting app allows you to schedule, manage, and display local notifications with advanced trigger types, interactive actions, and rich UI capabilities.
- [Example](/doc/Changelog/2.4.4/Notification/index_example.md)
- [SFTP Client <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.4/SFTP Client.md): SFTPClient provides access to a remote file system over an SSH connection using the SFTP protocol.
It supports directory operations, file management, attribute retrieval, and path resolution.
Files can be opened using openFile(), which returns an SFTPFile instance for reading and writing. Instances of this class are typically created through:
- [SFTP File <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.4/SFTP File.md): SFTPFile represents an opened remote file accessed through an SFTP session.
It provides low-level operations such as reading, writing, retrieving attributes, and closing the file. Instances of this class are typically obtained through:
- [SnippetIntent <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.4/SnippetIntent.md): SnippetIntent is a special kind of AppIntent whose purpose is to render interactive Snippet UI cards inside the Shortcuts app (iOS 26+). Key characteristics: Must be registered in app_intents.tsxMust specify protocol: AppIntentProtocol.SnippetIntentperform() must return a VirtualNode (TSX UI)Must be returned via Intent.snippetIntent()Must be invoked from the Shortcuts action “Show Snippet Intent”SnippetIntent is ideal for building interactive, step-based UI inside a Shortcut It is not a data-returning Intent; it is exclusively for UI rendering in Shortcuts. SnippetIntent requires iOS 26 or later. On iOS versions earlier than 26: Intent.snippetIntent() is not availableIntent.requestConfirmation() cannot be usedThe Shortcuts action “Show Snippet Intent” does not existSnippetIntent-type AppIntents cannot be invoked by Shortcuts Example: Another SnippetIntent: Requirements: protocol must be AppIntentProtocol.SnippetIntentperform() must return a TSX UI (VirtualNode)SnippetIntent cannot return non-UI types such as text, numbers, JSON, or file paths A SnippetIntent cannot be passed directly to Script.exit().
It must be wrapped in a IntentSnippetIntentValue. Type Definition This wrapper makes the return value compatible with the Shortcuts “Show Snippet Intent” action. iOS 26 Snippet Framework provides built-in confirmation UI driven by SnippetIntent. API ConfirmationActionName A predefined list of semantic action names used by system UI: Example Execution behavior: Displays a Snippet UI for confirmationIf the user confirms → Promise resolves and script continuesIf the user cancels → execution stops (system-driven behavior) iOS 26 adds a new Shortcuts action: Show Snippet Intent This action is the only correct way to display SnippetIntent UI. Comparison with Other Scripting Actions Usage Add “Show Snippet Intent” in ShortcutsSelect a Scripting script projectThe script must return Intent.snippetIntent(...)Shortcuts renders the UI in a Snippet card
- [TabView](/doc/Changelog/2.4.4/TabView.md): Scripting provides a modern Tab system aligned with iOS 18+: TabView — container that manages multiple tabs and switching between themTab — a single tab and its associated contentTabSection — a way to group tabs into sections, each with its own configuration and header Combined with TabView-level options and TabViewCustomization, this enables rich tab layouts, including sidebar representations, customization, and persistence. This document focuses on: How to structure tab content using TabView, Tab, and TabSectionHow to configure tab bar and sidebar behaviorsHow to use TabViewCustomization to persist and restore user customizations
- [Use with Toolbar Component](/doc/Changelog/2.4.4/Use with Toolbar Component.md): In Scripting, views can populate their navigation bar or toolbar area using either the original ToolBarProps object or the declarative component-based API that mirrors SwiftUI’s toolbar system. This document explains in detail how to use the Toolbar, ToolbarItem, ToolbarItemGroup, ToolbarSpacer, and DefaultToolbarItem components, including parameters, types, and usage patterns. The toolbar property can be used in two ways: By passing a ToolBarProps objectBy passing a VirtualNode, which must be a <Toolbar> component When using the component-based API, all toolbar content is declared inside a <Toolbar> container, and each item defines its placement explicitly. This provides clearer structure and more precise layout control, similar to SwiftUI. The <Toolbar> component serves as a container for toolbar content. It does not define placement itself; instead, ToolbarItem and ToolbarItemGroup determine where items go.
- [matchedGeometryEffect](/doc/Changelog/2.4.4/matchedGeometryEffect.md): matchedGeometryEffect establishes a geometric relationship between different views, allowing them to animate smoothly when transitioning across: Different layoutsDifferent containersDifferent conditional render statesDifferent size and position configurations It corresponds to SwiftUI’s matchedGeometryEffect and is a component-level geometry animation system, independent of navigation.
- [matchedTransitionSource](/doc/Changelog/2.4.4/matchedTransitionSource.md): matchedTransitionSource marks a view as the geometric source of a navigation transition. It allows a view to act as the starting point of a page-level transition animation, such as a zoom (Hero-style) transition. This API corresponds to SwiftUI’s matchedTransitionSource and is intended only for navigation transitions, not for component-level layout animations. Typical use cases include: Image → Image detail zoomCard → Detail page Hero animationAvatar → Profile page transition
- [AVPlayerView](/doc/Changelog/2.4.5/AVPlayerView.md): AVPlayerView is a video playback component introduced in Scripting that wraps the system-native AVPlayerViewController.
Unlike VideoPlayer, AVPlayerView fully supports system Picture in Picture (PiP) and exposes PiP lifecycle state to scripts. This component is intended for media-centric scenarios where native playback behavior, PiP, Now Playing integration, and background playback are required.
- [AppStore <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/AppStore.md): The AppStore API allows you to display App Store app information directly inside the Scripting app, without navigating users away to the system App Store application. This API is built on top of Apple’s native App Store presentation components and is suitable for scenarios such as app recommendations, app collections, related app discovery, and ecosystem entry points.
- [Assistant Conversation APIs <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/Assistant/Assistant Conversation APIs.md): The Conversation APIs are used to start, control, and present a system-hosted Assistant chat session.
A conversation corresponds to a fully managed chat page, where Scripting handles the UI, streaming output, provider selection, and message lifecycle. Key differences from other Assistant APIs: Conversation APIs are designed for interactive chat experiencesUI, streaming, and message handling are managed by the systemDevelopers control when the conversation starts, ends, and is shown
- [Assistant Quick Start <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/Assistant/Assistant Quick Start.md): The Assistant API in Scripting provides three distinct capabilities, each designed for a different type of use case: structured data, streaming output, and interactive conversations. Before choosing an API, first decide what kind of result you need.
- [requestStreaming <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/Assistant/requestStreaming.md): requestStreaming requests a streaming response from the Assistant.
Instead of returning a complete result at once, the Assistant emits chunks incrementally as the model generates output. This enables: Real-time UI updates (typing effect)Low-latency handling of long responsesProgressive rendering of resultsStreaming logs and intermediate output handling The API returns a ReadableStream<StreamChunk>, which can be consumed using for await ... of.
- [requestStructuredData <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/Assistant/requestStructuredData.md): requestStructuredData requests structured JSON output from the assistant that conforms to a provided JSON schema.
This API is designed for workflows where you want a predictable, programmatically usable result rather than free-form text. Common use cases include: Extracting structured fields from natural languageParsing invoices, receipts, and ticketsGenerating configuration objectsNormalizing data across different AI providers/models
- [CalendarEvent](/doc/Changelog/2.4.5/CalendarEvent.md): The CalendarEvent API enables creating, reading, editing, and managing events in the iOS calendar.
Developers can configure event details such as title, time, location, participants, recurrence rules, alarms, availability, and structured locations, and can display system-provided interfaces for creating or editing events.
- [DateFormatter](/doc/Changelog/2.4.5/DateFormatter.md): The DateFormatter class provides comprehensive date and time formatting capabilities. It allows converting Date objects into localized strings and parsing strings back into Date values.
This API wraps iOS-native date formatting behavior and supports multiple calendars, time zones, localized formats, and custom formatting templates.
- [EventAlarm](/doc/Changelog/2.4.5/EventAlarm.md): EventAlarm represents a reminder rule that can be attached to both CalendarEvent and Reminder objects.
It supports three major alarm types: Absolute-time alarmsRelative alarms (relative to an event’s start time)Location-based alarms (geofence triggers) This class aligns with the behavior of iOS EventKit alarms and provides flexible notification capabilities across calendar and reminder data.
- [Keychain](/doc/Changelog/2.4.5/Keychain.md): Keychain provides secure access to the system keychain for storing sensitive and persistent data inside the Scripting environment. It is designed for: Authentication tokensLogin credentialsLicense and subscription statesEncryption keysPrivate user data All data is protected using the system-level Keychain security mechanism.
- [LivePhotoView](/doc/Changelog/2.4.5/LivePhotoView.md): LivePhoto represents a system Live Photo, which consists of: A high-resolution still imageA short video clip bound to that image In Scripting, LivePhoto is a system-managed object. It cannot be instantiated directly with new and is typically obtained from: A photo picker resultAsynchronous construction from local image and video files LivePhoto is commonly used to: Display Live Photos in the UIAccess underlying image and video resourcesDecompose, rebuild, or re-save Live Photos
- [NavigationStack with path](/doc/Changelog/2.4.5/NavigationStack with path.md): NavigationStack.path provides observable, programmatic control over the navigation stack. It allows direct manipulation of the navigation history using a bound observable array. It enables: Programmatic navigationMulti-level stack controlReturning to the root viewDynamic page resolution via NavigationDestination
- [Photos](/doc/Changelog/2.4.5/Photos/index.md): The Photos module provides unified access to the system photo library and camera. It enables scripts to: Capture photos or record videos using the system cameraPick images, videos, or Live Photos from the photo libraryRetrieve the most recent photosSave images or videos to the Photos app All APIs are built on top of native iOS frameworks such as Photos and PHPicker, and follow these principles: System-managed permissionsPromise-based asynchronous APIsSystem-controlled UI presentationSecure and constrained access to media data
- [Example](/doc/Changelog/2.4.5/Photos/index_example.md)
- [Picture in Pictuer View Modifiers <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/Picture in Pictuer View Modifiers.md): Scripting provides a set of Picture in Picture (PiP) view modifiers that allow developers to render any SwiftUI view inside a system PiP window.
These APIs abstract away the underlying AVPictureInPicture implementation and provide a declarative, script-friendly way to control PiP presentation, interaction, and lifecycle. PiP is suitable for the following scenarios: Real-time status display (timers, workouts, progress indicators)Audio or video playback companion UILightweight views that should remain visible when the app enters background
- [Reminder](/doc/Changelog/2.4.5/Reminder.md): The Reminder API provides the ability to create, edit, and manage reminders in the iOS calendar system.
It supports configuring due dates through DateComponents, assigning priorities, adding notes, managing recurrence rules, working with alarms, and tracking completion state.
This API is suitable for a wide range of task and schedule reminder scenarios. The Reminder class represents an individual reminder item and provides properties and methods to read and modify its data. identifier: string A unique identifier assigned by the system (read-only). calendar: Calendar The calendar to which the reminder belongs.
Each reminder must be associated with a calendar. title: string The title or summary of the reminder. notes: string | null Optional notes providing additional context.
- [ReorderableForEach](/doc/Changelog/2.4.5/ReorderableForEach/index.md): ReorderableForEach is a high-level component in Scripting that provides built-in drag-to-reorder capability.
It preserves the familiar usage pattern of ForEach while adding native support for: Drag gesture recognitionActive item trackingManual reorder callbacks This allows developers to implement sortable lists and grids with minimal effort. Typical use cases include: Draggable card layoutsReorderable grids (LazyVGrid, LazyHGrid)User-defined module arrangements
- [Example](/doc/Changelog/2.4.5/ReorderableForEach/index_example.md)
- [Selectable List](/doc/Changelog/2.4.5/Selectable List.md): List.selection provides selection state binding for the List component. It enables: Single selection modeMultiple selection modeIntegration with edit mode via EditButtonAutomatic synchronization with user interaction
- [VideoPreviewView](/doc/Changelog/2.4.5/VideoPreviewView.md): VideoPreviewView is a UI component that displays the live camera preview associated with a VideoRecorder instance.
It renders the real-time output of the recorder’s capture session and serves as the visual foundation for custom camera interfaces. VideoPreviewView does not control recording behavior. All recording logic—preparation, start, pause, resume, stop, and disposal—is handled exclusively by VideoRecorder.
- [VideoRecorder <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Changelog/2.4.5/VideoRecorder.md): VideoRecorder provides a programmable video recording session in Scripting.
It encapsulates camera selection, audio/video capture, encoding, pause/resume handling, zoom, focus, torch control, and final file writing. This API is intended for custom camera interfaces, video capture utilities, and automated recording workflows.
- [WebViewController](/doc/Changelog/2.4.5/WebViewController.md): The WebViewController class allows you to display and interact with embedded web content inside your script. It is designed for use cases like custom in-app browsers, rendering dynamic HTML, or communicating with JavaScript running in a web context.
- [Device](/doc/Changelog/2.4.6/Device/index.md): The Device namespace provides access to device information, system environment data, screen and battery status, language and locale settings, and selected device capabilities (such as wake lock and network interface inspection). This API is commonly used for: Device-specific logic (iPhone / iPad / Mac)UI layout and adaptive designLocalization and language selectionNetwork inspection and debuggingPreventing the device from sleeping during script execution
- [Example](/doc/Changelog/2.4.6/Device/index_example.md)
- [Intent](/doc/Changelog/2.4.6/Intent.md): Scripting allows you to define custom iOS Intents using an intent.tsx file. These scripts can receive input from the iOS share sheet or the Shortcuts app and return structured results. With optional UI presentation, you can create interactive workflows that process data and deliver output dynamically.
- [ItemProvider](/doc/Changelog/2.4.6/ItemProvider.md): ItemProvider represents a deferred data provider used to access content such as files, images, text, or URLs in a controlled and secure way.
It is commonly used in scenarios like drag and drop, file importing, and content selection from Photos or Files. An ItemProvider does not store the data itself. Instead, it describes how and under what constraints the data can be accessed.
- [MediaComposer Example](/doc/Changelog/2.4.6/MediaComposer/MediaComposer Example.md): This example demonstrates how to use MediaComposer to compose a final video from video, image, and audio sources, and export it to the script directory. The workflow covered in this example includes: Picking an audio filePicking an imagePicking a videoBuilding a visual timeline (video + image)Inserting audio at a specific timeExporting the composed video
- [MediaTime](/doc/Changelog/2.4.6/MediaComposer/MediaTime.md): MediaTime represents precise media time values in audio and video processing. It is the fundamental time type used by MediaComposer in Scripting. Conceptually, MediaTime corresponds to a time value with an explicit time base (similar to CMTime in AVFoundation), but provides a safer and more expressive abstraction for the scripting layer. A MediaTime instance can represent numeric time, invalid time, indefinite time, or infinite time, and supports strict arithmetic and comparison operations.
- [Quick Start](/doc/Changelog/2.4.6/MediaComposer/Quick Start.md): MediaComposer is used in Scripting to compose video, image, and audio timelines and export a final media file.
It provides a stable and precise timeline model that supports video clips, image clips, audio overlays, fades, audio ducking, and flexible export configuration. This module is suitable for: Mixing videos and images into a single outputAdding background music, voice-over, or sound effectsGenerating videos from image sequencesAutomated and script-driven media production
- [SharedAudioSession](/doc/Changelog/2.4.6/SharedAudioSession.md): The SharedAudioSession interface provides a convenient way to manage and interact with the shared audio session in your script. The audio session acts as an intermediary between your script, the Scripting app, the operating system, and the underlying audio hardware, enabling you to configure and control audio behavior effectively.
- [VideoRecorder](/doc/Changelog/2.4.6/VideoRecorder.md): VideoRecorder provides a programmable video recording session in Scripting.
It encapsulates camera selection, audio/video capture, encoding, pause/resume handling, zoom, focus, torch control, and final file writing. This API is intended for custom camera interfaces, video capture utilities, and automated recording workflows.
- [onDrag and onDrop View Modifiers](/doc/Changelog/2.4.6/onDrag and onDrop View Modifiers.md): Scripting provides a Drag & Drop API closely aligned with the SwiftUI drag-and-drop interaction model. It enables views to act as drag sources, drop destinations, or both, supporting intra-app and cross-app drag-and-drop scenarios. The API is composed of three core parts: onDrag: Declares a view as a drag sourceonDrop: Declares a view as a drop destinationDropInfo / ItemProvider / UTType: Context objects describing drag content and state Drag and drop is a system-controlled interaction. Certain APIs are only valid during specific callbacks. These constraints are explicitly documented below and must be respected.
- [onDropContent](/doc/Changelog/2.4.6/onDropContent.md): onDropContent is a view modifier provided by Scripting that allows a view to act as a drop target, receiving files, images, or text dragged in from other applications.
- [Control Widget <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Control Widget.md): The ControlWidget API enables users to add custom Button or Toggle controls to the iOS Control Center or Lock Screen. Each control is linked to an AppIntent to execute custom script logic. The controls support privacy protection, dynamic state labels, and SFSymbols icons.
- [Custom Keyboard <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Custom Keyboard.md): The CustomKeyboard namespace provides a comprehensive API for building fully custom keyboard UIs in the Scripting app. It allows you to create JSX-based keyboards, insert or modify text, query input state, respond to user interaction, and control keyboard layout or navigation.
- [AVMetadataItem](/doc/Device Capabilities/AVMetadataItem.md): The AVMetadataItem class represents a single metadata entry within a media file, such as an audio or video resource.
Instances of this class are typically returned by the methods AVPlayer.loadMetadata() and AVPlayer.loadCommonMetadata() and provide access to metadata embedded in media resources. Each metadata item describes one piece of information—such as the title, artist, album name, artwork, or encoding details—and can be accessed in multiple typed forms.
- [AppStore <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/AppStore.md): The AppStore API allows you to display App Store app information directly inside the Scripting app, without navigating users away to the system App Store application. This API is built on top of Apple’s native App Store presentation components and is suitable for scenarios such as app recommendations, app collections, related app discovery, and ecosystem entry points.
- [Audio Player](/doc/Device Capabilities/Audio Player.md): The AVPlayer class provides audio and video playback capabilities with support for playback control, looping, event callbacks, and metadata retrieval.
You can use setSource() to set a media source (either a local file or a remote URL) and call play() to start playback.
- [AudioRecorder](/doc/Device Capabilities/AudioRecorder.md): The AudioRecorder class allows you to record audio data to a file. It provides functionalities to start, stop, pause, and manage audio recordings, with configurable settings for audio quality, sample rate, format, and more.
- [BackgroundKeeper <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/BackgroundKeeper.md): The BackgroundKeeper API provides control over background keep-alive behavior in the Scripting App, allowing scripts to extend their runtime after the app transitions to the background. This can be useful for maintaining ongoing operations, such as network connections or active processes, for a limited period while the app is not in the foreground. Availability:
This API is only available when the script is running in the main app (Script.env === "index").
Use it responsibly, as prolonged background execution may increase power consumption.
- [BluetoothCentralManager <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Bluetooth/BluetoothCentralManager.md): The BluetoothCentralManager namespace provides core functionality for managing Bluetooth Low Energy (BLE) operations as a central device. It supports scanning, connecting, disconnecting, and retrieving known or connected peripherals. This API is ideal for building custom Bluetooth workflows, interacting with smart devices, wearables, and IoT peripherals.
- [BluetoothCharacteristic <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Bluetooth/BluetoothCharacteristic.md): The BluetoothCharacteristic interface represents a Bluetooth Low Energy (BLE) characteristic, which is the fundamental data unit in a BLE service. A characteristic exposes a specific piece of data and supports operations such as reading, writing, or subscribing to notifications.
- [BluetoothPeripheral <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Bluetooth/BluetoothPeripheral.md): The BluetoothPeripheral interface represents a Bluetooth Low Energy (BLE) peripheral device. It provides properties and methods for interacting with the device, including connecting, discovering services and characteristics, reading/writing values, and subscribing to notifications.
- [BluetoothPeripheralManager <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Bluetooth/BluetoothPeripheralManager.md): The BluetoothPeripheralManager API enables your device to act as a Bluetooth Low Energy (BLE) peripheral. It allows you to: Advertise device name and service UUIDsAdd or remove services with characteristicsHandle read and write requests from central devicesNotify subscribed centrals of characteristic value changesManage connection parameters such as connection latency This API is ideal for building custom sensor devices, BLE peripheral simulators, controllers, and similar use cases.
- [BluetoothService <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Bluetooth/BluetoothService.md): The BluetoothService interface represents a Bluetooth Low Energy (BLE) service. A service is a logical grouping of related characteristics and possibly other included services. Services are used to define the functionality of a peripheral device, such as Heart Rate Monitoring or Battery Level Reporting.
- [Calendar](/doc/Device Capabilities/Calendar.md): The Calendar API in the Scripting app provides access to iOS calendars, calendar accounts, and event/reminder management.Developers can retrieve default calendars, create new ones, list calendars supporting specific entity types, and manage calendar properties.
- [CalendarEvent](/doc/Device Capabilities/CalendarEvent.md): The CalendarEvent API enables creating, reading, editing, and managing events in the iOS calendar.
Developers can configure event details such as title, time, location, participants, recurrence rules, alarms, availability, and structured locations, and can display system-provided interfaces for creating or editing events.
- [Contact](/doc/Device Capabilities/Contact/index.md): The Contact module in the Scripting app allows you to access and manage contacts on the device. You can create, query, update, and delete contacts, as well as manage contact groups and containers.
- [Example](/doc/Device Capabilities/Contact/index_example.md)
- [Device](/doc/Device Capabilities/Device/index.md): The Device namespace provides access to device information, system environment data, screen and battery status, language and locale settings, and selected device capabilities (such as wake lock and network interface inspection). This API is commonly used for: Device-specific logic (iPhone / iPad / Mac)UI layout and adaptive designLocalization and language selectionNetwork inspection and debuggingPreventing the device from sleeping during script execution
- [Example](/doc/Device Capabilities/Device/index_example.md)
- [DocumentPicker](/doc/Device Capabilities/DocumentPicker.md): The DocumentPicker class provides an interface to the iOS document picker, allowing users to select files or directories and export files from within the Files app. This is useful for scripts that need to access user files, share content, or organize resources in a specified directory.
- [EventAlarm](/doc/Device Capabilities/EventAlarm.md): EventAlarm represents a reminder rule that can be attached to both CalendarEvent and Reminder objects.
It supports three major alarm types: Absolute-time alarmsRelative alarms (relative to an event’s start time)Location-based alarms (geofence triggers) This class aligns with the behavior of iOS EventKit alarms and provides flexible notification capabilities across calendar and reminder data.
- [FontPicker <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/FontPicker.md): The FontPicker namespace provides methods for selecting fonts from the system’s available font list.
It opens the system font picker UI, allowing the user to choose a font, and returns the PostScript name of the selected font.
- [HapticFeedback](/doc/Device Capabilities/HapticFeedback.md)
- [HealthActivitySummary <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthActivitySummary.md): The HealthActivitySummary class provides an interface for accessing daily summaries of user activity as recorded by the Apple Health system. This includes move, exercise, and stand metrics, and optionally supports both energy-based and time-based activity move goals. This class is useful for apps that aim to present a user's daily activity rings or generate daily fitness reports.
- [HealthCategorySample <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthCategorySample.md): The HealthCategorySample class represents an individual category-based health record, such as a sleep session, menstrual flow level, or a test result. These samples are used to store discrete events or conditions over time, usually characterized by a start and end date along with a categorical value.
- [HealthCategoryType <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthCategoryType.md): The HealthCategoryType identifies discrete health-related states or events, often recorded as binary values (e.g., present or not present) or discrete outcomes. These are commonly used for tracking symptoms, reproductive health, audio exposure events, and sleep states.
- [HealthCategoryValue Types <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthCategoryValue Types.md): This document provides a comprehensive reference for all supported HealthCategoryValue enums used with HealthCategorySample.create() and related APIs. Each enum represents a specific categorical value associated with a HealthCategoryType.
- [HealthCharacteristicType <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthCharacteristicType.md): This section describes enums related to user health profile attributes and activity configuration, including biological sex, blood type, skin type, wheelchair use, and activity move mode. These enums are used with the Health API to retrieve user profile data from HealthKit.
- [HealthCorrelation <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthCorrelation.md): The HealthCorrelation class represents a group of health samples that are logically related. It provides an interface for accessing and creating correlation records that group multiple health data types together—such as combining dietary intake and blood pressure readings, or linking ovulation tests with menstrual flow records.
- [HealthHeartbeatSeriesSample <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthHeartbeatSeriesSample.md): The HealthHeartbeatSeriesSample class provides an interface for accessing heartbeat series samples, representing a series of individual heartbeat intervals recorded over time. These samples are typically used for analyzing heart rhythm and detecting irregularities such as atrial fibrillation. This class is returned by the public API method Health.queryHeartbeatSeriesSamples().
- [HealthKit Permission Behavior <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthKit Permission Behavior.md): When using the Health module provided by the Scripting app to access iOS HealthKit data, it's important to understand how HealthKit handles authorization and how Scripting adapts to these behaviors. This document explains the authorization flow, Promise behavior, and best practices for handling missing permissions.
- [HealthQuantitySample <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthQuantitySample.md): The HealthQuantitySample class represents a single health quantity data point, such as a heart rate measurement, a recorded step count, or a logged calorie value. It provides information about the measurement’s type, time interval, unit, value, and optional metadata. This class is the base for more specialized subclasses: HealthCumulativeQuantitySample and HealthDiscreteQuantitySample.
- [HealthQuantityType <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthQuantityType.md): This document lists all supported HealthQuantityType identifiers, categorized by domain. Each type is associated with a measurable health-related metric and can be used to track fitness, vital signs, nutrition, environment, and more.
- [HealthStatistics <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthStatistics.md): The HealthStatistics class provides an interface for analyzing aggregated health quantity data over a specified time range. It allows you to compute key statistical values such as: Total durationAverage, sum, minimum, maximum quantitiesMost recent value and its date range This class is ideal for generating summaries of daily, weekly, or custom health data intervals.
- [HealthStatisticsCollection <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthStatisticsCollection.md): The HealthStatisticsCollection class provides a structured representation of time-based grouped health statistics, such as daily, weekly, or monthly summaries. Each entry in the collection corresponds to one interval, and encapsulates its own HealthStatistics object. This class is particularly useful for: Plotting health trends over timeGenerating time-series reportsSeparating and accessing statistics by date intervals
- [HealthUnit <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthUnit.md): The HealthUnit class provides an interface to construct and manipulate various units used in HealthKit. You can create basic units (e.g., grams, meters, liters), apply metric prefixes (e.g., milligrams, kilometers), and perform arithmetic operations like multiplication, division, exponentiation, and inversion.
- [HealthWorkout <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthWorkout.md): The HealthWorkout class provides a high-level interface for accessing and analyzing workout data from Apple Health. A workout represents a full session of physical activity, such as running, swimming, or cycling, recorded between a start and end time, and may include additional events and aggregated statistics.
- [HealthWorkoutActivityType <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthWorkoutActivityType.md): Each enum value below includes a description of its purpose and typical use case. Usage Example:
- [HealthWorkoutEvent <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/HealthWorkoutEvent.md): The HealthWorkoutEvent class provides an interface for accessing workout-related events in Apple Health data. Each event represents a specific moment or action within a workout session, such as when the workout is paused, resumed, or marked with a lap or milestone.
- [Query Statistics Collection <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Query Statistics Collection.md): The Health.queryStatisticsCollection() method retrieves time-based aggregated statistics for a given HealthQuantityType over a specified date range. It returns a HealthStatisticsCollection object, which contains multiple HealthStatistics entries aligned to defined time intervals (such as daily, weekly, or monthly). This method is ideal for analyzing trends, building charts, and generating historical summaries of health data.
- [Query Statistics <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Query Statistics.md): The queryStatistics method retrieves aggregated statistics for a specific health quantity type over a defined date range. It can compute metrics such as total sum, average, minimum, maximum, most recent value, and duration, with optional support for breaking down results by source (e.g., device or app). This method is ideal for producing daily, weekly, or historical health summaries.
- [Reading Activity Summaries <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Activity Summaries.md): The Scripting app provides access to daily activity summary data from Apple Health using the global function Health.queryActivitySummaries(). These summaries represent Move, Exercise, and Stand goals tracked by Apple Watch, along with completion metrics and historical trends. This API is ideal for displaying daily ring data or analyzing long-term fitness trends.
- [Reading Category Samples <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Category Samples.md): The Scripting app provides access to category-based health data using the global function Health.queryCategorySamples(). Category samples represent health-related events or states with a start date, end date, and a discrete value — such as sleep stages, mindful sessions, menstrual flow, and ovulation test results. This guide explains how to query, interpret, and use category samples in your scripts.
- [Reading Characteristic Data <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Characteristic Data.md): HealthKit stores characteristics as immutable personal attributes, such as biological sex, date of birth, blood type, skin type, wheelchair usage, and activity move mode. These values are typically entered by the user in the Health app and rarely change. The Scripting app provides global asynchronous APIs for accessing these values.
- [Reading Correlation Data <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Correlation Data.md): The Scripting app allows you to query correlated health data using the global Health.queryCorrelations() API. A correlation groups related health samples into a single logical event — such as a blood pressure reading (systolic and diastolic) or a food intake record (calories, protein, etc.). This guide explains how to retrieve and interpret correlation data from HealthKit.
- [Reading Heartbeat Series Samples <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Heartbeat Series Samples.md): The Scripting app provides access to heartbeat series samples stored in Apple Health using the global API Health.queryHeartbeatSeriesSamples(). These samples represent beat-to-beat heartbeat intervals collected during workouts or background monitoring sessions (usually via Apple Watch). Each record contains the time range, number of beats, and optional metadata, but not the raw interval values.
- [Reading Quantity Samples <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Quantity Samples.md): The Scripting app allows you to query quantity-based health data, such as step count, heart rate, body mass, calories burned, distance, and more, using the global Health.queryQuantitySamples() API. This guide explains how to retrieve quantity samples and work with the results.
- [Reading Workout Samples <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Reading Workout Samples.md): The Scripting app allows you to retrieve workout sessions from HealthKit using the global Health.queryWorkouts() function. Workouts represent physical activity sessions such as running, walking, swimming, cycling, strength training, and more. Each workout includes metadata such as duration, activity type, start/end times, and detailed statistics like heart rate, distance, and energy burned.
- [Writing Health Category Samples <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Writing Health Category Samples.md): The Scripting app allows you to write categorical health data to Apple HealthKit using the HealthCategorySample class and the Health.saveCategorySample() method. Category samples represent discrete health-related events or conditions, such as sleep stages, mindful sessions, menstrual flow, ovulation test results, and more. This guide describes how to create and save a HealthCategorySample.
- [Writing Health Correlation Data <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Writing Health Correlation Data.md): In the Scripting app, you can write correlated health data to Apple HealthKit using the global HealthCorrelation.create() method and Health.saveCorrelation(). A correlation represents a relationship between multiple health samples, such as a blood pressure reading that includes both systolic and diastolic values, or a meal record that includes nutritional quantities. This guide explains how to create and save a correlation sample.
- [Writing Health Quantity Samples <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Health/Writing Health Quantity Samples.md): The Scripting app allows you to write quantity-based health data (such as step count, heart rate, calories, and more) to Apple HealthKit using the HealthQuantitySample class and the Health.saveQuantitySample method. This guide explains how to create and save a new quantity sample.
- [Keychain](/doc/Device Capabilities/Keychain.md): Keychain provides secure access to the system keychain for storing sensitive and persistent data inside the Scripting environment. It is designed for: Authentication tokensLogin credentialsLicense and subscription statesEncryption keysPrivate user data All data is protected using the system-level Keychain security mechanism.
- [LocalAuth](/doc/Device Capabilities/LocalAuth.md): The LocalAuth API is a wrapper around the iOS Local Authentication framework, enabling biometric or passcode authentication in your Scripting app scripts. This document explains how to use the LocalAuth API effectively.
- [Location](/doc/Device Capabilities/Location.md): The global Location API provides access to the device’s geographic location, including one-time location retrieval, reverse geocoding, user-driven location selection via map, accuracy control, and permission checking for widgets.
- [MediaComposer Example](/doc/Device Capabilities/MediaComposer/MediaComposer Example.md): This example demonstrates how to use MediaComposer to compose a final video from video, image, and audio sources, and export it to the script directory. The workflow covered in this example includes: Picking an audio filePicking an imagePicking a videoBuilding a visual timeline (video + image)Inserting audio at a specific timeExporting the composed video
- [MediaTime](/doc/Device Capabilities/MediaComposer/MediaTime.md): MediaTime represents precise media time values in audio and video processing. It is the fundamental time type used by MediaComposer in Scripting. Conceptually, MediaTime corresponds to a time value with an explicit time base (similar to CMTime in AVFoundation), but provides a safer and more expressive abstraction for the scripting layer. A MediaTime instance can represent numeric time, invalid time, indefinite time, or infinite time, and supports strict arithmetic and comparison operations.
- [Quick Start](/doc/Device Capabilities/MediaComposer/Quick Start.md): MediaComposer is used in Scripting to compose video, image, and audio timelines and export a final media file.
It provides a stable and precise timeline model that supports video clips, image clips, audio overlays, fades, audio ducking, and flexible export configuration. This module is suitable for: Mixing videos and images into a single outputAdding background music, voice-over, or sound effectsGenerating videos from image sequencesAutomated and script-driven media production
- [MediaPlayer](/doc/Device Capabilities/MediaPlayer.md): The MediaPlayer API allows you to interact with the Now Playing Center, manage Now Playing Info, and respond to remote control events. Below is a comprehensive guide on its usage, including best practices and examples.
- [Notification](/doc/Device Capabilities/Notification/index.md): The Notification module in the Scripting app allows you to schedule, manage, and display local notifications with advanced trigger types, interactive actions, and rich UI capabilities.
- [Example](/doc/Device Capabilities/Notification/index_example.md)
- [PDF](/doc/Device Capabilities/PDF.md): The PDFDocument and PDFPage classes in the Scripting app provide a simplified and powerful interface for working with PDF files, including reading, editing, and exporting content. Both synchronous and asynchronous methods are supported for optimal flexibility.
- [Pasteboard](/doc/Device Capabilities/Pasteboard.md): The Pasteboard namespace provides a complete interface for reading, writing, and observing system pasteboard (clipboard) changes in the Scripting app.
Compared to the deprecated Clipboard API, Pasteboard offers more robust features, including: Support for multiple data types (text, images, URLs, binary data, etc.)Change event callbacks (onChanged and onRemoved)Privacy controls such as localOnly and expiration time Note
To allow pasting from other apps, go to:
Settings > Scripting > Paste from Other Apps > Allow
- [Photos](/doc/Device Capabilities/Photos/index.md): The Photos module provides unified access to the system photo library and camera. It enables scripts to: Capture photos or record videos using the system cameraPick images, videos, or Live Photos from the photo libraryRetrieve the most recent photosSave images or videos to the Photos app All APIs are built on top of native iOS frameworks such as Photos and PHPicker, and follow these principles: System-managed permissionsPromise-based asynchronous APIsSystem-controlled UI presentationSecure and constrained access to media data
- [Example](/doc/Device Capabilities/Photos/index_example.md)
- [AVPlayerView](/doc/Device Capabilities/Play Video/AVPlayerView.md): AVPlayerView is a video playback component introduced in Scripting that wraps the system-native AVPlayerViewController.
Unlike VideoPlayer, AVPlayerView fully supports system Picture in Picture (PiP) and exposes PiP lifecycle state to scripts. This component is intended for media-centric scenarios where native playback behavior, PiP, Now Playing integration, and background playback are required.
- [VideoPlayer](/doc/Device Capabilities/Play Video/VideoPlayer/index.md): The VideoPlayer view integrates a powerful AVPlayer backend with a simple, customizable front-end UI for playing video and audio content. With this setup, you can easily load media, control playback, handle events, and even add custom overlays.
- [Example](/doc/Device Capabilities/Play Video/VideoPlayer/index_example.md)
- [QRCode](/doc/Device Capabilities/QRCode.md)
- [QuickLook](/doc/Device Capabilities/QuickLook.md): The QuickLook API in the Scripting app provides a simple way to preview text, images, or files within your scripts. This is a wrapper around iOS QuickLook capabilities, allowing you to quickly display previews for a wide range of content types. Each method returns a promise that resolves when the QuickLook view is dismissed, enabling you to chain actions or handle post-preview logic easily.
- [Recurrence](/doc/Device Capabilities/Recurrence.md): The recurrence-related types and classes (RecurrenceFrequency, RecurrenceDayOfWeek, RecurrenceWeekday, RecurrenceEnd, and RecurrenceRule) allow you to define and manage recurring patterns for events and reminders in the Scripting app. These types and classes make it possible to set up recurrence intervals, specify days or months for recurring patterns, and define end conditions.
- [Reminder](/doc/Device Capabilities/Reminder.md): The Reminder API provides the ability to create, edit, and manage reminders in the iOS calendar system.
It supports configuring due dates through DateComponents, assigning priorities, adding notes, managing recurrence rules, working with alarms, and tracking completion state.
This API is suitable for a wide range of task and schedule reminder scenarios. The Reminder class represents an individual reminder item and provides properties and methods to read and modify its data. identifier: string A unique identifier assigned by the system (read-only). calendar: Calendar The calendar to which the reminder belongs.
Each reminder must be associated with a calendar. title: string The title or summary of the reminder. notes: string | null Optional notes providing additional context.
- [Safari](/doc/Device Capabilities/Safari/index.md): The Safari module provides functions to open and display websites either externally using the system default browser or internally within the Scripting app using an in-app Safari view. It enables seamless web content access in both immersive and external browsing scenarios.
- [Example](/doc/Device Capabilities/Safari/index_example.md)
- [Send Mail](/doc/Device Capabilities/Send Mail.md): The MailUI module allows your script to present a native mail compose view, enabling users to send emails with recipients, subject, body, and attachments prefilled. It also provides a way to check whether the device is capable of sending emails. The original Mail module is deprecated and has been replaced by MailUI.
- [Send Message](/doc/Device Capabilities/Send Message.md): The MessageUI namespace provides functions to detect messaging capabilities and present a system message compose view from within a script. You can send SMS or MMS messages with optional subject and attachments, depending on device capabilities.
- [ShareSheet](/doc/Device Capabilities/ShareSheet.md)
- [SharedAudioSession](/doc/Device Capabilities/SharedAudioSession.md): The SharedAudioSession interface provides a convenient way to manage and interact with the shared audio session in your script. The audio session acts as an intermediary between your script, the Scripting app, the operating system, and the underlying audio hardware, enabling you to configure and control audio behavior effectively.
- [Speech](/doc/Device Capabilities/Speech/index.md): The Speech interface provides a high-level API for text-to-speech (TTS) functionality. This interface allows you to synthesize speech, control playback, and manage speech synthesis settings. Below are the details of the Speech API, its methods, properties, and usage examples.
- [Example](/doc/Device Capabilities/Speech/index_example.md)
- [SpeechRecognition](/doc/Device Capabilities/SpeechRecognition/index.md): The SpeechRecognition interface provides a high-level API for performing speech recognition. It supports real-time speech recognition and recognition of audio files, offering flexibility in a variety of use cases.
- [Example](/doc/Device Capabilities/SpeechRecognition/index_example.md)
- [Translation <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/Translation.md): The Translation API enables text translation between different languages. It supports both individual and batch translation use cases and is available on iOS 18.0 or later.
- [VideoRecorder <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Device Capabilities/VideoRecorder.md): VideoRecorder provides a programmable video recording session in Scripting.
It encapsulates camera selection, audio/video capture, encoding, pause/resume handling, zoom, focus, torch control, and final file writing. This API is intended for custom camera interfaces, video capture utilities, and automated recording workflows.
- [Vision](/doc/Device Capabilities/Vision.md): The Vision module provides APIs for text recognition tasks.It supports recognizing text from static images or by scanning documents using the camera.
- [Weather](/doc/Device Capabilities/Weather/index.md): The Weather API in Scripting provides access to real-time and forecast weather data, including current conditions, hourly forecasts, and daily forecasts. This API allows users to fetch weather details such as temperature, wind speed, humidity, and precipitation for a specified location.
- [Example](/doc/Device Capabilities/Weather/index_example.md)
- [WebViewController](/doc/Device Capabilities/WebViewController.md): The WebViewController class allows you to display and interact with embedded web content inside your script. It is designed for use cases like custom in-app browsers, rendering dynamic HTML, or communicating with JavaScript running in a web context.
- [Intent.continueInForeground <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Intent/Intent.continueInForeground.md): Intent.continueInForeground is an API that leverages the iOS 26+ AppIntents framework to request the system to bring the Scripting app to the foreground while a Shortcut is running. This method is used when a script—invoked from Shortcuts—requires full UI interaction within the Scripting app (for example: presenting a form, editing content, picking files, showing a full screen navigation flow, etc.). When invoked: The system displays a dialog asking the user to continue the workflow in the app.If the user confirms, the system opens Scripting in the foreground and the script continues.If the user cancels, the script terminates immediately. Because this is a system-level capability of AppIntents: This API requires iOS 26 or later.
- [Intent.requestConfirmation <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Intent/Intent.requestConfirmation.md): Intent.requestConfirmation pauses script execution and asks the user to confirm an action through a system-managed confirmation UI.
The confirmation interface consists of: A SnippetIntent UI (provided by you)Optional dialog text (system-generated or developer-defined) Behavior: If the user confirms, the script continues (Promise resolves).If the user cancels, the script terminates immediately.The UI is fully managed by the system.The presented UI is defined by the provided SnippetIntent’s perform() return. This API is only available on iOS 26 or later.
- [Quick Start](/doc/Intent/Quick Start.md): Scripting allows you to define custom iOS Intents using an intent.tsx file. These scripts can receive input from the iOS share sheet or the Shortcuts app and return structured results. With optional UI presentation, you can create interactive workflows that process data and deliver output dynamically.
- [SnippetIntent <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Intent/SnippetIntent.md): SnippetIntent is a special kind of AppIntent whose purpose is to render interactive Snippet UI cards inside the Shortcuts app (iOS 26+). Key characteristics: Must be registered in app_intents.tsxMust specify protocol: AppIntentProtocol.SnippetIntentperform() must return a VirtualNode (TSX UI)Must be returned via Intent.snippetIntent()Must be invoked from the Shortcuts action “Show Snippet Intent”SnippetIntent is ideal for building interactive, step-based UI inside a Shortcut It is not a data-returning Intent; it is exclusively for UI rendering in Shortcuts. SnippetIntent requires iOS 26 or later. On iOS versions earlier than 26: Intent.snippetIntent() is not availableIntent.requestConfirmation() cannot be usedThe Shortcuts action “Show Snippet Intent” does not existSnippetIntent-type AppIntents cannot be invoked by Shortcuts Example: Another SnippetIntent: Requirements: protocol must be AppIntentProtocol.SnippetIntentperform() must return a TSX UI (VirtualNode)SnippetIntent cannot return non-UI types such as text, numbers, JSON, or file paths A SnippetIntent cannot be passed directly to Script.exit().
It must be wrapped in a IntentSnippetIntentValue. Type Definition This wrapper makes the return value compatible with the Shortcuts “Show Snippet Intent” action. iOS 26 Snippet Framework provides built-in confirmation UI driven by SnippetIntent. API ConfirmationActionName A predefined list of semantic action names used by system UI: Example Execution behavior: Displays a Snippet UI for confirmationIf the user confirms → Promise resolves and script continuesIf the user cancels → execution stops (system-driven behavior) iOS 26 adds a new Shortcuts action: Show Snippet Intent This action is the only correct way to display SnippetIntent UI. Comparison with Other Scripting Actions Usage Add “Show Snippet Intent” in ShortcutsSelect a Scripting script projectThe script must return Intent.snippetIntent(...)Shortcuts renders the UI in a Snippet card
- [Interactive Widget and LiveActivity](/doc/Interactive Widget and LiveActivity.md): The Scripting app supports adding interactivity to widgets and LiveActivity, allowing you to create dynamic and interactive UIs using Button and Toggle components. These controls can execute AppIntents to trigger actions, making your widgets and live activities more powerful.
- [LiveActivity](/doc/LiveActivity.md): The LiveActivity API enables you to display real-time, dynamic information from your script on the Lock Screen and, where supported, in the Dynamic Island on iOS devices. It provides a structured interface to start, update, and end Live Activities, and observe their state throughout their lifecycle. This document provides a complete guide to using the LiveActivity API in the Scripting app, including: Core concepts and lifecycleHow to register a Live Activity UIHow to start, update, and end Live ActivitiesUI layout for Dynamic Island and Lock ScreenFull TypeScript/TSX examplesDetailed descriptions of every type and option The API wraps Apple’s ActivityKit and brings it into the Scripting environment with a React-style UI building approach. A Live Activity can appear in the following regions: Lock ScreenDynamic Island (iPhone 14 Pro and later)Banner-style presentation on devices without Dynamic Island Live Activities are used for time-based and progress-based information, such as: TimersFitness progressDelivery trackingCountdowns and remindersReal-time status updates In Scripting, each Live Activity consists of: contentState (a JSON-serializable object that updates over time)UI Builder (a function that produces TSX UI for each state) Represents a summary of each active Live Activity.
- [Quick Start](/doc/Quick Start.md): Welcome to Scripting, an iOS app that lets you code UI components in TypeScript using React-like TSX syntax. With Scripting, you can create and present iOS utility UI pages through a familiar coding structure, using wrapped SwiftUI views for a smooth, native experience on iOS. This guide walks you through setting up your project, creating components, and working with hooks to build dynamic interfaces. Table of Contents Getting StartedCreating a Script ProjectImporting ComponentsCreating Custom ComponentsPresenting UI ViewsUsing HooksBuilding Complex UIs 1. Getting Started In Scripting, you’ll create simple UI elements by defining them with function components. Every component and API you’ll need can be imported from the scripting package. 2. Creating a Script Project Before you begin coding, you need to create a script project. Once the project is set up, write your code in the index.tsx file. This is your main entry point for defining UI components and logic. Example setup in index.tsx: 3. Importing Views All views and some APIs from SwiftUI are wrapped and accessible through the scripting package. Here’s a list of some available views: Layout Views: VStack, HStack, ZStack, GridControls: Button, Picker, Toggle, Slider, ColorPickerCollections: List, SectionDate and Time: DatePickerText and Labels: Text, Label, TextField To use these in your project, import them as shown: 4. Creating Custom Components Function components in Scripting work just like in React, with JSX-like syntax for building reusable components. Example: 5. Presenting UI Views To present a UI view, use the Navigation.present method. This allows you to display a custom component as a modal view and handle its dismissal. The Navigation.present method returns a promise that fulfills when the view is dismissed. To avoid memory leaks, always call Script.exit() after the view is dismissed. Example: In this example, Navigation.present({ element: <View /> }) displays the View component, and when the user dismisses it, Script.exit() ensures resources are freed. 6. Using Hooks Scripting supports a range of React-like hooks for managing state, effects, memoization, and context. Here’s a guide on how to use each hook with examples: useState The useState hook lets you add local state to a function component. In this example, clicking the button updates the count variable, which automatically re-renders the component. useEffect The useEffect hook lets you perform side effects in your components, such as fetching data or setting up subscriptions. In this example, the useEffect hook sets up an interval to update the time variable every second, and clears the interval on component unmount. useReducer The useReducer hook is useful for managing complex state logic in components. The useReducer hook helps you handle complex state transitions by using a reducer function. useCallback The useCallback hook lets you memoize functions, optimizing performance by preventing unnecessary re-creations of the function on every render. With useCallback, the increment function is only re-created when necessary, improving performance in large or frequently updated components. useMemo The useMemo hook lets you memoize values, caching expensive computations for better performance. The useMemo hook optimizes performance by only re-calculating the factorial when count changes. useContext The useContext hook allows components to access shared state across the app without prop drilling, using a Context API. In this example, useContext accesses CountContext to get a shared count value across the app. 7. Building Complex UIs Combine available views, hooks, and custom components to create complex, fully functional UIs. Example: For further details, check the full API documentation, which includes more examples and use cases for scripting package components and APIs.
- [Script](/doc/Script.md): The Script module provides context and utility functions for managing script execution in the Scripting app. It enables you to access runtime metadata, terminate scripts with results, run other scripts programmatically, and construct URL schemes to launch or open scripts.
- [Alignment](/doc/Types/Alignment.md): The Alignment type defines how to position content within a view’s frame, mirroring the behavior of SwiftUI’s built-in alignments. By applying an Alignment value, you can control where elements will be placed if they have extra space or need to align in a specific way.
- [Color](/doc/Types/Color.md): The Color API supports various color formats, including HEX strings, RGBA strings, and predefined color keywords. It integrates seamlessly with SwiftUI's color system to provide vibrant, adaptive colors for your UI designs.
- [DynamicShapeStyle](/doc/Types/DynamicShapeStyle.md): The DynamicShapeStyle type allows you to define two distinct styles for a shape—one for light mode and another for dark mode. The system automatically applies the appropriate style based on the current color scheme (light or dark) of the user’s device.
- [Shape](/doc/Types/Shape.md): The Shape type defines a visual clipping or background shape used in view modifiers such as clipShape, background, or border. It mirrors SwiftUI's Shape protocol and supports standard system shapes and custom rounded rectangle configurations.
- [ShapeStyle](/doc/Types/ShapeStyle.md): The ShapeStyle type defines how colors, gradients, and materials can be applied to a view’s foreground or background, mirroring the styling capabilities found in SwiftUI. It encompasses a wide range of styling options, including simple colors, system materials, and complex gradients.
- [App Events](/doc/Utilities/App Events.md): The AppEvents module in the Scripting app provides an interface to observe global application state changes, such as scene lifecycle transitions and changes in system-wide appearance (light/dark mode). These capabilities are essential for writing responsive scripts that react appropriately to runtime context.
- [Archive <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/Archive.md): The Archive class provides a comprehensive interface for working with archive files (such as ZIP).
It supports reading, creating, updating, and extracting entries from archives, with both asynchronous and synchronous methods.
- [Crypto](/doc/Utilities/Crypto.md): The Crypto module provides a set of cryptographic utilities for hashing, HMAC authentication, symmetric key generation, and AES-GCM encryption/decryption. It is designed to securely process Data instances using industry-standard algorithms.
- [Data](/doc/Utilities/Data.md): The Data class represents binary data in memory and provides a wide range of methods for manipulating, converting, compressing, decompressing, and transforming that data. It is useful for working with raw byte buffers, encoded files, images, and more.
- [DateComponents](/doc/Utilities/DateComponents.md): The DateComponents class provides a flexible way to represent and manipulate individual components of a date and time value, such as year, month, day, hour, minute, second, and more. This class is modeled after Swift’s DateComponents and integrates with the current system calendar.
- [DateFormatter](/doc/Utilities/DateFormatter.md): The DateFormatter class provides comprehensive date and time formatting capabilities. It allows converting Date objects into localized strings and parsing strings back into Date values.
This API wraps iOS-native date formatting behavior and supports multiple calendars, time zones, localized formats, and custom formatting templates.
- [Encoding](/doc/Utilities/Encoding.md): The Encoding type defines a set of supported character encodings used by methods like: Data.fromRawString(str, encoding) — converts a text string into binary data using the specified encoding.Data.toRawString(encoding) — converts binary data back into a string using the specified encoding. These encodings allow interoperability with various text formats and systems, ensuring compatibility across languages and platforms.
- [FileEntity](/doc/Utilities/FileEntity.md): The FileEntity class provides low-level file read and write operations.
It allows scripts and HTTP servers to open, read, write, seek, and close files efficiently.
FileEntity can also be used as a response body for HttpResponse.raw() to serve static or downloadable files.
- [FileManager](/doc/Utilities/FileManager.md): The FileManager module provides a unified interface for interacting with the file system in Scripting. It serves as the primary API for accessing local files, iCloud files, App Group shared storage, and performing common file operations such as reading, writing, copying, moving, deleting, zipping, and unzipping.
- [HttpRequest <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/HttpServer/HttpRequest.md): The HttpRequest class represents an HTTP request received by the server.
It encapsulates all request information, including path, method, headers, body, client address, and parsed parameters.
An instance of this class is provided as an argument to handler functions registered through HttpServer.registerHandler().
- [HttpResponse <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/HttpServer/HttpResponse.md): The HttpResponse class represents an HTTP response object returned by the server to the client.
It defines the response’s status code, headers, and body, and provides convenient factory methods for creating common HTTP responses (e.g., ok, notFound, internalServerError). HttpResponse is typically used together with HttpResponseBody to send text, HTML, binary data, or files back to the client.
- [HttpResponseBody <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/HttpServer/HttpResponseBody.md): The HttpResponseBody class represents the body content of an HTTP response.
It can contain text, HTML, binary data, or other forms of content.
HttpResponseBody is typically used with the HttpResponse class to return formatted data to the client.
- [HttpServer <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/HttpServer/HttpServer.md): The HttpServer class provides a lightweight local HTTP server that can handle HTTP requests, serve static files, and manage WebSocket connections. It is commonly used for local debugging, communication between devices, and serving simple web APIs inside scripts.
- [WebSocketSession <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/HttpServer/WebSocketSession.md): The WebSocketSession class represents an active WebSocket connection session.
It is created automatically when a client connects to a WebSocket endpoint registered via HttpServer.registerWebsocket() and enables bi-directional real-time communication between the server and the client.
- [ItemProvider](/doc/Utilities/ItemProvider.md): ItemProvider represents a deferred data provider used to access content such as files, images, text, or URLs in a controlled and secure way.
It is commonly used in scenarios like drag and drop, file importing, and content selection from Photos or Files. An ItemProvider does not store the data itself. Instead, it describes how and under what constraints the data can be accessed.
- [OAuth2](/doc/Utilities/OAuth2.md): The OAuth2 class provides a robust interface for managing OAuth 2.0 authorization flows in Scripting. It supports standard authorization code flows, PKCE (Proof Key for Code Exchange), access token renewal, and customizable token handling.
- [Path](/doc/Utilities/Path.md): The Path API provides utility functions for handling and transforming file and directory paths. It is inspired by the Node.js path module, offering familiar methods for developers to work with paths effectively.
- [FormData](/doc/Utilities/Request/FormData.md): The FormData class provides a way to construct key/value pairs representing form fields and their values.
It is mainly used for building multipart/form-data requests that can include both text and binary data (such as files or images). In the Scripting app, FormData is fully compatible with the standard Fetch API, allowing you to send data through fetch() with mixed text and file fields.
- [Headers](/doc/Utilities/Request/Headers.md): The Headers class represents a collection of HTTP request or response header fields.
It is fully compatible with the Fetch API standard but includes additional convenience methods for scripting environments, such as JSON conversion for debugging and serialization. A Headers object can be used in the following contexts: When creating a request via RequestInit.headersWhen reading headers from a Response objectWhen programmatically modifying header data in a script
- [ReadableStream](/doc/Utilities/Request/ReadableStream.md): ReadableStream represents a stream of data that can be read incrementally rather than all at once.
In Scripting, ReadableStream<Data> is used in various scenarios, including: Handling streaming HTTP responses (e.g., Response.body)Chunked file downloads or large data transfersReal-time data streams such as logs, AI model output, or event streams It follows the same behavior as the standard Web Streams API, allowing asynchronous iteration (for await...of) and manual reading via a ReadableStreamDefaultReader.
- [Request & RequestInit](/doc/Utilities/Request/Request & RequestInit.md): The Request class represents a complete configuration of an HTTP request.
It can be passed directly to the fetch() method or used to clone, modify, or retry an existing request. In Scripting, the Request API behaves similarly to the browser’s Fetch API but adds native extensions, including: Binary Data type support for request bodiesCustom redirect handlingRequest timeout and cancellationOptional allowance for insecure (HTTP) requestsDebug labels for internal logging
- [Response](/doc/Utilities/Request/Response.md): The Response class represents the result of an HTTP request made using the fetch() API.
It provides access to the response body, headers, cookies, and metadata such as the status code and MIME type. In the Scripting app, the Response API extends the standard Fetch API behavior to provide native-level enhancements, including: Access to structured cookie dataBinary data handling via the Data typeSupport for response streaming (ReadableStream<Data>)Access to expected content length, MIME type, and text encoding
- [fetch](/doc/Utilities/Request/fetch.md): The fetch() method initiates an HTTP/HTTPS network request and returns a Promise that resolves to a Response object.
It behaves similarly to the standard Fetch API available in browsers but includes native extensions optimized for Scripting’s iOS runtime environment — such as local file access, Data integration, custom redirect handling, abort control, and debugging labels.
- [SFTP Client <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/SSH/SFTP Client.md): SFTPClient provides access to a remote file system over an SSH connection using the SFTP protocol.
It supports directory operations, file management, attribute retrieval, and path resolution.
Files can be opened using openFile(), which returns an SFTPFile instance for reading and writing. Instances of this class are typically created through:
- [SFTP File <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/SSH/SFTP File.md): SFTPFile represents an opened remote file accessed through an SFTP session.
It provides low-level operations such as reading, writing, retrieving attributes, and closing the file. Instances of this class are typically obtained through:
- [SSH Authentication Method <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/SSH/SSH Authentication Method.md): Represents a method for authenticating with an SSH server. This class provides static methods for creating different types of SSH authentication strategies, including password-based, RSA key, ED25519, and ECDSA (P-256, P-384, P-521) private key authentication. This class is essential when connecting to an SSH server using the SSHClient.connect() method.
- [SSH Client <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/SSH/SSH Client.md): The SSHClient class provides an interface for connecting to a remote SSH server, executing commands, opening TTY or PTY sessions, transferring files via SFTP, and performing multi-hop SSH jumps. It supports both command-based and interactive terminal-based workflows. This class is central to establishing and managing SSH sessions in your script.
- [TTY Stdin Writer <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/Utilities/SSH/TTY Stdin Writer.md): Represents a writable input stream for a TTY (teletypewriter) session opened over SSH. This class allows writing text to the remote terminal’s standard input and resizing the terminal window dynamically. This class is typically returned from methods such as SSHClient.withPTY() and SSHClient.withTTY().
- [Storage](/doc/Utilities/Storage.md): The Storage module provides a lightweight persistent key-value storage system for scripts. It allows scripts to save and retrieve simple typed data as well as binary data (Data). All data is persisted asynchronously in the background. By default, all values are stored in the private domain of the current script, which means other scripts cannot access them. To share data across multiple scripts, set the shared: true option to use the shared domain instead. The following types can be stored using the Storage API: stringnumberbooleanJSON (any JSON-serializable structure)Data (using setData / getData)
- [Thread](/doc/Utilities/Thread.md): Scripting’s UI rendering system and the vast majority of JavaScript execution run on the main thread by default. In normal usage, developers rarely need to manually switch threads. However, some system APIs or internal operations may occasionally execute on a background thread. To ensure UI updates are always safe, and to support running heavy work without blocking the main thread, Scripting provides the global Thread API. Thread is a global namespace and does not require imports.
- [UIImage](/doc/Utilities/UIImage.md): The UIImage class represents an image object that can be loaded, encoded, converted, and displayed.
It supports creating images from file paths, binary data, or Base64 strings and provides multiple format conversion methods (PNG/JPEG).
UIImage can be displayed directly in an Image component or used with the Data class for storage, uploading, or encryption.
- [BackgroundURLSession](/doc/Utilities/URLSession/BackgroundURLSession.md): BackgroundURLSession provides APIs in the Scripting app for creating, resuming, and managing background download and upload tasks that continue running even when your script or app is not active. Availability: Only available when your script is running in the main app (Script.env === "index").
- [URLSessionDownloadTask](/doc/Utilities/URLSession/URLSessionDownloadTask.md): URLSessionDownloadTask represents a background download task created by
BackgroundURLSession.startDownload() or BackgroundURLSession.resumeDownload().
It allows scripts in the Scripting app to download files in the foreground or background, and the task can continue even if the script is terminated or the app is suspended. Each download task is managed by the system and provides detailed state, progress, and event callbacks.
- [URLSessionUploadTask](/doc/Utilities/URLSession/URLSessionUploadTask.md): URLSessionUploadTask represents a background upload task instance.
It is created via BackgroundURLSession.startUpload() or BackgroundURLSession.resumeUpload() and allows file uploads to continue in the Scripting app, even when the app is in the background or the script is terminated. Each upload task provides real-time state, progress, and event callbacks for tracking upload activity.
- [UUID](/doc/Utilities/UUID.md): The UUID module provides an easy way to generate unique UUID strings.
- [WebScoket](/doc/Utilities/WebScoket.md): The WebSocket class provides an interface for creating and managing WebSocket connections, allowing for real-time communication with a server. You can send and receive both text and binary data, including byte buffers, over the WebSocket connection.
- [socket.io](/doc/Utilities/socket.io.md): The Socket.IO API provides robust tools for managing real-time, bidirectional communication between clients and servers. It includes a SocketManager for handling multiple namespaces and a SocketIOClient for individual socket connections. This document provides an overview of the API, including setup, configuration, and usage.
- [Animation and Transition](/doc/View Modifiers/Animation and Transition.md): Scripting Animation & Transition System The Animation class describes how values animate in time.
- [Chaining View Modifiers](/doc/View Modifiers/Chaining View Modifiers.md): The modifiers property allows you to apply multiple view modifiers to a view using a fluent, chainable syntax. This API is a flexible and expressive alternative to the traditional single modifier attribute on a view in TSX, which only supports one layer of modification. With modifiers, you can apply the same modifier multiple times (e.g., nested paddings or backgrounds), control modifier order explicitly, and build view style stacks that are closer in spirit to SwiftUI.
- [ChartMarkProps](/doc/View Modifiers/ChartMarkProps/index.md): ChartMarkProps defines a set of visual and behavioral modifiers applicable to individual chart marks such as bars, lines, or areas. These modifiers allow developers to customize the appearance, layout, and dynamic behavior of chart elements in BarChart, LineChart, AreaChart, and other mark-based components.
- [Charts Style](/doc/View Modifiers/Charts Style.md): The Chart component in the Scripting app provides a highly customizable interface for creating and displaying various types of charts. This documentation explains how to use the properties of the Chart view to configure axes, scales, labels, legends, and more. 1. Axis Visibility chartXAxisType: "automatic" | "hidden" | "visible"Description: Sets the visibility of the X-axis.Example:<Chart chartXAxis="visible">
  <BarChart ... />
</Chart>chartYAxisType: "automatic" | "hidden" | "visible"Description: Sets the visibility of the Y-axis.Example:<Chart chartYAxis="hidden">
  <LineChart ... />
</Chart> 2. Axis Labels chartXAxisLabelType:{
  position?: "automatic" | "bottom" | "bottomLeading" | "bottomTrailing" | "leading" | "overlay" | "top" | "topLeading" | "topTrailing" | "trailing";
  alignment?: "leading" | "center" | "trailing";
  spacing?: number;
  content: VirtualNode;
}Description: Adds a label to the X-axis.Example:<Chart
  chartXAxisLabel={{
    position: "bottom",
    alignment: "center",
    spacing: 10,
    content: <Text>X Axis Label</Text>,
  }}
>
  <BarChart ... />
</Chart>chartYAxisLabelType: Same as chartXAxisLabel.Description: Adds a label to the Y-axis.Example:<Chart
  chartYAxisLabel={{
    position: "leading",
    content: <Text>Y Axis Label</Text>,
  }}
>
  <LineChart ... />
</Chart> 3. Legend chartLegendType:"automatic" | "hidden" | "visible" | {
  position?: "automatic" | "bottom" | "bottomLeading" | "bottomTrailing" | "leading" | "overlay" | "top" | "topLeading" | "topTrailing" | "trailing";
  alignment?: "leading" | "center" | "trailing";
  spacing?: number;
  content?: VirtualNode;
}Description: Configures the chart legend.Example:<Chart
  chartLegend={{
    position: "top",
    alignment: "center",
    content: <Text>Legend</Text>,
  }}
>
  <AreaChart ... />
</Chart> 4. Scales chartXScale / chartYScaleType:ClosedRange<number> | ClosedRange<Date> | string[] | "category" | "date" | "linear" | "log" | "squareRoot" | "symmetricLog" | {
  domain: ClosedRange<number> | ClosedRange<Date> | string[];
  type: "category" | "date" | "linear" | "log" | "squareRoot" | "symmetricLog";
}Description: Configures the X or Y-axis scale.Example:<Chart
  chartXScale={{ domain: { from: 0, to: 100 }, type: "linear" }}
  chartYScale={["A", "B", "C"]}
>
  <LineChart ... />
</Chart> 5. Background chartBackgroundType:VirtualNode | {
  alignment?: "leading" | "center" | "trailing";
  content: VirtualNode;
}Description: Adds a background to the chart container.Example:<Chart
  chartBackground={{
    alignment: "center",
    content: <Rectangle fill="gray" />,
  }}
>
  <PieChart ... />
</Chart> 6. Foreground Style chartForegroundStyleScaleType:Record<string, ShapeStyle>;Description: Customizes colors for marks in the chart.Example:<Chart
  chartForegroundStyleScale={{
    "Category 1": { color: "blue" },
    "Category 2": { color: "red" },
  }}
>
  <BarChart ... />
</Chart> 7. Scrollable Axes chartScrollableAxesType:"vertical" | "horizontal" | "all"Description: Enables scrolling for the specified axes.Example:<Chart chartScrollableAxes="horizontal">
  <LineChart ... />
</Chart> 8. Selection chartXSelection / chartYSelection / chartAngleSelectionType:{
  value: string | number | null;
  onChanged: (newValue: string | number | null) => void;
  valueType: "string" | "number";
}Description: Enables selection for the specified axis.Example:<Chart
  chartXSelection={{
    value: "Category 1",
    onChanged: (newValue) => console.log("Selected:", newValue),
    valueType: "string",
  }}
>
  <BarChart ... />
</Chart> 9. Scroll Position chartScrollPositionX / chartScrollPositionYType:number | string | {
  value: number | string;
  onChanged: (newValue: number | string) => void;
}Description: Sets the initial scroll position along the X or Y-axis.Example:<Chart
  chartScrollPositionX={{
    value: 0,
    onChanged: (newValue) => console.log("Scroll X:", newValue),
  }}
>
  <BarChart ... />
</Chart>
- [Grid Layout Control](/doc/View Modifiers/Grid Layout Control.md): These view modifiers are used to control the layout behavior of individual views placed inside a Grid structure. They provide fine-grained control over cell spanning, alignment, and sizing, consistent with SwiftUI’s grid system. gridCellColumns Tells a view in a grid to span across multiple columns. Type Description Use this modifier to expand a single view across two or more columns. This is typically used for headers or wide content rows. Example gridCellAnchor Specifies a custom alignment anchor within the grid cell. Type Description Use this modifier to align the content of a cell to a specific anchor point, either using a named keyword (such as "center" or "topLeading") or a custom { x, y } point. Example gridCellUnsizedAxes Prevents the view from expanding in the specified directions when placed in a grid cell. Type Description This modifier tells the grid not to assign extra size to the view along specified axes, allowing the view to tightly wrap its content. Options "horizontal" – Prevent horizontal expansion"vertical" – Prevent vertical expansion"all" – Prevent expansion in both directions Example gridColumnAlignment Overrides the default horizontal alignment of the column the view appears in. Type Description Affects how all cells in the column are aligned horizontally. Only one view in a column needs to specify this to affect the whole column. Example
- [Image Style](/doc/View Modifiers/Image Style.md): These modifiers are specifically designed for views that render images (e.g., system symbols, local or remote images). They control layout behavior, scaling, and rendering characteristics of the image content.
- [Lifecycle Events](/doc/View Modifiers/Lifecycle Events.md): Scripting supports SwiftUI-style lifecycle hooks onAppear and onDisappear to execute custom logic when a view becomes visible or is removed from the visible interface. These hooks allow you to trigger animations, start data loading, update state, or perform cleanup when views enter or exit the screen.
- [Glass Effect Transition](/doc/View Modifiers/Liquid Glass/Glass Effect Transition/index.md): This document provides a comprehensive explanation of Glass Effect Transitions in Scripting, including how Liquid Glass materials animate during view changes, how geometry matching works, and how to correctly use NamespaceReader to access SwiftUI’s @Namespace within TSX code. Contents include: Overview of Liquid Glass transitionsThe three transition typesRelationship among glassEffectTransition, glassEffectID, and namespaceRole of glassEffectUnionPurpose and behavior of GlassEffectContainerDesign and usage of NamespaceReaderDetailed walkthrough of the provided exampleBest practice recommendations A Glass Effect Transition defines how a Liquid Glass material animates when: A view is inserted or removedLayout changesViews switch between two states These transitions affect only the Liquid Glass material—not the rest of the view’s opacity or scale. A transition controls: How the glass material appears or disappearsWhether the shape of the glass participates in animationWhether the glass attempts to match geometry with other shapes
- [Example](/doc/View Modifiers/Liquid Glass/Glass Effect Transition/index_example.md)
- [Liquid Glass Effect](/doc/View Modifiers/Liquid Glass/Liquid Glass Effect/index.md): Scripting provides full support for the new Liquid Glass visual system introduced in iOS 26. This includes glassEffect, GlassEffectContainer, UIGlass, and related geometry-matching and transition APIs. These APIs allow scripts to create rich translucent materials, fluid glass shapes, matched geometry animations, and unioned glass regions directly within TSX. This document explains how the Liquid Glass APIs are used in Scripting, including: Concepts and fundamentalsHow to apply glass effectsUIGlass configurationGeometry transitionsglassEffect identifiers and unionsGlassEffectContainer behaviorPractical examples and best practices Liquid Glass is a new material and animation system in iOS 26. Compared to earlier blur or material effects, Liquid Glass provides: Fluid, dynamic shapes that follow view geometryTintable and interactive glass materialsGeometry-matched transitionsGrouped “glass unions” to merge multiple regionsHigh-performance rendering inside containers Any view that adopts GlassProps can apply a Liquid Glass effect using the glassEffect property. Definition
- [Example](/doc/View Modifiers/Liquid Glass/Liquid Glass Effect/index_example.md)
- [Common](/doc/View Modifiers/List and Section View Modifiers/Common.md): These modifiers allow you to customize how rows and sections behave and appear inside a <List> component.
- [New List View Modifiers](/doc/View Modifiers/List and Section View Modifiers/New List View Modifiers.md): Description Controls whether the List shows the right-side section index (commonly used for A–Z navigation in contact lists). Possible values: "visible""hidden""automatic" (default system behavior) Example Description Customizes the margins of a section. When set, it fully replaces SwiftUI’s default section margin rules. Supported Formats 2.1 Single number Applies the same margin to all edges. 2.2 EdgeSets Applies the specified edges with the default margin. 2.3 Specific edges with length Applies a margin of length only to the specified edges. Equivalent to SwiftUI: Example Description Sets the character or text displayed in the right-side section index for this section. Typically a single letter. Example Description Adds custom UI elements such as buttons or menus to the section header’s trailing (accessory) area. Example: Refresh button Example: Menu with multiple actions
- [LiveActivity View Modifiers](/doc/View Modifiers/LiveActivity View Modifiers.md): Scripting provides two view modifiers that customize the appearance of Live Activities on the Lock Screen. These modifiers control the background tint color of the Live Activity and the foreground color of the system-provided action button. These properties are designed to match SwiftUI’s Live Activity customization options. These modifiers can only be applied to the content view of the Live Activity UI. They do not take effect when placed in: compactLeadingcompactTrailingminimal Only the full-size Lock Screen presentation (the content region) supports these appearance customizations.
- [Navigation View Modifiers](/doc/View Modifiers/Navigation View Modifiers.md): The Scripting app supports a set of navigation-related view modifiers that enable developers to control how views are presented within navigation stacks. These modifiers allow for the customization of navigation titles, title display styles, and back button behavior—closely following the conventions of SwiftUI's navigation system.
- [Picture in Pictuer View Modifiers <span style={{ backgroundColor:'#007bff',color:'white',borderRadius:'6px',padding:'2px 6px',fontSize:'0.7em',marginLeft:'8px'}}>PRO](/doc/View Modifiers/Picture in Pictuer View Modifiers.md): Scripting provides a set of Picture in Picture (PiP) view modifiers that allow developers to render any SwiftUI view inside a system PiP window.
These APIs abstract away the underlying AVPictureInPicture implementation and provide a declarative, script-friendly way to control PiP presentation, interaction, and lifecycle. PiP is suitable for the following scenarios: Real-time status display (timers, workouts, progress indicators)Audio or video playback companion UILightweight views that should remain visible when the app enters background
- [Presentation View Modifiers](/doc/View Modifiers/Presentation View Modifiers.md): These view modifiers customize the appearance, sizing, and interaction behavior of views presented using sheet in the Scripting app. They allow for adaptive presentations, resizing with detents, background interaction control, and more. Apply these modifiers to the root view of the sheet content (e.g., <VStack>, <NavigationStack>, or <List>).
- [Redaction View Modifiers](/doc/View Modifiers/Redaction View Modifiers.md): The Scripting app supports view modifiers for applying redaction to a view hierarchy. Redaction allows views to display placeholder, obscured, or invalidated content, commonly used to indicate loading states, protect sensitive data, or mark content as outdated. These modifiers closely follow SwiftUI's redacted(reason:) and unredacted() API behavior.
- [Safe Area](/doc/View Modifiers/Safe Area.md): Safe area modifiers in Scripting allow you to adjust layout behavior relative to the system-defined safe areas, such as the areas around notches, toolbars, or the on-screen keyboard.
- [Search Interactions](/doc/View Modifiers/Search Interactions.md): The Scripting app supports advanced search interactions similar to SwiftUI. You can add a search bar, control its visibility and placement, react to changes in input, and display dynamic suggestions.
- [Set environment values (environments)](/doc/View Modifiers/Set environment values (environments).md): The environments view modifier allows injecting specific environment values into the current view hierarchy.
It serves a role similar to SwiftUI’s .environment(), but with a more explicit and controlled design tailored for Scripting. Currently, the modifier supports: editMode — controls editing behavior in views such as ListopenURL — customizes how links are handled when tapped These environment values affect all descendants within the modified view subtree. The editMode environment value controls the editing state of views that support editing behavior, such as List with row deletion or movement. It must be provided as an Observable<EditMode> so views can reactively update when the editing state changes.
- [Swipe Actions](/doc/View Modifiers/Swipe Actions/index.md): In the Scripting app, you can attach swipe actions to views used as rows in a <List> (such as <HStack>) to support contextual interactions like deleting, editing, marking favorites, etc. To improve clarity and ease of use in TypeScript, the SwiftUI swipeActions modifier is split into two separate modifiers: leadingSwipeActions: For swipe gestures from left to right.trailingSwipeActions: For swipe gestures from right to left.
- [Example](/doc/View Modifiers/Swipe Actions/index_example.md)
- [Symbol Style](/doc/View Modifiers/Symbol Style.md): These modifiers allow you to customize how SF Symbols are displayed and animated inside views, particularly with the Image component.
- [Text Field](/doc/View Modifiers/Text Field.md): The following modifiers customize the behavior and appearance of TextField components. These allow you to control keyboard behavior, input handling, and submission logic.
- [Text View Modifiers](/doc/View Modifiers/Text View Modifiers.md): The following properties allow you to style and format text-based views, such as Text or Label, in ways that closely mirror SwiftUI’s built-in modifiers. By customizing these properties, you can control the font, weight, design, spacing, and other typographic attributes of the displayed text.
- [Toast](/doc/View Modifiers/Toast.md): The toast view modifier displays a temporary notification message (toast) over the current view.
It is typically used to show short feedback messages such as “Saved successfully,” “Action completed,” or “Network error.” You can show a simple text message or provide a fully custom view as the toast’s content.
You can also control its duration, position, background color, text color, corner radius, and shadow style.
- [ToolBar View Modifiers](/doc/View Modifiers/ToolBar View Modifiers.md): The Scripting app supports a collection of view modifiers that control the visibility, appearance, and behavior of system toolbars, including the navigation bar, bottom bar, and tab bar. These modifiers align closely with SwiftUI's APIs and provide declarative control over toolbar configuration at the view level.
- [blur](/doc/View Modifiers/blur.md): Applies a Gaussian blur effect to the view.
- [border](/doc/View Modifiers/border.md): The border property adds a border around the view using the specified style and optional width. This allows you to visually outline views with solid colors, gradients, or system materials, and support light/dark mode adaptations.
- [buttonStyle](/doc/View Modifiers/buttonStyle.md): The buttonStyle property allows you to customize the interaction behavior and appearance of buttons within a view hierarchy in your UI.
- [clipShape](/doc/View Modifiers/clipShape.md): Clips the view to the specified shape while maintaining its aspect ratio. Type Example
- [clipped](/doc/View Modifiers/clipped.md): Clips the view to its rectangular bounds. You can specify whether to apply anti-aliasing for smooth edges.
- [colorConvert](/doc/View Modifiers/colorConvert.md): Inverts the colors in this view. Useful for accessibility or visual emphasis. Type Example
- [containerRelativeFrame](/doc/View Modifiers/containerRelativeFrame.md): Positions the view within an invisible frame whose size and position are relative to its nearest container. This modifier is especially useful when working with container views like ScrollView, Grid, or layout stacks to achieve proportional layout behavior.
- [contentMargins](/doc/View Modifiers/contentMargins.md): The contentMargins modifier configures custom margins around a view’s content. This allows precise control over layout spacing, particularly in scrollable containers such as ScrollView, List, or Form. You can apply margins uniformly or selectively to certain edges and placement contexts.
- [contentShape](/doc/View Modifiers/contentShape.md): The contentShape property defines the interactive or visual boundary shape of a view's content. This shape can influence how a view behaves during interactions such as tapping, dragging, accessibility focus, hover effects, and previews. It is commonly used to fine-tune the hit-testing area or provide a custom visual outline for advanced interaction features. This is especially useful for views like Button, ListRow, or custom views where the tappable or interactive area should differ from the visual content.
- [contentTransition](/doc/View Modifiers/contentTransition.md): The contentTransition modifier specifies a transition animation to apply when the content within a single view changes. Unlike view-level transitions (such as .transition(.move)), contentTransition animates changes in content rather than the insertion or removal of the view itself. This is particularly useful when updating the contents of views like Text, Image, or symbol-based Image(systemName: ...), providing smooth visual feedback on state or data changes.
- [contextMenu](/doc/View Modifiers/contextMenu.md): The contextMenu property allows a view to present a contextual menu when the user performs a long-press or right-click gesture. This behavior is consistent with the system-provided context menus in iOS and iPadOS. Developers can define menu items and optionally include a preview view that appears alongside the menu.
- [controlGroupStyle](/doc/View Modifiers/controlGroupStyle.md): The controlGroupStyle property allows you to set the visual and interactive style for control groups within your view, reflecting the look and feel found in SwiftUI. By defining a ControlGroupStyle, you can influence how related controls—such as buttons, toggles, or other interactable elements—are grouped and presented to the user.
- [datePickerStyle](/doc/View Modifiers/datePickerStyle.md): The datePickerStyle property allows you to customize the appearance and interaction of the DatePicker view in your UI.
- [disabled](/doc/View Modifiers/disabled.md): Disables user interactions for this view and its children. Visual elements typically appear dimmed.
- [fixedSize](/doc/View Modifiers/fixedSize.md): Fixes the size of a view to its ideal dimensions, preventing the view from being compressed or expanded beyond its natural size.
- [flipsForRightToLeftLayoutDirection](/doc/View Modifiers/flipsForRightToLeftLayoutDirection.md): Determines whether the view should horizontally mirror its contents when the system layout direction is right-to-left (RTL), such as when the user interface is set to a right-to-left language (e.g., Arabic or Hebrew).
- [foregroundStyle & background](/doc/View Modifiers/foregroundStyle & background.md): These two modifiers—foregroundStyle and background—allow you to customize the visual styling of view content and its background, supporting a wide range of styles including solid colors, gradients, materials, and dynamic appearances for light/dark mode.
- [formStyle](/doc/View Modifiers/formStyle.md): The FormStyle type defines how a form’s content is visually arranged and presented. By choosing a particular style, you can influence the layout of labels, controls, and sections within your form, providing a more organized and intuitive user experience.
- [frame](/doc/View Modifiers/frame.md): The frame property defines the size and alignment of a view. You can specify it in one of two formats: 1. Fixed Width and Height This format allows you to specify a fixed width and/or height for the view, as well as how it is aligned within that frame. Example 2. Flexible Frame Constraints This format gives more control over layout by specifying minimum, maximum, and ideal dimensions for the frame. These values can be numeric or 'infinity', which instructs the view to expand to fill available space. Example
- [gaugeStyle](/doc/View Modifiers/gaugeStyle.md): The GaugeStyle type defines how a gauge is visually represented. By selecting a particular style, you control whether the gauge appears as a ring, a bar, or uses markers to indicate the current value. Some styles only apply on specific platforms (notably watchOS), while others are more broadly available.
- [hidden](/doc/View Modifiers/hidden.md): If true, the view is invisible and does not respond to interactions. However, it still occupies layout space in the view hierarchy.
- [labelsHidden](/doc/View Modifiers/labelsHidden.md): Hides the labels of controls (e.g. Picker, DatePicker) contained within the view. The controls remain visible and functional.
- [layoutPriority](/doc/View Modifiers/layoutPriority.md): layoutPriority determines how much priority a view has when its parent layout allocates space among multiple child views, especially when space is constrained. When multiple child views compete for space within a layout, those with a higher layout priority will be allocated more space, while those with a lower priority may be compressed or truncated.
- [listStyle](/doc/View Modifiers/listStyle.md): The listStyle property allows you to customize the behavior and appearance of a list in your UI when using the List view.
- [mask](/doc/View Modifiers/mask.md): The mask modifier clips the visual rendering of a view using the alpha channel of another view. Only the parts of the original view that align with the opaque (non-transparent) portions of the mask remain visible; the rest is hidden. This is commonly used to apply custom shapes, spotlight effects, or partial reveals.
- [matchedGeometryEffect](/doc/View Modifiers/matchedGeometryEffect.md): matchedGeometryEffect establishes a geometric relationship between different views, allowing them to animate smoothly when transitioning across: Different layoutsDifferent containersDifferent conditional render statesDifferent size and position configurations It corresponds to SwiftUI’s matchedGeometryEffect and is a component-level geometry animation system, independent of navigation.
- [matchedTransitionSource](/doc/View Modifiers/matchedTransitionSource.md): matchedTransitionSource marks a view as the geometric source of a navigation transition. It allows a view to act as the starting point of a page-level transition animation, such as a zoom (Hero-style) transition. This API corresponds to SwiftUI’s matchedTransitionSource and is intended only for navigation transitions, not for component-level layout animations. Typical use cases include: Image → Image detail zoomCard → Detail page Hero animationAvatar → Profile page transition
- [offset](/doc/View Modifiers/offset.md): Moves the view from its original position by the specified x and y distances.
- [onDrag and onDrop View Modifiers](/doc/View Modifiers/onDrag and onDrop View Modifiers.md): Scripting provides a Drag & Drop API closely aligned with the SwiftUI drag-and-drop interaction model. It enables views to act as drag sources, drop destinations, or both, supporting intra-app and cross-app drag-and-drop scenarios. The API is composed of three core parts: onDrag: Declares a view as a drag sourceonDrop: Declares a view as a drop destinationDropInfo / ItemProvider / UTType: Context objects describing drag content and state Drag and drop is a system-controlled interaction. Certain APIs are only valid during specific callbacks. These constraints are explicitly documented below and must be respected.
- [onDropContent](/doc/View Modifiers/onDropContent.md): onDropContent is a view modifier provided by Scripting that allows a view to act as a drop target, receiving files, images, or text dragged in from other applications.
- [opacity](/doc/View Modifiers/opacity.md): Sets the transparency level of a view. A value of 0 makes the view completely transparent (invisible), while 1 means fully opaque.
- [overlay](/doc/View Modifiers/overlay.md): The overlay modifier places a view on top of the modified view, creating a layered composition. This is useful for adding decorations, badges, shadows, visual indicators, or interactive elements such as buttons or loading spinners.
- [padding](/doc/View Modifiers/padding.md): The padding property adds space around the content of a view, mirroring the behavior of SwiftUI’s padding modifier. It helps separate a view from surrounding elements and improve layout clarity.
- [pickerStyle](/doc/View Modifiers/pickerStyle.md): The pickerStyle property allows you to customize the appearance and behavior of pickers within a view hierarchy in your UI.
- [position](/doc/View Modifiers/position.md): Positions the center of the view at the given x and y coordinates within its parent’s coordinate space.
- [preferredColorScheme](/doc/View Modifiers/preferredColorScheme.md): Sets the preferred system appearance (light or dark) for the view hierarchy. Only affects non-transient system overlays.
- [progressViewStyle](/doc/View Modifiers/progressViewStyle.md): The progressViewStyle property allows you to customize the appearance of a progress view in your UI.
- [refresable](/doc/View Modifiers/refresable/index.md): Marks a scrollable view as refreshable, enabling the user to pull down to trigger an asynchronous data reload.
- [Example](/doc/View Modifiers/refresable/refreshable_list.md)
- [rotationEffect](/doc/View Modifiers/rotationEffect.md): Rotates the view by a specified angle in degrees. You can optionally set the anchor point around which the rotation occurs.
- [scaleEffect](/doc/View Modifiers/scaleEffect.md): Scales the view horizontally and vertically. You can specify a common value or separate values, and optionally provide an anchor point.
- [shadow](/doc/View Modifiers/shadow.md): Applies a shadow behind the view. You can control color, blur radius, and x/y offset.
- [textFieldStyle](/doc/View Modifiers/textFieldStyle.md): The textFieldStyle property determines the visual style of your text fields, influencing how their borders, backgrounds, and layout appear. Different styles can help your text fields blend seamlessly into various UI designs, or provide subtle cues about their functionality.
- [tint](/doc/View Modifiers/tint.md): The tint property overrides the default accent color for a specific view using a given style. Unlike the global app accent color (which may be modified by user settings), tint is always respected and should be used to convey semantic meaning or visual emphasis at the component level.
- [toggleStyle](/doc/View Modifiers/toggleStyle.md): The toggleStyle property defines how a Toggle (commonly known as a switch or checkbox) visually appears and behaves. By selecting a style, you can influence the toggle’s look—whether it looks like a traditional switch, a button-like state indicator, or let the system decide what’s best.
- [Use with Toolbar Component](/doc/View Modifiers/toolbar/Use with Toolbar Component.md): In Scripting, views can populate their navigation bar or toolbar area using either the original ToolBarProps object or the declarative component-based API that mirrors SwiftUI’s toolbar system. This document explains in detail how to use the Toolbar, ToolbarItem, ToolbarItemGroup, ToolbarSpacer, and DefaultToolbarItem components, including parameters, types, and usage patterns. The toolbar property can be used in two ways: By passing a ToolBarProps objectBy passing a VirtualNode, which must be a <Toolbar> component When using the component-based API, all toolbar content is declared inside a <Toolbar> container, and each item defines its placement explicitly. This provides clearer structure and more precise layout control, similar to SwiftUI. The <Toolbar> component serves as a container for toolbar content. It does not define placement itself; instead, ToolbarItem and ToolbarItemGroup determine where items go.
- [Use with ToolbarProps](/doc/View Modifiers/toolbar/Use with ToolbarProps.md): The toolbar property allows you to populate a view’s navigation or toolbar area with various items, mirroring the functionality of SwiftUI's toolbar view modifier. By setting toolbar on a component, you can place items in the navigation bar or bottom toolbar, and specify their semantic roles.
- [translationHost](/doc/View Modifiers/translationHost.md): The translationHost view modifier is used to provide a translation service context to your UI. This modifier enables user interaction with system-level translation dialogs, such as downloading required languages or selecting ambiguous source languages.
- [widgetBackground](/doc/View Modifiers/widgetBackground.md): The widgetBackground modifier is used to define background styles specifically for widgets, with behavior optimized for iOS 18’s accented (tinted) rendering mode.
- [AVPlayerView](/doc/Views/AVPlayerView.md): AVPlayerView is a video playback component introduced in Scripting that wraps the system-native AVPlayerViewController.
Unlike VideoPlayer, AVPlayerView fully supports system Picture in Picture (PiP) and exposes PiP lifecycle state to scripts. This component is intended for media-centric scenarios where native playback behavior, PiP, Now Playing integration, and background playback are required.
- [AccessoryWidgetBackground](/doc/Views/AccessoryWidgetBackground.md): An adaptive background view that provides a standard appearance based on the widget’s environment.
- [Button](/doc/Views/Button.md): The Button component in the Scripting app allows you to create interactive elements with customizable actions, labels, styles, and roles. Buttons can trigger actions, execute intents, and display various visual styles based on the configuration. This documentation provides a detailed guide on how to use the Button API, including its properties, roles, styles, and examples.
- [AreaStackChart](/doc/Views/Charts/AreaStackChart/index.md): The AreaStackChart component displays a series of values as stacked areas over a shared axis, allowing for a clear comparison of data parts and totals across categories or time.
- [Example](/doc/Views/Charts/AreaStackChart/index_example.md)
- [Bar1DChart](/doc/Views/Charts/Bar1DChart/index.md): The Bar1DChart component renders a one-dimensional bar chart for comparing numerical values across discrete categories. Each bar represents a single category with its corresponding value, making it ideal for simple horizontal or vertical bar comparisons.
- [Example](/doc/Views/Charts/Bar1DChart/index_example.md)
- [BarChart](/doc/Views/Charts/BarChart/index.md): The BarChart component renders a standard bar chart, enabling visual comparison of numeric values across different categories. Each bar corresponds to a label and represents its associated value through height (vertical layout) or length (horizontal layout).
- [Example](/doc/Views/Charts/BarChart/index_example.md)
- [BarGanttChart](/doc/Views/Charts/BarGanttChart/index.md): The BarGanttChart component visualizes time intervals across multiple categories, making it ideal for illustrating schedules, timelines, or task durations. It displays bars that span from a start to an end value on a continuous axis, grouped by labeled categories.
- [Example](/doc/Views/Charts/BarGanttChart/index_example.md)
- [BarGroupChart](/doc/Views/Charts/BarGroupChart/index.md): This example demonstrates how to create grouped bars in a BarChart by using the positionBy property to segment bars by a secondary dimension (e.g., "color") and foregroundStyleBy to apply distinct colors to each group. This pattern is useful when comparing subcategories within a larger category.
- [Example](/doc/Views/Charts/BarGroupChart/index_example.md)
- [BarStackChart](/doc/Views/Charts/BarStackChart/index.md): The BarStackChart component renders grouped values as stacked bars, enabling visual comparison of cumulative totals and their individual components across categories. Each bar is split into colored segments that represent different subcategories within a shared label.
- [Example](/doc/Views/Charts/BarStackChart/index_example.md)
- [DonutChart](/doc/Views/Charts/DonutChart/index.md): The DonutChart component displays data as a circular ring divided into segments, where each segment’s angle represents a proportion of the whole. It is ideal for visualizing part-to-whole relationships with an inner radius that distinguishes it from a traditional pie chart.
- [Example](/doc/Views/Charts/DonutChart/index_example.md)
- [HeatMapChart](/doc/Views/Charts/HeatMapChart/index.md): The HeatMapChart component displays data values as a grid of cells, where the color intensity of each cell represents the magnitude of a numeric value. It is ideal for visualizing bivariate data distributions or correlations across two categorical dimensions.
- [Example](/doc/Views/Charts/HeatMapChart/index_example.md)
- [LineCategoryChart](/doc/Views/Charts/LineCategoryChart/index.md): The LineCategoryChart component displays multiple line series categorized by a secondary key, allowing you to compare trends across distinct groups (categories) along a shared axis of discrete labels. It is ideal for grouped comparisons across labeled segments (e.g., departments, months, stages) and is especially useful for showing how each category's values evolve over the same set of labels.
- [Example](/doc/Views/Charts/LineCategoryChart/index_example.md)
- [LineChart](/doc/Views/Charts/LineChart/index.md): The LineChart component renders a single continuous line across discrete labeled points. It is useful for visualizing simple trends or progressions where each data point is mapped to a category or label. It shares the same API as BarChart and is ideal for basic one-line comparisons over labeled axes.
- [Example](/doc/Views/Charts/LineChart/index_example.md)
- [Multiple Charts Example](/doc/Views/Charts/Multiple Charts Example/index.md): This example demonstrates how to combine multiple chart types in a single chart context, dynamically display annotations based on user interaction, and customize appearance and interactivity using chart overlays.
- [Example](/doc/Views/Charts/Multiple Charts Example/index_example.md)
- [PieChart](/doc/Views/Charts/PieChart/index.md): The PieChart component displays part-to-whole relationships using circular slices. Each slice represents a category, and its angle is proportional to the numeric value it contributes to the total. This chart is well-suited for visualizing distribution, market share, or proportions across categories.
- [Example](/doc/Views/Charts/PieChart/index_example.md)
- [PointCategoryChart](/doc/Views/Charts/PointCategoryChart/index.md): The PointCategoryChart component displays categorized points on a 2D plane, allowing for flexible visual encoding using color, symbol type, or symbol size. It is ideal for representing multi-category scatter plots, surveys, or segmented data comparisons.
- [Example](/doc/Views/Charts/PointCategoryChart/index_example.md)
- [PointChart](/doc/Views/Charts/PointChart/index.md): The PointChart component renders a basic 2D scatter plot, plotting individual points on an X-Y coordinate system. Each point is defined by a pair of numeric values and can be customized using standard mark styling properties. This chart is ideal for visualizing correlations, distributions, or individual measurements across two continuous dimensions.
- [Example](/doc/Views/Charts/PointChart/index_example.md)
- [RangeAreaChart](/doc/Views/Charts/RangeAreaChart/index.md): The RangeAreaChart component displays a shaded area between a range of values for each data point, typically between a start and end value. It is ideal for visualizing value intervals, such as temperature ranges, confidence intervals, or min/max ranges over time.
- [Example](/doc/Views/Charts/RangeAreaChart/index_example.md)
- [RectAreaChart](/doc/Views/Charts/RectAreaChart/index.md): The RectAreaChart component renders rectangular areas over a 2D chart coordinate space. It is useful for highlighting regions, data clusters, or ranges of interest on a chart. You can combine it with other charts like PointChart for layered visualizations.
- [Example](/doc/Views/Charts/RectAreaChart/index_example.md)
- [RectChart](/doc/Views/Charts/RectChart/index.md): The RectChart component renders a bar-like rectangular chart that visualizes value-based data associated with labels. It is similar in usage to BarChart and uses the same BarChartProps interface.
- [Example](/doc/Views/Charts/RectChart/index_example.md)
- [RuleChart](/doc/Views/Charts/RuleChart/index.md): The RuleChart component displays a range or duration for each labeled item as a horizontal or vertical rule. It is suitable for visualizing time spans, data ranges, or active periods across categories.
- [Example](/doc/Views/Charts/RuleChart/index_example.md)
- [RuleLineForLabelChart](/doc/Views/Charts/RuleLineForLabelChart.md): RuleLineForLabelChart overlays vertical or horizontal reference lines based on label (or date) positions in a chart. It is commonly used to highlight specific categories or time points in combination with other chart types, such as BarChart or LineChart.
- [RuleLineForValueChart](/doc/Views/Charts/RuleLineForValueChart.md): The RuleLineForValueChart component is used to draw one or more horizontal or vertical reference lines on a chart, based on numeric values. This is useful for highlighting thresholds, targets, or reference levels in your data visualization.
- [ConcentricRectangle](/doc/Views/ConcentricRectangle.md): ConcentricRectangle is a concentric rectangle shape view introduced in iOS 26+. It is designed to create rectangles with progressively inset (concentric) corner geometry, which adapts naturally to modern UI designs. It is especially suitable for: Glass-style buttonsCard backgroundsInteractive clipping regionsGlass transition masksLayered container UI In Scripting, ConcentricRectangle can be used both as: A standalone Shape viewA specialized shape inside:clipShapebackgroundcontentShape
- [ColorPicker](/doc/Views/Controls/ColorPicker/index.md): The ColorPicker component provides a system color picker UI that allows users to select a color and passes the selected color back to the application via the onChanged event. It supports the following formats for colors: Keyword colors (e.g., green, red, blue, etc.)Hexadecimal color strings (e.g., #FF5733 or #333)CSS rgba strings (e.g., rgba(255,0,0,1))
- [Example](/doc/Views/Controls/ColorPicker/index_example.md)
- [ContentUnavailableView](/doc/Views/Controls/ContentUnavailableView/index.md): ContentUnavailableView is a UI component designed to present a view when the content in your app is unavailable. It typically shows a title, an optional description, and an action area, making it clear to users that content is missing or not yet available. This component can be used in places like lists, where no data is available to show to the user.
- [Example](/doc/Views/Controls/ContentUnavailableView/index_example.md)
- [DatePicker](/doc/Views/Controls/DatePicker/index.md): The DatePicker is a UI component for selecting a date (and optionally a time). It supports various interactive display styles, such as calendar views, wheel selectors, and compact text formats. This component is ideal for scenarios where users need to select a specific date and time, such as choosing an event start date or a task deadline.
- [Example](/doc/Views/Controls/DatePicker/index_example.md)
- [Gauge](/doc/Views/Controls/Gauge/index.md): The Gauge component is a view used to display the current value in relation to a specified finite capacity, similar to a fuel gauge in an automobile. The Gauge component is highly configurable and can display any combination of the current value, the range the gauge can display, and a label describing the purpose of the gauge itself. It is suitable for showing the current value of a limited capacity, such as progress, level, or quantity.
- [Example](/doc/Views/Controls/Gauge/index_example.md)
- [Picker](/doc/Views/Controls/Picker/index.md): The Picker component is used to select a single value from a set of mutually exclusive options. It supports various display styles and allows users to choose a single value. The selected value and the change event can be managed using the value and onChanged properties.
- [Example](/doc/Views/Controls/Picker/index_example.md)
- [ProgressView](/doc/Views/Controls/ProgressView/index.md): ProgressView is a UI component that visually represents the progress of a task or operation. It can display both determinate (percentage complete) and indeterminate (progressing or not) types of progress. Additionally, it offers customizable progress view styles, including linear and circular representations. You can use ProgressView to display the progress of various tasks, such as downloading a file, completing a process, or waiting for an event. The component can also show additional details like labels for the task description and current progress.
- [Example](/doc/Views/Controls/ProgressView/index_example.md)
- [Slider](/doc/Views/Controls/Slider/index.md): The Slider component allows users to select a value from a bounded linear range of values. You can configure the slider by setting the minimum value, maximum value, step size, and the current value. The component also supports custom labels to describe the minimum and maximum values, as well as the slider itself. Additionally, it provides callbacks for handling value changes and editing state changes.
- [Example](/doc/Views/Controls/Slider/index_example.md)
- [Stepper](/doc/Views/Controls/Stepper/index.md): The Stepper is a control used for performing increment and decrement actions. It allows the user to increase or decrease a value by tapping the “+” or “-” buttons. The component also supports triggering callback functions when editing starts or ends.
- [Example](/doc/Views/Controls/Stepper/index_example.md)
- [Toggle](/doc/Views/Controls/Toggle/index.md): The Toggle component in the Scripting app provides a view control that allows users to toggle between "on" and "off" states. It supports various configuration options to suit different use cases, including user interaction handlers, intents for automation, and customization for display purposes.
- [Example](/doc/Views/Controls/Toggle/index_example.md)
- [Dialog](/doc/Views/Dialog/index.md): The Dialog module provides convenient methods to present various types of user interface dialogs such as alerts, confirmations, prompts, and action sheets. These dialogs are useful for requesting user input or interaction during script execution.
- [Example](/doc/Views/Dialog/index_example.md)
- [Displaying text](/doc/Views/Displaying text/index.md): The Text component is used to display one or more lines of read-only text in the Scripting app. It supports plain text, attributed text (Markdown), and rich text styling.
- [Example](/doc/Views/Displaying text/index_example.md)
- [Editor](/doc/Views/Editor.md): A powerful code editor that can be controlled programmatically or embedded into a user interface. It supports syntax highlighting, read/write access, and flexible presentation using the EditorController class and the Editor component.
- [EnvironmentValuesReader](/doc/Views/EnvironmentValuesReader.md): EnvironmentValuesReader is a Scripting component that allows you to read environment values from the current view hierarchy.
It serves a similar role to SwiftUI’s @Environment, but with a more explicit and controlled design:
You must specify which environment keys you want to read, and the component will inject only those values into the children callback. This makes environment access predictable, explicit, and optimized. Below are the descriptions of each field. 1. colorScheme Type: ColorScheme
The current system color appearance (light or dark). 2. colorSchemeContrast Type: ColorSchemeContrast
Represents contrast settings such as standard or increased. 3. displayScale Type: number
The display scale factor of the device (e.g., 2.0, 3.0). 4. horizontalSizeClass Type: UserInterfaceSizeClass | null
The horizontal size class of the current environment: compact or regular. 5. verticalSizeClass Type: UserInterfaceSizeClass | null
The vertical size class, same categories as above. 6. dismiss Type: () => void
A function to dismiss the currently presented view (equivalent to SwiftUI’s dismiss()). 7. dismissSearch Type: () => void
A function that dismisses the current searchable field, if active. 8. editMode Type: EditMode | null
Indicates whether the view is in editing mode (e.g., during List editing). 9. widgetRenderingMode Type: WidgetRenderingMode
The current widget rendering mode (e.g., fullColor, accented). 10. showsWidgetContainerBackground Type: boolean
Indicates whether the widget is showing the system-provided container background. 11. isSearching Type: boolean
Whether the view is currently in a searching state triggered by searchable. 12. isPresented Type: boolean
Whether the view is currently being shown, unlike onAppear which is called every time the view appears, isPresented is called only once when the view is first shown. 13. activityFamily Type: "small" | "medium"
The current LiveActivity size, similar to SwiftUI's activityFamily, used to determine the size of LiveActivity UI. 14. tabViewBottomAccessoryPlacement Type: 'expanded' | 'inline'
The current TabView bottom accessory placement, similar to SwiftUI's tabViewBottomAccessoryPlacement. keys Type: Array<keyof EnvironmentValues>
Specifies exactly which environment keys you want to read.
Only these keys will be retrieved and passed to the callback. children(values) Type: (values: EnvironmentValues) => VirtualNode
A rendering callback that receives the requested environment values and returns the corresponding view.
- [GeometryReader](/doc/Views/GeometryReader.md): GeometryReader in Scripting is the equivalent of SwiftUI’s GeometryReader. It provides layout information about the container in which its content is placed, including size, safe-area insets, and (on supported systems) container corner insets. This component is essential for building responsive layouts that depend on the parent container’s geometry. When GeometryReader constructs its child content, it injects a GeometryProxy instance into the children callback. This proxy exposes real-time layout information about the container.
- [Gestures](/doc/Views/Gestures.md): The Scripting app provides a gesture system similar to SwiftUI, allowing any view (<VStack>, <HStack>, <Text>, etc.) to respond to touch interactions such as tapping, long pressing, dragging, rotating, and magnifying. You can use: Simplified gesture properties like onTapGesture, onLongPressGesture, onDragGesture, orAdvanced gesture objects such as TapGesture(), LongPressGesture(), and the gesture modifiers for composition and priority control.
- [Image](/doc/Views/Image/index.md): The Image component allows you to display images from various sources, such as system symbols, network URLs, local files, or UIImage objects. It supports dynamic image sources that change based on light or dark color schemes. Additionally, several view modifiers are available to customize the behavior and appearance of the Image component.
- [Example](/doc/Views/Image/index_example.md)
- [FlowLayout](/doc/Views/Layout/FlowLayout.md): FlowLayout is a flow-based layout component that arranges its children horizontally and automatically wraps items to the next line when there is insufficient space. It is ideal for displaying a group of elements with dynamic widths such as tags, buttons, or icon lists.
- [Grid](/doc/Views/Layout/Grid/index.md): The Grid component in the Scripting app provides a flexible container for arranging child views in a two-dimensional grid layout. It supports customizable alignment, spacing, and nested child components to create visually appealing layouts. Grid Component A container view that arranges other views in a two-dimensional layout. Import Path Type: GridProps GridRow Component A child component of Grid that represents a horizontal row in the grid layout. Use GridRow to group and align child views horizontally within the grid. Type: GridRowProps
- [Example](/doc/Views/Layout/Grid/index_example.md)
- [HStack](/doc/Views/Layout/HStack/index.md): The HStack component in the Scripting app provides a convenient way to arrange views horizontally with flexible alignment and spacing options. This component is essential for creating layouts that require side-by-side positioning of subviews.
- [Example](/doc/Views/Layout/HStack/index_example.md)
- [LazyHGrid](/doc/Views/Layout/LazyHGrid/index.md): The LazyHGrid component is part of the Scripting app's UI library. It arranges its children in a grid layout with rows defined by customizable sizing and alignment options. Items are created and displayed only as needed, optimizing performance for large or dynamic data sets.
- [Example](/doc/Views/Layout/LazyHGrid/index_example.md)
- [LazyHStack](/doc/Views/Layout/LazyHStack/index.md): The LazyHStack component is part of the Scripting app's UI library. It arranges its children in a horizontal stack, creating and displaying items only as needed, which improves performance for large data sets.
- [Example](/doc/Views/Layout/LazyHStack/index_example.md)
- [LazyVGrid](/doc/Views/Layout/LazyVGrid/index.md): The LazyVGrid component is part of the Scripting app's UI library. It arranges its children in a grid layout with columns defined by customizable sizing and alignment options. Items are created and displayed only as needed, optimizing performance for large or dynamic data sets.
- [Example](/doc/Views/Layout/LazyVGrid/index_example.md)
- [LazyVStack](/doc/Views/Layout/LazyVStack/index.md): The LazyVStack component is part of the Scripting app's UI library. It arranges its children in a vertical stack, creating and displaying items only as needed, optimizing performance for large data sets.
- [Example](/doc/Views/Layout/LazyVStack/index_example.md)
- [VStack](/doc/Views/Layout/VStack/index.md): The VStack component in the Scripting app is a layout view that arranges its child views vertically. It provides flexible options for aligning its subviews and controlling the spacing between them.
- [Example](/doc/Views/Layout/VStack/index_example.md)
- [ZStack](/doc/Views/Layout/ZStack/index.md): The ZStack component in the Scripting app allows you to arrange subviews on top of each other in a layered stack. It provides flexibility in aligning the layers along both the x- and y-axes using predefined alignment guides.
- [Example](/doc/Views/Layout/ZStack/index_example.md)
- [Link](/doc/Views/Link.md): The Link component provides a way to create tappable controls that navigate to a specified URL. This component can be used to open web pages, app-specific URLs, or other schemes. Note: If the Link component is used within a widget, the widgetURL modifier will be ignored. Props Example This component supports both simple text and complex layouts as its children. When tapped, it opens the provided url using the appropriate handler (e.g., Safari, another app, or a custom scheme).
- [DisclosureGroup](/doc/Views/List/DisclosureGroup/index.md): The DisclosureGroup component allows you to organize related content into collapsible sections. This is useful for grouping items in a list, especially when dealing with hierarchical or optional content. This example demonstrates how to create a top-level disclosure group that can be toggled open or closed, and how to nest additional DisclosureGroup components for sub-sections.
- [Example](/doc/Views/List/DisclosureGroup/index_example.md)
- [Display data inside a row](/doc/Views/List/Display data inside a row/index.md): This example demonstrates how to use the List component to present structured data using custom row layouts. Each row displays a person's name and phone number in a clean and readable format, using stack-based layout components inspired by SwiftUI.
- [Example](/doc/Views/List/Display data inside a row/index_example.md)
- [Editable List](/doc/Views/List/Editable List/index.md): This example demonstrates how to build an editable list in the Scripting app using List, ForEach, and EditButton components. The list supports item deletion and reordering with built-in editing controls.
- [Example](/doc/Views/List/Editable List/index_example.md)
- [List interaction](/doc/Views/List/List interaction/index.md): This example demonstrates how to implement interactive list items in the Scripting app using swipe gestures. By leveraging leadingSwipeActions and trailingSwipeActions, you can provide contextual actions such as marking a message as unread, deleting a message, or flagging it.
- [Example](/doc/Views/List/List interaction/index_example.md)
- [List style](/doc/Views/List/List style/index.md): The listStyle property allows you to customize the behavior and appearance of a list in your UI when using the List view.
- [Example](/doc/Views/List/List style/list_style.md)
- [Refresable List](/doc/Views/List/Refresable List/index.md): Marks a scrollable view as refreshable, enabling the user to pull down to trigger an asynchronous data reload.
- [Example](/doc/Views/List/Refresable List/refreshable_list.md)
- [Represent data hierarchy in sections](/doc/Views/List/Represent data hierarchy in sections/index.md): This example demonstrates how to use the Section component in the Scripting app to visually organize hierarchical data within a List. The content is structured by grouping related items—such as staff members by department—into labeled sections for better readability and navigation.
- [Example](/doc/Views/List/Represent data hierarchy in sections/index_example.md)
- [Selectable List](/doc/Views/List/Selectable List.md): List.selection provides selection state binding for the List component. It enables: Single selection modeMultiple selection modeIntegration with edit mode via EditButtonAutomatic synchronization with user interaction
- [Use list for navigations](/doc/Views/List/Use list for navigations/index.md): This example demonstrates how to build a navigable list-based interface in the Scripting app. It organizes structured data into expandable sections using DisclosureGroup, and allows users to navigate to detail views using NavigationLink.
- [Example](/doc/Views/List/Use list for navigations/index_example.md)
- [LivePhotoView](/doc/Views/LivePhotoView.md): LivePhoto represents a system Live Photo, which consists of: A high-resolution still imageA short video clip bound to that image In Scripting, LivePhoto is a system-managed object. It cannot be instantiated directly with new and is typically obtained from: A photo picker resultAsynchronous construction from local image and video files LivePhoto is commonly used to: Display Live Photos in the UIAccess underlying image and video resourcesDecompose, rebuild, or re-save Live Photos
- [Markdown](/doc/Views/Markdown.md): The Markdown component renders styled Markdown content within your script’s user interface. It supports different visual themes and syntax highlighter styles for displaying code blocks, making it ideal for rendering documentation, previews, or custom rich-text content.
- [Menu](/doc/Views/Menu/index.md): The Menu component in Scripting is a user interface control that presents a list of actions or nested submenus. It functions as a container for contextual actions and supports both text-based and custom visual labels. Inspired by SwiftUI’s Menu, this component is especially useful in toolbars, context menus, and compact UI layouts.
- [Example](/doc/Views/Menu/index_example.md)
- [Modal presentaions](/doc/Views/Modal presentaions/index.md): The Scripting app supports SwiftUI-style modal view presentations through declarative properties applied to UI components. These include support for sheet, popover, fullScreenCover, alert, and confirmationDialog. Each of these is defined using structured configuration objects that allow you to present views based on application state.
- [Example](/doc/Views/Modal presentaions/index_example.md)
- [NamespaceReader](/doc/Views/NamespaceReader.md): NamespaceReader is used to create and manage a geometry animation namespace (Namespace).
This namespace is the foundational requirement for enabling: matchedGeometryEffect (component-level geometry animation)matchedTransitionSource (page-level navigation transition)navigationTransition (such as zoom transitions) You can think of NamespaceReader as: A “geometry animation coordinate provider” that defines which views belong to the same animation scope.
- [Collapsed split views](/doc/Views/Navigation/NavigationSplitView (for iPad)/Collapsed split views.md)
- [Control column visibility](/doc/Views/Navigation/NavigationSplitView (for iPad)/Control column visibility.md)
- [Three-column](/doc/Views/Navigation/NavigationSplitView (for iPad)/Three-column.md)
- [Two-column](/doc/Views/Navigation/NavigationSplitView (for iPad)/Two-column.md)
- [NavigationStack with path](/doc/Views/Navigation/NavigationStack/NavigationStack with path.md): NavigationStack.path provides observable, programmatic control over the navigation stack. It allows direct manipulation of the navigation history using a bound observable array. It enables: Programmatic navigationMulti-level stack controlReturning to the root viewDynamic page resolution via NavigationDestination
- [Use with NavigationLink](/doc/Views/Navigation/NavigationStack/Use with NavigationLink.md)
- [Use with navigationDestination](/doc/Views/Navigation/NavigationStack/Use with navigationDestination.md)
- [TabView with badge](/doc/Views/Navigation/TabView/TabView with badge.md)
- [TabView with multiple scrolling pages](/doc/Views/Navigation/TabView/TabView with multiple scrolling pages.md)
- [TabView](/doc/Views/Navigation/TabView/TabView.md): Scripting provides a modern Tab system aligned with iOS 18+: TabView — container that manages multiple tabs and switching between themTab — a single tab and its associated contentTabSection — a way to group tabs into sections, each with its own configuration and header Combined with TabView-level options and TabViewCustomization, this enables rich tab layouts, including sidebar representations, customization, and persistence. This document focuses on: How to structure tab content using TabView, Tab, and TabSectionHow to configure tab bar and sidebar behaviorsHow to use TabViewCustomization to persist and restore user customizations
- [Dismissing a presented view](/doc/Views/Present views/Dismissing a presented view/index.md): This example demonstrates how to programmatically dismiss a presented view using the Navigation.useDismiss hook. It is useful when you want to close a custom view in response to user interaction, such as tapping a button or a text label.
- [Example](/doc/Views/Present views/Dismissing a presented view/index_example.md)
- [Present a simple view](/doc/Views/Present views/Present a simple view/index.md): This example demonstrates how to display a basic UI screen in the Scripting app using the Navigation.present API. It also shows how to set up navigation-related features such as the navigation stack and page title.
- [Example](/doc/Views/Present views/Present a simple view/index_example.md)
- [SVG](/doc/Views/SVG.md): The SVG component is used to display SVG (Scalable Vector Graphics) images. It supports loading SVG content from the following sources: A remote URLA local file pathInline SVG code SVGs are rendered as bitmap images. You can choose to render them in template mode to apply tint colors using foregroundColor.
- [Scroll views](/doc/Views/Scroll views/index.md): The ScrollView component displays its content within a scrollable region. As the user performs scroll gestures, the visible portion of the content is updated accordingly. You can scroll vertically, horizontally, or in both directions using the axes prop.
- [Example](/doc/Views/Scroll views/index_example.md)
- [ScrollViewReader](/doc/Views/ScrollViewReader.md): The ScrollViewReader component equivalent to SwiftUI’s ScrollViewReader, allowing scripts to programmatically control scrolling position within scrollable content such as List or ScrollView. ScrollViewProxy represents the programmatic interface for controlling scrolling. It is provided by ScrollViewReader during rendering.
- [Search](/doc/Views/Search/index.md): The Scripting app supports advanced search interactions similar to SwiftUI. You can add a search bar, control its visibility and placement, react to changes in input, and display dynamic suggestions.
- [Example](/doc/Views/Search/index_example.md)
- [Shapes](/doc/Views/Shapes/index.md): Scripting provides a suite of shape components for creating scalable, vector-based UI elements such as rectangles, circles, capsules, ellipses, and rounded rectangles. These shapes support customizable fill, stroke, trimming, and sizing, making them ideal for dashboards, decorative elements, and interactive visuals.
- [Example](/doc/Views/Shapes/index_example.md)
- [Keyboard](/doc/Views/Text input/Keyboard.md): The Keyboard API, along with the useKeyboardVisible hook, allows you to interact with the software keyboard in the Scripting app. You can check the keyboard's visibility, hide it, listen for visibility changes, and access the current visibility state reactively in functional components.
- [SecureField](/doc/Views/Text input/SecureField/index.md): The SecureField component in Scripting provides a secure, private text input field intended for entering sensitive information such as passwords. The entered text is visually obscured and not displayed in plain text, mirroring the behavior of SwiftUI’s SecureField. This component is useful in authentication forms, PIN inputs, or any context where user privacy is essential.
- [Example](/doc/Views/Text input/SecureField/index_example.md)
- [TextField](/doc/Views/Text input/TextField/index.md): The TextField component in the Scripting app provides a declarative way to create a text input field, similar to SwiftUI’s TextField. It supports both single-line and multiline input, custom labels, placeholder prompts, scroll direction, focus handling, and line constraints. This component is ideal for collecting short inputs like usernames or longer inputs like messages, with seamless integration into reactive view hierarchies.
- [Example](/doc/Views/Text input/TextField/index_example.md)
- [Time-based label views](/doc/Views/Time-based label views.md): Scripting provides a set of convenient time-related label components that wrap SwiftUI's Text styles. These components allow you to display live-updating or formatted date and time strings in widgets and views, with support for dynamic behaviors like relative time and timers.
- [Toolbars](/doc/Views/Toolbars/index.md): The toolbar property allows you to populate the navigation bar, bottom toolbar, or keyboard accessory area with custom UI elements. This system is modeled after SwiftUI’s toolbar API and provides fine-grained placement control across various regions of the user interface. This feature is useful for adding primary or contextual actions, organizing control groups, and enhancing keyboard interactions.
- [Example](/doc/Views/Toolbars/index_example.md)
- [VideoPreviewView](/doc/Views/VideoPreviewView.md): VideoPreviewView is a UI component that displays the live camera preview associated with a VideoRecorder instance.
It renders the real-time output of the recorder’s capture session and serves as the visual foundation for custom camera interfaces. VideoPreviewView does not control recording behavior. All recording logic—preparation, start, pause, resume, stop, and disposal—is handled exclusively by VideoRecorder.
- [ControlGroup](/doc/Views/View groupings/ControlGroup.md)
- [ForEach](/doc/Views/View groupings/ForEach/index.md): The ForEach component renders a dynamic list of child views. It is used to display collections, create editable lists, and enable system-standard interactions such as swipe-to-delete. It is fully integrated with the Scripting app’s Observable state system and mirrors the design of SwiftUI’s ForEach. ForEach supports two usage modes: Deprecated mode: count + itemBuilderRecommended mode: data: Observable<T[]> + builder
- [Example](/doc/Views/View groupings/ForEach/iterating.md)
- [Form](/doc/Views/View groupings/Form.md)
- [Group](/doc/Views/View groupings/Group.md)
- [GroupBox](/doc/Views/View groupings/GroupBox.md)
- [Section](/doc/Views/View groupings/Section.md)
- [WebView](/doc/Views/WebView.md)
- [AccessoryWidgetBackground](/doc/Widget/AccessoryWidgetBackground.md): An adaptive background view that provides a standard appearance based on the widget’s environment.
- [Animation for Widget and LiveActivity](/doc/Widget/Animation for Widget and LiveActivity.md): These APIs allow you to display animation in a widget.
- [Tinted Mode Adaptation Guide](/doc/Widget/Tinted Mode Adaptation Guide.md): iOS 18 introduces a new widget rendering mode called accented mode, which tints the widget’s content using system-defined accent colors. To support this behavior in your widgets, the Scripting app provides three view modifiers: widgetAccentablewidgetAccentedRenderingModewidgetBackground These modifiers allow you to control which parts of your widget participate in the system’s accenting logic, enabling more expressive and adaptable designs.
- [Widget API](/doc/Widget/Widget API.md): The Widget class provides static methods and properties to interact with home screen widgets created using the Scripting app. This API enables rendering widgets, handling configuration parameters, previewing widget layouts, and managing widget timelines.
- [Widget Background in Tinted Mode](/doc/Widget/Widget Background in Tinted Mode.md): The widgetBackground modifier is used to define background styles specifically for widgets, with behavior optimized for iOS 18’s accented (tinted) rendering mode.
- [Widget Quick Start](/doc/Widget/Widget Quick Start.md): Scripting is an app that allows you to create iOS Home Screen widgets using TypeScript and React-like TSX syntax.
You can define your widget’s UI inside a widget.tsx file using SwiftUI-inspired components.

## Privacy

- [Privacy Policy](/privacy/policy.md)
- [Terms of Service & EULA](/privacy/service.md)