---
url: /zh/guide/AppIntent.md
---

# AppIntent

`AppIntentManager` 用于在 **Scripting** 中注册并管理 `AppIntent`，它是 Widget、Live Activity、ControlWidget 等控件执行脚本逻辑的核心机制。
所有的 `AppIntent` **必须** 定义在 `app_intents.tsx` 文件中，且在执行时其运行环境 `Script.env` 为 `"app_intents"`。

通过 `AppIntentManager` 注册的意图可以被 Widget / Live Activity / ControlWidget 中的 **Button** 与 **Toggle** 控件调用，以在用户交互时触发对应的脚本逻辑。

***

## 一、类型定义

### `AppIntent<T>`

表示一个具体的应用意图实例。

| 字段名        | 类型                  | 描述                                       |
| ---------- | ------------------- | ---------------------------------------- |
| `script`   | `string`            | 脚本路径，由系统内部生成。                            |
| `name`     | `string`            | 意图名称，唯一标识该 AppIntent。                    |
| `protocol` | `AppIntentProtocol` | 该意图实现的协议类型（如普通、音频播放、音频录制、Live Activity）。 |
| `params`   | `T`                 | 意图执行时的参数。                                |

***

### `AppIntentFactory<T>`

表示一个 **工厂函数**，用于通过参数创建 `AppIntent` 实例。

```ts
type AppIntentFactory<T> = (params: T) => AppIntent<T>
```

***

### `AppIntentPerform<T>`

表示一个执行函数，用于在意图被触发时执行实际逻辑。

```ts
type AppIntentPerform<T> = (params: T) => Promise<void>
```

***

### `AppIntentProtocol`

`AppIntentProtocol` 是枚举类型，用于指定意图的协议（行为类别）。

| 枚举成员                       | 描述                                                                                                                                       |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `AppIntent` (0)            | 普通 AppIntent。用于执行一般操作的意图。                                                                                                                |
| `AudioPlaybackIntent` (1)  | 播放、暂停或修改音频播放状态的意图。                                                                                                                       |
| `AudioRecordingIntent` (2) | （iOS 18.0+）启动、停止或修改音频录制状态的意图。**注意**：在 iOS/iPadOS 中，当使用 `AudioRecordingIntent` 协议时，必须在开始录音时启动一个 **Live Activity** 并在录音持续时保持活跃，否则音频录制将会停止。 |
| `LiveActivityIntent` (3)   | 启动、暂停或修改 Live Activity 的意图。                                                                                                              |

***

## 二、AppIntentManager 类

### `AppIntentManager.register<T>(options): AppIntentFactory<T>`

注册一个新的 `AppIntent`。
通过指定 `name`、`protocol` 和 `perform` 函数来注册，当控件（Button/Toggle）被触发时，系统会自动调用 `perform` 函数执行逻辑。

```ts
static register<T = undefined>(options: {
  name: string;
  protocol: AppIntentProtocol;
  perform: AppIntentPerform<T>;
}): AppIntentFactory<T>
```

#### 参数：

| 参数名        | 类型                    | 描述                                    |
| ---------- | --------------------- | ------------------------------------- |
| `name`     | `string`              | AppIntent 的名称，需唯一，用于标识该意图。            |
| `protocol` | `AppIntentProtocol`   | AppIntent 的协议类型。                      |
| `perform`  | `AppIntentPerform<T>` | 当控件触发该意图时执行的异步函数，参数为控件传递过来的 `params`。 |

#### 返回值：

- **`AppIntentFactory<T>`**：返回一个工厂函数，可通过传入参数创建 `AppIntent` 实例。

#### 示例：

```tsx
/// app_intents.tsx
export const ToggleDoorIntent = AppIntentManager.register({
  name: "ToggleDoorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async ({ id, newState }: { id: string; newState: boolean }) => {
    // 自定义逻辑：切换门的状态
    await setDoorState(id, newState)
    // 通知控件刷新状态（如 ControlWidgetToggle）
    ControlWidget.reloadToggles()
  }
})
```

在控件文件中（如 `control_widget_toggle.tsx`）：

```tsx
ControlWidget.present(
  <ControlWidgetToggle
    intent={ToggleDoorIntent({ id: "door1", newState: !currentState })}
    label={{
      title: "Door 1",
      systemImage: currentState ? "door.garage.opened" : "door.garage.closed"
    }}
    activeValueLabel={{ title: "The door is opened" }}
    inactiveValueLabel={{ title: "The door is closed" }}
  />
)
```

在小组件中使用（如 `widget.tsx`）:

```tsx
<Toggle
  title="Door 1"
  value={currentState}
  intent={ToggleDoorIntent({ id: "door1", newState: !currentState })}
/>
```

***

## 三、执行时环境

所有通过 `AppIntentManager` 定义的 AppIntent 在执行时，`Script.env` 会自动为 `"app_intents"`。
这意味着在 `perform` 函数中可以安全地使用适合 `"app_intents"` 环境的 API（如访问网络、更新 Live Activity 状态、触发控件刷新等）。

***

## 四、最佳实践

1. **集中管理**：所有 AppIntent 必须定义在 `app_intents.tsx` 文件中，避免分散。
2. **类型安全**：在 `perform` 和控件参数中定义严格的参数类型 `T`，以确保开发时的自动补全与类型检查。
3. **协议匹配**：根据控件行为选择合适的 `AppIntentProtocol`，例如：

   - 普通操作 → `AppIntent`
   - 控制音频播放 → `AudioPlaybackIntent`
   - 控制音频录制 → `AudioRecordingIntent`（iOS 18+ 且需保持 Live Activity）
   - 启动/暂停 Live Activity → `LiveActivityIntent`
4. **状态刷新**：执行完 `perform` 后，如需更新 UI 状态（例如切换门锁开关），请调用 `ControlWidget.reloadButtons()` 、 `ControlWidget.reloadToggles()` 或 `Widget.reloadAll()`。



---
url: /zh/guide/Assistant/Assistant Conversation APIs.md
---

# 智能助手会话 API

Conversation API 用于**启动、控制和展示一个由系统托管的 Assistant 对话会话**。
该会话对应一个**完整的聊天页面（Chat Page）**，由 Scripting App 统一管理 UI、状态和模型交互。

与 `requestStreaming` / `requestStructuredData` 的区别在于：

- Conversation API 面向**交互式聊天体验**
- 系统负责消息发送、流式输出、Provider 切换、UI 渲染
- 开发者只需关注“何时开始 / 何时结束 / 是否展示”

***

## 会话生命周期概览

一个典型的会话生命周期如下：

1. `startConversation` —— 创建会话（可选自动开始）
2. `present` —— 展示 Assistant 聊天页面
3. 用户与 Assistant 进行交互
4. `dismiss` —— 临时关闭聊天页面（会话仍存在）
5. `present` —— 再次展示会话
6. `stopConversation` —— 结束会话并释放资源

重要约束：

- **同一时间只能存在一个活动会话**
- 若已有会话在运行，再次调用 `startConversation` 会抛出错误
- 调用 `stopConversation` 会自动触发 `dismiss`

***

## startConversation

### API 定义

```ts
function startConversation(options: {
  message: string
  images?: UIImage[]
  autoStart?: boolean
  systemPrompt?: string
  modelId?: string
  provider?: Provider
}): Promise<void>
```

***

### 参数说明

#### options.message

- 类型：`string`
- 必填
- 会话的**初始用户消息**
- 相当于聊天页面中的第一条用户输入

***

#### options.images（可选）

- 类型：`UIImage[]`
- 会与 `message` 一起作为首条用户消息发送
- 适用于：

  - 图片分析
  - 拍照 / 截图后直接发起对话

***

#### options.autoStart（可选）

- 类型：`boolean`
- 默认值：`false`

行为说明：

- `true`：

  - 创建会话后立即开始生成回复
- `false`：

  - 仅创建会话，不自动发送
  - 通常配合 `present` 使用，由用户点击发送

***

#### options.systemPrompt（可选）

- 类型：`string`

说明：

- 若未提供：

  - 使用 Scripting Assistant 内置 system prompt
  - Assistant Tools 可用
- 若提供：

  - 完全替换默认 system prompt
  - **Assistant Tools 将不可用**

适用场景：

- 构建高度定制的聊天角色
- 禁用工具调用，仅使用纯模型能力

***

#### options.modelId（可选）

- 类型：`string`
- 指定本次会话使用的模型
- 用户仍可在聊天页面中手动切换模型（若 UI 允许）

***

#### options.provider（可选）

- 类型：`Provider`
- 指定默认 Provider
- 用户可在聊天页面中更改 Provider（若 UI 允许）

***

### 返回值

```ts
Promise<void>
```

- 会话创建成功即 resolve
- 若已有会话存在，将 reject

***

## present

### API 定义

```ts
function present(): Promise<void>
```

***

### 行为说明

- 展示当前会话对应的 Assistant 聊天页面
- 若页面已展示，调用不会产生额外效果
- 可在以下场景调用：

  - `startConversation` 之后首次展示
  - `dismiss` 后重新展示同一会话

***

### 返回值

```ts
Promise<void>
```

- 当聊天页面被用户关闭时 resolve

***

## dismiss

### API 定义

```ts
function dismiss(): Promise<void>
```

***

### 行为说明

- 关闭 Assistant 聊天页面
- **不会终止会话**
- 会话状态、历史消息仍保留

适用场景：

- 临时让出界面空间
- 页面跳转或多任务切换

***

### 返回值

```ts
Promise<void>
```

- 页面成功关闭后 resolve

***

## stopConversation

### API 定义

```ts
function stopConversation(): Promise<void>
```

***

### 行为说明

- 彻底终止当前会话
- 自动调用 `dismiss`
- 清理会话状态与资源
- 结束后可再次调用 `startConversation` 创建新会话

***

### 返回值

```ts
Promise<void>
```

***

## 会话状态相关常量

### Assistant.isAvailable

```ts
const isAvailable: boolean
```

- 表示当前用户是否**具备使用 Assistant 的权限**
- 若为 `false`：

  - 所有 Conversation API 均不可用

***

### Assistant.isPresented

```ts
const isPresented: boolean
```

- 表示 Assistant 聊天页面当前是否处于展示状态

***

### Assistant.hasActiveConversation

```ts
const hasActiveConversation: boolean
```

- 表示当前是否存在一个活动会话
- 常用于防止重复调用 `startConversation`

***

## 使用示例

### 示例一：最常见的使用方式

```ts
await Assistant.startConversation({
  message: "帮我总结这篇文章的要点",
  autoStart: true
})

await Assistant.present()
```

***

### 示例二：创建会话但不自动发送

```ts
await Assistant.startConversation({
  message: "我们来讨论一下系统架构设计",
  autoStart: false
})

await Assistant.present()
// 由用户在 UI 中手动点击发送
```

***

### 示例三：暂时关闭，再次展示

```ts
await Assistant.startConversation({
  message: "分析这张图片",
  images: [image],
  autoStart: true
})

await Assistant.present()

// 用户关闭页面
await Assistant.dismiss()

// 稍后再次展示同一会话
await Assistant.present()
```

***

### 示例四：结束当前会话并重新开始

```ts
if (Assistant.hasActiveConversation) {
  await Assistant.stopConversation()
}

await Assistant.startConversation({
  message: "开始一个新的话题",
  autoStart: true
})

await Assistant.present()
```

***

## 使用建议与最佳实践

- 将 Conversation API 视为“**托管聊天界面**”
- 不要在同一业务流中混用 Conversation API 与 `requestStreaming`
- 在调用 `startConversation` 前检查 `hasActiveConversation`
- 若仅需要数据或一次性输出，应使用：

  - `requestStructuredData`
  - `requestStreaming`
- 若用户需要持续交互体验，应使用 Conversation API

***

## 设计边界说明

- Conversation API 不适合无 UI 场景
- 不适合后台自动化任务
- 不适合需要完全控制 Prompt / Token / 输出格式的场景



---
url: /zh/guide/Assistant/Assistant Quick Start.md
---

# 快速了解智能助手

Scripting 的 Assistant API 提供了三类能力，分别面向 **数据处理**、**流式输出** 和 **交互式聊天** 三种不同使用场景。
在使用之前，建议先明确你的需求属于哪一类。

***

## Assistant API 分类总览

| API 分类 | 主要方法                                                             | 适用场景                   |
| ------ | ---------------------------------------------------------------- | ---------------------- |
| 结构化数据  | `requestStructuredData`                                          | 从文本 / 图片中提取结构化 JSON 数据 |
| 流式生成   | `requestStreaming`                                               | 实时展示 AI 输出内容           |
| 会话聊天   | `startConversation` / `present` / `dismiss` / `stopConversation` | 托管式聊天体验                |

***

## requestStructuredData

**用途**
用于请求**严格符合 JSON Schema 的结构化结果**。

**适合场景**

- 解析票据、发票、账单
- 从自然语言中提取字段
- 生成配置、规则、表单数据
- 需要直接用于程序逻辑的数据

**特点**

- 返回值稳定、可预测
- 不适合长文本或展示型输出
- 适合后台或无 UI 场景

**一句话总结**

> 需要“数据”，用 `requestStructuredData`

***

## requestStreaming

**用途**
用于获取**流式输出**，在模型生成过程中持续接收内容。

**适合场景**

- 聊天气泡逐字显示
- 长文本生成（文章、说明、分析）
- 需要低延迟反馈的 UI

**特点**

- 支持文本、推理、用量等多种 Chunk
- 可边生成边渲染
- 不保证输出结构

**一句话总结**

> 需要“过程”和“实时展示”，用 `requestStreaming`

***

## Conversation API（会话聊天）

**相关方法**

- `startConversation`
- `present`
- `dismiss`
- `stopConversation`

**用途**
用于创建并展示一个**系统托管的 Assistant 聊天页面**。

**适合场景**

- 类 ChatGPT 的交互体验
- 用户需要多轮对话
- 希望系统管理 UI、Provider 切换、消息状态

**特点**

- 内置完整聊天 UI
- 自动处理流式输出
- 同一时间仅支持一个会话

**一句话总结**

> 需要“完整聊天体验”，用 Conversation API

***

## 如何选择合适的 API

### 常见选择指南

- **我要解析一张账单 →** `requestStructuredData`
- **我要展示 AI 写文章的过程 →** `requestStreaming`
- **我要打开一个聊天页面让用户和 AI 对话 →** Conversation API
- **我不需要 UI，只要结果 →** `requestStructuredData` 或 `requestStreaming`
- **我希望系统帮我处理聊天 UI →** Conversation API

***

## 简单示例

### 结构化数据

```ts
const data = await Assistant.requestStructuredData(...)
```

***

### 流式输出

```ts
const stream = await Assistant.requestStreaming(...)
for await (const chunk of stream) {
  // handle chunk
}
```

***

### 聊天会话

```ts
await Assistant.startConversation({ message: "你好", autoStart: true })
await Assistant.present()
```

***

## 使用建议

- 不要在同一业务流程中混用 Conversation API 和 `requestStreaming`
- 有明确数据结构需求时，优先选择 `requestStructuredData`
- 展示型输出和交互体验优先考虑 `requestStreaming` 或 Conversation API

***

## 下一步

如果你需要更深入的内容，可以继续阅读：

- `requestStructuredData` 详细文档
- `requestStreaming` 详细文档
- Conversation API 生命周期说明



---
url: /zh/guide/Assistant/requestStreaming.md
---

# 请求流式数据

`requestStreaming` 用于向 Assistant 请求**流式输出（Streaming Response）**。
与一次性返回完整结果不同，该 API 会在模型生成内容的过程中**持续返回数据片段（Chunk）**，调用方可以边接收边处理，从而实现：

- 实时展示 AI 输出（打字机效果）
- 流式日志 / 分段结果处理
- 长文本生成的低延迟体验
- 在生成过程中提前终止或切换 UI 状态

该 API 返回的是一个 **`ReadableStream<StreamChunk>`**，你可以通过 `for await ... of` 逐块读取。

***

## API 定义

```ts
function requestStreaming(options: {
  systemPrompt?: string | null
  messages: MessageItem | MessageItem[]
  provider?: Provider
  modelId?: string
}): Promise<ReadableStream<StreamChunk>>
```

***

## 参数说明

### options.systemPrompt（可选）

- 类型：`string | null`
- 指定本次请求使用的 system prompt
- 若未提供：

  - 使用 Assistant 内置的默认 system prompt
- 若显式传入：

  - 将**完全替换默认 system prompt**
  - Assistant Tools 将**不可用**

适用场景：

- 构建专用角色（如代码审查、翻译、摘要）
- 严格约束模型行为或输出风格

***

### options.messages

- 类型：`MessageItem | MessageItem[]`
- 必填
- 用于描述对话上下文的消息列表

#### MessageItem 结构

```ts
type MessageItem = {
  role: "user" | "assistant"
  content: MessageContent | MessageContent[]
}
```

- `role`

  - `"user"`：用户输入
  - `"assistant"`：历史 Assistant 输出（用于上下文补全）

***

### MessageContent 类型

#### 文本内容

```ts
type MessageTextContent =
  | string
  | { type: "text"; content: string }
```

***

#### 图片内容

```ts
type MessageImageContent = {
  type: "image"
  content: string // data:image/...;base64,...
}
```

***

#### 文档内容

```ts
type MessageDocumentContent = {
  type: "document"
  content: {
    mediaType: string
    data: string // base64
  }
}
```

***

### options.provider（可选）

- 类型：`Provider`
- 指定使用的 AI Provider
- 若未指定：

  - 使用 Assistant 当前配置的默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 若未指定，使用 Provider 默认模型

***

## 返回值

```ts
Promise<ReadableStream<StreamChunk>>
```

该 Promise resolve 后，你将获得一个可异步迭代的流对象。

***

## StreamChunk 类型说明

`requestStreaming` 的流中会返回以下三类 Chunk。

***

### StreamTextChunk（文本输出）

```ts
type StreamTextChunk = {
  type: "text"
  content: string
}
```

- 表示 Assistant 生成的**可展示文本**
- 多个 chunk 拼接后构成完整回复

***

### StreamReasoningChunk（推理输出）

```ts
type StreamReasoningChunk = {
  type: "reasoning"
  content: string
}
```

- 表示模型的**中间推理过程**
- 是否返回、返回粒度取决于 Provider / Model

***

### StreamUsageChunk（用量信息）

```ts
type StreamUsageChunk = {
  type: "usage"
  content: {
    totalCost: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    inputTokens: number
    outputTokens: number
  }
}
```

说明：

- 通常在流的**末尾**返回一次
- 不同 Provider 支持的字段略有差异
- `totalCost` 可能为 `null`（例如 Provider 未提供费用信息）

***

## 使用示例

### 示例一：最基本的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: {
    role: "user",
    content: "给我讲一个简短的科幻故事"
  },
  provider: "openai"
})

let text = ""

for await (const chunk of stream) {
  if (chunk.type === "text") {
    text += chunk.content
    console.log(chunk.content)
  }
}
```

***

### 示例二：区分文本、推理和用量

```ts
const stream = await Assistant.requestStreaming({
  systemPrompt: "你是一个严谨的技术写作助手",
  messages: [
    {
      role: "user",
      content: "解释什么是 HTTP/3"
    }
  ]
})

let answer = ""
let reasoningLog = null
let usage = null

for await (const chunk of stream) {
  switch (chunk.type) {
    case "text":
      answer += chunk.content
      break

    case "reasoning":
      reasoningLog = (reasoningLog ?? "") + chunk.content
      break

    case "usage":
      usage = chunk.content
      break
  }
}

console.log(answer)
console.log(usage)
```

***

### 示例三：包含图片与文档的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: [
    {
      role: "user",
      content: [
        {
          type: "text",
          content: "请分析这份文档的核心内容"
        },
        {
          type: "document",
          content: {
            mediaType: "application/pdf",
            data: "JVBERi0xLjQKJcfs..."
          }
        }
      ]
    }
  ],
  provider: "anthropic"
})

for await (const chunk of stream) {
  if (chunk.type === "text") {
    console.log(chunk.content)
  }
}
```

***

## 使用建议与注意事项

- 流式结果**必须按顺序消费**，不可并发读取
- UI 场景下建议：

  - 文本 chunk 实时渲染
  - reasoning chunk 仅用于调试
  - usage chunk 延迟处理
- 若中途不再需要结果，应主动中止读取，避免无意义消耗
- 并非所有 Provider / Model 都会返回 reasoning 或 usage
- 不同 Provider 的 chunk 粒度不同，不应假设单次 chunk 是完整句子



---
url: /zh/guide/Assistant/requestStructuredData.md
---

# 请求结构化数据

`requestStructuredData` 用于向 Assistant 请求**严格符合指定 JSON Schema 的结构化 JSON 数据**。
该 API 适合在你需要**可预测、可直接用于程序逻辑**的数据结果时使用，而不是自由文本。

典型使用场景包括：

- 从自然语言中提取结构化字段
- 解析发票、收据、账单、票据
- 生成配置对象、规则数据
- 在不同 AI Provider / Model 之间获得一致的数据结构

***

## 支持的 JSON Schema 类型

Scripting 提供了一套轻量级、跨模型可用的 Schema 描述方式，由三种基础类型组成。

### Primitive（基础类型）

```ts
type JSONSchemaPrimitive = {
  type: "string" | "number" | "boolean"
  required?: boolean
  description: string
}
```

***

### Object（对象类型）

```ts
type JSONSchemaObject = {
  type: "object"
  properties: Record<string, JSONSchemaType>
  required?: boolean
  description: string
}
```

***

### Array（数组类型）

```ts
type JSONSchemaArray = {
  type: "array"
  items: JSONSchemaType
  required?: boolean
  description: string
}
```

***

## API 定义

### 不包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

### 包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  images: string[],
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

## 参数说明

### prompt

- 类型：`string`
- 必填
- 向模型说明**需要解析或生成什么结构化数据**
- 强烈建议在 prompt 中明确：

  - 时间格式（如 ISO-8601）
  - 金额是否为纯数字
  - 缺失字段的处理规则

***

### images（可选）

- 类型：`string[]`
- 每一项必须是 Data URI，例如：

```text
data:image/png;base64,iVBORw0KGgoAAAANS...
```

- 并非所有 Provider / Model 都支持图片输入
- 图片数量过多可能导致请求失败

***

### schema

- 类型：`JSONSchemaArray | JSONSchemaObject`
- 必填
- 定义模型**唯一允许返回的 JSON 结构**
- 每一个字段都应提供清晰的 `description`，这是保证结果稳定的关键

***

### options.provider

- 类型：`Provider`
- 可选，未指定时使用 Assistant 当前默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 未指定时使用 Provider 默认模型

***

## 返回值

```ts
Promise<R>
```

- `R` 为调用方声明的泛型类型
- 返回结果应严格符合 Schema 描述
- 若模型无法生成合法结构，Promise 将被 reject

***

## 使用示例

### 示例一：解析票据 / 收据，提取消费项目、时间和金额

该示例演示如何将一段票据文本解析为结构化数据，包括：

- 整体消费时间（`purchasedAt`）
- 币种（`currency`）
- 消费项目列表（`items`）

  - 项目名称
  - 项目时间（若无则为空）
  - 金额
- 合计金额（`total`）

```ts
type ReceiptItem = {
  name: string
  time: string
  amount: number
}

type ReceiptParsed = {
  purchasedAt: string
  currency: string
  items: ReceiptItem[]
  total: number
}

const receiptText = `
Star Coffee
2026-01-08 14:23
Latte (Large)   $5.50
Blueberry Muffin $3.20
Tax             $0.79
Total           $9.49
`

const parsed = await Assistant.requestStructuredData<ReceiptParsed>(
  [
    "请分析以下票据文本，并提取结构化信息：",
    "- purchasedAt：整体消费时间，使用 ISO-8601 格式，若无法判断则返回空字符串",
    "- currency：币种代码（如 USD / EUR / CNY），若无法判断则返回空字符串",
    "- items：仅包含实际消费项目，不包含税费、合计等行",
    "  - name：项目名称",
    "  - time：项目级时间，若无则返回空字符串",
    "  - amount：数值类型的金额",
    "- total：合计金额，若无则返回 -1",
    "",
    "票据内容：",
    receiptText
  ].join("\n"),
  {
    type: "object",
    description: "票据解析结果",
    properties: {
      purchasedAt: {
        type: "string",
        description: "整体消费时间（ISO-8601），若无则为空字符串"
      },
      currency: {
        type: "string",
        description: "币种代码，若无法判断则为空字符串"
      },
      items: {
        type: "array",
        description: "消费项目列表（不包含税费、合计等）",
        items: {
          type: "object",
          description: "单个消费项目",
          properties: {
            name: {
              type: "string",
              description: "项目名称"
            },
            time: {
              type: "string",
              description: "项目时间（ISO-8601），若无则为空字符串"
            },
            amount: {
              type: "number",
              description: "项目金额"
            }
          }
        }
      },
      total: {
        type: "number",
        description: "合计金额，若不存在则为 -1"
      }
    }
  },
  {
    provider: "openai"
  }
)

// 建议在业务层将空字符串 / -1 归一化为 null
console.log(parsed)
```

***

### 示例二：生成数组结构

```ts
type Expense = {
  name: string
  amount: number
}

const expenses = await Assistant.requestStructuredData<Expense[]>(
  "列出三项常见的日常支出及其大致金额",
  {
    type: "array",
    description: "支出列表",
    items: {
      type: "object",
      description: "单项支出",
      properties: {
        name: {
          type: "string",
          description: "支出名称"
        },
        amount: {
          type: "number",
          description: "金额"
        }
      }
    }
  },
  {
    provider: "gemini"
  }
)
```

***

### 示例三：结合图片生成结构化结果

```ts
type ImageSummary = {
  description: string
  containsText: boolean
}

const summary = await Assistant.requestStructuredData<ImageSummary>(
  "分析这张图片的主要内容",
  ["data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD..."],
  {
    type: "object",
    description: "图片分析结果",
    properties: {
      description: {
        type: "string",
        description: "图片内容描述"
      },
      containsText: {
        type: "boolean",
        description: "是否包含可识别文本"
      }
    }
  },
  {
    provider: "openai"
  }
)
```

***

## 使用建议与注意事项

- 当返回结果用于业务逻辑时，优先使用 `requestStructuredData`
- Schema 描述越明确，结果越稳定
- 复杂业务规则不要放在 Schema 中，应由业务代码处理



---
url: /zh/guide/AssistantTool.md
---

# 智能助手工具

Assistant Tool 是 Scripting 应用中为智能助手（Assistant）提供系统功能扩展的机制。通过定义和实现 Assistant Tool，开发者可以为 Assistant 提供设备能力访问、文件读写操作、数据分析处理等辅助功能，提升 Assistant 的智能性和实用性。

本文以一个示例工具「Request Current Location」为基础，介绍 Assistant Tool 的完整实现流程，包括工具创建、配置文件说明、执行逻辑实现以及各类函数的详细说明。

***

## 一、工具创建流程

1. 打开任意脚本项目，在文件管理界面点击“添加 Assistant Tool”按钮。

2. 在弹出的配置窗口中填写Assistant Tool 相关的信息。

3. 点击“保存”后，系统会自动在脚本中生成两个文件：

- `assistant_tool.json`：描述工具的元数据和参数信息。
- `assistant_tool.tsx`：实现工具的执行逻辑。

***

## 二、配置文件 assistant\_tool.json

该文件用于声明工具的基本信息和行为配置。以下是示例内容及字段说明：

```json
{
  "displayName": "Request Current Location",
  "id": "request_current_location",
  "description": "This tool allows you to request the one-time delivery of the latitude and longitude of the user’s current location.",
  "icon": "location.fill",
  "color": "systemBlue",
  "parameters": [],
  "requireApproval": true,
  "autoApprove": true,
  "scriptEditorOnly": false
}
```

### 字段说明：

| 字段                 | 类型      | 说明                  |
| ------------------ | ------- | ------------------- |
| `displayName`      | string  | 工具在界面中显示的名称         |
| `id`               | string  | 工具唯一标识符，不能重复        |
| `description`      | string  | 工具功能描述              |
| `icon`             | string  | 使用的 SF Symbols 图标名  |
| `color`            | string  | 工具主色调               |
| `parameters`       | array   | 工具需要的参数（为空表示无输入）    |
| `requireApproval`  | boolean | 是否需要用户批准            |
| `autoApprove`      | boolean | 是否支持 Assistant 自动批准 |
| `scriptEditorOnly` | boolean | 工具是否仅能在脚本编辑器中使用     |

***

## 三、执行逻辑 assistant\_tool.tsx 实现示例

```tsx
type RequestCurrentLocationParams = {}

const locationApprovalRequest: AssistantToolApprovalRequestFn<RequestCurrentLocationParams> = async (
  params,
) => {
  return {
    message: "The assistant wants to request your current location.",
    primaryButtonLabel: "Allow"
  }
}

const requestCurrentLocation: AssistantToolExecuteWithApprovalFn<RequestCurrentLocationParams> = async (
  params,
  {
    primaryConfirmed,
    secondaryConfirmed,
  }
) => {
  try {
    const location = await Location.requestCurrent()
    if (location) {
      return {
        success: true,
        message: [
          "The user's current location info:",
          `<latitude>${location.latitude}</latitude>`,
          `<longitude>${location.longitude}</longitude>`
        ].join("\n")
      }
    }
    return {
      success: false,
      message: "Failed to request user's current location, ask user to check the device's location permission."
    }
  } catch {
    return {
      success: false,
      message: "Failed to request user's current location, ask user to check the device's location permission."
    }
  }
}

const testRequestLocationApprovalFn = AssistantTool.registerApprovalRequest(
  locationApprovalRequest
)

const testRequestLocationExecuteFn = AssistantTool.registerExecuteToolWithApproval(
  requestCurrentLocation
)

// 可在脚本编辑器中运行以下测试代码：
testRequestLocationApprovalFn({})
testRequestLocationExecuteFn({}, {
  primaryConfirmed: true,
  secondaryConfirmed: false
})
```

***

## 四、AssistantTool 注册函数详解

### 1. `registerApprovalRequest`

注册一个函数，在执行工具前向用户请求批准。

```ts
function registerApprovalRequest<P>(
  requestFn: AssistantToolApprovalRequestFn<P>
): AssistantToolApprovalRequestTestFn<P>
```

**参数说明**：

- `requestFn(params, scriptEditorProvider?)`：返回提示信息，包括 message、按钮文本等。
- `params`：工具执行时的输入参数。
- `scriptEditorProvider`：仅在工具设置为仅限脚本编辑器使用时可用，提供脚本文件访问能力。

**返回值说明**：

返回的测试函数可用于在脚本编辑器中模拟触发批准请求。

***

### 2. `registerExecuteToolWithApproval`

注册一个需要用户批准的执行函数。

```ts
function registerExecuteToolWithApproval<P>(
  executeFn: AssistantToolExecuteWithApprovalFn<P>
): AssistantToolExecuteWithApprovalTestFn<P>
```

**参数说明**：

- `params`：工具执行时的输入参数。
- `userAction`：用户在批准提示中选择的操作：

```ts
type UserActionForApprovalRequest = {
  primaryConfirmed: boolean
  secondaryConfirmed: boolean
}
```

- `scriptEditorProvider`：同上。

**返回值说明**：

返回一个对象：

```ts
{
  success: boolean
  message: string
}
```

- `success`: 是否执行成功。
- `message`: 返回给Assistant的执行成功或失败的信息。

***

### 3. `registerExecuteTool`

注册一个不需要用户批准的工具逻辑。

```ts
function registerExecuteTool<P>(
  executeFn: AssistantToolExecuteFn<P>
): AssistantToolExecuteTestFn<P>
```

**适用场景**：如操作无敏感性、不涉及设备权限时，可使用此方式。

***

### 4. 测试函数使用

每个注册函数会返回对应的测试函数，可在脚本中运行：

```ts
testApprovalRequestFn({ ...params })
testExecuteFn({ ...params }, {
  primaryConfirmed: true,
  secondaryConfirmed: false,
})
testExecuteToolFn({ ...params })
```

***

## 五、脚本编辑器接口说明（ScriptEditorProvider）

当工具设置为 `scriptEditorOnly: true` 时，系统提供 `ScriptEditorProvider` 接口，允许访问脚本项目的文件系统与语法信息。

接口能力包括：

- 文件读写（读取、更新、写入、插入、替换）
- 差异比较（openDiffEditor）
- 语法检查结果（getLintErrors）
- 获取项目中所有文件/文件夹列表

适用于如格式化脚本、批量修改内容等编辑类工具。

***

## 六、执行与用户体验流程

1. Assistant 在会话中判断是否需要调用某个工具。
2. 如果工具设置为需要批准，系统弹出批准对话框：
   - 显示由 `registerApprovalRequest` 返回的提示信息。
   - 用户点击“允许”后执行工具逻辑。
3. 执行结果通过 `message` 字段返回给 Assistant，并可呈现给用户。

***

## 七、无需批准的工具实现方式

当不需要显示批准提示时，可直接使用 `registerExecuteTool` 注册逻辑函数：

```ts
AssistantTool.registerExecuteTool<MyParams>(async (params) => {
  // 执行逻辑
  return {
    success: true,
    message: "Tool executed successfully."
  }
})
```

将 `assistant_tool.json` 中的 `requireApproval` 字段设置为 `false` 即可。

***

## 八、小结

Assistant Tool 是 Scripting 应用提供的可扩展能力模块，支持用户授权、文件操作、系统调用等多种场景。开发流程主要包括：

1. 在脚本项目中创建工具；
2. 配置工具元信息；
3. 实现逻辑函数并注册；
4. 使用测试函数验证行为；
5. 在 Assistant 会话中自动或主动触发执行。



---
url: /zh/guide/Changelog/2.4.3/Animation and Transition.md
---

# 动画和过渡

Scripting 通过 `Observable` / `useObservable`、`Animation`、`Transition`、`withAnimation` 以及视图的 `animation` / `transition` 属性，基本对齐了 SwiftUI 的动画能力，包括：

- **属性动画**：数值、颜色、布局等属性随状态变化平滑过渡
- **过渡动画**：视图插入 / 移除时的进出效果（如淡入淡出、滑入滑出、翻转）
- **显式动画**：通过 `withAnimation` 包裹一段「状态更新代码」统一加动画

## Animation 类

`Animation` 用来描述「属性变化的时间曲线与节奏」，类似 SwiftUI 的 `Animation`。

### 工厂方法（创建动画）

#### `Animation.default()`

```ts
static default(): Animation
```

- 创建一个默认动画（通常是系统预设的 ease-in-out 曲线）
- 无需配置，适合「只想要一个普通的过渡效果」的场景

示例：

```tsx
<Text animation={{
  animation: Animation.default(),
  value: value
}}>默认动画</Text>
```

***

#### `Animation.linear(duration?)`

```ts
static linear(duration?: DurationInSeconds | null): Animation
```

- 匀速动画，整段时间内速度保持恒定
- `duration`：动画持续时间（秒），可选，不传时使用默认时长

适合：进度条数值增长、颜色线性变化等。

***

#### `Animation.easeIn(duration?)`

```ts
static easeIn(duration?: DurationInSeconds | null): Animation
```

- 开始慢、后面加速
- 适合：元素「加速进入」的感觉

***

#### `Animation.easeOut(duration?)`

```ts
static easeOut(duration?: DurationInSeconds | null): Animation
```

- 开始快、结尾慢
- 适合：元素「减速停止」的感觉，如卡片滑入后停在目标位置

***

#### `Animation.bouncy(options?)`

```ts
static bouncy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 带回弹效果的动画
- 参数：

  - `duration`：总时长（秒）
  - `extraBounce`：额外弹性，越大越明显

适合：按钮点击放大回弹、卡片弹出等「有趣」的动效。

***

#### `Animation.smooth(options?)`

```ts
static smooth(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 相对柔和、过渡自然的动画
- 与 `bouncy` 相比，弹性感更弱，更偏「丝滑」

***

#### `Animation.snappy(options?)`

```ts
static snappy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 动作「干脆利落」，响应速度快
- 常见于触控反馈、选中高亮等瞬间反馈场景

***

#### `Animation.spring(options?)`

```ts
static spring(options?: {
  blendDuration?: number
} & ({
  duration?: DurationInSeconds
  bounce?: number
  response?: never
  dampingFraction?: never
} | {
  response?: number
  dampingFraction?: number
  duration?: never
  bounce?: never
})): Animation
```

支持两种配置方式（注意互斥）：

1. **基于时长的弹簧动画**

   - `duration`: 动画持续时间
   - `bounce`: 弹性大小

2. **物理参数模式**

   - `response`: 响应速度（值越小反馈越快）
   - `dampingFraction`: 阻尼系数（0\~1，越大越「稳」，越小越「弹」）

额外参数：

- `blendDuration`：动画混合时长，用于多动画衔接场景（可选）

示例：

```tsx
// 简单弹簧
const anim1 = Animation.spring({
  duration: 0.4,
  bounce: 0.3
})

// 高级弹簧
const anim2 = Animation.spring({
  response: 0.25,
  dampingFraction: 0.7
})
```

***

#### `Animation.interactiveSpring(options?)`

```ts
static interactiveSpring(options?: {
  response?: number
  dampingFraction?: number
  blendDuration?: number
}): Animation
```

- 面向「交互驱动」的弹簧动画，例如拖拽结束后的回弹
- 参数与 `spring` 的物理参数模式类似，语义更偏向手势交互

***

#### 0 `Animation.interpolatingSpring(options?)`

```ts
static interpolatingSpring(options?: {
  mass?: number
  stiffness: number
  damping: number
  initialVelocity?: number
} | {
  duration?: DurationInSeconds
  bounce?: number
  initialVelocity?: number
  mass?: never
  stiffness?: never
  damping?: never
}): Animation
```

两种配置方式（互斥）：

1. **物理参数模式**

   - `mass`: 质量
   - `stiffness`: 刚度
   - `damping`: 阻尼
   - `initialVelocity`: 初速度（可选）

2. **时长 + 弹性模式**

   - `duration`: 动画时长
   - `bounce`: 弹性
   - `initialVelocity`: 初速度（可选）

适合对动态效果「非常在意手感」的高级场景。

***

### 修改已有动画（链式 API）

#### `delay(time)`

```ts
delay(time: DurationInSeconds): Animation
```

- 使动画延迟 `time` 秒后再开始
- 返回一个新的 `Animation` 实例（原动画不变）

示例：

```tsx
const [animValue, setAnimValue] = useState(0)
const anim = Animation
  .spring({ duration: 0.4, bounce: 0.3 })
  .delay(0.2)

<Text animation={{
  animation: anim,
  value: animValue
}>延迟弹簧</Text>
```

***

#### `repeatCount(count, autoreverses?)`

```ts
repeatCount(count: number, autoreverses?: boolean): Animation
```

- 重复执行动画 `count` 次
- `autoreverses`（默认 `true`）：是否来回反向播放

示例：

```tsx
const pulse = Animation
  .easeIn(0.6)
  .repeatCount(3, true)

<Text animation={{
  animation: pulse,
  value: value
}}>闪烁三次</Text>
```

***

#### `repeatForever(autoreverses?)`

```ts
repeatForever(autoreverses?: boolean): Animation
```

- 无限次重复动画
- 适合加载动画、呼吸灯效果等

***

### Animation 实战示例

#### 示例 1：基本大小动画

```tsx
import { VStack, Button, Rectangle, useObservable, Animation, withAnimation } from "scripting"

export function Demo() {
  const size = useObservable(80)

  return <VStack spacing={16}>
    <Rectangle
      frame={{ width: size.value, height: size.value }}
      backgroundColor="blue"
      animation={{
        animation: Animation.spring({ duration: 0.3, bounce: 0.2 }),
        value: size.value
      }}
    />

    <Button
      title="Toggle Size"
      action={() => {
        withAnimation(() => {
          size.setValue(size.value === 80 ? 140 : 80)
        })
      }}
    />
  </VStack>
}
```

***

## Transition 类（视图过渡）

`Transition` 描述的是**视图插入与移除**时的「进场 / 退场效果」，对应 SwiftUI 的 `AnyTransition`。

> 注意：只有当视图在 JSX 中「存在与否」发生变化（如 `{visible.value && <Text ... />}`）时，`transition` 才会生效。

### 实例方法

#### `animation(animation?)`

```ts
animation(animation?: Animation): Transition
```

- 为当前过渡指定（或覆盖）使用的 `Animation`
- 不传时使用默认动画

示例：

```tsx
const t = Transition
  .move("bottom")
  .animation(Animation.spring({ duration: 0.4 }))
```

***

#### `combined(other)`

```ts
combined(other: Transition): Transition
```

- 组合两个过渡效果，类似 SwiftUI 的 `.combined`
- 如：向下滑入 + 淡入

示例：

```tsx
const t = Transition
  .move("bottom")
  .combined(Transition.opacity())
```

在视图中使用：

```tsx
<Text transition={t}>组合过渡</Text>
```

***

### 静态方法（构造不同类型的过渡）

#### `Transition.identity()`

```ts
static identity(): Transition
```

- 「没有任何过渡」，视图插入 / 移除时不会做动画
- 通常用于禁用某些分支的过渡效果

***

#### `Transition.move(edge)`

```ts
static move(edge: Edge): Transition
```

- 从某个边缘移入 / 移出
- `edge` 通常是 `"leading" | "trailing" | "top" | "bottom"` 等（和 SwiftUI 对齐）

示例：

```tsx
<Text transition={Transition.move("leading")}>
  从左侧滑入 / 滑出
</Text>
```

***

#### `Transition.offset(position?)`

```ts
static offset(position?: Point): Transition
```

- 通过偏移实现过渡
- `position`: `{ x: number, y: number }`，默认 `{ x: 0, y: 0 }`

例如：

```tsx
<Text
  transition={Transition.offset({ x: 0, y: 40 })}
>
  从下方位移进出
</Text>
```

***

#### `Transition.pushFrom(edge)`

```ts
static pushFrom(edge: Edge): Transition
```

- 类似导航 push 的效果，从某个边缘推入并把旧内容推走
- 适合做「页面切换」类效果

***

#### `Transition.opacity()`

```ts
static opacity(): Transition
```

- 单纯的淡入 / 淡出
- 与 `Animation` 搭配可以控制淡入淡出的节奏

***

#### `Transition.scale(scale?, anchor?)`

```ts
static scale(
  scale?: number,
  anchor?: Point | KeywordPoint
): Transition
```

- 缩放过渡
- `scale`：缩放比（默认 1）
- `anchor`：缩放基准点，支持：

  - `Point`：如 `{ x: 0.5, y: 0.5 }`
  - `KeywordPoint`：如 `"center"`、`"top"`, `"bottom"` 等（具体值与 Scripting 内部对齐）

示例：

```tsx
<Text
  transition={Transition.scale(0.8, "center")}
>
  缩放进出
</Text>
```

***

#### `Transition.slide()`

```ts
static slide(): Transition
```

- 类似 SwiftUI 的 `.slide`，通常是从一侧滑入 / 滑出（具体方向由系统决定）
- 常用于列表项、简单出现 / 消失效果

***

#### `Transition.fade(duration?)`

```ts
static fade(duration?: DurationInSeconds): Transition
```

- 带时长配置的淡入 / 淡出
- 与 `Transition.opacity()` 类似，但可以直接指定过渡时间

***

#### Flip 系列（翻转过渡）

```ts
static flipFromLeft(duration?: DurationInSeconds): Transition
static flipFromBottom(duration?: DurationInSeconds): Transition
static flipFromRight(duration?: DurationInSeconds): Transition
static flipFromTop(duration?: DurationInSeconds): Transition
```

- 类似卡片翻转的 3D 过渡

示例：

```tsx
<Text
  transition={Transition.flipFromLeft(0.4)}
>
  左侧翻入 / 翻出
</Text>
```

***

#### 0 `Transition.asymmetric(insertion, removal)`

```ts
static asymmetric(
  insertion: Transition,
  removal: Transition
): Transition
```

- 插入和移除使用不同的过渡效果
- 典型用法：进入时从下方滑入，离开时淡出

示例：

```tsx
const appear = Transition
  .move("bottom")
  .combined(Transition.opacity())

const disappear = Transition.opacity()

const t = Transition.asymmetric(appear, disappear)

<Text transition={t}>不对称过渡</Text>
```

***

### Transition 实战示例

#### 示例：多种过渡效果对比

```tsx
const visible = useObservable(true)

return <VStack spacing={12}>
  {visible.value &&
    <Text
      transition={Transition.slide().combined(Transition.opacity())}
    >
      Slide + Fade
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.move("leading")}
    >
      Move leading
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.scale()}
    >
      Scale
    </Text>
  }

  <Button
    title="Toggle"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## withAnimation：显式动画入口

`withAnimation` 用来「显式」地将一段状态更新包裹在动画上下文中，类似 SwiftUI 的 `withAnimation`。
它返回 `Promise<void>`，方便在异步逻辑中等待动画完成。

### 重载签名

```ts
function withAnimation(body: () => void): Promise<void>
function withAnimation(animation: Animation, body: () => void): Promise<void>
function withAnimation(
  animation: Animation,
  completionCriteria: "logicallyComplete" | "removed",
  body: () => void
): Promise<void>
```

- 第一个重载：使用默认动画
- 第二个重载：指定动画曲线 / 弹性等
- 第三个重载：额外指定**完成条件**：

  - `"logicallyComplete"`：动画在时间轴上播放完成时视为完成（典型属性动画）
  - `"removed"`：通常用于涉及过渡的场景，等待相关视图被移出 / 动画结束后再继续逻辑（具体行为依赖底层 SwiftUI）

> 实际等待的精确时机由内部动画系统决定，一般可理解为「该动画相关的视图不再处于动画中」。

***

### 基本用法

#### 默认动画

```tsx
const size = useObservable(100)

<Button
  title="Toggle"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value === 100 ? 200 : 100)
    })
  }}
/>
```

***

#### 指定动画

```tsx
const visible = useObservable(true)

<Button
  title="Toggle Panel"
  action={() => {
    withAnimation(
      Animation.spring({ duration: 0.3, bounce: 0.2 }),
      () => {
        visible.setValue(!visible.value)
      }
    )
  }}
/>
```

***

#### 在异步函数中等待动画结束

```ts
async function hideThenRunTask() {
  await withAnimation(Animation.easeOut(0.25), () => {
    visible.setValue(false)
  })

  // 此处可以认为相关动画已经结束，再继续耗时任务或导航
  await doSomethingHeavy()
}
```

***

## 视图上的 animation / transition 属性

在 Scripting 的视图组件上，可以通过 props 的形式配置动画相关行为：

- `animation?: Animation`（属性动画）
- `transition?: Transition`（插入 / 移除过渡）

### 属性动画（animation）

属性动画的核心逻辑：

- 当某个视图依赖的 `Observable` 的 `value` 发生变化时
- 如果该视图设置了 `animation={...}` 或更新发生在 `withAnimation` 中
- 则 SwiftUI 会对这些属性差异进行插值，从原值平滑过渡到新值

示例：

```tsx
const size = useObservable(80)

<Rectangle
  frame={{
    width: size.value,
    height:size.value
  }}
  backgroundColor="green"
  animation={{
    animation: Animation.spring({ duration: 0.3, bounce: 0.25 }),
    value: size.value
  }}
/>
```

配合 `withAnimation`：

```tsx
<Button
  title="Grow"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value + 20)
    })
  }}
/>
```

***

### 过渡动画（transition）

过渡动画只在「视图从无到有 / 从有到无」时生效。

关键点：

- 通常通过条件渲染控制：

  ```tsx
  {visible.value && <Text transition={...}>Hello</Text>}
  ```

- 状态变化本身需要动画上下文（`withAnimation` 或默认动画）

- `Transition.animation(...)` 可为过渡指定特定 `Animation`

示例：条件面板的进出过渡

```tsx
const visible = useObservable(false)

<VStack>
  {visible.value &&
    <Text
      transition={Transition
        .move("bottom")
        .combined(Transition.opacity())
        .animation(Animation.spring({ duration: 0.35, bounce: 0.3 }))
      }
    >
      Panel
    </Text>
  }

  <Button
    title="Toggle Panel"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## 综合示例：列表增删带过渡与属性动画

```tsx
import {
  VStack,
  HStack,
  Text,
  Button,
  useObservable,
  Animation,
  Transition
} from "scripting"

type Item = { id: string; title: string }

export function AnimatedList() {
  const items = useObservable<Item[]>([
    { id: "1", title: "First" },
    { id: "2", title: "Second" }
  ])

  function addItem() {
    withAnimation(Animation.spring({ duration: 0.3 }), () => {
      const next = items.value.length + 1
      items.setValue([
        ...items.value,
        { id: String(next), title: `Item ${next}` }
      ])
    })
  }

  function removeLast() {
    if (items.value.length === 0) return
    withAnimation(Animation.easeOut(0.25), () => {
      items.setValue(items.value.slice(0, -1))
    })
  }

  return <VStack spacing={12}>
    {items.value.map(item =>
      <HStack
        key={item.id}
        transition={Transition
          .move("trailing")
          .combined(Transition.opacity())
        }
      >
        <Text>{item.title}</Text>
      </HStack>
    )}

    <HStack spacing={12}>
      <Button title="Add" action={addItem} />
      <Button title="Remove Last" action={removeLast} />
    </HStack>
  </VStack>
}
```

这个示例中：

- 使用 `Observable<Item[]>` 作为列表数据源
- `transition` 负责列表项插入 / 删除时的滑动 + 淡入淡出
- `withAnimation` 包裹增删操作，确保这些更新被动画化



---
url: /zh/guide/Changelog/2.4.3/EnvironmentValuesReader.md
---

`EnvironmentValuesReader` 是 Scripting 提供的一个组件，用于读取 SwiftUI 风格的环境值（Environment Values）。
它允许脚本在视图层级中访问当前环境的上下文信息，例如颜色模式、尺寸类别、是否正在搜索、是否被呈现、编辑模式等。

该组件的定位与 SwiftUI 中的 `@Environment` 类似，但设计上更加明确：
**你必须指定要读取的 environment keys，系统仅在渲染时读取这些值并传入回调函数。**

***

# EnvironmentValues 类型

```ts
type EnvironmentValues = {
    colorScheme: ColorScheme;
    colorSchemeContrast: ColorSchemeContrast;
    displayScale: number;
    horizontalSizeClass: UserInterfaceSizeClass | null;
    verticalSizeClass: UserInterfaceSizeClass | null;
    dismiss: () => void;
    dismissSearch: () => void;
    editMode: EditMode | null;
    widgetRenderingMode: WidgetRenderingMode;
    showsWidgetContainerBackground: boolean;
    isSearching: boolean;
    isPresented: boolean;
    activityFamily: "small" | "medium";
    tabViewBottomAccessoryPlacement: 'expanded' | 'inline';
};
```

以下为每个字段的说明：

***

## 字段说明

### 1. colorScheme

类型：`ColorScheme`
说明：当前系统的颜色模式，例如 `light` 或 `dark`。

***

### 2. colorSchemeContrast

类型：`ColorSchemeContrast`
说明：颜色对比度模式，例如 `standard`、`increased`。

***

### 3. displayScale

类型：`number`
说明：设备屏幕的像素缩放比例，例如 **2.0**, **3.0**。

***

### 4. horizontalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：横向尺寸类别，可用于响应式布局。
可能值：`compact` / `regular`。

***

### 5. verticalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：纵向尺寸类别，行为同上。

***

### 6. dismiss

类型：`() => void`
说明：用于关闭当前呈现的界面，等价于 SwiftUI 的 `dismiss()`。

***

### 7. dismissSearch

类型：`() => void`
说明：关闭当前的搜索 UI（如果 `searchable` 处于激活状态）。

***

### 8. editMode

类型：`EditMode | null`
说明：当前视图是否处于编辑模式（例如 List 的编辑状态）。

***

### 9. widgetRenderingMode

类型：`WidgetRenderingMode`
说明：Widget 渲染模式，例如 `fullColor`、`accented` 等。

***

### 10. showsWidgetContainerBackground

类型：`boolean`
说明：指示 widget 是否显示系统容器背景。

***

### 11. isSearching

类型：`boolean`
说明：当前 view 是否处于搜索状态（来自 `searchable`）。

***

### 12. isPresented

类型：`boolean`
说明：当前 view 是否已呈现，和 `onAppear` 回调不同，不像 `onAppear` 会多次触发。

***

### 13. activityFamily

类型：`"small" | "medium"`
说明：当前LiveActivity的尺寸，同 SwiftUI 中的 `activityFamily`，用于根据些大小渲染 LiveActivity UI。

***

### 14. tabViewBottomAccessoryPlacement

类型：`'expanded' | 'inline'`
说明：当前 TabView 的底部辅助栏的显示方式，同 SwiftUI 中的 `tabViewBottomAccessoryPlacement`。

# EnvironmentValuesReader 组件

```ts
type EnvironmentValuesReaderProps = {
    /**
     * The keys to read from the environment values.
     */
    keys: Array<keyof EnvironmentValues>;
    /**
     * The callback function to render the children, it will be called with the environment values.
     */
    children: (values: EnvironmentValues) => VirtualNode;
};
```

***

# Props 说明

## keys

类型：`Array<keyof EnvironmentValues>`
说明：指定需要读取的 environment key 列表。

只有指定的 key 才会被 read 并传入 children。

***

## children(values)

类型：`(values: EnvironmentValues) => VirtualNode`
说明：用于渲染子节点的回调。
系统会收集你请求的 environment key，并将其值合并成一个对象传入。

***

# 组件定义

```ts
declare const EnvironmentValuesReader: FunctionComponent<EnvironmentValuesReaderProps>;
```

***

# 使用示例

## 示例：读取 colorScheme 和 displayScale

```tsx
import { EnvironmentValuesReader, Text, VStack } from "scripting"

function View() {
  return <EnvironmentValuesReader
    keys={["colorScheme", "displayScale"]}
  >
    {(env) => {
      return <VStack>
        <Text>Color Scheme: {env.colorScheme}</Text>
        <Text>Scale: {env.displayScale}</Text>
      </VStack>
    }}
  </EnvironmentValuesReader>
}
```

***

## 示例：读取 dismiss

```tsx
<EnvironmentValuesReader keys={["dismiss"]}>
  {(env) => {
    return <Button
      title="Close"
      action={() => env.dismiss()}
    />
  }}
</EnvironmentValuesReader>
```

***

## 示例：根据 sizeClass 动态布局

```tsx
<EnvironmentValuesReader keys={["horizontalSizeClass"]}>
  {(env) => {
    const compact = env.horizontalSizeClass === "compact"
    return compact ? <Text>Compact Layout</Text> : <Text>Regular Layout</Text>
  }}
</EnvironmentValuesReader>
```

***

# 使用注意事项

1. **必须显式指定 keys**，否则不会读取任何 environment 值。
2. 每次所指定的 environment key 发生变化时，`children()` 会重新渲染。
3. `dismiss` 和 `dismissSearch` 是实际可调用的操作，与 SwiftUI 一致。
4. environment 的来源来自父视图树，包括 `Navigation`, `searchable`, `editMode`, `Widget` 等组件。
5. 未在 keys 中声明的字段不会出现在 values 对象中。
6. 不用于替代全局状态，适用于读取系统环境或父组件传递的上下文信息。



---
url: /zh/guide/Changelog/2.4.3/ForEach/index.md
---

`ForEach` 是 Scripting 中用于渲染可变数量子视图的组件，用于构建动态列表、可编辑列表，以及支持系统级的删除与移动行为。其设计参考 SwiftUI 的 `ForEach`，并与 Scripting 的 `Observable` 状态管理系统深度集成。

组件支持两种模式：

1. **旧版模式（已不推荐使用）**：`count + itemBuilder`
2. **推荐的现代模式**：`data: Observable<T[]> + builder`

***

# 1. 类型定义

## ForEachDeprecatedProps（已不推荐）

```ts
type ForEachDeprecatedProps = {
  count: number;
  itemBuilder: (index: number) => VirtualNode;
  onDelete?: (indices: number[]) => void;
  onMove?: (indices: number[], newOffset: number) => void;
};
```

### 参数说明

#### count: number

要渲染的元素数量，`itemBuilder` 将从 0 到 `count - 1` 依次构建每个子视图。

#### itemBuilder(index)

基于索引构建一个 `VirtualNode`。

#### onDelete(indices)

注册删除行为。
当 ForEach 放置在 `List` 中时，如果提供 `onDelete`，将启用系统级的滑动删除交互。
回调触发时，`List` 中对应的行已被移除，你必须在回调中同步删除数据源中的对应项目。

#### onMove(indices, newOffset)

注册移动行为，用于支持编辑状态下的拖动排序。
如希望禁用移动能力，可传入 `null`。

***

# 2. ForEachProps（推荐使用）

```ts
type ForEachProps<T extends { id: string }> =
  | ForEachDeprecatedProps
  | {
      data: Observable<T[]>;
      builder: (item: T, index: number) => VirtualNode;
      editActions?: "delete" | "move" | "all" | null;
    };
```

### 参数说明

#### data: Observable\<T\[]>

一个可观察数组，数组元素必须包含唯一的 `id: string` 字段。

使用 `Observable` 的好处：

- 当数组变动（增删改）时，会自动触发 SwiftUI 刷新
- 可以保留动画
- 更接近 SwiftUI 中 `ForEach($items)` 的使用体验
- 支持与 `List`、`NavigationStack` 等组件无缝联动

#### builder(item, index)

用于基于当前数组的每个元素构建对应的 VirtualNode。

**注意：必须为返回的子节点提供唯一的 key（通常使用 item.id）。**

#### editActions: "delete" | "move" | "all" | null

控制 ForEach 的可编辑能力：

| 值          | 含义            |
| ---------- | ------------- |
| `"delete"` | 仅启用删除         |
| `"move"`   | 仅启用移动（拖动排序）   |
| `"all"`    | 同时启用删除与移动     |
| `null`     | 不提供任何编辑能力（默认） |

当 `ForEach` 位于 `List` 内部时，编辑能力会自动映射到系统提供的交互方式。

***

# 3. ForEachComponent 接口

```ts
interface ForEachComponent {
  <T extends { id: string }>(props: ForEachProps<T>): VirtualNode;
}
```

`ForEach` 是一个泛型组件，接受带有 `id` 的任意数据类型。

***

# 4. 系统级删除交互示例

当 `ForEach` 放在 `List` 内部，并使用 `data + builder` 模式时，系统会自动启用 swipe-to-delete，只需正确提供 `id` 和编辑能力。

### 示例代码

```tsx
function View() {
  const fruits = useObservable(() =>
    ["Apple", "Bananer", "Papaya", "Mango"].map((name, index) => ({
      id: index.toString(),
      name,
    }))
  );

  return (
    <NavigationStack>
      <List
        navigationTitle="Fruits"
        toolbar={{
          topBarTrailing: <EditButton />,
        }}>
        <ForEach data={fruits} builder={(item, index) => <Text key={item.id}>{item.name}</Text>} />
      </List>
    </NavigationStack>
  );
}
```

***

# 5. 使用建议与最佳实践

### 1. 推荐使用 `data: Observable<T[]>` 方案

新版 API 更接近 SwiftUI 行为，拥有更好的性能与类型推断支持，且未来将接入更多 SwiftUI-style 的能力。

### 2. 每个元素必须拥有 `id: string`

这是确保 Diff 和动画正确工作的基础。

### 3. 必须为 builder 返回的节点提供 `key={item.id}`

否则可能导致:

- 动画不生效
- 列表渲染混乱
- 删除或移动行为出错

### 4. 若需要与编辑按钮联动，必须放置于 `List` 中

并设置 toolbar：

```tsx
toolbar={{
  topBarTrailing: <EditButton />
}}
```



---
url: /zh/guide/Changelog/2.4.3/ForEach/iterating.md
---

# 示例

```tsx
import { Button, Font, ForEach, List, Navigation, NavigationStack, Script, Section, Text, useObservable, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  const namedFonts = useObservable(() => {
    return [
      "largeTitle",
      "title",
      "headline",
      "body",
      "caption"
    ].map(e => ({
      id: e,
      name: e as Font
    }))
  })

  return <NavigationStack>
    <List
      navigationTitle={"Iterating"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        header={
          <Text
            textCase={null}
          >ForEach</Text>
        }
      >
        <ForEach
          data={namedFonts}
          builder={(namedFont) => {
            return <Text
              key={namedFont.id}
              font={namedFont.name}
            >{namedFont.name}</Text>
          }}
        />
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >Iterating in code block</Text>
        }
      >
        <VStack>
          {namedFonts.value.map(namedFont =>
            <Text
              font={namedFont.name}
            >{namedFont.name}</Text>
          )}
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Changelog/2.4.3/GeometryReader.md
---

`GeometryReader` 是 Scripting 中与 SwiftUI 等效的几何布局读取组件。
它能够在视图构建阶段提供当前容器的尺寸、边距、安全区域和角落内边距等信息，使开发者可以根据环境动态布局内容。

当你需要根据父容器的大小进行自适应布局（响应式布局）时，`GeometryReader` 是非常重要的工具。

***

# GeometryProxy

当 `GeometryReader` 构建其子内容时，会将一个 `GeometryProxy` 实例传递给 `children` 回调。开发者可以使用此对象访问与当前容器相关的布局信息。

```ts
interface GeometryProxy {
  readonly size: Size;
  readonly safeAreaInsets: {
      leading: number;
      top: number;
      trailing: number;
      bottom: number;
  };
  /**
   * Requires iOS 26.0+.
   */
  readonly containerCornerInsets: {
      bottomLeading: Size;
      bottomTrailing: Size;
      topLeading: Size;
      topTrailing: Size;
  } | null;
}
```

***

# GeometryProxy 属性说明

## 1. size

```ts
readonly size: Size
```

当前容器在布局时的实际尺寸。

### Size 结构

```ts
type Size = {
  width: number
  height: number
}
```

### 示例

```tsx
proxy.size.width
proxy.size.height
```

用于动态计算子视图布局，例如宽高比、自适应排版等。

***

## 2. safeAreaInsets

```ts
readonly safeAreaInsets: {
  leading: number
  top: number
  trailing: number
  bottom: number
}
```

当前视图所处环境中的安全区域内边距，包括顶部、底部、左右侧的避让区域。
通常用于避免内容被刘海、Home Indicator 等遮挡。

### 示例用途：

- 内容距离屏幕底部安全区域以上对齐
- 自定义导航栏、工具栏时避免被遮挡
- 实现与设备 UI 边界一致的响应式布局

***

## 3. containerCornerInsets（iOS 26.0+）

```ts
readonly containerCornerInsets: {
  bottomLeading: Size
  bottomTrailing: Size
  topLeading: Size
  topTrailing: Size
} | null
```

该属性仅在 **iOS 26+** 提供，并在设备或容器具有物理圆角偏移时报告每个角落的内边距。

### 用途

- 为圆角窗口、Stage Manager 或分屏环境适配布局
- 在容器圆角内做精确的 UI 对齐

如果平台不支持，则为 `null`。

***

# GeometryReader

```ts
type GeometryReaderProps = {
  children: (proxy: GeometryProxy) => VirtualNode;
};
declare const GeometryReader: FunctionComponent<GeometryReaderProps>;
```

## Props 说明

| 属性名      | 类型                                      | 必须 | 说明                                     |
| -------- | --------------------------------------- | -- | -------------------------------------- |
| children | `(proxy: GeometryProxy) => VirtualNode` | 是  | 构建内容的回调函数，传入 `GeometryProxy` 用于读取布局信息。 |

***

# 工作机制

1. GeometryReader 占据父布局中的位置，并在布局阶段获取当前容器的尺寸与安全区域信息。
2. 将 `GeometryProxy` 注入给 `children(proxy)` 回调。
3. 回调返回的内容将根据读取的信息动态布局。

与 SwiftUI 一样，`GeometryReader` 默认会扩展到可用空间。

***

# 示例：居中布局

```tsx
import { GeometryReader, Text, VStack } from "scripting"

function View() {
  return <GeometryReader>
    {(proxy) => {
      return <VStack
        frame={{
          width: proxy.size.width,
          height: proxy.size.height,
          alignment: "center"
        }}
      >
        <Text>Hello Geometry</Text>
        <Text>
          width: {proxy.size.width}
        </Text>
        <Text>
          height: {proxy.size.height}
        </Text>
      </VStack>
    }}
  </GeometryReader>
}
```

***

# 示例：根据安全区域调整布局

```tsx
<GeometryReader>
  {(proxy) => {
    return <VStack
      padding={{
        top: proxy.safeAreaInsets.top,
        bottom: proxy.safeAreaInsets.bottom
      }}
    >
      <Text>Content inside safe area.</Text>
    </VStack>
  }}
</GeometryReader>
```

***

# 示例（iOS 26+）：读取 containerCornerInsets

```tsx
<GeometryReader>
  {(proxy) => {
    const corners = proxy.containerCornerInsets
    return <Text>
      {corners == null
        ? "Corner insets not available"
        : `Top Leading Corner: ${corners.topLeading.width}, ${corners.topLeading.height}`
      }
    </Text>
  }}
</GeometryReader>
```

***

# 使用建议

- 在需要响应容器尺寸时使用 GeometryReader，例如图片缩放、动态布局、等比布局。
- 避免将大量复杂布局放入 GeometryReader 内，可能影响性能（同 SwiftUI）。



---
url: /zh/guide/Changelog/2.4.3/LiveActivity View Modifiers.md
---

Scripting 支持与 SwiftUI 等效的 Live Activity 外观控制修饰符。这些修饰符专门用于 **锁屏（Lock Screen）中的 Live Activity 界面**，用于自定义背景色和系统动作按钮颜色。

通过为 Activity UI 中的 `content` 视图设置这些修饰符，可使 Live Activity 更符合品牌风格或特定活动主题。

***

# 修饰符定义

```ts
/**
 * 用于设置 Live Activity 在锁屏界面显示时的背景着色。
 */
activityBackgroundTint?: Color | {
  light: Color
  dark: Color
}

/**
 * 用于设置 Live Activity 在锁屏界面显示时，系统提供的辅助操作按钮的文本（前景）颜色。
 */
activitySystemActionForegroundColor?: Color | {
  light: Color
  dark: Color
}
```

***

# 属性说明

## 1. activityBackgroundTint

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置 Live Activity 在锁屏界面显示时的背景 Tint。
这个颜色会影响系统渲染 Live Activity 主卡片的底色。

### 使用示例

- 使用品牌主色作为 Activity 背景
- 为不同活动提供独立主题色
- 让内容在亮色或深色背景下更易阅读

***

## 2. activitySystemActionForegroundColor

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置系统在锁屏的 Live Activity 卡片旁显示的“辅助操作按钮”的文本前景色。
这些操作按钮可能包括暂停、继续、停止等。

### 使用示例

- 在深色背景上显示浅色按钮文本
- 将关键操作按钮突出显示
- 使用和 UI 一致的主题色

***

# 示例：在 Live Activity UI Builder 中使用

Live Activity 的 UI builder 必须返回包含多个区域（content / compactLeading / compactTrailing / minimal等）的对象结构。

以下示例展示了如何在 **content** 区域中使用这两个修饰符：

```tsx
function ActivityView() {
  <LiveActivityUI
    content={
      <ContentView
        activityBackgroundTint={"blue"}
        activitySystemActionForegroundColor={"white"}
      />
    }
    compactLeading={...}
    compactTrailing={...}
    minimal={<Image systemName="clock" />}
  >
    <LiveActivityUIExpandedCenter>
      <ContentView />
    </LiveActivityUIExpandedCenter>
  </LiveActivityUI>
}
```

***

# 使用说明

- **修饰符仅在 Live Activity UI 中有效**，并且只影响 **锁屏界面** 的外观。
- 必须在 Live Activity UI builder 的 `content` 中使用。
- 如果不设置颜色，系统会使用默认样式。



---
url: /zh/guide/Changelog/2.4.3/LiveActivity.md
---

`LiveActivity` API 允许你的脚本在 iOS 的锁屏界面以及支持的设备上的动态岛中展示实时数据。通过该 API，你可以创建、更新并结束 Live Activity，同时监听其生命周期状态和系统支持情况。

本文件详细介绍 Scripting app 中的 **LiveActivity API**，包括：

- Live Activity 的生命周期与核心概念
- 如何注册 Live Activity UI
- 如何在脚本中启动、更新、结束 Live Activity
- 如何构建 Live Activity UI（包括 Dynamic Island 多种布局）
- 所有类型参数说明
- 完整示例代码与最佳实践

本 API 基于 Apple ActivityKit 能力，并以 TypeScript/TSX 的方式封装，允许开发者使用 React 风格构建 Lock Screen 与 Dynamic Island 界面。

***

# 1. Live Activity 概念理解

Live Activity 展示在以下区域：

- **锁屏界面**
- **iPhone 14 Pro+ 的 Dynamic Island**
- **其他设备的悬浮样式（Banner）**

它能随着应用或脚本运行实时更新内容，如：

- 计时器
- 外卖进度
- 健身、运动状态
- 倒计时、打卡、提醒

**在 Scripting app 中，一个 Live Activity 由两部分组成：**

1. **内容状态（contentState）**
   一个 JSON 可序列化的对象，会随时间改变。
2. **UI Builder**
   通过 TSX 描述不同区域的展示方式。

***

# 2. Live Activity 状态类型

```ts
type LiveActivityState = "active" | "dismissed" | "ended" | "stale";
```

| 状态        | 描述                              |
| --------- | ------------------------------- |
| active    | 正在显示，可以更新内容                     |
| stale     | 已过期，需要更新 staleDate 后才能恢复 active |
| ended     | 活动已结束但仍在锁屏显示（最长 4 小时或自定时间）      |
| dismissed | 已被系统或用户移除，不再可见                  |

***

# 3. LiveActivityDetail 类型

```ts
type LiveActivityDetail = {
  id: string;
  state: LiveActivityState;
};
```

用于描述当前正在运行的所有 Live Activity 信息。

***

# 4. LiveActivity UI 构建类型

## 4.1 LiveActivityUIProps

```ts
type LiveActivityUIProps = {
  content: VirtualNode;
  compactLeading: VirtualNode;
  compactTrailing: VirtualNode;
  minimal: VirtualNode;
  children: VirtualNode | VirtualNode[];
};
```

这些字段对应 Dynamic Island：

- **content**：锁屏和普通设备顶部 Banner 显示
- **compactLeading / compactTrailing**：Dynamic Island 收缩状态左右区域
- **minimal**：最小化的单点显示
- **children**：展开后的多个区域（使用 `LiveActivityUIExpanded*` 包裹）

***

# 5. 注册 Live Activity UI

Live Activity 必须放在单独的文件中，例如 `live_activity.tsx`：

```tsx
import { LiveActivity, LiveActivityUI, LiveActivityUIBuilder } from "scripting";

export type State = {
  mins: number;
};

function ContentView(state: State) {
  return (
    <HStack activityBackgroundTint={{ light: "clear", dark: "clear" }}>
      <Image systemName="waterbottle" foregroundStyle="systemBlue" />
      <Text>{state.mins}分钟后补水</Text>
    </HStack>
  );
}

const builder: LiveActivityUIBuilder<State> = (state) => {
  return (
    <LiveActivityUI
      content={<ContentView {...state} />}
      compactLeading={
        <HStack>
          <Image systemName="clock" />
          <Text>{state.mins}m</Text>
        </HStack>
      }
      compactTrailing={<Image systemName="waterbottle" foregroundStyle="systemBlue" />}
      minimal={<Image systemName="clock" />}>
      <LiveActivityUIExpandedCenter>
        <ContentView {...state} />
      </LiveActivityUIExpandedCenter>
    </LiveActivityUI>
  );
};

export const MyLiveActivity = LiveActivity.register("MyLiveActivity", builder);
```

***

# 6. 在脚本中使用 Live Activity

下面展示如何启动、更新、监听状态并结束 Live Activity。

```tsx
import {
  Button,
  Text,
  VStack,
  Navigation,
  NavigationStack,
  useMemo,
  useState,
  LiveActivityState,
  BackgroundKeeper,
} from "scripting";
import { MyLiveActivity } from "./live_activity";

function Example() {
  const dismiss = Navigation.useDismiss();
  const [state, setState] = useState<LiveActivityState>();

  const activity = useMemo(() => {
    const instance = MyLiveActivity();

    instance.addUpdateListener((s) => {
      setState(s);
      if (s === "dismissed") {
        BackgroundKeeper.stop();
      }
    });

    return instance;
  }, []);

  return (
    <NavigationStack>
      <VStack
        navigationTitle="LiveActivity 示例"
        navigationBarTitleDisplayMode="inline"
        toolbar={{
          cancellationAction: <Button title="完成" action={dismiss} />,
        }}>
        <Text>当前状态：{state ?? "-"}</Text>

        <Button
          title="启动 Live Activity"
          disabled={state != null}
          action={() => {
            let count = 5;
            BackgroundKeeper.keepAlive();

            activity.start({ mins: count });

            function tick() {
              setTimeout(() => {
                count -= 1;

                if (count === 0) {
                  activity.end({ mins: 0 });
                  BackgroundKeeper.stop();
                } else {
                  activity.update({ mins: count });
                  tick();
                }
              }, 60000);
            }
            tick();
          }}
        />
      </VStack>
    </NavigationStack>
  );
}

async function run() {
  await Navigation.present(<Example />);
  Script.exit();
}

run();
```

***

# 7. LiveActivity 类 API 说明

## 7.1 start(contentState, options?)

```ts
start(contentState: T, options?: LiveActivityOptions): Promise<boolean>
```

- 请求系统启动 Live Activity
- contentState 必须可以 JSON 序列化

### LiveActivityOptions

```ts
type LiveActivityOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
};
```

- staleDate：到期变为 stale 的时间戳（ms） 或 Date 对象
- relevanceScore：控制 Dynamic Island 的优先级

***

## 7.2 update(contentState, options?)

```ts
update(contentState: T, options?: LiveActivityUpdateOptions)
```

### LiveActivityUpdateOptions

```ts
type LiveActivityUpdateOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  alert?: {
    title: string;
    body: string;
  };
};
```

可带 Apple Watch 的更新提示。

***

## 7.3 end(contentState, options?)

```ts
end(contentState: T, options?: LiveActivityEndOptions)
```

### LiveActivityEndOptions

```ts
type LiveActivityEndOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  dismissTimeInterval?: number;
};
```

dismissTimeInterval（单位秒）:

- 未提供：系统默认最长保留 4 小时
- \<= 0：立即移除
- \> 0：指定多久后移除

***

## 7.4 获取活动状态

```ts
getActivityState(): Promise<LiveActivityState | null>
```

***

## 7.5 监听状态更新

```ts
addUpdateListener(listener);
removeUpdateListener(listener);
```

当 Live Activity 状态变更时回调，例如：

- active → stale
- active → ended
- ended → dismissed

***

## 7.6 静态方法

```ts
static areActivitiesEnabled(): Promise<boolean>
static getAllActivities(): Promise<LiveActivityDetail[]>
static getAllActivitiesIds(): Promise<string[]>
static getActivityState(activityId: string)
static from(activityId, name)
static endAllActivities(options?)
```

***

# 8. Live Activity UI 组件

| 组件                             | 描述         |
| ------------------------------ | ---------- |
| LiveActivityUI                 | 注册 UI 的根结构 |
| LiveActivityUIExpandedCenter   | 展开状态的中间区域  |
| LiveActivityUIExpandedLeading  | 左侧区域       |
| LiveActivityUIExpandedTrailing | 右侧区域       |
| LiveActivityUIExpandedBottom   | 底部区域       |

用于构建 Dynamic Island 展开布局。

***

# 9. 注意事项与最佳实践

## 9.1 必须 JSON 可序列化

contentState 中不能包含：

- 函数
- Date 对象（需转 timestamp）
- class 实例
- 非可序列化对象

## 9.2 Live Activity 必须放在独立文件

例如：

```
live_activity.tsx
```

这与系统对 UI 构建的要求有关。

## 9.3 Scripting 的 Live Activity 与脚本生命周期隔离

即使脚本结束，Live Activity 会继续保持。

若你希望脚本保持运行，可使用：

```ts
BackgroundKeeper.keepAlive();
```

***

# 10. 完整示例（简化版）

```tsx
const activity = MyLiveActivity();

await activity.start({ mins: 10 });

await activity.update({ mins: 5 });

await activity.end({ mins: 0 }, { dismissTimeInterval: 0 });
```

# 11. 注意事项

- Live Activity 的启动是异步的，需要等到 `start` 返回 `true` 时才能调用 `update` 和 `end`
- Live Activity 不能访问 Documents 和 iCloud 目录，只能访问 app group 目录，如果你想要访问文件或者渲染图片，必须把文件或图片保存到 `FileManager.appGroupDocumentsDirectory` 目录中。 比如渲染图片，你保存到 `FileManager.appGroupDocumentsDirectory` 中， 再通过 `<Image filePath={Path.join(FileManager.appGroupDocumentsDirectory, 'example.png')} />` 渲染
- Live Activity 可以访问与 App 共享的 Storage 数据



---
url: /zh/guide/Changelog/2.4.3/ReorderableForEach/index.md
---

# 可拖拽的 ForEach (ReorderableForEach)

`ReorderableForEach` 是 Scripting 提供的一个支持 **拖拽排序（Drag to Reorder）** 的高级渲染组件。
它在保持 `ForEach` 使用方式的同时，内置了拖拽手势识别、激活态管理、排序回调等能力，使开发者可以非常低成本地实现 **可拖拽排序的列表或网格布局**。

该组件特别适用于以下场景：

- 拖拽调整排序的卡片布局
- 拖拽调整顺序的网格（`LazyVGrid` / `LazyHGrid`）
- 脚本驱动的可交互功能模块编排界面

***

## 一、组件定义

```ts
type ReorderableForEachProps<T extends {
  id: string
}> = {
  active: Observable<T | null>
  data: T[]
  builder: (item: T, index: number) => VirtualNode
  onMove: (indices: number[], newOffset: number) => void
}

interface ReorderableForEachComponent {
  <T extends {
    id: string
  }>(props: ReorderableForEachProps<T>): VirtualNode
}

declare const ReorderableForEach: ReorderableForEachComponent
```

***

## 二、泛型约束说明

### 必须包含 `id` 字段

`ReorderableForEach` 的泛型参数 `T` 必须满足：

```ts
T extends { id: string }
```

也就是说，每一项数据必须具备：

- 唯一的 `id` 值
- 稳定不变的标识

该 `id` 用于：

- 识别当前被拖拽的元素
- 维持拖拽过程中的元素一致性
- 正确计算排序变更位置

如果 `id` 不唯一或在拖拽过程中发生变化，将导致排序错乱。

***

## 三、Props 参数说明

### 1. `active`

```ts
active: Observable<T | null>
```

用于表示 **当前正在被拖拽的元素状态**。

行为说明：

- 拖拽开始时，当前项会被写入 `active.value`
- 拖拽结束时，`active.value` 会恢复为 `null`
- 你可以利用它实现：

  - 拖拽元素高亮
  - 透明度变化
  - 联动动画
  - 状态辅助 UI

***

### 2. `data`

```ts
data: T[]
```

当前参与排序的数据数组。

重要说明：

- `ReorderableForEach` **不会自动修改该数组**
- 拖拽完成后，必须在 `onMove` 中手动更新该数组顺序
- 推荐与 `useObservable` 配合使用：

```ts
const data = useObservable<T[]>(...)
```

***

### 3. `builder`

```ts
builder: (item: T, index: number) => VirtualNode
```

用于渲染每一项的 UI 视图。

参数说明：

| 参数      | 含义                 |
| ------- | ------------------ |
| `item`  | 当前数据项              |
| `index` | 当前项在 `data` 中的实时索引 |

返回值必须是一个合法的 `VirtualNode`。

注意：

- 这里的 `index` 是拖拽后的实时索引
- 不应在此依赖旧索引逻辑做安全判断

***

### 4. `onMove`

```ts
onMove: (indices: number[], newOffset: number) => void
```

当用户完成一次拖拽排序后触发。

参数含义：

| 参数          | 类型         | 说明              |
| ----------- | ---------- | --------------- |
| `indices`   | `number[]` | 被拖动元素在原数组中的索引集合 |
| `newOffset` | `number`   | 新插入的起始位置        |

你必须在此方法中：

1. 根据 `indices` 取出被移动的元素
2. 从原数据中移除它们
3. 按 `newOffset` 重新插入
4. 使用 `Observable.setValue` 提交新顺序

标准实现如下：

```ts
const onMove = (indices: number[], newOffset: number) => {
  const movingItems = indices.map(index => data.value[index])
  const newValue = data.value.filter((_, index) => !indices.includes(index))
  newValue.splice(newOffset, 0, ...movingItems)
  data.setValue(newValue)
}
```

***

## 四、`contentShape` 的真实作用说明

在你的示例代码中：

```tsx
.contentShape({
  kind: 'dragPreview',
  shape: {
    type: 'rect',
    cornerRadius: 16
  }
})
```

该配置的核心作用是：

> **设置拖拽时的预览形状，使拖拽时显示的形状与非拖拽状态下保持一致（RoundedRectangle）。**

它并不是简单地“开启拖拽”，而是用于：

- 定义拖拽时的命中区域
- 同步拖拽预览的视觉形状
- 避免：

  - 拖拽时出现矩形裁切
  - 与原有圆角样式不一致的问题

如果不配置 `dragPreview` 形状，拖拽时可能会退化为默认矩形预览，破坏一致性。

***

## 五、完整使用流程说明

### 1. 数据模型定义

```ts
type Item = {
  id: string
  color: Color
}
```

***

### 2. 初始化可排序数据源

```ts
const data = useObservable<Item[]>(() => {
  return new Array(30)
    .fill(0)
    .map((_, index) => ({
      id: String(index),
      color: colors[index % colors.length]
    }))
})
```

***

### 3. 声明拖拽激活态

```ts
const active = useObservable<Item | null>(null)
```

***

### 4. 单项拖拽视图（保持拖拽前后外观一致）

```tsx
<VStack
  modifiers={
    modifiers()
      .frame({ height: 80 })
      .frame({ maxWidth: 'infinity' })
      .background(
        <RoundedRectangle
          cornerRadius={16}
          fill={item.color}
        />
      )
      .contentShape({
        kind: 'dragPreview',
        shape: {
          type: 'rect',
          cornerRadius: 16
        }
      })
  }
>
```

***

### 5. 在 `LazyVGrid` 中使用 ReorderableForEach

```tsx
<ReorderableForEach
  active={active}
  data={data.value}
  builder={(item) =>
    <ItemView item={item} />
  }
  onMove={onMove}
/>
```

***

## 六、关于在 `List` 中使用的限制说明

虽然从技术上讲，`ReorderableForEach` 可以放入 `List` 内部使用，但 **整体上并不推荐在 `List` 中使用该组件**，原因如下：

1. `List` 自带：

   - 行分隔线
   - 行高计算
   - 选中态
   - 系统滑动手势
   - 系统编辑模式

2. 这些系统行为会与：

   - 自定义拖拽动画
   - 自定义排序逻辑
   - 拖拽命中区域计算

   产生不可控的冲突。

3. 可能带来的问题包括：

- 拖拽过程中跳动
- 命中区域错位
- 拖拽排序时系统进入编辑态
- 行复用与拖拽状态不同步

因此推荐的使用容器是：

- `ScrollView`
- `LazyVGrid`
- `LazyHGrid`
- 纯自定义布局容器

而不是 `List`。

***

## 七、组件工作机制总结

`ReorderableForEach` 的行为逻辑可以总结为：

1. 依据 `data` 构建可拖拽子节点
2. 依据 `dragPreview contentShape` 确定拖拽命中区域与预览形状
3. 拖拽过程中：

   - 自动维护 `active`
   - 实时计算目标插入位置
4. 拖拽结束后：

   - 通过 `onMove` 将排序结果交给开发者处理
   - 由开发者负责最终数据顺序更新

***

## 八、适用场景

- 功能模块拖拽排序
- 工具栏按钮排序
- 卡片式任务优先级调整
- 桌面组件布局排序
- 视觉网格自由排序



---
url: /zh/guide/Changelog/2.4.3/ReorderableForEach/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, ScrollView, useObservable, LazyVGrid, ReorderableForEach, RoundedRectangle, VStack, Toolbar, ToolbarItem, modifiers, Color } from "scripting"

type Item = {
  id: string
  color: Color
}

const colors: Color[] = [
  'systemRed',
  'systemBlue',
  'systemGreen',
  'systemPink',
  'systemOrange',
  'systemPurple',
]

function ItemView({
  item
}: {
  item: Item
}) {

  return <VStack
    modifiers={
      modifiers()
        .frame({
          height: 80
        })
        .frame({
          maxWidth: 'infinity'
        })
        .background(
          <RoundedRectangle
            cornerRadius={16}
            fill={item.color}
          />
        )
        .contentShape({
          kind: 'dragPreview',
          shape: {
            type: 'rect',
            cornerRadius: 16
          }
        })
    }
  >
    <Text
      foregroundStyle="white"
      font="title"
    >{item.id}</Text>
  </VStack>
}

function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  const data = useObservable<Item[]>(() => {
    return new Array(30)
      .fill(0)
      .map((_, index) => ({
        id: String(index),
        color: colors[index % colors.length]
      }))
  })

  const active = useObservable<Item | null>(null)

  const onMove = (indices: number[], newOffset: number) => {
    const movingItems = indices.map(index => data.value[index])
    const newValue = data.value.filter((_, index) => !indices.includes(index))
    newValue.splice(newOffset, 0, ...movingItems)
    data.setValue(newValue)
  }

  return <NavigationStack>
    <ScrollView
      navigationTitle="ReorderableForEach demo"
      toolbar={
        <Toolbar>
          <ToolbarItem
            placement="topBarLeading"
          >
            <Button
              title="Close"
              action={dismiss}
            />
          </ToolbarItem>
        </Toolbar>
      }
    >
      <LazyVGrid
        columns={[
          {
            size: {
              type: 'flexible'
            }
          },
          {
            size: {
              type: 'flexible'
            }
          }
        ]}
        padding={{
          horizontal: true
        }}
      >
        <ReorderableForEach
          active={active}
          data={data.value}
          builder={(item) =>
            <ItemView
              item={item}
            />
          }
          onMove={onMove}
        />
      </LazyVGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  // Present view.
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.3/SSH Client.md
---

# SSH 客户端

`SSHClient` 类用于连接远程 SSH 服务器，支持执行命令、打开 TTY/PTY 会话、使用 SFTP 进行文件传输，以及通过跳板主机进行多级 SSH 跳转。该类是建立和管理 SSH 会话的核心接口。

***

## 静态方法

### `SSHClient.connect(options): Promise<SSHClient>`

建立与远程 SSH 服务器的连接。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    服务器的主机名或 IP 地址。

  - `port?`（数字）：
    连接端口，默认是 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    SSH 身份验证方式，例如密码或私钥。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任服务器公钥列表。如果提供，客户端将验证服务器公钥。

  - `reconnect?`（`"never" | "once" | "always"`）：
    可选的重连策略，默认是 `"never"`。

#### 返回值：

- 成功连接时返回 `Promise<SSHClient>` 实例。

#### 示例：

```ts
const ssh = await SSHClient.connect({
  host: "192.168.0.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("root", "password")
})
```

***

## 属性

### `onDisconnect: (() => void) | null`

SSH 连接断开时触发的回调函数。

#### 示例：

```ts
ssh.onDisconnect = () => {
  console.log("SSH 已断开")
}
```

***

## 实例方法

### `executeCommand(command: string, options?): Promise<string>`

在远程服务器上执行命令，并返回结果字符串。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `options?`（对象）：

  - `maxResponseSize?`（数字）：
    最大响应字节数。

  - `includeStderr?`（布尔）：
    是否包含标准错误输出，默认为 `false`。

  - `inShell?`（布尔）：
    是否在 shell 中执行命令（如 `sh -c`），默认是 `false`。

#### 返回值：

- 返回一个 `Promise<string>`，为命令的输出。

#### 示例：

```ts
const result = await ssh.executeCommand("uname -a")
```

***

### `executeCommandStream(command, onOutput, options?): Promise<void>`

以流的形式逐行执行命令并获取输出。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `onOutput`（函数）：
  每一行输出都会调用该回调函数 `(data: Data, isStderr: boolean) => boolean`。返回 `false` 可提前终止输出接收。

- `options?`（对象）：

  - `inShell?`（布尔）：
    是否在 shell 中执行。

#### 返回值：

- 返回一个 `Promise`，命令执行完毕后 resolve。

#### 示例：

```ts
const output = Data.fromIntArray([])
await ssh.executeCommandStream("ping -c 4 google.com", (data, isStderr) => {
  output.append(data)
  return true
})
console.log(output.toDecodedString()())
```

***

### `withPTY(options): Promise<TTYStdinWriter>`

打开一个 PTY（伪终端）会话，支持交互式终端程序（如 `top`、`vim`）。

#### 参数：

- `options`（对象）：

  - `wantReply?`（布尔）：
    是否等待服务器回应，默认 `true`。

  - `term?`（字符串）：
    终端类型，默认是 `"xterm"`。

  - `terminalCharacterWidth?`（数字）：
    字符宽度，默认 `80`。

  - `terminalRowHeight?`（数字）：
    字符行数，默认 `24`。

  - `terminalPixelWidth?`（数字）：
    像素宽度，默认 `0`。

  - `terminalPixelHeight?`（数字）：
    像素高度，默认 `0`。

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>`，可用于写入输入和调整终端大小。

#### 示例：

```ts
let output: Data | undefined
let timerId: number | undefined
const writer = await ssh.withPTY({
  onOutput: (data, isStderr) => {
    if (output == null) {
      output = data
    } else {
      output.append(data)
    }
    clearTimeout(timerId)
    timerId = setTimeout(() => {
      console.log(output.toDecodedString()())
      output = undefined
    }, 500)
    return true
  }
})
await writer.write("top\n")
```

***

### `withTTY(options): Promise<TTYStdinWriter>`

打开一个简化的 TTY 会话（不包含终端尺寸设置）。

#### 参数：

- `options`（对象）：

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>` 实例。

***

### `openSFTP(): Promise<SFTPClient>`

打开一个 SFTP 会话，用于远程文件读写、目录管理等操作。

#### 返回值：

- 一个 `Promise<SFTPClient>` 实例。

#### 示例：

```ts
const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/test.txt", "Hello world")
```

***

### `jump(options): Promise<SSHClient>`

从当前连接跳转（跳板）至另一个远程 SSH 主机。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    目标主机地址。

  - `port?`（数字）：
    端口，默认为 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    跳转主机的身份验证方式。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任主机公钥。

#### 返回值：

- 一个新的 `SSHClient` 实例，表示跳转后的连接。

#### 示例：

```ts
const nextHop = await ssh.jump({
  host: "10.0.0.2",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user2", "pass2")
})
```

***

### `close(): Promise<void>`

关闭 SSH 连接并释放资源。

> **注意：** 当不再需要 SSH 连接时应显式调用该方法，以防资源或 socket 泄漏。

#### 返回值：

- 一个 `Promise`，成功关闭连接时 resolve。

#### 示例：

```ts
await ssh.close()
```

***

## 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "password")
})

const output = await ssh.executeCommand("uptime")
console.log("系统运行时间：", output)

const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/hello.txt", "Hello SSH")

await ssh.close()
```



---
url: /zh/guide/Changelog/2.4.3/ScrollViewReader.md
---

**ScrollViewReader** 组件，用于在脚本中获得对可滚动内容的编程化控制能力，使开发者能够在运行时滚动至任意视图位置，包括列表项、文本节点等。

ScrollViewReader 与 SwiftUI 的行为保持一致：
开发者通过一个回调函数获得一个 `ScrollViewProxy` 实例，并可以在任意时机调用 `scrollTo(id)` 控制滚动视图的位置。

***

# ScrollViewProxy

`ScrollViewProxy` 是提供滚动控制的代理对象，由 `ScrollViewReader` 在渲染期间自动注入。

```ts
interface ScrollViewProxy {
    scrollTo: (id: string | number, anchor?: KeywordPoint | Point) => void;
}
```

## 方法

### scrollTo(id, anchor?)

滚动到某个具有指定 `id` 的元素。
该 `id` 必须在可滚动内容内存在，并通过 `key` 配置。

#### 参数说明

| 参数     | 类型             | 必须       | 说明 |                                         |
| ------ | -------------- | -------- | -- | --------------------------------------- |
| id     | `string`       | `number` | 是  | 要滚动到的目标元素的唯一标识符。通常对应 `<View key="xxx">` |
| anchor | `KeywordPoint` | `Point`  | 否  | 滚动目标在可视区域中的对齐方式。可为字符串关键字或坐标点。           |

### KeywordPoint 类型

属于字符串关键字，常用：

- `'top'`
- `'center'`
- `'bottom'`

### Point 类型

用于精确控制滚动位置：

```ts
type Point = {
  x: number
  y: number
}
```

***

# ScrollViewReader

ScrollViewReader 用于包裹可滚动内容，并提供一个 `scrollViewProxy` 以控制内部滚动。

```ts
type ScrollViewReaderProps = {
    children: (scrollViewProxy: ScrollViewProxy) => VirtualNode
};
declare const ScrollViewReader: FunctionComponent<ScrollViewReaderProps>
```

## Props 说明

| 名称       | 类型                                        | 必须 | 说明                                          |
| -------- | ----------------------------------------- | -- | ------------------------------------------- |
| children | `(proxy: ScrollViewProxy) => VirtualNode` | 是  | 回调函数，将滚动代理传给开发者，并返回 ScrollView、List 等可滚动视图。 |

***

# 使用说明

1. **ScrollViewReader 必须包裹 List、ScrollView 等可滚动组件**。
2. **回调中的 proxy 只在视图构建阶段提供一次**，开发者可利用 `useRef` 保存。
3. 支持在动画中使用，例如 `withAnimation`。
4. 锚点可选，不传则使用默认对齐方式。
5. 所有 ScrollView 内部节点都可以使用 `key` 来作为 `scrollTo` 的目标。

***

# 基础示例

下面是一个完整的使用示例，包括滚动到指定元素以及使用动画的方式。

```tsx
import {
  Button,
  Navigation,
  NavigationStack,
  Script,
  Text,
  List,
  ScrollViewReader,
  ScrollView,
  VStack,
  useRef,
  ScrollViewProxy,
  withAnimation
} from "scripting"

function Item({ index }: { index: number }) {
  return <Text>
    Item - {index}
  </Text>
}

function View() {
  const dismiss = Navigation.useDismiss()
  const proxyRef = useRef<ScrollViewProxy>()

  return <NavigationStack>
    <VStack navigationTitle="ScrollViewReader">

      <ScrollViewReader>
        {(proxy) => {
          // 记录 proxy 实例，供按钮点击时使用
          proxyRef.current = proxy

          return <List>
            {new Array(100).fill(0).map((_, index) =>
              <Item
                key={index}
                index={index}
              />
            )}
            <Text key="bottom">
              Bottom
            </Text>
          </List>
        }}
      </ScrollViewReader>

      <Button
        title="跳转"
        action={() => {
          if (proxyRef.current == null) {
            console.log("no proxy found")
            return
          }

          const index = Math.random() * 100 | 0

          withAnimation(() => {
            proxyRef.current?.scrollTo(index, "bottom")
            // proxyRef.current?.scrollTo("bottom", "bottom")
          })
        }}
      />

    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```

***

# 关于 ID（key）匹配的说明

`scrollTo(id)` 依赖于内部节点的 `key` 属性。
以下配置都可作为滚动目标：

```tsx
<Text key="bottom">Bottom</Text>
```

`key` 与 SwiftUI 的 `.id()` 行为保持一致。

***

# 动画支持

ScrollViewReader 支持结合 `withAnimation` 来进行平滑滚动。例如：

```tsx
withAnimation(() => {
  proxy.scrollTo("target", "center")
})
```

在动画块中触发滚动，将获得平滑过渡。

***

# 注意事项

1. **必须在 ScrollViewReader 回调中记录 proxy**，否则外部无法访问。
2. **必须确保目标元素存在并有唯一 id**，否则无法滚到目标位置。
3. **不支持在 ScrollViewReader 外部渲染可滚动组件**。
4. **滚动行为与 SwiftUI 基本一致**，包括 anchor 对齐方式。



---
url: /zh/guide/Changelog/2.4.3/Set environment values (environments).md
---

`environments` 是 Scripting 新增的视图修饰符，用于向当前视图树（View Hierarchy）注入特定的 environment values。
它的作用与 SwiftUI 的 `.environment()` 类似，但基于 Scripting 的设计进行了显式声明和类型收敛，避免隐式行为。

目前 `environments` 支持以下 environment 值：

- `editMode`: 控制视图的编辑模式（如 List 的编辑状态）
- `openURL`: 自定义打开链接（URL）的处理方式

这些 environment 值会影响其子视图中的行为与交互能力。

***

# 修饰符定义

```ts
environments?: {
  editMode?: Observable<EditMode>;
  openURL?: (url: string) => OpenURLActionResult;
};
```

***

# 一、editMode（编辑模式）

`editMode` 用于设置当前视图树中所有支持编辑模式的组件的编辑状态。

典型用途：

- 控制 `List` 的编辑状态
- 启用批量删除、移动操作
- 与用户交互同步（如切换编辑按钮）

## 类型定义

```ts
class EditMode {
  readonly value: "active" | "inactive" | "transient" | "unknown"
  readonly isEditing: boolean

  static active(): EditMode
  static inactive(): EditMode
  static transient(): EditMode
}
```

### `value` 含义

| 值           | 描述           |
| ----------- | ------------ |
| `active`    | 编辑模式已开启      |
| `inactive`  | 编辑模式已关闭      |
| `transient` | 临时状态（如交互中切换） |
| `unknown`   | 非预期状态，通常不需使用 |

### 与 `Observable` 配合使用

由于 editMode 是动态值，必须使用 `Observable<EditMode>` 传递，以便视图随编辑状态变化而刷新。

***

## editMode 使用示例

```tsx
const editMode = useObservable(() => EditMode.active())

<List
  environments={{
    editMode: editMode
  }}
>
  <ForEach
    editActions="all"
    data={items}
    builder={item => <Text key={item.id}>{item}</Text>}
  />
</List>
```

说明：

- 将 `editMode` 设置到 List 的 environment 中
- List 中的 `ForEach` 会根据该状态启用、禁用删除/移动等编辑能力
- 修改 `editMode.value` 将自动刷新界面

***

# 二、openURL（自定义 URL 打开行为）

`openURL` environment 允许为当前视图树定义一套自定义的 URL 打开逻辑。
这会覆盖如 `<Link>`、`Text(url:)` 等组件的默认行为。

用途示例：

- 控制 URL 在 App 内打开还是系统浏览器打开
- 根据 URL 类型执行不同逻辑
- 拦截 URL 点击并进行验证或跳转处理

## 类型定义

```ts
openURL?: (url: string) => OpenURLActionResult;
```

***

# OpenURLActionResult

自定义 URL 打开逻辑的返回类型。

```ts
class OpenURLActionResult {
  type: string

  static handled(): OpenURLActionResult
  static discarded(): OpenURLActionResult

  static systemAction(options?: {
    url?: string
    prefersInApp: boolean // Requires iOS26.0+
  }): OpenURLActionResult
}
```

## 作用说明

| 返回值                     | 含义                         |
| ----------------------- | -------------------------- |
| `handled()`             | URL 已处理，不执行默认行为            |
| `discarded()`           | 忽略该 URL                    |
| `systemAction(options)` | 要求系统打开给定 URL（支持 App 内或外打开） |

***

## openURL 使用示例

```tsx
<Group
  environments={{
    openURL: (url) => {
      return OpenURLActionResult.systemAction({
        url,
        prefersInApp: false
      })
    }
  }}
>
  {urls.map(url =>
    <Link url={url}>{url}</Link>
  )}
</Group>
```

说明：

- 所有 `<Link>` 均会交给自定义的 `openURL` 方法处理
- 示例将所有 URL 交由系统处理，并要求“非 App 内打开（prefersInApp: false）”

***

# 使用总结

| environment key | 类型                             | 作用范围      | 使用场景         |
| --------------- | ------------------------------ | --------- | ------------ |
| `editMode`      | `Observable<EditMode>`         | 影响所有可编辑组件 | List 编辑、批量操作 |
| `openURL`       | `(url) => OpenURLActionResult` | 所有链接组件    | 自定义 URL 处理逻辑 |

***

# 完整示例：同时使用 editMode 与 openURL

```tsx
const editMode = useObservable(() => EditMode.inactive())

<VStack
  environments={{
    editMode,
    openURL: (url) => {
      if (url.startsWith("https://safe.com")) {
        return OpenURLActionResult.systemAction({ url, prefersInApp: true })
      }
      return OpenURLActionResult.discarded()
    }
  }}
>
  <Button
    title="Toggle Edit"
    action={() => {
      editMode.value = editMode.value.isEditing
        ? EditMode.inactive()
        : EditMode.active()
    }}
  />

  <List>
    ...
  </List>

  <Link url="https://safe.com">Safe Link</Link>
  <Link url="https://blocked.com">Blocked Link</Link>
</VStack>
```

***

# 注意事项

1. `environments` 为局部作用域，仅影响其子视图。
2. `editMode` 必须是 `Observable<EditMode>` 才能触发界面更新。
3. `openURL` 若返回 `handled()`，将阻止默认行为。
4. `systemAction` 中的 `prefersInApp` 会影响是否在 App 内打开链接。
5. 与 SwiftUI 不同，Scripting 的 `environment` 是显式声明，不会隐式传播所有 key。



---
url: /zh/guide/Changelog/2.4.3/Thread.md
---

# 线程（Thread）

Scripting 的 UI 渲染系统以及绝大多数 JavaScript 执行逻辑默认运行在主线程中，因此通常开发者无需主动切换线程。

为了确保 UI 更新安全、避免主线程阻塞，并在必要时执行后台任务，Scripting 提供了全局 `Thread` API。部分系统 API 或运行时逻辑可能会在后台执行，此 API 能帮助你安全地处理复杂场景。

`Thread` 为全局命名空间，无需导入即可使用。

***

## `Thread.isMainThread: boolean`

指示当前 JavaScript 执行环境是否在主线程。

在大多数情况下此值为 `true`，但某些系统回调或内部任务可能会切换到后台线程。在需要进行 UI 更新时，可以通过此属性确认当前线程是否安全。

```ts
if (Thread.isMainThread) {
  console.log('当前在主线程')
} else {
  console.log('当前不在主线程')
}
```

***

## `Thread.runInMain(execute: () => void): void`

在主线程中执行指定的函数。

由于 JavaScript 默认运行在主线程，通常无需手动调用此方法。它主要用于以下情况：

- 某些系统 API 回调在后台线程触发，开发者需要确保 UI 更新在主线程执行
- 希望严格保证某段逻辑在主线程中执行

此方法不会返回值，也不会切回执行前的线程，仅保证同步在主线程执行。

```ts
Thread.runInMain(() => {
  title.value = 'Updated on main thread'
})
```

***

## `Thread.runInBackground<T>(execute: () => T | Promise<T>): Promise<T>`

在后台线程执行指定函数，并以 Promise 形式将结果切回到调用处所在的线程（通常是主线程）。

适用于：

- 计算密集型任务
- 大型数据处理
- 不希望阻塞 UI 的耗时操作

`execute` 可以返回值或 Promise。

```ts
const sum = await Thread.runInBackground(() => {
  let v = 0
  for (let i = 0; i < 5_000_000; i++) v += i
  return v
})

console.log('结果:', sum)
```

异步示例：

```ts
const image = await Thread.runInBackground(async () => {
  const raw = await loadImage()
  return processImage(raw)
})

Thread.runInMain(() => {
  setImage(image)
})
```

***

## 异步 I/O 的自动线程切换行为

Scripting 中 **大量异步 I/O 方法**（包括文件、网络、数据库等）会自动在后台线程执行，无需开发者手动使用 `runInBackground`。

例如：

```ts
const content = await FileManager.readAsString(path)
```

`readAsString` 会自动切换到后台线程执行文件读取操作，然后将结果以 Promise 的方式切回调用时所在的线程（通常是主线程）。
这意味着你可以放心地直接调用异步 API，而无需担心阻塞 UI。

### 只有同步方法会在主线程执行

例如：

```ts
const content = FileManager.readAsStringSync(path)
```

同步方法不会切线程，会在主线程直接执行 I/O 操作。因此：

- 不建议在同步方法中处理大型文件或执行耗时操作
- 如果需要高性能且不阻塞 UI，应使用异步版本（如 readAsString）

***

## 使用建议

- JavaScript 默认在主线程运行，大部分场景不需要调用 `runInMain`
- 异步 I/O（如 FileManager.readAsString）已经自动在后台线程执行
- 仅在执行计算密集型任务或同步 I/O 时需要使用 `runInBackground`
- 如果某些系统 API 回调在后台线程中触发，可使用 `runInMain` 保证 UI 更新安全
- 不应在后台线程中直接访问 UI，应在后台任务完成后再回到主线程处理



---
url: /zh/guide/Changelog/2.4.3/useObservable.md
---

Scripting 提供一套响应式状态系统，由 `Observable<T>` 与 `useObservable<T>` 组成，用于驱动组件渲染、与动画系统协同工作，并与 SwiftUI 的双向绑定能力保持一致（例如 `List(selection:)`、`NavigationStack(path:)` 等未来扩展接口）。

***

# 1. Observable\<T>

`Observable<T>` 是一个可观察的数据容器，当 `.value` 更新时，会触发依赖该值的 UI 自动重新渲染。

## 1.1 类定义

```ts
class Observable<T> {
  constructor(initialValue: T);
  value: T;
  setValue(value: T): void;
  subscribe(callback: (value: T, oldValue: T) => void): void;
  unsubscribe(callback: (value: T, oldValue: T) => void): void;
  dispose(): void;
}
```

***

## 1.2 属性与方法说明

### value

存储当前值。读取 `.value` 不会产生副作用。

### setValue(newValue)

更新值，并触发 UI 重绘：

```ts
observable.setValue(newValue);
```

支持任何类型 `T`（包括对象、数组、字面量、类实例等）。

### subscribe / unsubscribe

用于在组件体系外手动监听值变化。

### dispose

释放监听器和内部资源。
一般无需手动调用，仅在高级场景使用。

***

# 2. useObservable\<T>

`useObservable<T>` 是在组件内部创建本地状态的 Hook。
返回值为 `Observable<T>`，用于驱动 UI 更新。

## 2.1 函数签名

```ts
declare function useObservable<T>(): Observable<T | undefined>;
declare function useObservable<T>(value: T): Observable<T>;
declare function useObservable<T>(initializer: () => T): Observable<T>;
```

***

## 2.2 初始化方式

### 1. 无初始值（value 为 undefined）

```tsx
const data = useObservable<string>();
```

### 2. 直接提供初始值

```tsx
const count = useObservable(0);
```

### 3. 惰性初始化（初次渲染时执行）

```tsx
const user = useObservable(() => createDefaultUser());
```

***

# 3. 在 UI 中使用 Observable

在组件中，只需读取 `.value`：

```tsx
<Text>{name.value}</Text>
```

当 `.setValue` 被调用，组件会自动重新渲染：

```tsx
<Button title="Tap" action={() => name.setValue("Updated")} />
```

无需手动触发更新，行为与 React useState 类似，但带来更 SwiftUI 式的数据绑定体验。

***

# 4. 与动画协同工作

Observable 是动画触发源。
支持以下场景：

## 4.1 显式动画：withAnimation

```tsx
withAnimation(() => {
  size.setValue(size.value + 20);
});
```

任何依赖 `size.value` 的视图都会执行动画。

***

## 4.2 隐式动画：animation 修饰符

视图可通过 animation 属性监听某个值的变化并执行动画。

### 正确写法：

```tsx
animation={{
  animation: Animation.spring({ duration: 0.3 }),
  value: size.value
}}
```

示例：

```tsx
<Rectangle
  frame={{
    width: size.value,
    height: size.value,
  }}
  animation={{
    animation: Animation.easeIn(0.25),
    value: size.value,
  }}
/>
```

***

# 5. 与 SwiftUI Binding 风格的 API 对接（扩展能力）

Observable 将作为未来 Scripting 的标准双向绑定机制，用于支持 SwiftUI 风格的 API，例如：

### 5.1 List(selection:)

```tsx
const selection = useObservable<string | undefined>(undefined)

<List selection={selection}>
  ...
</List>
```

### 5.2 NavigationStack(path:)

```tsx
const path = useObservable<string[]>([])

<NavigationStack path={path}>
  ...
</NavigationStack>
```

这类 API 使用方式与 SwiftUI 一致，开发者无需学习额外的绑定机制。

***

# 6. ForEach：推荐使用 Observable 数据源

为了获得更接近 SwiftUI 的体验，推荐使用：

```tsx
<ForEach data={observableArray} builder={(item, index) => <Text>{item.name}</Text>} />
```

其中：

```ts
T extends { id: string }
```

为什么推荐这种写法：

- 性能更佳
- 插入与删除动画体验更自然

示例：

```tsx
const items = useObservable([
  { id: "1", name: "Apple" },
  { id: "2", name: "Banana" }
])

<ForEach
  data={items}
  editActions="all"
  builder={(item) => <Text>{item.name}</Text>}
/>
```

***

# 7. 综合示例

```tsx
export function Demo() {
  const visible = useObservable(true);
  const size = useObservable(100);

  return (
    <VStack spacing={20}>
      {visible.value && (
        <Rectangle
          frame={{
            width: size.value,
            height: size.value,
          }}
          background="blue"
          animation={{
            animation: Animation.spring({ duration: 0.4, bounce: 0.3 }),
            value: size.value,
          }}
          transition={Transition.opacity()}
        />
      )}

      <Button
        title="Toggle Visible"
        action={() => {
          withAnimation(() => {
            visible.setValue(!visible.value);
          });
        }}
      />

      <Button
        title="Resize"
        action={() => {
          withAnimation(Animation.easeOut(0.25), () => {
            size.setValue(size.value === 100 ? 160 : 100);
          });
        }}
      />
    </VStack>
  );
}
```

***

# 8. 总结

- `Observable<T>` 是 Scripting 中的核心响应式数据结构
- `useObservable` 在组件内创建状态，支持任意类型 T
- 与 UI 自动联动，无需额外刷新逻辑
- 为动画系统提供依赖值，用于属性动画与显式动画
- 为未来的 SwiftUI 风格 API 提供双向绑定能力
- ForEach 推荐使用 `data: Observable<Array<T>>`，获得一致的 SwiftUI 体验



---
url: /zh/guide/Changelog/2.4.4/ConcentricRectangle.md
---

# 同心圆矩形（ConcentricRectangle）

`ConcentricRectangle` 是 iOS 26+ 引入的一种**同心矩形（Concentric Rectangle）形状视图**，用于创建具有“向内递进圆角”特性的矩形结构。
该形状特别适合用于：

- 现代玻璃风格按钮
- 卡片容器背景
- 交互裁剪区域（命中测试形状）
- 玻璃过渡动画遮罩
- 动态层级 UI 结构

在 Scripting 中，`ConcentricRectangle` 既可以作为一个**独立 Shape 视图渲染**，也可以作为：

- `clipShape`
- `background`
- `contentShape`

中的**专用形状类型使用**。

***

## 一、ConcentricRectangle 基本定义

```ts
type ConcentricRectangleProps = ShapeProps & ConcentricRectangleShape

/**
 * A concentric rectangle aligned inside the frame of the view containing it.
 * @available iOS 26+.
 */
declare const ConcentricRectangle: FunctionComponent<ConcentricRectangleProps>
```

### 说明

- `ConcentricRectangle` 是一个标准 `Shape` 组件
- 同时支持：

  - 填充（fill）
  - 描边（stroke）
  - 路径裁剪（trim）
  - 复杂角样式控制（ConcentricRectangleShape）
- 该视图始终在其父视图的 `frame` 内部进行布局与渲染
- 仅支持 iOS 26 及以上系统

***

## 二、角样式系统：EdgeCornerStyle

`ConcentricRectangle` 的核心能力来自其角样式系统 `EdgeCornerStyle`，用于描述单个角的行为方式。

```ts
type EdgeCornerStyle =
  | {
      style: "fixed"
      radius: number
    }
  | {
      style: "concentric"
      minimum: number
    }
  | "concentric"
```

***

### 1. 固定圆角模式（fixed）

```ts
{
  style: "fixed"
  radius: number
}
```

用于创建传统固定半径圆角矩形。

参数说明：

| 参数       | 说明            |
| -------- | ------------- |
| `radius` | 固定圆角半径，单位为 pt |

该模式适合传统静态卡片、按钮等场景。

***

### 2. 同心递进圆角模式（concentric）

```ts
{
  style: "concentric"
  minimum: number
}
```

用于创建随尺寸递进变化的“同心圆角效果”。

参数说明：

| 参数        | 说明                       |
| --------- | ------------------------ |
| `minimum` | 最小内层圆角半径，系统会根据实际尺寸自动向外递进 |

该模式适用于：

- 玻璃按钮
- 动态尺寸卡片
- 层级叠加组件
- 动态动画遮罩

***

### 3. 简写模式

```ts
"concentric"
```

等价于：

```ts
{
  style: "concentric"
  minimum: 系统默认最小值
}
```

适用于无需手动控制最小值的快速使用场景。

***

## 三、ConcentricRectangleShape（角分布规则）

`ConcentricRectangleShape` 用于描述 **每个角是否统一控制，或分别控制**。
该类型支持 7 种结构组合模式。

***

### 1. 全角统一模式（最常用）

```ts
{
  corners: EdgeCornerStyle
  isUniform?: boolean
}
```

参数说明：

| 参数          | 说明                |
| ----------- | ----------------- |
| `corners`   | 应用于全部角的样式         |
| `isUniform` | 是否强制完全一致，默认 false |

示例：

```tsx
<ConcentricRectangle
  corners={{
    style: "concentric",
    minimum: 8
  }}
  fill="red"
/>
```

***

### 2. 四个角完全独立定义

```ts
{
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 不规则异形卡片
- 特殊边角 UI
- 半圆角容器

***

### 3. 底部统一角

```ts
{
  uniformBottomCorners?: EdgeCornerStyle
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 上直角，下圆角卡片
- 底部弹出面板背景

***

### 4. 顶部统一角

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 顶部弹窗
- 顶部玻璃标题栏

***

### 5. 顶部与底部统一组合

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  uniformBottomCorners?: EdgeCornerStyle
}
```

***

### 6. 左侧统一角

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

***

### 7. 左右统一组合

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  uniformTrailingCorners?: EdgeCornerStyle
}
```

***

## 四、通用 Shape 属性（ShapeProps）

```ts
type ShapeProps = {
  trim?: {
    from: number
    to: number
  }

  fill?: ShapeStyle | DynamicShapeStyle

  stroke?: ShapeStyle | DynamicShapeStyle | {
    shapeStyle: ShapeStyle | DynamicShapeStyle
    strokeStyle: StrokeStyle
  }
}
```

***

### 1. trim（路径裁剪）

```ts
trim={{
  from: 0.0,
  to: 0.5
}}
```

用于路径绘制动画、环形裁剪、渐进描边等效果。

***

### 2. fill（填充）

```ts
fill="red"
fill="ultraThinMaterial"
```

支持：

- 纯色
- 动态材质
- 渐变样式

***

### 3. stroke（描边）

```ts
stroke="blue"

stroke={{
  shapeStyle: "blue",
  strokeStyle: {
    lineWidth: 2
  }
}}
```

***

## 五、ConcentricRectangle 在 View Modifiers 中的使用

### 1. 作为 clipShape 使用

```ts
clipShape?: Shape | "concentricRect" | ({
  type: "concentricRect"
} & ConcentricRectangleShape)
```

示例：

```tsx
<VStack
  clipShape={{
    type: "concentricRect",
    corners: {
      style: "concentric",
      minimum: 10
    }
  }}
/>
```

用于：

- 裁剪真实内容显示区域
- 玻璃过渡遮罩
- 动态蒙版

***

### 2. 作为 background 使用

```ts
background?: ShapeStyle | DynamicShapeStyle | {
  style: ShapeStyle | DynamicShapeStyle
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
} | VirtualNode | {
  content: VirtualNode
  alignment: Alignment
}
```

示例：

```tsx
<VStack
  background={{
    style: "ultraThinMaterial",
    shape: {
      type: "concentricRect",
      corners: "concentric"
    }
  }}
/>
```

***

### 3. 作为 contentShape 使用（命中测试区域）

```ts
contentShape?: Shape | {
  kind: ContentShapeKinds
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
}
```

用于控制点击、悬停、拖拽等交互命中区域。

***

## 六、完整示例解析

示例代码：

```tsx
<ZStack
  frame={{
    width: 300,
    height: 200
  }}
  containerShape={{
    type: "rect",
    cornerRadius: 32
  }}
>
  <ConcentricRectangle
    corners={{
      style: "concentric",
      minimum: 8
    }}
    fill="red"
  />
</ZStack>
```

该示例实现了：

- 外部容器为固定圆角矩形
- 内部使用同心递进圆角矩形
- 内外形成层级差异与视觉纵深感
- 红色填充用于强调 ConcentricRectangle 的实际形态

***

## 七、设计与实现注意事项

1. `minimum` 不应超过实际高度或宽度的一半
2. 同心圆角更适合与：

   - `glass`
   - `material`
   - `blur`
   - `opacity`
     等视觉效果配合使用
3. 作为 `contentShape` 使用时，仅影响点击区域，不影响视觉裁剪
4. 作为 `clipShape` 使用时，会真实裁剪子视图渲染内容



---
url: /zh/guide/Changelog/2.4.4/Glass Effect Transition/index.md
---

Liquid Glass 在 iOS 26 引入了更先进的几何匹配与材质过渡能力。
Scripting 完整支持这些特性，并通过 `glassEffectTransition`、`glassEffectID`、`glassEffectUnion`、`GlassEffectContainer` 以及 `NamespaceReader` 组合实现自然、顺滑且结构化的玻璃动画体验。

本文将详细说明：

- 什么是 Glass Effect Transition
- 三种过渡类型
- 为什么需要 glassEffectID 与 namespace
- glassEffectUnion 的作用
- NamespaceReader 的设计目的与机制
- 实际示例解析
- 最佳实践

***

# 1. 概述：什么是 Glass Effect Transition

`glassEffectTransition` 用于指定 Liquid Glass 在视图出现、消失或布局变化期间应如何过渡。

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

Glass Effect Transition 控制三个核心内容：

1. **玻璃材质如何出现 / 消失**
2. **玻璃的几何形状是否会参与动画**
3. **玻璃是否与容器中其他视图的几何形状匹配**

过渡效果只影响“玻璃材质本身”，而不是普通视图的 opacity 或 scale。

***

# 2. 三种过渡类型

## 2.1 identity（无过渡）

```tsx
glassEffectTransition="identity"
```

含义：

- 不应用任何几何或材质动画。
- 内容会直接呈现，不做淡入或几何匹配。

适用于：

- 禁用动画
- 确保界面非常静态
- 开发调试

***

## 2.2 materialize（材质出现动画）

```tsx
glassEffectTransition="materialize"
```

特点：

- 内容会逐渐淡入。
- Liquid Glass 材质会以柔和方式出现和消失。
- 不进行几何匹配，不尝试从其他玻璃形状“过渡”。

适用于：

- 材质出现／消失强调明显
- 不需要几何跟随效果
- 简单切换菜单或按钮

***

## 2.3 matchedGeometry（匹配几何）

```tsx
glassEffectTransition="matchedGeometry"
```

特点：

- 玻璃材质会尝试“继承”同一 namespace 内、相同 ID 的玻璃形状。
- 在视图切换时，从旧形状平滑过渡到新形状。
- 需要使用 `glassEffectID` 指定对应关系。

适用于：

- 复杂菜单切换
- 视图替换（Edit → Home）
- 需要视觉连续性的动画

是 Liquid Glass 最强大也是最常用的模式。

***

# 3. glassEffectID 与 namespace：匹配几何的核心

## 3.1 为什么需要 ID？

几何匹配动画需要知道：

- “旧玻璃”是谁
- “新玻璃”是谁

因此必须给玻璃效果一个身份标识：

```tsx
glassEffectID={{
  id: 1,
  namespace
}}
```

如果两个玻璃视图：

- 位于相同 namespace
- glassEffectID 的 id 相同

系统会认为它们是同一“玻璃实体”的不同状态，允许过渡。

***

## 3.2 为什么必须有 namespace？

SwiftUI 的 matchedGeometry 效果依赖 `@Namespace`，在 Scripting 中我们通过 `NamespaceReader` 暴露给 TSX。

`NamespaceReader` 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ... 在此作用域中所有 glassEffectID 都应使用这个 namespace ...
  )}
</NamespaceReader>
```

原因：

- namespace 用于组织 matchedGeometry 的作用域
- 同一 namespace 内的 ID 才能互相匹配
- 不同 namespace 之间永远不会彼此动画匹配

***

# 4. glassEffectUnion：玻璃材质的联合区域

除了匹配几何形状外，Liquid Glass 还能把多个玻璃区域合并为一个连续材质区域：

```tsx
glassEffectUnion={{
  id: 1,
  namespace
}}
```

效果：

- 相同 union ID 的按钮共享同一个玻璃材质分区
- 多个按钮可看起来像“同一块玻璃切出来的”
- 提升视觉统一性

通常和 matchedGeometry 同时使用。

***

# 5. 示例解析

以下示例展示菜单在两种布局之间切换，并使用动画呈现玻璃过渡：

```tsx
isAlternativeMenu.value
  ? <>
      <Button
        title="Home"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Settings"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
  : <>
      <Button
        title="Edit"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Erase"
        glassEffectID={{id:3, namespace}}
        glassEffectUnion={{id:1,namespace}}
        glassEffectTransition="materialize"
      />
      <Button
        title="Delete"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
```

重点说明：

### 1. 按钮之间共享 Union ID = 1

所有按钮（无论菜单 A 或 B）实际上共享一个玻璃材质“池”。
这样切换时材质背景连续且自然。

### 2. Home / Edit 共享 ID = 1

- 当菜单切换时，Edit → Home 的玻璃材质会自动匹配几何形状，触发 matchedGeometry 动画。

### 3. Delete / Settings 共享 ID = 2

- Delete → Settings 也会使用 matching transition。

### 4. Erase 设置了 materialize

```tsx
glassEffectTransition="materialize"
```

它不会尝试匹配几何，而是用材质淡入淡出的动画。
这可以让某个按钮以不同方式呈现，令人体验变化更明显。

### 5. 整个 HStack 包裹在 GlassEffectContainer

```tsx
<GlassEffectContainer>
  <HStack> ... </HStack>
</GlassEffectContainer>
```

容器提供：

- 匹配几何所需的上下文
- 优化渲染性能
- 让 union 生效

***

# 6. NamespaceReader：Scripting 如何暴露 @Namespace

在 SwiftUI 中：

```swift
@Namespace private var ns
```

只能在 SwiftUI View 中使用，无法直接从 TypeScript 中访问。

因此 Scripting 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ...
  )}
</NamespaceReader>
```

### 作用：

1. 实际内部创建 SwiftUI 的 `@Namespace`
2. 自动管理生命周期
3. 将 namespace 提供给 TS
4. 保证同一 TSX 作用域使用同一个 namespace

等价于：

```tsx
@Namespace var namespace

glassEffectID={{ id: x, namespace }}
```

没有 NamespaceReader，无论 matchedGeometry 还是 union 都无法工作。

***

# 7. 动画触发方式（withAnimation）

玻璃过渡不会自行动画，必须使用动画触发状态切换：

```tsx
withAnimation(() => {
  isAlternativeMenu.setValue(
    !isAlternativeMenu.value
  )
})
```

匹配几何、材质出现动画等会自动附着到这次动画事务中。

***

# 8. 最佳实践

### 1. 所有参与动画的视图必须在同一个 GlassEffectContainer

否则 matchedGeometry 不会生效。

### 2. namespace 必须由同一个 NamespaceReader 提供

**不要跨层级或重复构造 namespace**。

### 3. glassEffectID 必须在两个状态中都出现

否则 SwiftUI 无法关联动画。

### 4. 若要连续的材质外观，应使用 glassEffectUnion

让按键像同一块玻璃切换。

### 5. 除特殊情况外，尽量使用 matchedGeometry

可获得更自然的“流动感”。

***

# 9. 总结

Glass Effect Transition 是 iOS 26 Liquid Glass 系统的核心特性之一，它让玻璃材质在视图切换中具备几何匹配、材质渐变与联合区域动画。

在 Scripting 中：

- `glassEffectTransition` 控制动画类型
- `glassEffectID` + `namespace` 让几何匹配成为可能
- `glassEffectUnion` 提供材质连续感
- `GlassEffectContainer` 管理动画环境
- `NamespaceReader` 使 TSX 能访问 SwiftUI 的 @Namespace



---
url: /zh/guide/Changelog/2.4.4/Glass Effect Transition/index_example.md
---

# 示例

```tsx
import { Button, GlassEffectContainer, HStack, NamespaceReader, Navigation, Script, VStack, useObservable } from "scripting"

function View() {

  const isAlternativeMenu = useObservable(false)

  return <NamespaceReader>{namespace => <VStack
    spacing={50}
    frame={{
      maxWidth: 'infinity',
      maxHeight: 'infinity'
    }}
    background="systemYellow"
  >
    <GlassEffectContainer
    >
      <HStack
        spacing={0}
        font="largeTitle"
        imageScale="large"
        buttonStyle="glass"
        labelStyle="iconOnly"
      >
        {
          isAlternativeMenu.value
            ? <>
              <Button
                title="Home"
                systemImage="house"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Settings"
                systemImage="gear"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>

            : <>
              <Button
                title="Edit"
                systemImage="pencil"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Erase"
                systemImage="eraser"
                action={() => { }}
                glassEffectID={{
                  id: 3,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
                glassEffectTransition="materialize"
              />
              <Button
                title="Delete"
                systemImage="trash"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>
        }
      </HStack>
    </GlassEffectContainer>

    <Button
      title="Toggle"
      buttonStyle="bordered"
      action={() => {
        withAnimation(() => {
          isAlternativeMenu.setValue(
            !isAlternativeMenu.value
          )
        })
      }}
    />
  </VStack>
  }</NamespaceReader>
}

async function run() {
  await Navigation.present(<View />)

  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.4/Intent.continueInForeground.md
---

`Intent.continueInForeground` 用于在脚本从 Shortcuts 中后台执行时，**请求系统将流程转移到 Scripting App 的前台继续运行**。
此过程需要用户明确确认。

适用场景包括：

- 需要展示完整 UI（如表单、列表、导航页面）
- 需要用户在 App 内进行交互操作
- 后续步骤无法在后台执行

调用此方法后，系统会弹出确认对话框：

- 用户 **允许** → Scripting App 打开到前台，脚本继续执行
- 用户 **取消** → 当前脚本立即终止
- 此行为完全由系统管理，开发者无需手动处理跳转流程

由于该能力基于 iOS 26 引入的 AppIntents 行为：

**该 API 只能在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function continueInForeground(
  dialog?: Dialog | null,
  options?: {
    alwaysConfirm?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## dialog?: Dialog | null

用于提示用户为什么需要切换到前台继续执行。

`Dialog` 的类型格式支持三种形式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否前往应用继续执行？";
```

或带辅助说明：

```ts
{
  full: "需要在应用中继续执行下一步操作",
  supporting: "接下来的步骤需要完整的 UI 交互。",
  systemImageName: "app"
}
```

若传入 `null`，系统可能不显示提示，仅直接触发系统确认（不推荐）。

***

## `options?: { alwaysConfirm?: boolean }`

用于控制系统是否每次都显示确认提示。

- `alwaysConfirm: false`（默认）
  系统一般会根据上下文自动判断是否需要确认。

- `alwaysConfirm: true`
  每次调用都会提示用户明确确认。

示例：

```ts
{
  alwaysConfirm: true;
}
```

***

# 执行流程

执行 `await Intent.continueInForeground(...)` 时：

1. 快捷指令执行暂停

2. 系统弹出确认对话框

3. 用户选择：

   - **确认** → 打开 Scripting App → 脚本继续
   - **取消** → 脚本立即终止

4. 后续脚本在 Scripting App 前台环境中继续执行

**注意：脚本不会在后台继续运行，必须等待用户操作。**

***

# 典型应用场景

推荐在以下场景调用：

- 需要展示完整的导航界面或交互表单（如示例中的 TextField）
- 需要使用 `Navigation.present` 呈现 UI
- 需要 App 内操作如：

  - 预览文件
  - 编辑长文本
  - 选择复杂数据
  - 多步骤流程

不推荐在以下情况使用：

- 单纯的数据处理，不需要 UI
- 简单操作已经可通过 SnippetIntent 完成

***

# 完整示例代码

以下示例展示如何从 Shortcuts 通过 `continueInForeground` 切换到 Scripting App 前台，然后展示 UI 让用户输入文本，输入结束后再返回 Shortcuts。

```tsx
// intent.tsx
import {
  Button,
  Intent,
  List,
  Navigation,
  NavigationStack,
  Script,
  Section,
  TextField,
  useState,
} from "scripting";

function View() {
  const dismiss = Navigation.useDismiss();
  const [text, setText] = useState("");

  return (
    <NavigationStack>
      <List navigationTitle="Intent Demo">
        <TextField title="Enter a text" value={text} onChanged={setText} />

        <Section>
          <Button
            title="Return Text"
            action={() => {
              dismiss(text);
            }}
            disabled={!/\S+/.test(text)}
          />
        </Section>
      </List>
    </NavigationStack>
  );
}

async function runIntent() {
  // 请求系统将执行流程切换到 Scripting App 前台
  await Intent.continueInForeground("Do you want to open the app and continue?");

  // 在前台呈现交互式 UI，用户填写文本
  const text = await Navigation.present<string | null>(<View />);

  // 可选：返回到快捷指令界面
  Safari.openURL("shortcuts://");

  // 返回结果给 Shortcuts
  Script.exit(Intent.text(text ?? "No text return"));
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**，否则会抛出异常或行为不可用。
- 若脚本依赖用户输入、复杂 UI 或操作，请使用该 API 触发前台模式。
- 对话内容应清晰说明需要用户切换前台的原因，提升用户信任度。
- 若用户拒绝，脚本将终止，开发者无需自行处理取消逻辑。
- 可以与 SnippetIntent 结合，构建完整的后台 UI + 前台 UI 混合流程。



---
url: /zh/guide/Changelog/2.4.4/Intent.requestConfirmation.md
---

`Intent.requestConfirmation` 用于在脚本执行过程中，**向用户请求确认某项操作**。
调用后，系统会暂停脚本执行，并展示一个基于 **SnippetIntent 的 UI** 作为确认界面，同时可显示提示对话内容。

确认流程行为：

- 用户 **确认** → Promise resolve，脚本继续执行
- 用户 **取消** → 当前脚本终止执行
- 确认界面通过传入的 **SnippetIntent** 的 UI 定义
- 系统自动管理此流程，无需开发者处理 UI 呈现逻辑

**该 API 仅可在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function requestConfirmation(
  actionName: ConfirmationActionName,
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## actionName: ConfirmationActionName

用于告诉系统“要确认的行为语义是什么”，系统会根据该值生成自然语言文案。例如：

- `"set"` → “确定要设置…？”
- `"buy"` → “确定要购买…？”
- `"toggle"` → “是否切换…？”

可选值如下（与苹果 AppIntents 框架一致）：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" |
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

选择合适的语义有助于提高确认界面的自然体验。

***

## snippetIntent: SnippetIntent

必须是一个 **注册为 SnippetIntent 类型的 AppIntent**：

```ts
AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>;
```

用户在确认界面中看到的内容就是该 SnippetIntent 的 `perform()` 返回的 UI，例如选项列表、内容预览等。

***

## `options?: { dialog?: Dialog; showDialogAsPrompt?: boolean }`

### dialog?: Dialog

用于在确认 UI 上方或系统对话框中显示提示文本。
支持四种格式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否继续？";
```

更复杂的：

```ts
{
  full: "确定要设置此颜色吗？",
  supporting: "此操作将更新应用的主题颜色。",
  systemImageName: "paintpalette"
}
```

用途：

- 解释确认动作含义
- 提醒用户可能产生的影响
- 提供更友好的交互上下文

***

### showDialogAsPrompt?: boolean

默认值：`true`
决定系统是否以「提示弹窗」方式显示对话文本。

设为 `false` 时，文本可能以更沉浸的方式显示在 Snippet 卡片内部。

***

# 执行流程

调用 `await Intent.requestConfirmation(...)` 时脚本执行顺序如下：

1. 脚本暂停执行

2. 系统展示确认界面（SnippetIntent UI + 可选 dialog 文案）

3. 用户进行交互：

   - **确认** → Promise resolve，脚本继续
   - **取消** → 脚本终止执行

4. 不需要开发者手动关闭 UI

此流程完全由系统管理。

***

# 使用场景

以下场景推荐使用 `requestConfirmation`：

- 修改重要设置（如主题颜色、隐私设置）
- 对数据执行有副作用的操作（如删除、更新、重置）
- 流程中一步需用户明确授权
- 启动某个需要用户选择的 UI 子流程（如颜色选择器、账号切换器）

不适用场景：

- 简单数据处理，不需要用户确认
- 可以在后台无 UI 完成的操作

***

# 完整示例代码

以下示例展示如何使用 `requestConfirmation` 请求用户确认一次颜色选择，并在确认后继续执行脚本。

假设你已有两个 SnippetIntent：

- `PickColorIntent`：颜色选择 UI
- `ShowResultIntent`：结果展示 UI

## intent.tsx 示例

```tsx
import { Intent, Script } from "scripting";
import { PickColorIntent, ShowResultIntent } from "./app_intents";

async function runIntent() {
  // 第一步：请求用户确认颜色选择
  await Intent.requestConfirmation("set", PickColorIntent(), {
    dialog: {
      full: "确定要设置此颜色吗？",
      supporting: "此操作将更新应用的主题颜色。",
      systemImageName: "paintpalette",
    },
  });

  // 第二步：读取来自 Shortcuts 的输入（如果有）
  const text =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts";

  // 第三步：呈现最终 SnippetIntent
  const snippet = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: text }),
  });

  Script.exit(snippet);
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**
  提前检查系统版本或优雅降级。

- **总是提供清晰的 dialog 文案**
  确认行为应让用户理解，不应仅依赖 Snippet UI 本身。

- **用于重要或可逆性较差的操作**
  如修改设置、启动后台任务、提交数据等。

- **与 SnippetIntent 配合使用效果最佳**
  因为确认 UI 直接展示 SnippetIntent 的视图。

- **用户取消时脚本会被系统直接终止**
  不要在后续代码中假设脚本一定会继续执行。



---
url: /zh/guide/Changelog/2.4.4/IntentMemoryStorage.md
---

IntentMemoryStorage 是一个用于 **在多个 AppIntent 执行之间保留临时数据** 的内存存储系统。然而，它的生命周期并不严格绑定在单次 AppIntent 或 Script.exit 以上，而是由系统对 Extension 环境（Intent Extension / Widget Extension）的运行状态决定，因此具有一定的非确定性。

以下文档基于你之前确认的完整版结构，并加入系统行为的解释。

***

# 概述

在 Scripting 中，每个 AppIntent 都运行在其所属脚本的 **脚本执行上下文（Script Execution Context）** 中。当 AppIntent 的 `perform()` 执行完成，或在 `intent.tsx` 中调用 `Script.exit()` 时，当前 AppIntent 的执行流程会结束。

但关键点是：

**IntentMemoryStorage 不会在 AppIntent 或 Script.exit 结束时被立即销毁**

它的生命周期依赖于：

- 系统是否继续保留当前 Extension 进程
- 系统是否因为内存压力或其他策略回收 Extension
- Widget 或 Live Activity 是否仍在使用同一 Extension

因此：

- 在 Shortcuts 再次运行同一个脚本时
  **有可能读取到上次设置的 MemoryStorage 值**
- 在 Widget 或 Live Activity 中调用 AppIntent
  **同一个脚本的 JS Context 可能被重用，因此 MemoryStorage 也会保留**
- 系统何时清除 MemoryStorage **不可预测**

MemoryStorage 的本质是：

**存储在当前 Extension 进程中的短期内存，非持久化、非可靠、非严格会话级**

***

# 作用范围（Scopes）

IntentMemoryStorage 提供两类存储区域：

## 1. 脚本级（Script-scoped）存储

默认行为。

- 属于单个脚本项目
- 脚本 A 不能访问脚本 B 的脚本级存储
- Extension 不被系统销毁时，会保留该脚本的存储
- Extension 一旦被销毁，存储也随之清空

适用于该脚本内部多步骤流程。

***

## 2. 共享（Shared）存储

使用 `{ shared: true }` 可访问一个共享区域：

- 所有脚本的 AppIntent 都可访问
- 在 Extension 未被系统释放前可以持续存在
- Extension 被销毁后清空

适合在多个脚本之间协调状态。

***

# Extension 生命周期与 JS Context 行为

## 情况一：在 Shortcuts 中运行 Intent

- Shortcuts 执行完成后：

  - 当前 JS Context 会被销毁
  - 当前 AppIntent 执行结束
- 但：**IntentMemoryStorage 不一定被销毁**
  因为系统未必会立即销毁 Intent Extension

因此：

### 再次运行同一个脚本时，可能读到上次的数据。

例：

```ts
IntentMemoryStorage.set("color", "red")
```

下一次 Shortcut 再运行时：

```ts
const c = IntentMemoryStorage.get("color")
```

可能仍然得到 `"red"`。

这是系统层面的行为，并非 Scripting 的行为。

***

## 情况二：在小组件（Widget/Control Widget）中调用 AppIntent

Widget Extension 的特点：

- Scripting 会尽量复用 JS Context
- 即使 AppIntent 执行结束，JS Context 也可能继续存在
- 因此 MemoryStorage 也可能持续存在

但：

### 系统随时可能回收 Extension（尤其在内存压力下），JS Context 和 MemoryStorage 都会被清空。

***

## 情况三：Live Activity 调用 AppIntent

Live Activity Extension 也可能复用上下文：

- 多次调用 AppIntent 通常复用同一 JS Context
- MemoryStorage 可能继续保留
- 但系统没有保证稳定性
- 扩展环境被杀死后 MemoryStorage 立即失效

***

## 总结生命周期（非常关键）

| 行为                         | 是否导致 MemoryStorage 清空 |
| -------------------------- | --------------------- |
| AppIntent 执行结束             | 否                     |
| Script.exit()              | 否                     |
| Shortcut 流程结束              | 不一定                   |
| Widget 更新 AppIntent        | 不一定                   |
| Live Activity 调用 AppIntent | 不一定                   |
| 系统回收 Extension 进程          | 是（彻底清空）               |

MemoryStorage 的生命周期与 **Extension 进程生命周期** 完全一致，而 Extension 何时被系统保留/销毁是不可预测的系统行为。

***

# API 定义

```ts
namespace IntentMemoryStorage {
  function get<T>(key: string, options?: { shared?: boolean }): T | null
  function set(key: string, value: any, options?: { shared?: boolean }): void
  function remove(key: string, options?: { shared?: boolean }): void
  function contains(key: string, options?: { shared?: boolean }): boolean
  function clear(): void
  function keys(): string[]
}
```

说明：

- `shared` 仅作用于 get / set / remove / contains
- clear() 和 keys() 始终只针对脚本级存储区域

***

# API 详细说明

## get

```ts
function get<T>(key: string, options?: { shared?: boolean }): T | null
```

读取键值。注意：

- 若 Extension 尚未被销毁，则可能读到上一次执行留下的值
- 若系统已清理 Extension，则可能返回 null

脚本级：

```ts
const color = IntentMemoryStorage.get<string>("color")
```

shared：

```ts
const token = IntentMemoryStorage.get<string>("token", { shared: true })
```

***

## set

```ts
function set(key: string, value: any, options?: { shared?: boolean }): void
```

写入存储区域。

脚本级：

```ts
IntentMemoryStorage.set("color", "systemBlue")
```

shared：

```ts
IntentMemoryStorage.set("sessionID", "abc123", { shared: true })
```

***

## remove

```ts
function remove(key: string, options?: { shared?: boolean }): void
```

删除键值。

脚本级：

```ts
IntentMemoryStorage.remove("color")
```

shared：

```ts
IntentMemoryStorage.remove("sessionID", { shared: true })
```

***

## contains

```ts
function contains(key: string, options?: { shared?: boolean }): boolean
```

检查键是否存在。
注意：此结果取决于当前 Extension 是否仍在。

***

## clear

```ts
function clear(): void
```

清空脚本级存储。
shared 区域不会被清空。

***

## keys

```ts
function keys(): string[]
```

返回脚本级存储的 key 列表。

***

# 使用场景

## 脚本级（默认）

适用于：

- 单脚本的多步骤流程
- 融合 SnippetIntent → AppIntent → SnippetIntent
- 临时保存当前 UI 状态、表单数据、步骤编号

示例：

```ts
IntentMemoryStorage.set("step", 2)
```

***

## shared（跨脚本）

适用于：

- 多脚本协同
- 工作流中跨多个项目传递会话状态
- 保存当前 Shortcut 全局状态

示例：

```ts
IntentMemoryStorage.set("workflowID", "xyz", { shared: true })
```

***

# 不适用用途

- 不保证一定存在
- 不保证一定被清理
- 不适合存储大对象
- 不适合存储持久数据
- 不适合跨天或长期使用（可能在任何时间丢失）

推荐持久方案：

- `Storage`
- `FileManager`

***

# 示例

## 脚本级示例

```ts
IntentMemoryStorage.set("color", "red")

const color = IntentMemoryStorage.get<string>("color")
```

***

## shared 跨脚本示例

Script A：

```ts
IntentMemoryStorage.set("sessionID", "12345", { shared: true })
```

Script B：

```ts
const id = IntentMemoryStorage.get<string>("sessionID", { shared: true })
```

***

# 存储结构示例

脚本级：

```json
{
  "color": "green",
  "step": 2
}
```

shared：

```json
{
  "token": "xyz"
}
```

***

# 最佳实践

- 不保证 MemoryStorage 一定存在或一定被清理
- 不要用于关键数据
- 不要用于大数据存储
- 对 shared 使用清晰命名，例如：

  - `"global.sessionID"`
  - `"workflow.status"`
- 在依赖该存储前考虑数据可能不存在



---
url: /zh/guide/Changelog/2.4.4/Liquid Glass Effect/index.md
---

**GlassEffect、GlassEffectContainer、UIGlass** 等相关 API 基于 SwiftUI 新引入的 Liquid Glass 技术，让开发者能够在脚本中以 TSX 方式使用流体化、动态的玻璃材质效果，并支持过渡动画、匹配几何、联合玻璃区域等高级特性。

***

## 1. Liquid Glass 概述

Liquid Glass 是 iOS 26 新增的视觉效果系统，用于创建带有流动质感、半透明材质与动态边界的玻璃效果。与早期的 `blur` 或 `material` 不同，Liquid Glass 提供了：

- 动态玻璃形状（使用 Shape）
- 基于几何匹配的过渡动画
- 可交互的玻璃（interactive）
- 可指定 tint 色彩的玻璃材质
- 可组合多个视图的玻璃“联合”

***

# 2. GlassEffect 基础用法

所有支持玻璃效果的视图，都可以通过 `glassEffect` 修饰符添加 Liquid Glass 材质。

### 属性定义

```ts
type GlassProps = {
  glassEffect?: boolean | UIGlass | Shape | {
      glass: UIGlass
      shape: Shape
  }

  glassEffectTransition?: GlassEffectTransition

  glassEffectID?: {
      id: string | number
      namespace: NamespaceID
  }

  glassEffectUnion?: {
      id: string | number
      namespace: NamespaceID
  }
}
```

***

## 2.1 `glassEffect`

glassEffect 有四种主要使用方式：

### 方式一：启用默认玻璃材质

```tsx
<Text glassEffect>Foo</Text>
```

使用系统默认的 Liquid Glass 材质（相当于 `UIGlass.regular()`）。

***

### 方式二：使用指定的 UIGlass

```tsx
<Text glassEffect={UIGlass.regular().interactive(false)}>Foo</Text>
```

可以链式配置 tint、interactive 等属性。

***

### 方式三：设置玻璃的形状（Shape）

```tsx
<Text glassEffect={{ glass: UIGlass.regular(), shape: { type: 'rect', cornerRadius: 10 } }}>
  Foo
</Text>
```

或直接传入 Shape：

```tsx
<Text
  glassEffect={{
    type: 'rect',
    cornerRadius: 10
  }}
>
  Foo
</Text>
```

表示该视图的玻璃材质会严格限定在指定几何图形内。

***

### 方式四：Boolean 短写

```tsx
<View glassEffect />
```

等同于默认 UIGlass.regular()。

***

# 3. UIGlass 类

`UIGlass` 用于描述玻璃材质本身，可以选用内置材质或链式组合属性。

### 可用静态方法

| 方法                   | 描述                        |
| -------------------- | ------------------------- |
| `UIGlass.clear()`    | 完全透明的玻璃材质，用于融合或叠加效果。      |
| `UIGlass.regular()`  | 默认的 Liquid Glass 材质。      |
| `UIGlass.identity()` | 身份材质，不会改变内容外观，相当于不应用玻璃效果。 |

### 链式配置方法

```ts
interactive(value?: boolean): UIGlass
tint(color: Color): UIGlass
```

示例：

```tsx
glassEffect={UIGlass.regular().interactive().tint("red")}
```

***

# 4. GlassEffectTransition（玻璃过渡动画）

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

### 三种模式说明

| transition          | 描述                                 |
| ------------------- | ---------------------------------- |
| `'identity'`        | 不应用任何几何或材质的动画变化。                   |
| `'materialize'`     | 内容渐入，同时玻璃材质出现或消失，但不尝试匹配几何形状。       |
| `'matchedGeometry'` | 根据容器内其他玻璃形状的几何信息匹配过渡动画，具备更自然的动画效果。 |

### 使用方式

```tsx
<Text 
  glassEffect
  glassEffectTransition="materialize"
>
  Foo
</Text>
```

matchedGeometry 通常需要配合 `glassEffectID` 或 `glassEffectUnion` 使用。

***

# 5. glassEffectID 与 glassEffectUnion

Liquid Glass 支持“识别”不同视图间的玻璃效果，用于 matched geometry 动画或合并多块玻璃区域。

***

## 5.1 glassEffectID

为玻璃效果赋予唯一的 ID，用于 matchedGeometry 动画。

```tsx
<Text
  glassEffect
  glassEffectID={{ id: "avatar", namespace }}
>
  Foo
</Text>
```

多个视图使用相同 ID + namespace 时，系统会尝试匹配形状，从而产生流体几何动画效果。

***

## 5.2 glassEffectUnion

用于将多个玻璃效果统一为一个更大区域。

```tsx
<Text
  glassEffect
  glassEffectUnion={{ id: 1, namespace }}
/>
```

多个视图的玻璃材质将被合并，形成更一致的视觉区域。

***

# 6. GlassEffectContainer

`GlassEffectContainer` 是用于组织和管理玻璃效果的容器。容器内部的所有 glassEffect 视图，都能参与几何匹配、联合效果和过渡动画。

### 示例

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image glassEffect systemName="1.circle" />
    <Image glassEffect systemName="2.circle" />
  </HStack>
</GlassEffectContainer>
```

在容器中：

- matchedGeometry 正常工作
- glassEffectUnion 可以跨子视图生效
- glassEffectID 的动画效果可互相关联

GlassEffectContainer 不需要额外参数，但提供了玻璃效果组织空间。

***

# 7. 按钮的玻璃样式 buttonStyle

Scripting 在 iOS 26 提供新增按钮样式：

- `"glass"`
- `"glassProminent"`

示例：

```tsx
<Button title="Glass" action={...} buttonStyle="glass" />
<Button title="Glass Prominent" action={...} buttonStyle="glassProminent" />

<Button
  title="Glass & Tint"
  buttonStyle="glass"
  tint="red"
/>
```

这些按钮会自动使用 Liquid Glass 材质，并适配 tint、press 动效。

***

# 8. 实战示例说明

以下示例展示完整的用法，包括：

- 背景图片
- Glass 按钮
- GlassEffectContainer
- 使用 UIGlass 自定义玻璃
- 使用指定形状的玻璃

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image
      systemName="1.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: 30, y: 0 }}
    />
    <Image
      systemName="2.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: -30, y: 0 }}
    />
  </HStack>
</GlassEffectContainer>
```

***

# 9. 使用建议与最佳实践

### 1. 大量玻璃视图应包裹在同一个 GlassEffectContainer

可提高动画一致性与性能。

### 2. 使用 matchedGeometry 时务必提供 glassEffectID

否则无法产生几何跟随动画。

### 3. 复杂的玻璃区域可使用 glassEffectUnion 合并

让多个子视图形成连续材质。

### 4. 为了避免过度渲染，玻璃不应嵌套太深

可以多用 ZStack 管理效果。

### 5. UIGlass.identity 非常适合“禁用玻璃但保持结构”

它允许你保留现有布局但不实际渲染材质。



---
url: /zh/guide/Changelog/2.4.4/Liquid Glass Effect/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, VStack, ZStack, Image, Path, GlassEffectContainer, HStack } from "scripting"

function View({
  image
}: {
  image: UIImage
}) {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle="GlassEffect DEMO"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <ZStack>
        <Image
          image={image}
          resizable
          scaleToFill
        />
        <VStack>
          <HStack>
            <Button
              title="Glass"
              action={() => { }}
              buttonStyle="glass"
            />
            <Button
              title="Glass & Tint"
              action={() => { }}
              buttonStyle="glass"
              tint="red"
            />
          </HStack>
          <HStack>
            <Button
              title="Glass Prominent"
              action={() => { }}
              buttonStyle="glassProminent"
            />
            <Button
              title="Glass Prominent & Tint"
              action={() => { }}
              buttonStyle="glassProminent"
              tint="red"
            />
          </HStack>
          <GlassEffectContainer>
            <HStack spacing={40}>
              <Image
                systemName="1.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: 30, y: 0 }}
              />
              <Image
                systemName="2.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: -30, y: 0 }}
              />
            </HStack>
          </GlassEffectContainer>
          <HStack spacing={12}>
            <Text
              padding
              glassEffect
            >Foo</Text>
            <Text
              padding
              glassEffect={{
                type: 'rect',
                cornerRadius: 10
              }}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().interactive()}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().tint("red")}
              foregroundStyle="white"
            >Foo</Text>
          </HStack>
        </VStack>
      </ZStack>
    </VStack>
  </NavigationStack>
}

async function run() {
  try {
    const image = (await Photos.pickPhotos(1))?.at(0)
    if (!image) {
      throw new Error("You must pick an image as the background.")
    }
    // Present view.
    await Navigation.present({
      element: <View
        image={image}
      />
    })
  } catch (e) {
    console.present()
    console.error(e)
  }

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.4/NamespaceReader.md
---

# 命名空间读取器（NamespaceReader）

`NamespaceReader` 用于 **创建并管理一个几何动画命名空间（Namespace）**。
该命名空间是实现以下能力的**前提条件**：

- `matchedGeometryEffect`（组件级几何联动动画）
- `matchedTransitionSource`（页面级导航转场动画）
- `navigationTransition`（如 zoom 转场）

可以将 `NamespaceReader` 理解为：

> 一个“动画坐标系提供者”，用于告诉系统：哪些视图属于**同一组几何动画作用域**。

***

## 一、API 角色说明

`NamespaceReader` 并不是一个普通的 UI 组件，而是一个 **命名空间生成器**，用于：

- 创建一个全新的 `NamespaceID`
- 通过 render function 方式暴露给子视图使用
- 作为几何匹配动画系统的“分组边界”

它在 Scripting 中对应 SwiftUI 的：

- `@Namespace`
- `Namespace.ID`

***

## 二、基本使用方式

### 1. 最小用法结构

```tsx
<NamespaceReader>
  {namespace => (
    // 在这个作用域内
    // 使用 namespace 绑定 matchedGeometryEffect 或 matchedTransitionSource
  )}
</NamespaceReader>
```

说明：

- `NamespaceReader` 是一个 **函数式子节点组件**
- 其子节点必须是一个函数
- 该函数的参数 `namespace` 即为当前创建的命名空间实例

***

## 三、Namespace 的本质作用

### 1. 命名空间的真正含义

`namespace` 的本质作用是：

- 把一组“逻辑上可能互相关联的视图”
- 显式地声明为：

  > “它们允许进行几何匹配动画”

如果没有相同的 `namespace`：

- 即使两个视图的 `id` 完全一致
- 依然 **不会产生任何几何动画**

***

### 2. Namespace 的隔离能力

| 情况                       | 是否发生几何匹配 |
| ------------------------ | -------- |
| 相同 `id` + 相同 `namespace` | 会        |
| 相同 `id` + 不同 `namespace` | 不会       |
| 不同 `id` + 相同 `namespace` | 不会       |
| 不同 `id` + 不同 `namespace` | 不会       |

结论：

> **必须同时满足 `id` 与 `namespace` 完全一致，系统才会建立几何匹配关系。**

***

## 四、NamespaceReader 与几何动画系统的关系

### 1. 与 matchedGeometryEffect 的关系

- `matchedGeometryEffect` 依赖 `namespace` 建立“跨视图几何映射”
- `NamespaceReader` 是 `matchedGeometryEffect` 的 **前置条件**
- 没有 `NamespaceReader`：

  - `matchedGeometryEffect` 无法工作

***

### 2. 与 matchedTransitionSource 的关系

- 页面级转场动画依赖 `namespace` 来配对：

  - 转场源视图
  - 目标页面
- `NamespaceReader` 用于：

  - 在源页面生成 namespace
  - 并传递给目标页面作为统一坐标系统

***

## 五、最基础的 NamespaceReader 示例（组件级）

```tsx
const expanded = useObservable(false)

<NamespaceReader>
  {namespace => (
    <VStack>
      {!expanded.value && (
        <Circle
          matchedGeometryEffect={{
            id: "shape",
            namespace
          }}
          onTapGesture={() => {
            expanded.setValue(true)
          }}
        />
      )}

      {expanded.value && (
        <Circle
          frame={{ width: 200, height: 200 }}
          matchedGeometryEffect={{
            id: "shape",
            namespace,
            isSource: false
          }}
        />
      )}
    </VStack>
  )}
</NamespaceReader>
```

该示例中：

- `NamespaceReader` 负责创建动画坐标系
- 两个 `Circle` 因为：

  - `id` 相同
  - `namespace` 相同
    从而建立起几何联动关系

***

## 六、导航转场中的 NamespaceReader 典型结构

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

该结构说明：

- `namespace` 由 `NamespaceReader` 生成
- 同时被：

  - 源视图使用
  - 目标页面使用
- 从而建立完整的页面级共享几何动画

***

## 七、命名空间的生命周期与作用范围

### 1. 生命周期

- `NamespaceReader` 每次创建：

  - 都会生成一个 **全新的 namespace**
- 该 namespace 的生命周期：

  - 仅存在于当前组件树
  - 随组件卸载而销毁

***

### 2. 作用范围

- namespace 只对其 render function 内部的视图生效
- 不可跨越组件树自动共享
- 如果需要跨组件共享：

  - 必须通过 props 显式传递 `namespace`

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- 是否真的使用了 `NamespaceReader`
- 是否正确接收并传递了 `namespace`
- source 与 target 是否引用的是 **同一个 namespace 实例**

***

### 2. 动画偶尔失效、不稳定

常见原因：

- `NamespaceReader` 被条件渲染反复销毁与重建
- 每次重建都会生成新的 namespace
- 导致旧视图与新视图：

  - 实际上不在同一个动画坐标系中

建议：

- 将 `NamespaceReader` 放在 **稳定的父级节点**
- 避免在 `if / ternary` 结构中频繁切换

***

### 3. 多个 NamespaceReader 嵌套导致动画错乱

问题表现：

- id 相同
- 但实际 namespace 不同
- 系统无法建立匹配关系

排查思路：

- 确认 source 与 target 是否真的来自：

  - 同一个 `NamespaceReader` 实例

***

## 九、设计层面的使用建议

1. 一个独立动画区域使用一个 `NamespaceReader`
2. 不要为每一个视图都单独创建 `NamespaceReader`
3. 页面级动画：

   - NamespaceReader 应放在整个页面的根节点
4. 组件级动画：

   - NamespaceReader 应包裹同一个逻辑模块
5. 同一个 namespace 内：

   - 不要复用相同的 `id` 给不相关的视图

***

## 十、适用场景总结

适合使用 `NamespaceReader` 的场景：

- 卡片 → 详情页的共享元素动画
- Tab 指示器几何联动
- 图片放大预览
- 列表项 → 详情内容过渡
- 多视图间的空间连续动画

不需要使用 `NamespaceReader` 的场景：

- 普通 opacity / scale 动画
- 单视图内部的简单过渡
- 不涉及跨视图几何同步的动画



---
url: /zh/guide/Changelog/2.4.4/New List View Modifiers.md
---

# 属性概览

| 属性名                          | 类型                                                          | 系统要求      | 说明                         |
| ---------------------------- | ----------------------------------------------------------- | --------- | -------------------------- |
| `listSectionIndexVisibility` | `Visibility`                                                | iOS 26.0+ | 控制 List 右侧 Section 索引条的可见性 |
| `listSectionMargins`         | `number \| EdgeSets \| { edges: EdgeSets; length: number }` | iOS 26.0+ | 自定义 Section 边距，替换系统默认边距规则  |
| `sectionIndexLabel`          | `string`                                                    | iOS 26.0+ | 设置 Section 在索引条中的字符标签      |
| `sectionActions`             | `VirtualNode`                                               | iOS 18.0+ | 为 Section 添加自定义操作区域        |

***

# 1. listSectionIndexVisibility

```ts
/**
 * Sets the visibility of the list section index.
 * @available iOS 26.0+.
 */
listSectionIndexVisibility?: Visibility
```

### 功能说明

控制 List 的右侧索引条是否显示。常用于需要类似通讯录 A-Z 快速跳转的场景。

可选值：

- `"visible"`
- `"hidden"`
- `"automatic"`（系统自行判断）

### 示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```

***

# 2. listSectionMargins

```ts
/**
 * Set the section margins for the specific edges.
 * @available iOS 26.0+.
 */
listSectionMargins?: number | EdgeSets | {
  edges: EdgeSets
  length: number
}
```

### 功能说明

设置 Section 的外边距，完全替换系统默认边距。可使用数值、 EdgeSets，或指定边的写法。

### 三种写法说明

### 2.1 使用单一数字作为四边边距

```tsx
listSectionMargins={12}
```

### 2.2 使用 EdgeInsets

```tsx
listSectionMargins={"all"}
```

### 2.3 针对特定边设置长度

```tsx
listSectionMargins={{
  edges: "horizontal",
  length: 20
}}
```

此写法等同于 SwiftUI 中：

```swift
.listSectionMargins(.horizontal, 20)
```

### 示例

```tsx
<Section
  header={<Text>Favorites</Text>}
  listSectionMargins={{
    edges: "vertical",
    12
  }}
>
  <Text>Item A</Text>
  <Text>Item B</Text>
</Section>
```

***

# 3. sectionIndexLabel

```ts
/**
 * Sets the label that is used in a section index.
 * @available iOS 26.0+.
 */
sectionIndexLabel?: string
```

### 功能说明

为 Section 设置索引条的显示字符，一般为单字母，如 “A”、“B”、“C”。

### 示例

```tsx
<Section
  header={<Text>A</Text>}
  sectionIndexLabel="A"
>
  <Text>Adam</Text>
  <Text>Ana</Text>
</Section>
```

***

# 4. sectionActions

```ts
/**
 * Adds custom actions to a section.
 * @available iOS 18.0+
 */
sectionActions?: VirtualNode
```

### 功能说明

为 Section 添加自定义操作按钮、菜单等 UI，位置通常显示在 Section Header 区域的右侧。

### 示例：添加刷新按钮

```tsx
<Section
  header={<Text>Downloads</Text>}
  sectionActions={
    <Button title="Refresh" action={() => doRefresh()} />
  }
>
  <Text>File 1</Text>
  <Text>File 2</Text>
</Section>
```

### 示例：添加菜单动作

```tsx
<Section
  header={<Text>Photos</Text>}
  sectionActions={
    <Menu title="Actions">
      <Button title="Upload All" action={() => uploadAll()} />
      <Button title="Delete All" action={() => deleteAll()} />
    </Menu>
  }
>
  {photos.map(photo => <Text key={photo.id}>{photo.name}</Text>)}
</Section>
```

***

# 完整示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
        listSectionMargins={12}
        sectionActions={
          <Button title="Refresh" action={() => refreshGroup(group)} />
        }
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```



---
url: /zh/guide/Changelog/2.4.4/Notification/index.md
---

# 通知

Scripting App 中的 `Notification` 模块用于安排、管理和展示本地通知，支持多种触发方式、交互操作按钮和富交互界面（自定义 UI）。

***

## 目录

1. [安排通知](#安排通知)
2. [通知触发器](#通知触发器)

   - [TimeIntervalNotificationTrigger](#timeintervalnotificationtrigger)
   - [CalendarNotificationTrigger](#calendarnotificationtrigger)
   - [LocationNotificationTrigger](#locationnotificationtrigger)
3. [通知操作按钮](#通知操作按钮)
4. [富通知（自定义 UI）](#富通知自定义-ui)
5. [通知管理](#通知管理)
6. [通知信息与请求结构](#通知信息与请求结构)
7. [完整示例](#完整示例)

***

## 安排通知

使用 `Notification.schedule` 来安排本地通知。它支持标题、触发器、点击行为、操作按钮、自定义 UI 和其他投递选项：

```ts
await Notification.schedule({
  title: "提醒事项",
  body: "该起身活动了！",
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 1800,
    repeats: true
  }),
  actions: [
    {
      title: "我知道了",
      icon: "checkmark",
      url: Script.createRunURLScheme("确认脚本", { acknowledged: true })
    }
  ],
  tapAction: {
    type: "runScript",
    scriptName: "确认脚本"
  },
  customUI: false
})
```

### 参数说明

| 参数名                 | 类型                                                                                                            | 说明                                          |
| ------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| `title`             | `string`                                                                                                      | 必填，通知标题。                                    |
| `subtitle`          | `string?`                                                                                                     | 可选，副标题内容。                                   |
| `body`              | `string?`                                                                                                     | 可选，正文内容。                                    |
| `iconImageData`     | `Data` \| `SystemImageIcon` \| `null`                                                                         | 可选，自定义通知图标图片的二进制数据或系统图标名称。                  |
| `badge`             | `number?`                                                                                                     | 可选，应用图标角标数字。                                |
| `silent`            | `boolean?`                                                                                                    | 可选，默认为 `false`。设为 `true` 则不播放声音静默送达。        |
| `interruptionLevel` | `"active"` \| `"passive"` \| `"timeSensitive"`                                                                | 可选，通知的重要级别和投递优先级。                           |
| `userInfo`          | `Record<string, any>?`                                                                                        | 可选，附加的自定义数据。                                |
| `threadIdentifier`  | `string?`                                                                                                     | 可选，用于通知分组的标识符。                              |
| `trigger`           | `TimeIntervalNotificationTrigger` \| `CalendarNotificationTrigger` \| `LocationNotificationTrigger` \| `null` | 可选，定义何时发送通知。                                |
| `actions`           | `NotificationAction[]?`                                                                                       | 可选，通知展开后展示的操作按钮。                            |
| `customUI`          | `boolean?`                                                                                                    | 可选，设为 `true` 可使用 `notification.tsx` 自定义 UI。 |
| `tapAction`         | `"none"` \| `{ type: "runScript", scriptName: string }` \| `{ type: "openURL", url: string }`                 | 可选，定义用户点击通知时执行的操作。                          |

#### SystemImageIcon

```ts
type SystemImageIcon = {
  systemImage: string
  color: Color
}
```

用于定义通知图标的系统图标名称和颜色。

- `systemImage`: 系统图标（SFSymbol）名称
- `color`: 图标颜色

***

### 通知操作按钮（`actions`）

通过 `actions` 参数，你可以为通知添加操作按钮。操作按钮会在通知展开后出现，用户可以点击进行操作。

#### 通知操作按钮类型（`NotificationAction`）

```ts
type NotificationAction = {
    title: string;
    icon?: string;
    url: string;
    destructive?: boolean;
}
```

- `title`: 按钮标题
- `icon`: 按钮图标
- `url`: 点击后打开的 URL
- `destructive`: 是否为破坏性操作

***

### 点击行为（`tapAction`）

通过 `tapAction` 参数，你可以完全控制用户**点击通知**时的行为：

- `"none"`：点击后无任何响应
- `{ type: "runScript", scriptName: string }`：运行指定脚本
- `{ type: "openURL", url: string }`：打开指定 URL，可为 deeplink 或 https 链接

如果不设置 `tapAction`，默认行为是运行**当前脚本**，你可以通过 `Notification.current` 获取通知内容。

***

## 通知触发器

### TimeIntervalNotificationTrigger

在指定秒数后触发通知：

```ts
new TimeIntervalNotificationTrigger({
  timeInterval: 3600,
  repeats: true
})
```

- `timeInterval`: 延迟秒数
- `repeats`: 是否重复触发
- `nextTriggerDate()`: 返回下次预期触发的时间

***

### CalendarNotificationTrigger

根据特定日期和时间触发通知：

```ts
const components = new DateComponents({ hour: 8, minute: 0 })
new CalendarNotificationTrigger({
  dateMatching: components,
  repeats: true
})
```

- 支持设置 `year`、`month`、`day`、`hour` 等
- 适用于每日、每周或特定时间提醒

***

### LocationNotificationTrigger

当进入或离开某个地理区域时触发：

```ts
new LocationNotificationTrigger({
  region: {
    identifier: "公司",
    center: { latitude: 37.7749, longitude: -122.4194 },
    radius: 100,
    notifyOnEntry: true,
    notifyOnExit: false
  },
  repeats: false
})
```

- 支持进入/离开圆形区域的触发

***

## 通知操作按钮

通过 `actions` 参数添加通知操作按钮：

```ts
actions: [
  {
    title: "查看详情",
    url: Script.createRunURLScheme("详情脚本", { fromNotification: true })
  },
  {
    title: "忽略",
    url: Script.createRunURLScheme("忽略脚本", { dismissed: true }),
    destructive: true
  }
]
```

- 使用 `Script.createRunURLScheme(...)` 创建 URL
- 按钮在长按或下拉通知时显示

***

## 富通知（自定义 UI）

你可以使用 TSX 文件定义通知的展开视图：

1. 安排通知时设置 `customUI: true`
2. 在脚本中添加 `notification.tsx` 文件
3. 使用 `Notification.present(<JSX>)` 渲染 UI

### `Notification.present(element: JSX.Element): void`

在 `notification.tsx` 中调用，用于渲染富通知界面。

***

### 示例 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function NotificationView() {
  return (
    <VStack>
      <Text>需要完成你的任务吗？</Text>
      <Button title="已完成" action={() => console.log("任务完成")} />
      <Button title="稍后提醒" action={() => console.log("稍后提醒")} />
    </VStack>
  )
}

Notification.present(<NotificationView />)
```

***

## 通知管理

| 方法名                                    | 说明              |
| -------------------------------------- | --------------- |
| `getAllDelivereds()`                   | 获取所有已送达的通知      |
| `getAllPendings()`                     | 获取所有已安排但尚未送达的通知 |
| `removeAllDelivereds()`                | 移除所有已送达的通知      |
| `removeAllPendings()`                  | 取消所有待发送通知       |
| `removeDelivereds(ids)`                | 移除指定 ID 的已送达通知  |
| `removePendings(ids)`                  | 取消指定 ID 的已安排通知  |
| `getAllDeliveredsOfCurrentScript()`    | 获取当前脚本发送的已送达通知  |
| `getAllPendingsOfCurrentScript()`      | 获取当前脚本安排的待发送通知  |
| `removeAllDeliveredsOfCurrentScript()` | 清除当前脚本的所有已送达通知  |
| `removeAllPendingsOfCurrentScript()`   | 清除当前脚本的所有待发送通知  |
| `setBadgeCount(count)`                 | 设置应用图标的角标数值     |

***

## 通知信息与请求结构

当脚本是通过点击通知启动时，可以通过 `Notification.current` 获取上下文信息：

```ts
if (Notification.current) {
  const { title, userInfo } = Notification.current.request.content
  console.log(`从通知启动：${title}`, userInfo)
}
```

### `NotificationRequest` 字段

| 字段名                        | 说明              |
| -------------------------- | --------------- |
| `identifier`               | 通知请求的唯一标识符      |
| `content.title`            | 通知标题            |
| `content.subtitle`         | 通知副标题           |
| `content.body`             | 通知正文            |
| `content.userInfo`         | 附加信息            |
| `content.threadIdentifier` | 分组标识            |
| `trigger`                  | 触发器对象，控制通知的投递逻辑 |

***

## 完整示例

以下示例展示了通知的完整用法：自定义 UI、交互按钮、点击行为、重复触发等。

### 第一步：安排通知

```ts
await Notification.schedule({
  title: "喝水提醒",
  body: "别忘了喝水哦！",
  interruptionLevel: "timeSensitive",
  iconImageData: UIImage
    .fromSFSymbol("waterbottle")!
    .withTintColor("systemBlue")!
    .toPNGData(),
  customUI: true,
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 3600,
    repeats: true
  }),
  tapAction: {
    type: "runScript",
    scriptName: "喝水记录"
  },
  actions: [
    {
      title: "已喝水",
      url: Script.createRunURLScheme("喝水记录", { drank: true }),
    },
    {
      title: "忽略",
      url: Script.createRunURLScheme("喝水记录", { drank: false }),
      destructive: true
    }
  ]
})
```

### 第二步：创建 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function HydrationUI() {
  return (
    <VStack>
      <Text>你刚刚喝水了吗？</Text>
      <Button title="是的" action={() => console.log("已确认喝水")} />
      <Button title="还没" action={() => console.log("忽略提醒")} />
    </VStack>
  )
}

Notification.present(<HydrationUI />)
```

***

## 总结

Scripting 中的 `Notification` API 提供了强大的本地通知功能：

- 支持时间、日历、位置触发器
- 支持操作按钮及跳转脚本
- 通过 `tapAction` 自定义点击通知的行为
- 使用 `notification.tsx` 创建富交互通知界面
- 提供全面的通知生命周期管理



---
url: /zh/guide/Changelog/2.4.4/Notification/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Notification, Script, Section, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Notification"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
      >
        <Button
          title={"Schedule a Notification with actions"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down",
              actions: [
                {
                  title: "Widget",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "Widget",
                  })
                },
                {
                  title: "LiveActivity",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "LiveActivity",
                  })
                }
              ]
            })
          }}
        />
      </Section>

      <Section
      >
        <Button
          title={"Schedule a Notification with Rich Content"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down to show rich content.",
              customUI: true,
              userInfo: {
                title: "AudioRecorder",
                subtitle: "The interface allows you to record audio data to a file. It provides functionalities to start, stop, pause, and manage audio recordings, with configurable settings for audio quality, sample rate, format, and more.",
              }
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.4/SFTP Client.md
---

`SFTPClient` 用于通过 SSH 连接访问远程文件系统，基于 **SFTP 协议**。
它提供目录操作、文件操作、路径解析等能力，并可通过 `openFile()` 获得更强大的 `SFTPFile` 对象执行读取、写入等低层操作。

该类实例通常由：

```ts
const sftp = await ssh.openSFTP()
```

返回。

***

## 属性

### `readonly isActive: boolean`

指示当前 SFTP 连接是否仍然有效。

- `true`：连接仍然处于活跃状态
- `false`：连接已关闭或发生错误

***

## 方法

***

## `close(): Promise<void>`

关闭当前 SFTP 连接。

#### 返回值：

- `Promise<void>`：关闭成功后 resolve

#### 示例：

```ts
await sftp.close()
```

***

## `readDirectory(atPath: string): Promise<DirectoryEntry[]>`

读取指定目录下的文件与子目录。

#### 参数：

- **`atPath`**：远程目录路径

#### 返回值：

**`DirectoryEntry[]`** 数组，结构如下：

```ts
{
  filename: string
  longname: string
  attributes: {
    size?: number
    userId?: number
    groupId?: number
    accessTime?: Date
    modificationTime?: Date
    permissions?: number
  }
}[]
```

#### 示例：

```ts
const items = await sftp.readDirectory("/var/log")
```

***

## `createDirectory(atPath: string): Promise<void>`

在指定路径创建一个目录。

#### 参数：

- `atPath`：目标目录路径

#### 返回值：

- `Promise<void>`：创建成功后 resolve

#### 示例：

```ts
await sftp.createDirectory("/home/user/new-folder")
```

***

## `removeDirectory(atPath: string): Promise<void>`

删除一个目录（需为空目录）。

#### 参数：

- `atPath`：要删除的目录路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.removeDirectory("/home/user/empty-dir")
```

***

## `rename(oldPath: string, newPath: string): Promise<void>`

重命名或移动文件 / 目录。

#### 参数：

- `oldPath`：原路径
- `newPath`：目标路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.rename("/home/user/a.txt", "/home/user/b.txt")
```

***

## `getAttributes(atPath: string): Promise<FileAttributes>`

读取文件或目录的信息。

#### 返回值：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

#### 示例：

```ts
const attrs = await sftp.getAttributes("/etc/hosts")
```

***

## `openFile(filePath: string, flags: SFTPOpenFileFlags | SFTPOpenFileFlags[]): Promise<SFTPFile>`

以指定模式打开远程文件，返回 `SFTPFile` 对象进行读写。

#### 参数：

- `filePath`：文件路径
- `flags`：打开文件的模式，可为单个 flag 或数组

可用的 flag：

```
"read" | "write" | "append" | "create" | "truncate" | "forceCreate"
```

#### 返回值：

- `Promise<SFTPFile>`：一个可读写、可关闭的文件对象

#### 示例：

```ts
const file = await sftp.openFile("/home/user/log.txt", ["read"])
const data = await file.readAll()
await file.close()
```

***

## `remove(atPath: string): Promise<void>`

删除指定路径的文件。

#### 参数：

- `atPath`：要删除的文件路径

#### 示例：

```ts
await sftp.remove("/home/user/old.txt")
```

***

## `getRealPath(atPath: string): Promise<string>`

解析符号链接、相对路径、`~` 等，返回绝对路径。

#### 示例：

```ts
const real = await sftp.getRealPath("~/documents")
```

***

# 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "pass")
})

const sftp = await ssh.openSFTP()

// 查看目录内容
const list = await sftp.readDirectory("/home/user")

// 打开文件读取
const file = await sftp.openFile("/home/user/info.txt", "read")
const data = await file.readAll()
await file.close()

// 创建目录
await sftp.createDirectory("/home/user/new-folder")

// 删除文件
await sftp.remove("/home/user/temp.txt")

await sftp.close()
```



---
url: /zh/guide/Changelog/2.4.4/SFTP File.md
---

`SFTPFile` 表示一个已经通过 SFTP 打开的远程文件句柄。
通过该类，你可以对文件执行读取、写入、获取属性、关闭等底层操作。

实例通常通过：

```ts
const file = await sftp.openFile(path, flags)
```

获得。

***

## 属性

***

### `readonly isActive: boolean`

指示当前文件是否仍然处于打开状态。

- `true`：文件句柄有效，可继续读写
- `false`：文件已关闭或出现错误

***

## 方法

***

# `readAttributes(): Promise<FileAttributes>`

读取文件的元数据属性。

### 返回值：

一个包含文件属性的对象：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

### 示例：

```ts
const attrs = await file.readAttributes()
console.log(attrs.size)
```

***

# `read(options?: { from?: number, length?: number }): Promise<Data>`

按指定范围读取文件内容。

### 参数：

- `from?`：读取的起始偏移（字节），默认从 `0` 开始
- `length?`：读取的字节数，默认读取到文件末尾

### 返回值：

- 一个 `Promise<Data>`，包含读取到的数据

### 示例：

```ts
const data = await file.read({ from: 100, length: 50 })
```

***

# `readAll(): Promise<Data>`

读取文件的全部内容。

### 返回值：

- 一个 `Promise<Data>`，包含完整的文件数据

### 示例：

```ts
const data = await file.readAll()
```

***

# `write(data: Data, at?: number): Promise<void>`

向文件写入数据。

### 参数：

- `data`：要写入的二进制数据
- `at?`：写入的起始偏移（字节）。

  - 若未提供，则根据 flags 的模式决定：

    - 若使用 `"append"` 打开，则追加到文件末尾
    - 若使用 `"write"` 打开，则从当前偏移或默认 0 写入

### 返回值：

- `Promise<void>`，写入成功后 resolve

### 示例：

```ts
await file.write(Data.fromRawString("Hello world"))
```

***

# `close(): Promise<void>`

关闭文件句柄。
关闭后，`isActive` 将变为 `false`，无法继续读写。

### 示例：

```ts
await file.close()
```

***

# 使用示例

```ts
// 打开文件（读取模式）
const file = await sftp.openFile("/home/user/info.txt", ["read"])

// 获取文件属性
const attrs = await file.readAttributes()

// 读取内容
const allData = await file.readAll()

// 部分读取
const partial = await file.read({ from: 50, length: 100 })

// 关闭文件
await file.close()
```



---
url: /zh/guide/Changelog/2.4.4/SnippetIntent.md
---

SnippetIntent 是一种特殊类型的 AppIntent，可在 Shortcuts 中生成原生的 Snippet UI 卡片。它适用于：

- 多步骤表单式交互
- 从 Shortcuts 中获取用户输入
- 键值选择、确认、展示结果等轻量级交互
- 在 Shortcuts 工作流中内嵌 UI 组件

SnippetIntent 特点如下：

1. 在 Scripting 中必须通过 `AppIntentManager.register` 注册
2. `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
3. `perform()` 必须返回一个 `VirtualNode`（TSX UI）
4. 在脚本中必须以 `Intent.snippetIntent()` 封装后返回
5. Shortcuts 必须使用「Show Snippet Intent」动作才能显示 Snippet UI

***

# 系统要求

**SnippetIntent 只能在 iOS 26 及以上系统运行。**

在 iOS 26 以下环境：

- 无法调用 `Intent.snippetIntent`
- 无法使用 `Intent.requestConfirmation`
- Shortcuts 中不存在「Show Snippet Intent」动作
- SnippetIntent 类型的 AppIntent 不会被 Shortcuts 正常识别

***

# 注册 SnippetIntent（app\_intents.tsx）

在 `app_intents.tsx` 中声明 SnippetIntent：

```tsx
export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})
```

再例如：

```tsx
export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    return <ResultView content={content} />
  }
})
```

要求：

- `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
- `perform()` 必须返回 `VirtualNode`
- 与普通 AppIntent 区别在于返回的是 UI，而非数据

***

# SnippetIntent 返回值封装：Intent.snippetIntent

SnippetIntent 不能直接作为 JS 返回值，必须通过 `Intent.snippetIntent()` 包装成 `IntentSnippetIntentValue`。

```tsx
const snippetValue = Intent.snippetIntent({
  value: Intent.text("Some value returning for Shortcuts"),
  snippetIntent: ShowResultIntent({
    content: "Example Text"
  })
})

Script.exit(snippetValue)
```

### 类型定义

```ts
type SnippetIntentValue = {
  value?: IntentAttributedTextValue | IntentFileURLValue | IntentJsonValue | IntentTextValue | IntentURLValue | IntentFileValue | null
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>
}

declare class IntentSnippetIntentValue extends IntentValue<
  'SnippetIntent',
  SnippetIntentValue
> {
  value: SnippetIntentValue
  type: 'SnippetIntent'
}
```

封装的返回值可被 Shortcuts 的「Show Snippet Intent」动作识别并展示 UI。

***

# Snippet 确认界面：Intent.requestConfirmation

SnippetIntent 支持在执行逻辑中先请求用户确认某个操作。此能力同样基于 iOS 26。

```ts
Intent.requestConfirmation(
  actionName: ConfirmationActionName,
  intent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>
```

### ConfirmationActionName

这些名称会影响 Shortcuts UI 中呈现的文案，例如 “Set …”、“Add …”、“Toggle …” 等。

示例值：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" | 
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

### 示例

```tsx
await Intent.requestConfirmation(
  "set",
  PickColorIntent()
)
```

效果：

- Shortcuts 弹出 PickColorIntent 对应的 Snippet UI
- 用户点击确认后 Promise resolve
- 用户取消时脚本执行终止

***

# Shortcuts 的「Show Snippet Intent」动作（iOS 26+）

Shortcuts 在 iOS 26 新增动作：

**Show Snippet Intent**

用于展示 SnippetIntent 返回的 Snippet UI。

### 与其他动作对比

| Shortcuts 动作                 | 显示界面                 | 支持 SnippetIntent | 场景               |
| ---------------------------- | -------------------- | ---------------- | ---------------- |
| Run Script                   | 无 UI                 | 否                | 纯数据处理            |
| Run Script in App            | Scripting App UI（前台） | 否                | 大型 UI、文件选择等      |
| Show Snippet Intent（iOS 26+） | Snippet 卡片 UI        | 是                | SnippetIntent 场景 |

使用方式：

1. 在 Shortcuts 中添加「Show Snippet Intent」
2. 选择脚本项目（需包含 intent.tsx）
3. 脚本返回 `Intent.snippetIntent(...)`
4. Shortcuts 显示 Snippet UI

***

# IntentMemoryStorage — 跨 AppIntent 状态共享

## 1. 为什么需要 IntentMemoryStorage

由于系统行为，每次 Intent 执行后：

- AppIntent 的 `perform()` 执行完毕后立即销毁上下文
- `intent.tsx` 执行完并调用 `Script.exit()` 后脚本上下文也会完全释放

因此无法依赖 JS 变量在多个 Intent 之间保持状态。

例如：

- PickColorIntent（选择颜色）
- SetColorIntent（设置颜色）
- ShowResultIntent（展示颜色结果）

在这些 Intent 之间共享状态必须依赖持久化存储。

## 2. IntentMemoryStorage 提供轻量级、跨 Intent 的共享存储

API 定义：

```ts
namespace IntentMemoryStorage {
  function get<T>(key: string): T | null
  function set(key: string, value: any): void
  function remove(key: string): void
  function contains(key: string): boolean
  function clear(): void
  function keys(): string[]
}
```

用途：

- 存储小量状态，例如当前颜色、当前步骤、临时选项
- 在多个 AppIntent 之间共享数据
- 生命周期跨 Intent 调用，但随脚本生命周期管理

### 示例：存储用户颜色选择

```ts
IntentMemoryStorage.set("color", "systemBlue")

const color = IntentMemoryStorage.get<Color>("color")
```

### 建议

- 不要存储大型数据（如大图像、长文本）
- 大型数据请使用：

  - `Storage`（持久键值存储）
  - `FileManager` 写入 appGroupDocumentsDirectory

IntentMemoryStorage 适合作为临时状态共享，不适合当作数据库使用。

***

# 完整示例（iOS 26+）

## app\_intents.tsx

```tsx
export const SetColorIntent = AppIntentManager.register({
  name: "SetColorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async (color: Color) => {
    IntentMemoryStorage.set("color", color)
  }
})

export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})

export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    const color = IntentMemoryStorage.get<Color>("color") ?? "systemBlue"
    return <ResultView content={content} color={color} />
  }
})
```

## intent.tsx

```tsx
async function runIntent() {

  // 1. 通过 Snippet 请求用户确认颜色
  await Intent.requestConfirmation(
    "set",
    PickColorIntent()
  )

  // 2. 从 Shortcuts 输入中读取文本
  const textContent =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts"

  // 3. 创建 SnippetIntent 返回结果
  const snippetIntentValue = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: textContent })
  })

  Script.exit(snippetIntentValue)
}

runIntent()
```



---
url: /zh/guide/Changelog/2.4.4/TabView.md
---

Scripting 提供了与最新 iOS TabView 体系一致的 API：
通过 `TabView`、`Tab`、`TabSection` 组织界面结构，使应用能够在 iOS 18+ 环境下完整支持多标签视图、侧边栏标签、可定制布局等。

相比旧版本依赖 `tabItem` 修饰符的方式，新的结构更加灵活、分组更清晰，并能与 TabViewCustomization 等新特性无缝配合。

***

# 一、基础结构：TabView + Tab

在最基本的形式中，`TabView` 作为容器，内部包含多个 `Tab`。
每个 `Tab` 定义：

- 标签标题
- 图标
- 标识值（value）
- 角色（如 search）
- 对应的内容视图

示例：

```tsx
function RootView() {
  const selection = useObservable<number>(0)

  return (
    <TabView selection={selection}>
      <Tab
        title="首页"
        systemImage="house.fill"
        value={0}
      >
        <HomeView />
      </Tab>

      <Tab
        title="搜索"
        systemImage="magnifyingglass"
        value={1}
        role="search"
      >
        <SearchView />
      </Tab>

      <Tab
        title="设置"
        systemImage="gearshape.fill"
        value={2}
      >
        <SettingsView />
      </Tab>
    </TabView>
  )
}
```

要点：

- `selection` 通过 Observable 控制当前激活的标签
- `value` 必须与 `selection` 的泛型类型匹配（string 或 number）
- Search Tab 可使用 `role="search"` 与搜索相关行为联动

***

# 二、使用 TabSection 组织分组标签

当 Tab 数量较多、需要按功能分类、需要在侧边栏中显示复杂结构时，可以使用 `TabSection`。

结构关系为：

```
TabView
 ├─ TabSection
 │   ├─ Tab
 │   ├─ Tab
 │   └─ ...
 ├─ TabSection
 │   ├─ Tab
 │   └─ ...
```

## 1. 使用 title 作为分组标题

```tsx
<TabView selection={selection}>
  <TabSection title="收件箱">
    <Tab title="收件箱" systemImage="tray.fill" value="inbox">
      <InboxView />
    </Tab>
    <Tab title="已发送" systemImage="paperplane.fill" value="sent">
      <SentView />
    </Tab>
  </TabSection>

  <TabSection title="标签">
    <Tab title="重要" systemImage="star.fill" value="important">
      <ImportantView />
    </Tab>
  </TabSection>
</TabView>
```

## 2. 使用 header 作为自定义组头

如需显示图标、说明文字或复合内容，可用 `header`：

```tsx
<TabSection
  header={
    <HStack spacing={8}>
      <Image systemName="folder.fill" />
      <VStack>
        <Text fontWeight="bold">项目</Text>
        <Text fontSize={12} foregroundColor="secondary">
          最近打开的项目
        </Text>
      </VStack>
    </HStack>
  }
>
  <Tab title="项目 A" systemImage="doc.fill" value="projectA">
    <ProjectAView />
  </Tab>
</TabSection>
```

***

# 三、TabSection 的高级能力：布局、操作区、拖拽与可见性

`TabSection` 提供了丰富的分组级配置，让 Tab 分组的呈现方式更加灵活。

## 1. tabPlacement（标签位置策略）

支持：

- `automatic`
- `pinned`
- `sidebarOnly`

例如将某组仅显示在侧边栏：

```tsx
<TabSection title="标签" tabPlacement="sidebarOnly">
  <Tab title="重要" systemImage="star.fill" value="important">
    <ImportantView />
  </Tab>
</TabSection>
```

## 2. sectionActions（分组操作区）

为某一组提供额外操作按钮：

```tsx
<TabSection
  title="列表"
  sectionActions={
    <Button title="添加" systemImage="plus" action={addItem} />
  }
>
  ...
</TabSection>
```

## 3. 分组可见性与可定制行为

通过：

- `defaultVisibility`
- `customizationID`
- `customizationBehavior`
- `draggable`
- `dropDestination`

可以为每个分组提供：

- 默认显示策略
- 是否允许用户自定义排序或隐藏
- 是否可以拖动
- 外部拖拽数据的处理

例如：

```tsx
<TabSection
  title="文件"
  customizationID="file-section"
  customizationBehavior="reorderable"
  draggable="file-section"
  dropDestination={items => handleDrop(items)}
>
  ...
</TabSection>
```

***

# 四、TabView 级别的高级配置

TabView 本身提供了一系列属性，可用于构建高级 UI（iOS 18～26）。

包括：

- `tabBarMinimizeBehavior`
- `tabViewBottomAccessory`
- `tabViewSearchActivation`
- `tabViewCustomization`
- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

以下为每项能力的说明。

***

## 1. tabBarMinimizeBehavior（iOS 26.0+）

控制 TabBar 是否根据滚动方向自动最小化：

- `automatic`
- `never`
- `onScrollDown`
- `onScrollUp`

示例：

```tsx
<TabView
  selection={selection}
  tabBarMinimizeBehavior="onScrollDown"
>
  ...
</TabView>
```

***

## 2. tabViewBottomAccessory（iOS 26.0+）

为 TabView 添加底部附加视图，例如提示栏：

```tsx
<TabView
  selection={selection}
  tabViewBottomAccessory={
    <HStack>
      <Text>左右滑动切换标签</Text>
      <Spacer />
      <Button title="知道了" action={dismiss} />
    </HStack>
  }
>
  ...
</TabView>
```

***

## 3. tabViewSearchActivation（iOS 26.0+）

控制搜索 Tab 的激活方式：

- `automatic`
- `searchTabSelection`

与 `role="search"` 搭配使用：

```tsx
<TabView
  selection={selection}
  tabViewSearchActivation="searchTabSelection"
>
  ...
</TabView>
```

***

## 4. 侧边栏附属视图（iOS 18.0+）

包括：

- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

示例：

```tsx
<TabView
  selection={selection}
  tabViewSidebarHeader={<UserHeader />}
  tabViewSidebarFooter={<SettingsButton />}
  tabViewSidebarBottomBar={<UpgradeButton />}
>
  ...
</TabView>
```

***

# 五、TabViewCustomization：标签页可定制化体系（重点补充）

`TabViewCustomization` 是一个可序列化的状态对象，用于存储和恢复用户对 Tab 布局的自定义行为，包括：

- Tab 分组顺序
- 分组内部的 Tab 排序
- Tab 可见性（在 TabBar 与 Sidebar 中分别独立管理）
- 重置各种设置
- 持久化与恢复

它通常放在 TabView 根视图中，通过：

```tsx
tabViewCustomization={customizationState}
```

来注入。

## 1. 创建与加载 TabViewCustomization

创建方式通常是：

```tsx
const customization = useObservable<TabViewCustomization >(() => {
  const data = Storage.get('tab_customization')
  if (data) {
    return TabViewCustomization.fromData(data) ?? new TabViewCustomization()
  }
  return new TabViewCustomization()
})

useEffect(() => {
  const listener = (newValue: TabViewCustomization) => {
    const data = newValue.toData()
    if (data) {
      Storage.set('tab_customization', data)
    }
  }
  customization.subscribe(listener)
  return () => {
    customization.unsubscribe(listener)
  }
}, [])
```

如需创建一个新的空自定义对象，可使用：

```tsx
const customizationState = useObservable(() => new TabViewCustomization())
```

## 2. 保存自定义内容

你可以将用户调整后的 Tab 布局序列化保存：

```tsx
const data = customization.value?.toData()
Storage.set('tab_customization', data)
```

`toData()` 会将内部状态转换为可存储的 `Data` 对象。

## 3. 获取并操作分组（Section）

```ts
getSection(id: string): TabViewCustomizationSection | null
```

`TabSection` 通常带有 `customizationID`，这样就可以获取特定分组并操作它：

```tsx
const section = customization.value?.getSection('file-section')

section?.tabOrder        // 一个包含 tab ID 顺序的数组，或 null
section?.resetTabOrder() // 重置排序
```

场景示例：

- 用户将“文件”分组中的 Tab 重新排序
- 用户将某些 Tab 移动到“更多”区域
- 应用需要根据用户排序更新 UI

## 4. 获取并操作单个 Tab

```ts
getTab(id: string): TabViewCustomizationTab | null
```

可通过 Tab 的 `customizationID` 获取并调整其可见性：

```tsx
const tab = customization.value?.getTab('important-tab')

tab?.tabBarVisibility         // Visibility 类型
tab.sidebarVisibility = 'hidden'
```

适用场景：

- 控制 Tab 在 TabBar 或 Sidebar 中是否显示
- 用户可通过自定义界面操作 Tab 可见性
- 程序自动隐藏某些 Tab

## 5. 全局重置

```ts
resetSectionOrder(): void
resetVisibility(): void
```

通常用于：

- 点击“恢复默认布局”按钮
- 版本更新后清理已有布局逻辑

示例：

```tsx
<Button
  title="恢复默认"
  action={() => {
    customization.value?.resetSectionOrder()
    customization.value?.resetVisibility()
  }}
/>
```

***

# 六、与旧的 tabItem 写法的关系

此文档采用全新的结构化写法：

- TabView
- Tab
- TabSection
- TabViewCustomization

旧的 `tabItem` 写法仍可用于简单场景以及兼容iOS 17，但与侧边栏、Tab 分组、自定义布局等高级能力不兼容。
在复杂应用中，建议全面迁移到新的组件体系。



---
url: /zh/guide/Changelog/2.4.4/Use with Toolbar Component.md
---

Scripting 的工具栏系统不仅支持直接在 `toolbar` 属性中传入 `ToolBarProps` 对象，也支持使用与 SwiftUI 结构一致的 `<Toolbar>`、`<ToolbarItem>`、`<ToolbarItemGroup>`、`<ToolbarSpacer>`、`<DefaultToolbarItem>` 等组件，构建更灵活、更强大的导航栏和工具栏布局。

这些组件能够提供更精细的控制，允许开发者像 SwiftUI 一样以声明式方式编排工具栏内容，并为复杂布局提供更高可读性和可维护性。

***

# 基本概念

工具栏组件始终通过视图的 `toolbar` 属性使用：

```tsx
<List
  toolbar={
    <Toolbar>
      {/* 工具栏项 */}
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

`toolbar` 可以接受：

- `ToolBarProps` 对象（与原机制一致）
- `VirtualNode`（必须为 `<Toolbar>` 组件）

使用 `<Toolbar>` 时，所有内容都通过 `<ToolbarItem>` 系列组件明确定义位置和呈现方式。

***

# Toolbar

`Toolbar` 组件是工具栏的容器，用于包含多个工具栏项。它本身不定义位置，内部的 `ToolbarItem` 或 `ToolbarItemGroup` 决定实际布局。

## 用法示例

```tsx
<List
  toolbar={
    <Toolbar>
      <ToolbarItem placement="topBarLeading">
        <Button title="关闭" action={() => dismiss()} />
      </ToolbarItem>
      <ToolbarItem placement="topBarTrailing">
        <Button title="完成" action={() => handleDone()} />
      </ToolbarItem>
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

***

# ToolbarItem

`ToolbarItem` 表示放置在工具栏指定位置的单个项目。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明                                                       |
| ----------- | ---------------------- | ----------- | -------------------------------------------------------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 指定工具栏位置，如 `topBarLeading`、`navigation`、`primaryAction` 等 |
| `children`  | `VirtualNode`          | 无           | 工具栏项的实际内容，例如按钮或文本                                        |

## 示例

```tsx
<Toolbar>
  <ToolbarItem placement="navigation">
    <Button title="返回" action={Navigation.useDismiss()} />
  </ToolbarItem>
</Toolbar>
```

***

# ToolbarItemGroup

`ToolbarItemGroup` 用于在同一位置放置多个工具栏项目，所有子项目将作为一组呈现。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明      |
| ----------- | ---------------------- | ----------- | ------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 工具栏位置   |
| `children`  | 多个 VirtualNode         | 无           | 多个工具栏元素 |

## 示例

```tsx
<Toolbar>
  <ToolbarItemGroup placement="topBarTrailing">
    <Button title="刷新" action={reload} />
    <Button title="更多" action={openMenu} />
  </ToolbarItemGroup>
</Toolbar>
```

***

# ToolbarSpacer

`ToolbarSpacer` 用于在工具栏项之间添加空白区域，适合需要自定义布局的场景。

## 参数说明

| 参数          | 类型                      | 默认值         | 说明                   |
| ----------- | ----------------------- | ----------- | -------------------- |
| `sizing`    | `'fixed' \| 'flexible'` | `flexible`  | 控制 Spacer 是否固定大小或可伸缩 |
| `placement` | `ToolbarItemPlacement`  | `automatic` | Spacer 所在位置          |

### 行为说明

- `flexible`: 工具栏中的弹性空间，它会占据剩余区域。
- `fixed`: 提供固定间隔，适合多个按钮之间进行细微布局。

## 示例：在同一组中强制按钮分隔

```tsx
<Toolbar>
  <ToolbarItem placement="topBarTrailing">
    <Button title="Edit" action={edit} />
  </ToolbarItem>
  <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
  <ToolbarItem placement="topBarTrailing">
    <Button title="Save" action={save} />
  </ToolbarItem>
</Toolbar>
```

***

# DefaultToolbarItem

```ts
type ToolbarDefaultItemKind = "sidebarToggle" | "search" | "title";

type DefaultToolbarItemProps = {
  kind: ToolbarDefaultItemKind;
  placement?: ToolbarItemPlacement;
};

declare const DefaultToolbarItem: FunctionComponent<DefaultToolbarItemProps>;
```

用于渲染系统提供的默认工具栏项目，例如侧边栏切换按钮、搜索按钮、标题显示等。

## 参数说明

| 参数          | 类型                                       | 默认值         | 说明         |
| ----------- | ---------------------------------------- | ----------- | ---------- |
| `kind`      | `"sidebarToggle" \| "search" \| "title"` | 无           | 选择系统默认项目类型 |
| `placement` | `ToolbarItemPlacement`                   | `automatic` | 放置位置       |

## 示例：添加默认的搜索栏按钮

```tsx
<Toolbar>
  <DefaultToolbarItem kind="search" placement="topBarTrailing" />
</Toolbar>
```

***

# 综合示例：使用 Toolbar 构建复杂工具栏

```tsx
<NavigationStack>
  <List
    toolbar={
      <Toolbar>

        {/* 左侧导航按钮 */}
        <ToolbarItem placement="navigation">
          <Button title="返回" action={Navigation.useDismiss()} />
        </ToolbarItem>

        {/* 标题 */}
        <DefaultToolbarItem kind="title" />

        {/* 右侧一组按钮 */}
        <ToolbarItem placement="topBarTrailing">
          <Button title="编辑" action={edit} />
        </ToolbarItem>
        <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
        <ToolbarItem placement="topBarTrailing">
          <Button title="完成" action={finish} />
        </ToolbarItem>

        {/* 底部区域按钮 */}
        <ToolbarItem placement="bottomBar">
          <Button title="帮助" action={showHelp} />
        </ToolbarItem>

      </Toolbar>
    }
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

此结构灵活而清晰，可复现 SwiftUI 中复杂的工具栏布局。

***

# 与 ToolBarProps 的关系

在 API 层面：

| 方式                                          | 说明                  |
| ------------------------------------------- | ------------------- |
| `toolbar={ { topBarTrailing: <Button/> } }` | 简洁、直观，适合简单场景        |
| `toolbar={<Toolbar>...</Toolbar>}`          | 可组合，可精确布局，适合复杂、多组内容 |

两种方式完全兼容，可根据需要选择。

***

# 总结

Toolbar 组件提供了高度灵活的工具栏布局能力，包括：

- 单项工具栏项 (`ToolbarItem`)
- 工具栏项目组 (`ToolbarItemGroup`)
- 自适应空白区域 (`ToolbarSpacer`)
- 系统默认工具栏元素 (`DefaultToolbarItem`)
- 容器式声明 (`<Toolbar>`)



---
url: /zh/guide/Changelog/2.4.4/matchedGeometryEffect.md
---

# 匹配几何效果（matchedGeometryEffect）

`matchedGeometryEffect` 用于在 **不同视图之间建立几何关联关系**，使视图在：

- 位置变化
- 尺寸变化
- 布局层级变化
- 条件渲染切换

这些场景中，仍然保持 **连续、平滑、空间一致的动画过渡效果**。

该能力对应 SwiftUI 中的 `matchedGeometryEffect`，属于 **组件级几何联动动画系统**，不依赖导航系统。

***

## 一、API 定义

```ts
matchedGeometryEffect?: {
  id: string | number
  namespace: NamespaceID
  properties?: MatchedGeometryProperties
  anchor?: Point | KeywordPoint
  isSource?: boolean
}
```

```ts
type MatchedGeometryProperties = "frame" | "position" | "size"
```

***

## 二、核心作用

`matchedGeometryEffect` 的核心作用是：

> 让两个“逻辑上是同一个元素”的视图，在 **不同布局结构中共享几何信息**，从而产生连续的过渡动画。

它解决的问题包括：

- 视图从一个容器移动到另一个容器时的“跳变”
- 视图尺寸变化时的“突变”
- 列表项展开为详情页时的“断层感”
- Tab 切换指示器的“瞬移感”

***

## 三、参数详解

### 1. id（几何匹配唯一标识）

```ts
id: string | number
```

- 用于标识这是 **哪一个几何元素**
- 在同一个 `namespace` 下：

  - **id 相同的视图才会参与几何匹配**
- 通常来自：

  - 数据模型 ID
  - 索引值
  - 业务唯一标识

规则：

- id 必须稳定
- 动画期间不能频繁变化
- 同一时刻：

  - 一个 id 只能有一个 `isSource = true`

***

### 2. namespace（几何命名空间）

```ts
namespace: NamespaceID
```

- 用于将多个匹配动画分组隔离
- 不同 namespace 之间：

  - 即使 id 相同，也不会产生动画
- 必须由 `NamespaceReader` 创建并注入

规则：

- source 与 target 必须使用 **同一个 namespace**
- 不允许跨 namespace 匹配

***

### 3. properties（参与匹配的几何属性）

```ts
properties?: "frame" | "position" | "size"
```

默认值：

```ts
properties = "frame"
```

含义说明：

| 值            | 含义          |
| ------------ | ----------- |
| `"frame"`    | 同时匹配位置 + 尺寸 |
| `"position"` | 仅匹配中心点位置    |
| `"size"`     | 仅匹配尺寸，不匹配位置 |

选择原则：

- `"frame"`：最完整、最自然的动画
- `"position"`：指示器、滑块、选中背景
- `"size"`：放大缩小、展开收起

***

### 4. anchor（锚点）

```ts
anchor?: Point | KeywordPoint
```

默认值：

```ts
anchor = "center"
```

作用：

- 决定动画进行时：

  - 元素是从哪个相对位置进行对齐和计算的

常见取值：

- `"center"`
- `"topLeading"`
- `"topTrailing"`
- `"bottomLeading"`
- `"bottomTrailing"`

使用场景：

- 卡片从左上角展开
- 头像从右上角放大
- 底部元素向上弹出

***

### 5. isSource（是否作为几何数据的“源”）

```ts
isSource?: boolean
```

默认值：

```ts
isSource = true
```

含义说明：

| 值       | 行为             |
| ------- | -------------- |
| `true`  | 当前视图向外“提供”几何数据 |
| `false` | 当前视图“接收”几何动画结果 |

标准使用模式：

- 原始视图：`isSource = true`
- 目标视图：`isSource = false`

如果省略：

- 第一个出现的视图默认作为 source
- 其余作为接收方

***

## 四、最小可用示例（位置 + 尺寸联动）

该示例演示：
一个圆形在两个区域之间切换位置与尺寸，并保持连续动画。

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <VStack spacing={40}>
      <Button
        title="Toggle"
        action={() => {
          expanded.setValue( !expanded.value)
        }}
      />

      <ZStack
        frame={{ width: 300, height: 200 }}
        background="systemGray6"
      >
        {!expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 60, height: 60 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace
            }}
          />
        )}
      </ZStack>

      <ZStack
        frame={{ width: 300, height: 300 }}
        background="systemGray4"
      >
        {expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 150, height: 150 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace,
              isSource: false
            }}
          />
        )}
      </ZStack>
    </VStack>
  )}
</NamespaceReader>
```

该示例实现的动画效果：

- 同一个圆：

  - 从上方小尺寸区域
  - 平滑移动并放大到下方大区域
- 无跳变、无突变、无瞬移

***

## 五、仅同步“位置”的示例（指示器动画）

```tsx
const selected = useObservable(0)

return <NamespaceReader>
  {namespace => (
    <HStack spacing={24}>
      <Text
        onTapGesture={() => selected.setValue(0)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 0
        }}
      >
        Tab 1
      </Text>

      <Text
        onTapGesture={() => selected.setValue(1)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 1
        }}
      >
        Tab 2
      </Text>
    </HStack>
  )}
</NamespaceReader>
```

适用于：

- Tab 选中动画
- 滑块指示器
- 选中背景平移

***

## 六、仅同步“尺寸”的示例（放大缩小）

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <ZStack>
      <Circle
        fill="systemBlue"
        frame={{
          width: expanded.value ? 200 : 80,
          height: expanded.value ? 200 : 80
        }}
        matchedGeometryEffect={{
          id: "avatar",
          namespace,
          properties: "size"
        }}
        onTapGesture={() => {
          expanded.setValue(!expanded.value)
        }}
      />
    </ZStack>
  )}
</NamespaceReader>
```

适用于：

- 头像放大
- 卡片展开
- 按钮按压动画

***

## 七、多元素联动示例（卡片 → 详情）

```tsx
<NamespaceReader>
  {namespace => (
    <ZStack>
      {!showDetail.value && (
        <VStack spacing={16}>
          <Image
            source="cover"
            matchedGeometryEffect={{
              id: "card.image",
              namespace
            }}
          />
          <Text
            matchedGeometryEffect={{
              id: "card.title",
              namespace
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}

      {showDetail.value && (
        <VStack spacing={24}>
          <Image
            source="cover"
            frame={{ width: 300, height: 200 }}
            matchedGeometryEffect={{
              id: "card.image",
              namespace,
              isSource: false
            }}
          />
          <Text
            font="largeTitle"
            matchedGeometryEffect={{
              id: "card.title",
              namespace,
              isSource: false
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}
    </ZStack>
  )}
</NamespaceReader>
```

效果说明：

- 图片与标题同时参与几何匹配
- 从卡片形态平滑过渡为详情页布局
- 无需使用导航动画

***

## 八、关键使用规则总结

1. **namespace 必须完全相同**
2. **id 必须完全一致**
3. 同一时刻：

   - 一个 id 只能有一个 `isSource = true`
4. 默认行为：

   ```ts
   properties = "frame"
   anchor = "center"
   isSource = true
   ```
5. source 与 target 必须：

   - 同一渲染周期内完成切换
6. 如果 source 和 target：

   - 同时存在，且都为 `isSource = true`
     → 动画不确定，可能失效
7. Widget 与 Live Activity 环境不支持完整 matchedGeometry 动画能力

***

## 九、适用场景总结

适合使用 `matchedGeometryEffect` 的场景：

- Tab 指示器动画
- 卡片 → 详情展开
- 图片放大预览
- 列表项选中动画
- 分栏布局中的选中项切换

不适合使用的场景：

- 高频数据刷新列表
- 大量同时进行几何动画的复杂视图树
- 帧率敏感的实时图表



---
url: /zh/guide/Changelog/2.4.4/matchedTransitionSource.md
---

# 匹配过渡源（matchedTransitionSource）

`matchedTransitionSource` 用于 **标记某个视图作为“导航转场动画的几何源视图”**，使该视图在页面跳转时可以作为：

- 缩放动画的起点
- 位置过渡的起点
- 共享几何动画的起始帧

该能力对应 SwiftUI 中的 `matchedTransitionSource`，主要用于：

- 页面级导航动画
- Zoom（缩放）转场
- Hero 动画（共享元素转场）

它 **只用于导航转场**，不用于组件级几何联动（组件级联动应使用 `matchedGeometryEffect`）。

***

## 一、API 定义

```ts
/**
 * Identifies this view as the source of a navigation transition, such as a zoom transition.
 * @available iOS 18.0+
 */
matchedTransitionSource?: {
  id: string | number
  namespace: NamespaceID
}
```

***

## 二、核心作用

`matchedTransitionSource` 的核心作用是：

> 在一次导航跳转中，指定“从哪个视图开始做几何过渡动画”。

它解决的问题是：

- 页面跳转时视图“瞬间消失 + 新页面突然出现”的割裂感
- 图片、卡片、头像等元素在跳转时缺乏空间连续性
- 无法实现从“点击的那个元素”缩放进入目标页面的效果

通过 `matchedTransitionSource`，可以实现典型的：

- 图片 → 图片详情页的缩放动画
- 卡片 → 详情页的 Hero 动画
- 头像 → 个人主页的放大过渡

***

## 三、参数详解

### 1. id（转场源唯一标识）

```ts
id: string | number
```

含义：

- 标识“这是哪一个转场源视图”
- 必须与目标页面中 `navigationTransition.sourceID` 完全一致

规则：

- 同一个 `namespace` 内：

  - `id` 必须唯一
- 一次导航转场中：

  - 只能有一个 `matchedTransitionSource` 与 `sourceID` 对应

***

### 2. namespace（转场命名空间）

```ts
namespace: NamespaceID
```

含义：

- 用于把“源视图”和“目标页面”放入同一个转场作用域
- 由 `NamespaceReader` 创建并注入

规则：

1. 源视图与目标页面 **必须使用同一个 namespace**
2. 不同 namespace 之间 **绝对不会发生转场匹配**
3. 即使 `id` 相同，只要 namespace 不同，也不会触发动画

***

## 四、matchedTransitionSource 的工作机制

一次完整的导航缩放转场，必须同时满足以下四个条件：

1. **源视图定义了 `matchedTransitionSource`**
2. **目标页面定义了 `navigationTransition`**
3. **`sourceID === matchedTransitionSource.id`**
4. **两者使用的是同一个 `namespace`**

只有在这四个条件全部满足时，系统才会：

- 读取源视图的：

  - 真实 Frame
  - 屏幕位置
  - 缩放比例
- 读取目标页面的最终布局 Frame
- 自动计算：

  - 初始缩放比例
  - 平移路径
  - 最终尺寸
- 并生成完整的缩放过渡动画

***

## 五、最小可用示例：图片缩放进入详情页

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        frame={{
          width: 120,
          height: 160
        }}
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

### 该示例实现的效果

1. 用户点击封面图片
2. 页面开始跳转到 `DetailPage`
3. 新页面并不是“直接出现”
4. 而是：

   - 从点击的那张图片位置开始
   - 按比例放大
   - 平滑过渡到详情页的最终布局

***

## 六、卡片 → 详情页 Hero 动画示例

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "card-1"
          }}
        />
      }
    >
      <VStack
        frame={{
          width: 280,
          height: 180
        }}
        background="systemGray6"
        matchedTransitionSource={{
          id: "card-1",
          namespace
        }}
      >
        <Text>Card Title</Text>
      </VStack>
    </NavigationLink>
  )}
</NamespaceReader>
```

该示例实现：

- 整个卡片作为转场起点
- 跳转后卡片“变形为”详情页容器
- 具备典型的 Hero 动画特征

***

## 七、matchedTransitionSource 与 matchedGeometryEffect 的本质区别

| 对比项             | matchedTransitionSource | matchedGeometryEffect |
| --------------- | ----------------------- | --------------------- |
| 使用场景            | 页面级导航转场                 | 组件级几何联动               |
| 是否依赖 Navigation | 是                       | 否                     |
| 是否支持多个元素同步      | 否                       | 是                     |
| 是否需要 sourceID   | 是                       | 否                     |
| 是否控制 properties | 否                       | 是                     |
| 是否支持布局内动画       | 否                       | 是                     |

一句话总结：

- `matchedTransitionSource`：**只负责“从哪儿开始跳页面”**
- `matchedGeometryEffect`：**负责“布局内部怎么动”**

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- `sourceID` 是否与 `matchedTransitionSource.id` 完全一致
- 是否使用了同一个 `namespace`
- 是否真的发生了 `NavigationLink` 跳转

***

### 2. 动画方向异常或缩放错位

常见原因：

- 源视图有 `scaleEffect`、`offset` 等变换
- 源视图所在的容器使用了：

  - `clipShape`
  - `mask`
  - `containerShape`

这些变换会影响系统获取“真实几何 Frame”。

***

### 3. 同时存在多个 source

错误示例：

- 同一个页面中：

  - 多个视图都使用了相同 `id`
  - 且都设置了 `matchedTransitionSource`

后果：

- 系统无法判定哪个才是转场源
- 动画结果不可预测

***

## 九、使用限制说明

1. `matchedTransitionSource` 仅适用于：

   - `NavigationLink`
   - 基于 Navigation 的页面跳转
2. 在以下环境中不支持或行为受限：

   - Widget
   - Live Activity
3. 不适用于：

   - 组件内部状态切换
   - tab 切换
   - 展开折叠菜单

这些场景应使用 `matchedGeometryEffect`。

***

## 十、适用场景总结

非常适合使用 `matchedTransitionSource` 的场景：

- 图片点击 → 图片详情页
- 文章封面 → 阅读页
- 商品卡片 → 商品详情页
- 用户头像 → 个人主页
- 卡片列表 → 大卡详情页

不适合使用的场景：

- 高频切换的 UI 状态
- 大量小组件同时动画
- 实时刷新型界面



---
url: /zh/guide/Changelog/2.4.5/AVPlayerView.md
---

# 视频播放组件(AVPlayerView)

`AVPlayerView` 是 Scripting 提供的视频播放组件，基于系统原生 `AVPlayerViewController` 封装。
与 `VideoPlayer` 不同，`AVPlayerView` **完整支持系统级 Picture in Picture（画中画，PiP）**，并允许脚本层监听 PiP 的生命周期变化。

该组件适用于对**原生播放行为、后台播放、PiP、锁屏与控制中心联动**有明确需求的媒体类场景。

***

## 一、何时使用 AVPlayerView

当你的场景满足以下任意条件时，应使用 `AVPlayerView`：

- 需要视频进入系统 PiP 模式
- 需要原生播放控制 UI
- 需要在后台持续播放视频
- 需要与系统 Now Playing / 锁屏 / 控制中心联动
- 需要精确感知 PiP 的开始与结束

如果仅做简单的视频展示且不需要 PiP，`VideoPlayer` 仍然是更轻量的选择。

***

## 二、核心属性详解

### 1. `player`

```ts
player: AVPlayer
```

- 实际执行播放的核心对象
- 由开发者自行创建和管理
- 支持网络视频、本地文件、HLS 等格式

`AVPlayerView` **不会管理播放器的生命周期**，播放器在 PiP 期间必须保持存活。

***

### 2. `pipStatus`

```ts
pipStatus: Observable<PIPStatus>
```

用于监听系统 PiP 的生命周期状态变化。

可能的取值如下：

| 状态                 | 含义            |
| ------------------ | ------------- |
| `willStart`        | PiP 即将开始      |
| `didStart`         | PiP 已开始       |
| `willStop`         | PiP 即将结束      |
| `didStop`          | PiP 已结束       |
| `undefined / null` | 尚未进入 PiP 生命周期 |

该状态完全由系统控制，**只能监听，不应手动修改**。

***

## 三、PiP 相关配置项

### 1. `allowsPictureInPicturePlayback`

```ts
allowsPictureInPicturePlayback?: boolean
```

- 是否允许视频进入 PiP
- 默认值：`true`

若设为 `false`：

- 系统 PiP 按钮不会显示
- 视频无法进入画中画模式

***

### 2. `canStartPictureInPictureAutomaticallyFromInline`

```ts
canStartPictureInPictureAutomaticallyFromInline?: boolean
```

- 当应用从前台切换到后台时，是否自动进入 PiP
- 默认值：`false`

适合以下场景：

- 用户按下 Home 键离开应用
- 希望播放不中断并自动进入 PiP

***

### 3. `updatesNowPlayingInfoCenter`

```ts
updatesNowPlayingInfoCenter?: boolean
```

- 是否自动更新系统 Now Playing 信息
- 默认值：`true`

开启后，视频信息会显示在：

- 锁屏界面
- 控制中心
- 外接播放设备

***

## 四、全屏播放行为

### 1. `entersFullScreenWhenPlaybackBegins`

```ts
entersFullScreenWhenPlaybackBegins?: boolean
```

- 播放开始时是否自动进入全屏
- 默认值：`false`

***

### 2. `exitsFullScreenWhenPlaybackEnds`

```ts
exitsFullScreenWhenPlaybackEnds?: boolean
```

- 播放结束时是否自动退出全屏
- 默认值：`false`

***

## 五、视频显示方式（videoGravity）

```ts
videoGravity?: AVLayerVideoGravity
```

| 值                  | 行为说明           |
| ------------------ | -------------- |
| `resize`           | 拉伸填满，不保持比例     |
| `resizeAspect`     | 保持比例，完整显示（默认）  |
| `resizeAspectFill` | 保持比例，填满区域，可能裁剪 |

***

## 六、完整 DEMO 示例

以下示例演示了：

- 创建并配置 `AVPlayer`
- 正确配置音频会话
- 监听 PiP 生命周期
- 控制播放 / 暂停
- 正确释放资源

```tsx
function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(
    TimeControlStatus.paused
  )
  const pipstatus = useObservable<PIPStatus>()

  console.log(pipstatus.value)

  const player = useMemo(() => {
    const player = new AVPlayer()

    player.setSource(
      "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
    )

    player.onTimeControlStatusChanged = status => {
      setStatus(status)
    }

    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      "playback",
      ["defaultToSpeaker"]
    )

    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="VideoPlayer"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        cancellationAction: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <AVPlayerView
        player={player}
        pipStatus={pipstatus}
        canStartPictureInPictureAutomaticallyFromInline
        updatesNowPlayingInfoCenter
        entersFullScreenWhenPlaybackBegins
      />

      <Button
        title={
          status === TimeControlStatus.paused
            ? "Play"
            : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 七、PiP 生命周期说明

PiP 状态通常按以下顺序变化：

1. `willStart`
2. `didStart`
3. PiP 运行中
4. `willStop`
5. `didStop`

在异常或系统打断情况下，部分状态可能被跳过，因此应以 `didStart` 和 `didStop` 作为最终判断依据。

***

## 八、重要注意事项

### 1. AVPlayerView 使用的是系统级视频 PiP

- 基于系统原生视频 PiP
- 与 Scripting 的自定义 PiP View Modifiers **完全不同**
- 两种 PiP 机制不可混用

***

### 2. PiP 依赖正确的音频会话配置

要保证 PiP 正常工作，必须：

- 激活音频会话
- 使用 `playback` 类别
- 正确配置后台音频能力

否则可能出现 PiP 无法启动或静默失败的情况。

***

### 3. PiP 期间不要销毁 AVPlayer

- PiP 运行中销毁或替换 `AVPlayer`
- 会导致 PiP 异常退出
- 甚至触发系统错误

应在 `pipStatus` 变为 `didStop` 后再释放播放器资源。

***

## 九、推荐实践总结

- 视频 PiP 场景始终使用 `AVPlayerView`
- 将 `pipStatus` 视为只读状态
- PiP 期间保持 `AVPlayer` 生命周期稳定
- 显式配置音频会话
- 避免频繁创建或替换播放器
- 在 PiP 完全结束后再释放资源



---
url: /zh/guide/Changelog/2.4.5/AppStore.md
---

# AppStore

`AppStore` API 用于在 **不离开 Scripting 应用** 的情况下，展示 App Store 中某个应用的详情页面。
该能力基于系统原生的 App Store 展示组件，适合用于实现 **应用推荐、应用收藏夹、关联应用跳转、生态扩展入口** 等场景。

***

## 命名空间：`AppStore`

```ts
namespace AppStore
```

***

## 功能概述

- 在 Scripting App 内以 **模态窗口（Modal）** 方式展示指定 App 的 App Store 页面
- 用户可直接查看应用介绍、截图、评分、更新日志
- 用户可在该页面中完成 **下载 / 更新 / 打开应用**
- 关闭后自动返回当前脚本页面
- 不会跳转到系统 App Store 应用

***

## 方法一览

| 方法                       | 说明                      |
| ------------------------ | ----------------------- |
| `presentApp(id: string)` | 打开指定 App 的 App Store 页面 |
| `dismissApp()`           | 主动关闭当前展示的 App Store 页面  |

***

## 方法说明

### `presentApp(id: string): Promise<void>`

在 Scripting App 内展示指定 App 的 App Store 页面。

#### 参数

| 参数   | 类型       | 说明                              |
| ---- | -------- | ------------------------------- |
| `id` | `string` | App 的 **App Store 标识符（App ID）** |

- 该 ID 是 App Store 中的数字 ID
- 通常可从 App Store URL 中获取
  例如：
  `https://apps.apple.com/app/id123456789`
  则 `id` 为 `"123456789"`

#### 返回值

- 返回一个 `Promise<void>`
- 当用户 **关闭 App Store 模态页面** 时，Promise resolve
- 如果当前已经有一个 App Store 页面在展示中，则会抛出错误

#### 行为说明

- 以模态方式打开 App Store 页面
- 同一时间 **只能存在一个 App Store 模态窗口**
- 如果重复调用 `presentApp`，将导致 Promise reject

#### 示例

```ts
await AppStore.presentApp("123456789")
```

***

### `dismissApp(): Promise<void>`

关闭当前通过 `presentApp` 打开的 App Store 页面。

#### 返回值

- 返回一个 `Promise<void>`
- 当模态页面成功关闭后 resolve

#### 使用说明

- 一般情况下不需要手动调用
- 适用于：

  - 自定义 UI 控制关闭行为
  - 脚本中需要在特定逻辑点强制关闭 App Store 页面

#### 示例

```ts
await AppStore.dismissApp()
```

***

## 使用示例

### 示例一：应用推荐入口

```ts
import { Button } from "scripting"

function AppRecommendation() {
  return (
    <Button
      title="查看推荐应用"
      action={() => {
        AppStore.presentApp("123456789")
      }}
    />
  )
}
```

***

### 示例二：应用收藏夹

```ts
const favoriteApps = [
  { name: "App A", id: "123456789" },
  { name: "App B", id: "987654321" }
]

function AppList() {
  return favoriteApps.map(app => (
    <Button
      title={app.name}
      action={() => {
        AppStore.presentApp(app.id)
      }}
    />
  ))
}
```

***

## 错误与注意事项

### 常见错误

- **已有 App Store 页面正在展示**

  - 再次调用 `presentApp` 会抛出错误
  - 建议在逻辑层控制调用时机

### 使用限制

- 仅支持 App Store 应用页面
- 不支持展示订阅页、开发者主页等其他 App Store 内容
- 必须传入有效的 App Store App ID



---
url: /zh/guide/Changelog/2.4.5/Assistant/Assistant Conversation APIs.md
---

# 智能助手会话 API

Conversation API 用于**启动、控制和展示一个由系统托管的 Assistant 对话会话**。
该会话对应一个**完整的聊天页面（Chat Page）**，由 Scripting App 统一管理 UI、状态和模型交互。

与 `requestStreaming` / `requestStructuredData` 的区别在于：

- Conversation API 面向**交互式聊天体验**
- 系统负责消息发送、流式输出、Provider 切换、UI 渲染
- 开发者只需关注“何时开始 / 何时结束 / 是否展示”

***

## 会话生命周期概览

一个典型的会话生命周期如下：

1. `startConversation` —— 创建会话（可选自动开始）
2. `present` —— 展示 Assistant 聊天页面
3. 用户与 Assistant 进行交互
4. `dismiss` —— 临时关闭聊天页面（会话仍存在）
5. `present` —— 再次展示会话
6. `stopConversation` —— 结束会话并释放资源

重要约束：

- **同一时间只能存在一个活动会话**
- 若已有会话在运行，再次调用 `startConversation` 会抛出错误
- 调用 `stopConversation` 会自动触发 `dismiss`

***

## startConversation

### API 定义

```ts
function startConversation(options: {
  message: string
  images?: UIImage[]
  autoStart?: boolean
  systemPrompt?: string
  modelId?: string
  provider?: Provider
}): Promise<void>
```

***

### 参数说明

#### options.message

- 类型：`string`
- 必填
- 会话的**初始用户消息**
- 相当于聊天页面中的第一条用户输入

***

#### options.images（可选）

- 类型：`UIImage[]`
- 会与 `message` 一起作为首条用户消息发送
- 适用于：

  - 图片分析
  - 拍照 / 截图后直接发起对话

***

#### options.autoStart（可选）

- 类型：`boolean`
- 默认值：`false`

行为说明：

- `true`：

  - 创建会话后立即开始生成回复
- `false`：

  - 仅创建会话，不自动发送
  - 通常配合 `present` 使用，由用户点击发送

***

#### options.systemPrompt（可选）

- 类型：`string`

说明：

- 若未提供：

  - 使用 Scripting Assistant 内置 system prompt
  - Assistant Tools 可用
- 若提供：

  - 完全替换默认 system prompt
  - **Assistant Tools 将不可用**

适用场景：

- 构建高度定制的聊天角色
- 禁用工具调用，仅使用纯模型能力

***

#### options.modelId（可选）

- 类型：`string`
- 指定本次会话使用的模型
- 用户仍可在聊天页面中手动切换模型（若 UI 允许）

***

#### options.provider（可选）

- 类型：`Provider`
- 指定默认 Provider
- 用户可在聊天页面中更改 Provider（若 UI 允许）

***

### 返回值

```ts
Promise<void>
```

- 会话创建成功即 resolve
- 若已有会话存在，将 reject

***

## present

### API 定义

```ts
function present(): Promise<void>
```

***

### 行为说明

- 展示当前会话对应的 Assistant 聊天页面
- 若页面已展示，调用不会产生额外效果
- 可在以下场景调用：

  - `startConversation` 之后首次展示
  - `dismiss` 后重新展示同一会话

***

### 返回值

```ts
Promise<void>
```

- 当聊天页面被用户关闭时 resolve

***

## dismiss

### API 定义

```ts
function dismiss(): Promise<void>
```

***

### 行为说明

- 关闭 Assistant 聊天页面
- **不会终止会话**
- 会话状态、历史消息仍保留

适用场景：

- 临时让出界面空间
- 页面跳转或多任务切换

***

### 返回值

```ts
Promise<void>
```

- 页面成功关闭后 resolve

***

## stopConversation

### API 定义

```ts
function stopConversation(): Promise<void>
```

***

### 行为说明

- 彻底终止当前会话
- 自动调用 `dismiss`
- 清理会话状态与资源
- 结束后可再次调用 `startConversation` 创建新会话

***

### 返回值

```ts
Promise<void>
```

***

## 会话状态相关常量

### Assistant.isAvailable

```ts
const isAvailable: boolean
```

- 表示当前用户是否**具备使用 Assistant 的权限**
- 若为 `false`：

  - 所有 Conversation API 均不可用

***

### Assistant.isPresented

```ts
const isPresented: boolean
```

- 表示 Assistant 聊天页面当前是否处于展示状态

***

### Assistant.hasActiveConversation

```ts
const hasActiveConversation: boolean
```

- 表示当前是否存在一个活动会话
- 常用于防止重复调用 `startConversation`

***

## 使用示例

### 示例一：最常见的使用方式

```ts
await Assistant.startConversation({
  message: "帮我总结这篇文章的要点",
  autoStart: true
})

await Assistant.present()
```

***

### 示例二：创建会话但不自动发送

```ts
await Assistant.startConversation({
  message: "我们来讨论一下系统架构设计",
  autoStart: false
})

await Assistant.present()
// 由用户在 UI 中手动点击发送
```

***

### 示例三：暂时关闭，再次展示

```ts
await Assistant.startConversation({
  message: "分析这张图片",
  images: [image],
  autoStart: true
})

await Assistant.present()

// 用户关闭页面
await Assistant.dismiss()

// 稍后再次展示同一会话
await Assistant.present()
```

***

### 示例四：结束当前会话并重新开始

```ts
if (Assistant.hasActiveConversation) {
  await Assistant.stopConversation()
}

await Assistant.startConversation({
  message: "开始一个新的话题",
  autoStart: true
})

await Assistant.present()
```

***

## 使用建议与最佳实践

- 将 Conversation API 视为“**托管聊天界面**”
- 不要在同一业务流中混用 Conversation API 与 `requestStreaming`
- 在调用 `startConversation` 前检查 `hasActiveConversation`
- 若仅需要数据或一次性输出，应使用：

  - `requestStructuredData`
  - `requestStreaming`
- 若用户需要持续交互体验，应使用 Conversation API

***

## 设计边界说明

- Conversation API 不适合无 UI 场景
- 不适合后台自动化任务
- 不适合需要完全控制 Prompt / Token / 输出格式的场景



---
url: /zh/guide/Changelog/2.4.5/Assistant/Assistant Quick Start.md
---

# 快速了解智能助手

Scripting 的 Assistant API 提供了三类能力，分别面向 **数据处理**、**流式输出** 和 **交互式聊天** 三种不同使用场景。
在使用之前，建议先明确你的需求属于哪一类。

***

## Assistant API 分类总览

| API 分类 | 主要方法                                                             | 适用场景                   |
| ------ | ---------------------------------------------------------------- | ---------------------- |
| 结构化数据  | `requestStructuredData`                                          | 从文本 / 图片中提取结构化 JSON 数据 |
| 流式生成   | `requestStreaming`                                               | 实时展示 AI 输出内容           |
| 会话聊天   | `startConversation` / `present` / `dismiss` / `stopConversation` | 托管式聊天体验                |

***

## requestStructuredData

**用途**
用于请求**严格符合 JSON Schema 的结构化结果**。

**适合场景**

- 解析票据、发票、账单
- 从自然语言中提取字段
- 生成配置、规则、表单数据
- 需要直接用于程序逻辑的数据

**特点**

- 返回值稳定、可预测
- 不适合长文本或展示型输出
- 适合后台或无 UI 场景

**一句话总结**

> 需要“数据”，用 `requestStructuredData`

***

## requestStreaming

**用途**
用于获取**流式输出**，在模型生成过程中持续接收内容。

**适合场景**

- 聊天气泡逐字显示
- 长文本生成（文章、说明、分析）
- 需要低延迟反馈的 UI

**特点**

- 支持文本、推理、用量等多种 Chunk
- 可边生成边渲染
- 不保证输出结构

**一句话总结**

> 需要“过程”和“实时展示”，用 `requestStreaming`

***

## Conversation API（会话聊天）

**相关方法**

- `startConversation`
- `present`
- `dismiss`
- `stopConversation`

**用途**
用于创建并展示一个**系统托管的 Assistant 聊天页面**。

**适合场景**

- 类 ChatGPT 的交互体验
- 用户需要多轮对话
- 希望系统管理 UI、Provider 切换、消息状态

**特点**

- 内置完整聊天 UI
- 自动处理流式输出
- 同一时间仅支持一个会话

**一句话总结**

> 需要“完整聊天体验”，用 Conversation API

***

## 如何选择合适的 API

### 常见选择指南

- **我要解析一张账单 →** `requestStructuredData`
- **我要展示 AI 写文章的过程 →** `requestStreaming`
- **我要打开一个聊天页面让用户和 AI 对话 →** Conversation API
- **我不需要 UI，只要结果 →** `requestStructuredData` 或 `requestStreaming`
- **我希望系统帮我处理聊天 UI →** Conversation API

***

## 简单示例

### 结构化数据

```ts
const data = await Assistant.requestStructuredData(...)
```

***

### 流式输出

```ts
const stream = await Assistant.requestStreaming(...)
for await (const chunk of stream) {
  // handle chunk
}
```

***

### 聊天会话

```ts
await Assistant.startConversation({ message: "你好", autoStart: true })
await Assistant.present()
```

***

## 使用建议

- 不要在同一业务流程中混用 Conversation API 和 `requestStreaming`
- 有明确数据结构需求时，优先选择 `requestStructuredData`
- 展示型输出和交互体验优先考虑 `requestStreaming` 或 Conversation API

***

## 下一步

如果你需要更深入的内容，可以继续阅读：

- `requestStructuredData` 详细文档
- `requestStreaming` 详细文档
- Conversation API 生命周期说明



---
url: /zh/guide/Changelog/2.4.5/Assistant/requestStreaming.md
---

# 请求流式数据

`requestStreaming` 用于向 Assistant 请求**流式输出（Streaming Response）**。
与一次性返回完整结果不同，该 API 会在模型生成内容的过程中**持续返回数据片段（Chunk）**，调用方可以边接收边处理，从而实现：

- 实时展示 AI 输出（打字机效果）
- 流式日志 / 分段结果处理
- 长文本生成的低延迟体验
- 在生成过程中提前终止或切换 UI 状态

该 API 返回的是一个 **`ReadableStream<StreamChunk>`**，你可以通过 `for await ... of` 逐块读取。

***

## API 定义

```ts
function requestStreaming(options: {
  systemPrompt?: string | null
  messages: MessageItem | MessageItem[]
  provider?: Provider
  modelId?: string
}): Promise<ReadableStream<StreamChunk>>
```

***

## 参数说明

### options.systemPrompt（可选）

- 类型：`string | null`
- 指定本次请求使用的 system prompt
- 若未提供：

  - 使用 Assistant 内置的默认 system prompt
- 若显式传入：

  - 将**完全替换默认 system prompt**
  - Assistant Tools 将**不可用**

适用场景：

- 构建专用角色（如代码审查、翻译、摘要）
- 严格约束模型行为或输出风格

***

### options.messages

- 类型：`MessageItem | MessageItem[]`
- 必填
- 用于描述对话上下文的消息列表

#### MessageItem 结构

```ts
type MessageItem = {
  role: "user" | "assistant"
  content: MessageContent | MessageContent[]
}
```

- `role`

  - `"user"`：用户输入
  - `"assistant"`：历史 Assistant 输出（用于上下文补全）

***

### MessageContent 类型

#### 文本内容

```ts
type MessageTextContent =
  | string
  | { type: "text"; content: string }
```

***

#### 图片内容

```ts
type MessageImageContent = {
  type: "image"
  content: string // data:image/...;base64,...
}
```

***

#### 文档内容

```ts
type MessageDocumentContent = {
  type: "document"
  content: {
    mediaType: string
    data: string // base64
  }
}
```

***

### options.provider（可选）

- 类型：`Provider`
- 指定使用的 AI Provider
- 若未指定：

  - 使用 Assistant 当前配置的默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 若未指定，使用 Provider 默认模型

***

## 返回值

```ts
Promise<ReadableStream<StreamChunk>>
```

该 Promise resolve 后，你将获得一个可异步迭代的流对象。

***

## StreamChunk 类型说明

`requestStreaming` 的流中会返回以下三类 Chunk。

***

### StreamTextChunk（文本输出）

```ts
type StreamTextChunk = {
  type: "text"
  content: string
}
```

- 表示 Assistant 生成的**可展示文本**
- 多个 chunk 拼接后构成完整回复

***

### StreamReasoningChunk（推理输出）

```ts
type StreamReasoningChunk = {
  type: "reasoning"
  content: string
}
```

- 表示模型的**中间推理过程**
- 是否返回、返回粒度取决于 Provider / Model

***

### StreamUsageChunk（用量信息）

```ts
type StreamUsageChunk = {
  type: "usage"
  content: {
    totalCost: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    inputTokens: number
    outputTokens: number
  }
}
```

说明：

- 通常在流的**末尾**返回一次
- 不同 Provider 支持的字段略有差异
- `totalCost` 可能为 `null`（例如 Provider 未提供费用信息）

***

## 使用示例

### 示例一：最基本的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: {
    role: "user",
    content: "给我讲一个简短的科幻故事"
  },
  provider: "openai"
})

let text = ""

for await (const chunk of stream) {
  if (chunk.type === "text") {
    text += chunk.content
    console.log(chunk.content)
  }
}
```

***

### 示例二：区分文本、推理和用量

```ts
const stream = await Assistant.requestStreaming({
  systemPrompt: "你是一个严谨的技术写作助手",
  messages: [
    {
      role: "user",
      content: "解释什么是 HTTP/3"
    }
  ]
})

let answer = ""
let reasoningLog = null
let usage = null

for await (const chunk of stream) {
  switch (chunk.type) {
    case "text":
      answer += chunk.content
      break

    case "reasoning":
      reasoningLog = (reasoningLog ?? "") + chunk.content
      break

    case "usage":
      usage = chunk.content
      break
  }
}

console.log(answer)
console.log(usage)
```

***

### 示例三：包含图片与文档的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: [
    {
      role: "user",
      content: [
        {
          type: "text",
          content: "请分析这份文档的核心内容"
        },
        {
          type: "document",
          content: {
            mediaType: "application/pdf",
            data: "JVBERi0xLjQKJcfs..."
          }
        }
      ]
    }
  ],
  provider: "anthropic"
})

for await (const chunk of stream) {
  if (chunk.type === "text") {
    console.log(chunk.content)
  }
}
```

***

## 使用建议与注意事项

- 流式结果**必须按顺序消费**，不可并发读取
- UI 场景下建议：

  - 文本 chunk 实时渲染
  - reasoning chunk 仅用于调试
  - usage chunk 延迟处理
- 若中途不再需要结果，应主动中止读取，避免无意义消耗
- 并非所有 Provider / Model 都会返回 reasoning 或 usage
- 不同 Provider 的 chunk 粒度不同，不应假设单次 chunk 是完整句子



---
url: /zh/guide/Changelog/2.4.5/Assistant/requestStructuredData.md
---

# 请求结构化数据

`requestStructuredData` 用于向 Assistant 请求**严格符合指定 JSON Schema 的结构化 JSON 数据**。
该 API 适合在你需要**可预测、可直接用于程序逻辑**的数据结果时使用，而不是自由文本。

典型使用场景包括：

- 从自然语言中提取结构化字段
- 解析发票、收据、账单、票据
- 生成配置对象、规则数据
- 在不同 AI Provider / Model 之间获得一致的数据结构

***

## 支持的 JSON Schema 类型

Scripting 提供了一套轻量级、跨模型可用的 Schema 描述方式，由三种基础类型组成。

### Primitive（基础类型）

```ts
type JSONSchemaPrimitive = {
  type: "string" | "number" | "boolean"
  required?: boolean
  description: string
}
```

***

### Object（对象类型）

```ts
type JSONSchemaObject = {
  type: "object"
  properties: Record<string, JSONSchemaType>
  required?: boolean
  description: string
}
```

***

### Array（数组类型）

```ts
type JSONSchemaArray = {
  type: "array"
  items: JSONSchemaType
  required?: boolean
  description: string
}
```

***

## API 定义

### 不包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

### 包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  images: string[],
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

## 参数说明

### prompt

- 类型：`string`
- 必填
- 向模型说明**需要解析或生成什么结构化数据**
- 强烈建议在 prompt 中明确：

  - 时间格式（如 ISO-8601）
  - 金额是否为纯数字
  - 缺失字段的处理规则

***

### images（可选）

- 类型：`string[]`
- 每一项必须是 Data URI，例如：

```text
data:image/png;base64,iVBORw0KGgoAAAANS...
```

- 并非所有 Provider / Model 都支持图片输入
- 图片数量过多可能导致请求失败

***

### schema

- 类型：`JSONSchemaArray | JSONSchemaObject`
- 必填
- 定义模型**唯一允许返回的 JSON 结构**
- 每一个字段都应提供清晰的 `description`，这是保证结果稳定的关键

***

### options.provider

- 类型：`Provider`
- 可选，未指定时使用 Assistant 当前默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 未指定时使用 Provider 默认模型

***

## 返回值

```ts
Promise<R>
```

- `R` 为调用方声明的泛型类型
- 返回结果应严格符合 Schema 描述
- 若模型无法生成合法结构，Promise 将被 reject

***

## 使用示例

### 示例一：解析票据 / 收据，提取消费项目、时间和金额

该示例演示如何将一段票据文本解析为结构化数据，包括：

- 整体消费时间（`purchasedAt`）
- 币种（`currency`）
- 消费项目列表（`items`）

  - 项目名称
  - 项目时间（若无则为空）
  - 金额
- 合计金额（`total`）

```ts
type ReceiptItem = {
  name: string
  time: string
  amount: number
}

type ReceiptParsed = {
  purchasedAt: string
  currency: string
  items: ReceiptItem[]
  total: number
}

const receiptText = `
Star Coffee
2026-01-08 14:23
Latte (Large)   $5.50
Blueberry Muffin $3.20
Tax             $0.79
Total           $9.49
`

const parsed = await Assistant.requestStructuredData<ReceiptParsed>(
  [
    "请分析以下票据文本，并提取结构化信息：",
    "- purchasedAt：整体消费时间，使用 ISO-8601 格式，若无法判断则返回空字符串",
    "- currency：币种代码（如 USD / EUR / CNY），若无法判断则返回空字符串",
    "- items：仅包含实际消费项目，不包含税费、合计等行",
    "  - name：项目名称",
    "  - time：项目级时间，若无则返回空字符串",
    "  - amount：数值类型的金额",
    "- total：合计金额，若无则返回 -1",
    "",
    "票据内容：",
    receiptText
  ].join("\n"),
  {
    type: "object",
    description: "票据解析结果",
    properties: {
      purchasedAt: {
        type: "string",
        description: "整体消费时间（ISO-8601），若无则为空字符串"
      },
      currency: {
        type: "string",
        description: "币种代码，若无法判断则为空字符串"
      },
      items: {
        type: "array",
        description: "消费项目列表（不包含税费、合计等）",
        items: {
          type: "object",
          description: "单个消费项目",
          properties: {
            name: {
              type: "string",
              description: "项目名称"
            },
            time: {
              type: "string",
              description: "项目时间（ISO-8601），若无则为空字符串"
            },
            amount: {
              type: "number",
              description: "项目金额"
            }
          }
        }
      },
      total: {
        type: "number",
        description: "合计金额，若不存在则为 -1"
      }
    }
  },
  {
    provider: "openai"
  }
)

// 建议在业务层将空字符串 / -1 归一化为 null
console.log(parsed)
```

***

### 示例二：生成数组结构

```ts
type Expense = {
  name: string
  amount: number
}

const expenses = await Assistant.requestStructuredData<Expense[]>(
  "列出三项常见的日常支出及其大致金额",
  {
    type: "array",
    description: "支出列表",
    items: {
      type: "object",
      description: "单项支出",
      properties: {
        name: {
          type: "string",
          description: "支出名称"
        },
        amount: {
          type: "number",
          description: "金额"
        }
      }
    }
  },
  {
    provider: "gemini"
  }
)
```

***

### 示例三：结合图片生成结构化结果

```ts
type ImageSummary = {
  description: string
  containsText: boolean
}

const summary = await Assistant.requestStructuredData<ImageSummary>(
  "分析这张图片的主要内容",
  ["data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD..."],
  {
    type: "object",
    description: "图片分析结果",
    properties: {
      description: {
        type: "string",
        description: "图片内容描述"
      },
      containsText: {
        type: "boolean",
        description: "是否包含可识别文本"
      }
    }
  },
  {
    provider: "openai"
  }
)
```

***

## 使用建议与注意事项

- 当返回结果用于业务逻辑时，优先使用 `requestStructuredData`
- Schema 描述越明确，结果越稳定
- 复杂业务规则不要放在 Schema 中，应由业务代码处理



---
url: /zh/guide/Changelog/2.4.5/CalendarEvent.md
---

`CalendarEvent` API 用于在 iOS 日历中创建、读取、编辑与管理事件。
开发者可以操作事件的标题、时间、地点、参与者、重复规则、提醒（EventAlarm）、事件可用性以及地理位置信息，并且可以使用系统提供的创建/编辑界面。

***

# 一、类型说明

## EventParticipant

表示事件的参与者：

- `isCurrentUser: boolean`：是否为当前用户
- `name?: string`：姓名
- `role: ParticipantRole`：角色
- `type: ParticipantType`：类型
- `status: ParticipantStatus`：出席状态

### ParticipantRole

- `chair`（主持人）
- `nonParticipant`（非参与者）
- `optional`（可选）
- `required`（必需）
- `unknown`（未知）

### ParticipantType

- `group`（群组）
- `person`（个人）
- `resource`（资源）
- `room`（房间）
- `unknown`（未知）

### ParticipantStatus

- `unknown`（未知）
- `pending`（待定）
- `accepted`（接受）
- `declined`（拒绝）
- `tentative`（暂定）
- `delegated`（已委托）
- `completed`（已完成）
- `inProcess`（处理中）

***

## EventAvailability

用于表明事件在日程中的可用性状态：

- `notSupported`：日历不支持可用性设置
- `busy`：忙碌
- `free`：空闲
- `tentative`：暂定
- `unavailable`：不可用

***

## EventStructuredLocation

用于地理位置提醒的结构化位置：

- `title: string | null`：名称
- `geoLocation: LocationInfo | null`：地理位置（经纬度）
- `radius: number`：触发半径（米）

此结构与 `EventAlarm.structuredLocation` 配合使用。

***

## AlarmProximity

位置提醒的触发方式：

- `none`：不使用位置触发
- `enter`：进入区域时触发
- `leave`：离开区域时触发

***

# 二、EventAlarm（事件提醒）

CalendarEvent 支持添加多个 `EventAlarm`，包括：

- **绝对时间提醒**
- **相对事件开始时间提醒**
- **位置提醒（geofence）**

详细说明请参考独立的 EventAlarm 文档。

***

# 三、CalendarEvent 类

## 构造函数

```ts
new(): CalendarEvent
```

创建一个新的事件实例（尚未保存到日历）。

***

# 四、属性说明

## 基本信息

### identifier: string

事件的唯一标识符。

### title: string

事件标题。

### notes: string | null

事件备注。

### url: string | null

关联 URL。

### calendar: Calendar | null

事件所属的日历。
不可设为 `null`。
如果需要删除事件，请使用 `remove()`。

***

## 时间与地点

### isAllDay: boolean

是否为全天事件。

### startDate: Date

开始时间。

### endDate: Date

结束时间。

### timeZone: string | null

事件使用的时区。

### location: string | null

纯文本地点信息。

### structuredLocation: EventStructuredLocation | null

结构化位置（支持 geofence 提醒）。

***

## 事件状态与生成信息（新增）

### creationDate: Date | null

事件创建日期（只读）。

### lastModifiedDate: Date | null

事件最后修改时间（只读）。

### occurrenceDate: Date

对于重复事件中的“单个实例”，此属性表示该实例原始发生日期。

### isDetached: boolean

是否为重复事件的“脱离实例”。
例如用户单独修改某一发生日期的事件时，该实例会成为 detached instance。

***

## 参与者与可用性（新增相关属性）

### attendees: EventParticipant\[] | null

参与者数组（只读）。

### organizer: EventParticipant | null

事件组织者（只读）。

### hasAttendees: boolean

是否包含参与者。

### availability: EventAvailability

事件在日程中的可用性状态。

***

## 提醒（Alarm）相关

### alarms: EventAlarm\[] | null

事件绑定的提醒列表。

### hasAlarm: boolean

事件是否包含提醒。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

事件的重复规则数组。

### hasRecurrenceRules: boolean

是否包含重复规则。

***

## 其他状态属性（新增）

### hasNotes: boolean

是否包含备注。

### hasChanges: boolean

事件或其内部对象是否有未保存的更改。

***

# 五、实例方法

## 1. 提醒管理

### addAlarm(alarm: EventAlarm): void

为事件添加一个提醒。

### removAlarm(alarm: EventAlarm): void

从事件移除一个提醒。
（注意拼写：API 为 `removAlarm`）

***

## 2. 重复规则

### addRecurrenceRule(rule: RecurrenceRule): void

添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除一条重复规则。

***

## 3. 事件保存与删除

### `save(): Promise<void>`

保存事件（或重复事件的变化）。

### `remove(): Promise<void>`

从日历中移除事件。

***

## 4. 显示编辑界面

### `presentEditView(): Promise<EventEditViewAction>`

显示系统提供的事件编辑界面，并返回用户执行的操作：

- `"saved"`
- `"deleted"`
- `"canceled"`

***

# 六、静态方法

## `getAll(startDate: Date, endDate: Date, calendars?: Calendar[]): Promise<CalendarEvent[]>`

获取指定日期范围内的事件。

- 可传入 `calendars` 数组过滤事件
- 若不传或传 `null`，则搜索所有可访问的日历

***

## `presentCreateView(): Promise<CalendarEvent | null>`

显示事件创建界面。

- 用户点击保存时返回创建的事件
- 用户取消时返回 `null`

***

# 七、使用示例

## 1. 创建并保存事件

```ts
const defaultCalendar = await Calendar.defaultForEvents()
const event = new CalendarEvent()
event.title = "团队会议"
event.calendar = defaultCalendar!
event.startDate = new Date("2024-01-15T09:00:00")
event.endDate = new Date("2024-01-15T10:00:00")
event.location = "会议室"

await event.save()
```

***

## 2. 添加重复规则

```ts
const rule = RecurrenceRule.create({
  frequency: "weekly",
  interval: 1,
  daysOfTheWeek: ["monday", "wednesday", "friday"],
  end: RecurrenceEnd.fromDate(new Date("2024-12-31")),
})

event.addRecurrenceRule(rule)
await event.save()
```

***

## 3. 添加提醒（Alarm）

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
event.addAlarm(alarm)
await event.save()
```

***

## 4. 获取日期范围内的事件

```ts
const events = await CalendarEvent.getAll(
  new Date("2024-01-01"),
  new Date("2024-01-31")
 )

for (const e of events) {
  console.log(`事件: ${e.title} 开始时间: ${e.startDate}`)
}
```

***

## 5. 使用事件创建界面

```ts
const created = await CalendarEvent.presentCreateView()
if (created) {
  console.log("新事件已创建:", created.title)
}
```

***

## 6. 编辑事件

```ts
const result = await event.presentEditView()
console.log("编辑操作:", result)
```

***

## 7. 删除事件

```ts
await event.remove()
console.log("事件已移除")
```

***

# 八、补充说明

### 时区处理

当处理跨时区事件时，请务必设置 `timeZone`，否则可能出现偏移时间或显示错误。

### 重复事件编辑

- 修改单个重复事件实例会创建一个 detached instance
- `occurrenceDate` 可用于识别该实例对应的原始日期

### 参与者

参与者信息由系统从日历源（如 iCloud、Exchange）读取。
部分字段可能因日历源不同而缺失。

### structuredLocation 与 geofence

若使用位置提醒，请确保用户授权位置权限。



---
url: /zh/guide/Changelog/2.4.5/DateFormatter.md
---

`DateFormatter` 类用于将 `Date` 类型格式化为字符串，或将字符串解析为 `Date`。
该类封装了 iOS 的 `DateFormatter` 能力，适用于格式化日期、时间、本地化展示、农历日期展示（通过切换日历）、相对日期显示等场景。

***

# 枚举与类型定义

## DateFormatterStyle

用于指定日期或时间的格式化级别。

| 枚举值      | 含义                                |
| -------- | --------------------------------- |
| `none`   | 不显示日期或时间                          |
| `short`  | 短格式，例如 `12/1/25`、`3:20 PM`        |
| `medium` | 中等格式，例如 `Dec 1, 2025`             |
| `long`   | 长格式，例如 `December 1, 2025`         |
| `full`   | 全格式，例如 `Monday, December 1, 2025` |

***

## DateFormatterBehavior

指定格式化器的行为模式。

| 枚举值            | 含义                 |
| -------------- | ------------------ |
| `default`      | 系统默认行为             |
| `behavior10_4` | 兼容旧系统格式化行为（通常无需使用） |

***

## CalendarIdentifier

指定 `DateFormatter` 使用的历法类型。可用于格式化如：

- 公历（gregorian）
- 农历（chinese）
- 佛历（buddhist）
- 日本历（japanese）
- 伊斯兰历（islamic）
  等。

可选值示例：

```
"current" | "gregorian" | "chinese" | "japanese" | "islamic" | "iso8601" | ...
```

其中：

- `"current"` 代表当前系统日历
- `"autoupdatingCurrent"` 表示系统日历变更后自动更新

***

## TimeZoneIdentifier

指定时区。

可选值：

```
"current" | "autoupdatingCurrent" | "gmt" | string
```

当传入普通字符串时，可以使用任意合法时区 ID，例如：

- `"Asia/Shanghai"`
- `"America/Los_Angeles"`
- `"UTC"`

***

# 类：DateFormatter

## 初始化

### `new(): DateFormatter`

创建一个新的日期格式器实例。

***

# 静态方法

## `DateFormatter.localizedString(date, options)`

根据指定的日期格式与时间格式返回本地化后的字符串。

```ts
DateFormatter.localizedString(date: Date, options: {
  dateStyle: DateFormatterStyle
  timeStyle: DateFormatterStyle
}): string
```

适用于快速格式化，无需手动设置 formatter 属性。

***

## `DateFormatter.dateFormat(template, locale?)`

根据日期模板生成本地化后的格式化字符串。

```
static dateFormat(template: string, locale?: string): string | null
```

示例模板：`"yyyyMMdd"`, `"MMM d"`, `"HH:mm"`

如果传入 locale，则按指定语言区域生成；否则使用系统 locale。

***

# 实例方法

## `string(date: Date): string`

将 Date 转换为格式化字符串。

注意：如果设置了 `dateFormat`，则优先使用自定义格式；
否则根据 `dateStyle` 和 `timeStyle` 自动格式化。

***

## `date(string: string): Date | null`

将字符串解析为 Date。
解析能力依赖于当前 dateFormat、locale、calendar 等属性。

***

## `setLocalizedDateFormatFromTemplate(template: string): void`

根据模板生成本地化格式，并自动设置到 `dateFormat` 属性中。

***

# 属性说明

以下为所有可配置属性的功能说明。

## 日期与时间格式属性

### `calendar: CalendarIdentifier`

选择日期格式化使用的历法，如公历、农历、佛历等。

***

### `timeZone: TimeZoneIdentifier`

设置时区，例如 `"Asia/Shanghai"`。

***

### `locale: string`

指定区域语言，例如：

- `"zh_CN"`
- `"en_US"`
- `"ja_JP"`

***

### `dateFormat: string`

手动指定格式化模板。例如：

```
"yyyy-MM-dd HH:mm"
"MMM d, yyyy"
"EEEE"
```

如果设置该属性，则忽略 `dateStyle` 和 `timeStyle`。

***

### `dateStyle/timeStyle: DateFormatterStyle`

分别控制日期和时间格式级别。

***

## 行为属性

### `generatesCalendarDates: boolean`

是否生成历法日期，一般保持默认即可。

***

### `formatterBehavior: DateFormatterBehavior`

控制格式器行为，通常使用默认值。

***

### `isLenient: boolean`

是否宽松解析输入，例如解析模糊格式字符串。
一般保持 `false`，避免误解析。

***

### `twoDigitStartDate: Date | null`

设置双位数年份的起始范围。用于解析如 `"20"` 这样的年份值。

***

### `defaultDate: Date | null`

解析字符串无法获得时间时，使用的默认日期。

***

## 本地化符号与文案属性

以下属性用于自定义本地化符号，如月份名称、星期名称等。
这些属性通常无需手动设置，除非需要覆盖本地化字符串。

举例属性：

- `eraSymbols`
- `monthSymbols`
- `shortMonthSymbols`
- `weekdaySymbols`
- `shortWeekdaySymbols`
- `standaloneMonthSymbols`
- `amSymbol`
- `pmSymbol`
- `quarterSymbols`
- `standaloneQuarterSymbols`
- `veryShortWeekdaySymbols`
- `gregorianStartDate`

这些属性主要作用于需要深度定制本地化展示的场景。

***

## `doesRelativeDateFormatting: boolean`

启用相对日期格式化，例如：

- Today
- Yesterday
- Tomorrow

在中文环境中可显示为：

- 今天
- 昨天
- 明天

通常与 `dateStyle = .medium` 等组合使用。

***

# 示例代码

以下示例展示如何使用 `DateFormatter` 进行多种日期格式化场景。

***

## 示例一：使用 dateStyle 和 timeStyle 进行本地化格式化

```tsx
import { DateFormatter } from "scripting"

const df = new DateFormatter()
df.locale = "zh_CN"
df.dateStyle = DateFormatterStyle.full
df.timeStyle = DateFormatterStyle.short

const result = df.string(new Date())
// 输出示例： "2025年12月12日 星期五 下午3:20"
```

***

## 示例二：自定义日期格式模板

```tsx
const df = new DateFormatter()
df.locale = "en_US"
df.dateFormat = "yyyy-MM-dd HH:mm"

df.timeZone = "Asia/Shanghai"

const str = df.string(new Date())
// 输出示例： "2025-12-12 15:20"
```

***

## 示例三：使用农历格式化（chinese calendar）

```tsx
const df = new DateFormatter()

df.calendar = "chinese"
df.locale = "zh_CN"
df.dateFormat = "yyyy年MM月dd日 EEEE"

const lunar = df.string(new Date())
// 输出示例： "四十三年十月廿二日 星期五"
```

***

## 示例四：解析字符串为日期

```tsx
const df = new DateFormatter()
df.dateFormat = "yyyy/MM/dd HH:mm"

const date = df.date("2025/12/12 08:00")
```

***

## 示例五：使用模板生成本地化格式

```tsx
const df = new DateFormatter()
df.locale = "zh_CN"

// 自动设置为符合中文习惯的格式，例如 "12月12日"
df.setLocalizedDateFormatFromTemplate("MMdd")

const str = df.string(new Date())
```

***

## 示例六：使用静态快速格式化

```tsx
const str = DateFormatter.localizedString(new Date(), {
  dateStyle: DateFormatterStyle.medium,
  timeStyle: DateFormatterStyle.short
})
```



---
url: /zh/guide/Changelog/2.4.5/EventAlarm.md
---

# 事件闹钟

`EventAlarm` 用于为 **日历事件（CalendarEvent）** 和 **提醒事项（Reminder）** 设置提醒规则。
通过该类，开发者可以创建：

- 基于绝对时间触发的提醒
- 基于事件开始时间的相对提醒
- 基于地理围栏（Geofence）触发的提醒

此类为 Scripting Calendar/Reminder API 的基础能力，用于构建灵活的提醒行为。

***

## 一、创建 Alarm

### 1. `EventAlarm.fromAbsoluteDate(date: Date): EventAlarm`

创建一个基于绝对时间触发的提醒。

- 不依赖事件的开始时间
- 在系统时间到达指定时刻时触发

示例：

```ts
const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-01-01T09:00:00"))
```

***

### 2. `EventAlarm.fromRelativeOffset(offset: DurationInSeconds): EventAlarm`

创建一个以「事件开始时间」为基准的提醒。

`offset`（秒）含义如下：

- 负数：事件开始前触发
- 正数：事件开始后触发

示例（事件开始前 10 分钟提醒）：

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
```

***

## 二、属性说明

### 1. `absoluteDate: Date | null`

提醒的绝对触发时间。

行为规则：

- 如果为相对提醒设置 `absoluteDate`，提醒会自动转换为绝对提醒，同时 `relativeOffset` 会被清除。
- 如果为 `null`，表示提醒可能为相对提醒或位置提醒。

***

### 2. `relativeOffset: number`

事件开始时间的偏移量（秒）。

行为规则：

- 若为绝对提醒设置该属性，则提醒会转换为相对提醒，且 `absoluteDate` 会被置空。
- 相对提醒永远以 CalendarEvent 或 Reminder 的开始时间为基准。

示例：

```ts
alarm.relativeOffset = -300  // 提前 5 分钟触发
```

***

### 3. `structuredLocation: EventStructuredLocation | null`

位置提醒的触发地点。

`EventStructuredLocation` 包含：

- `title: string | null`：地点名称
- `geoLocation: LocationInfo | null`：经纬度位置
- `radius: number`：地理围栏触发半径（米）

示例：

```ts
alarm.structuredLocation = {
  title: "公司",
  geoLocation: { latitude: 37.332, longitude: -122.030 },
  radius: 100
}
```

***

### 4. `proximity: AlarmProximity`

位置提醒的触发方式。

支持的值：

| 值       | 含义         |
| ------- | ---------- |
| `none`  | 默认，不使用位置触发 |
| `enter` | 进入该地点范围时触发 |
| `leave` | 离开该地点范围时触发 |

示例：

```ts
alarm.proximity = AlarmProximity.enter
```

***

## 三、EventAlarm 在不同 API 中的使用方式

### 1. 在 CalendarEvent 中使用

```ts
const event = new CalendarEvent()
event.title = "会议"
event.startDate = ...
event.endDate = ...

const alarm = EventAlarm.fromRelativeOffset(-900)
event.addAlarm(alarm)

await event.save()
```

***

### 2. 在 Reminder 中使用

`Reminder` 与 `CalendarEvent` 均支持添加 `EventAlarm`：

```ts
const reminder = new Reminder()
reminder.title = "交电费"

const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-02-01T10:00:00"))
reminder.addAlarm(alarm)

await reminder.save()
```

位置提醒同样适用于 `Reminder`。

***

## 四、使用建议

1. **绝对提醒适合作为固定时间提醒**
   如生日、账单日等。

2. **相对提醒适用于基于事件开始时间的通知**
   如会议开始前十分钟提醒。

3. **地理围栏提醒适用于“到达某地时执行某事”**
   如到家提醒拿快递。

4. 使用位置提醒时，应确保用户授予定位权限。



---
url: /zh/guide/Changelog/2.4.5/Keychain.md
---

# 钥匙串

`Keychain` 提供对系统钥匙串（Keychain）的安全访问接口，用于在 **Scripting 脚本环境中安全、持久地存储敏感数据**，典型用途包括：

- 登录凭证
- Token
- 许可证信息
- 订阅状态
- 加密密钥
- 用户隐私数据

所有数据均使用系统级 Keychain 安全机制存储，具备高安全性与持久性。

***

## 一、Keychain 的脚本作用域隔离规则

在 Scripting 中，`Keychain` 采用 **按脚本隔离（Per-Script Sandbox）** 的安全模型：

### 1. 作用域规则

- **每一个脚本拥有独立的 Keychain 作用域**

- 每个脚本 **只能访问自己写入的 Keychain 数据**

- 不同脚本之间：

- 即使 Key 名相同

- 即使 `synchronizable: true`

- 也 **无法互相读取或覆盖数据**

- 脚本被视为独立安全单元

***

### 2. 该规则的安全意义

该设计确保：

- 不同脚本之间的数据完全隔离
- 防止第三方脚本窃取用户隐私数据
- 防止恶意脚本读取登录态、订阅状态、授权信息
- 提供比系统 Keychain 更细粒度的安全隔离层

***

### 3. 脚本卸载对 Keychain 的影响

- 当脚本被删除后：

  - 该脚本作用域下的 Keychain 数据将被系统回收
- 其他脚本的数据不会受到任何影响

***

## 二、API 命名空间

```ts
namespace Keychain
```

***

## 三、支持的数据类型

`Keychain` 支持以下三种数据类型：

| 类型    | 写入        | 读取        |
| ----- | --------- | --------- |
| 字符串   | `set`     | `get`     |
| 布尔值   | `setBool` | `getBool` |
| 二进制数据 | `setData` | `getData` |

***

## 四、KeychainAccessibility 可访问性策略

```ts
type KeychainAccessibility =
  | 'passcode'
  | 'unlocked'
  | 'unlocked_this_device'
  | 'first_unlock'
  | 'first_unlock_this_device'
```

| 值                          | 说明                  |
| -------------------------- | ------------------- |
| `passcode`                 | 仅在设备设置锁屏密码时可访问，不会迁移 |
| `unlocked`                 | 仅在设备解锁状态下可访问        |
| `unlocked_this_device`     | 仅限本设备访问，不会迁移        |
| `first_unlock`             | 重启后首次解锁即可访问         |
| `first_unlock_this_device` | 重启后首次解锁即可访问，不会迁移    |

默认值：

```ts
accessibility: "unlocked"
```

***

## 五、iCloud 同步（synchronizable）

```ts
synchronizable?: boolean
```

| 值       | 说明                 |
| ------- | ------------------ |
| `true`  | 在同一 Apple ID 设备间同步 |
| `false` | 仅存储在本设备            |

默认值：

```ts
synchronizable: false
```

***

## 六、写入数据

### 1. 写入字符串

```ts
Keychain.set(key: string, value: string, options?): boolean
```

```ts
Keychain.set("token", "abcdef")
```

```ts
Keychain.set("token", "abcdef", {
  accessibility: "first_unlock",
  synchronizable: true
})
```

***

### 2. 写入布尔值

```ts
Keychain.setBool(key: string, value: boolean, options?): boolean
```

```ts
Keychain.setBool("is_login", true)
```

***

### 3. 写入二进制数据

```ts
Keychain.setData(key: string, value: Data, options?): boolean
```

```ts
Keychain.setData("avatar", imageData)
```

***

### 4. 覆盖规则

- Key 已存在时会自动覆盖
- 成功返回 `true`
- 失败返回 `false`

***

## 七、读取数据

### 字符串

```ts
Keychain.get(key: string, options?): string | null
```

### 布尔值

```ts
Keychain.getBool(key: string, options?): boolean | null
```

### 二进制数据

```ts
Keychain.getData(key: string, options?): Data | null
```

***

## 八、删除数据

```ts
Keychain.remove(key: string, options?): boolean
```

- Key 存在：删除并返回 `true`
- Key 不存在：安全返回 `true`

***

## 九、是否存在

```ts
Keychain.contains(key: string, options?): boolean
```

***

## 十、获取所有 Key

```ts
Keychain.keys(options?): string[]
```

***

## 十一、清空 Keychain

```ts
Keychain.clear(options?): boolean
```

- 仅清空当前脚本作用域内的数据
- 不影响其他脚本
- 不影响 App 自身或其他 App 的系统 Keychain 数据

***

## 十二、synchronizable 的读写一致性规则

如果某 Key 使用：

```ts
synchronizable: true
```

则后续所有操作必须带相同参数：

```ts
Keychain.set("token", "abc", { synchronizable: true })

Keychain.get("token") // 读取不到
Keychain.get("token", { synchronizable: true }) // 可读取
```

***

## 十三、安全性与使用建议

### 适合存储的数据

- 登录 Token
- 订阅与授权状态
- 用户唯一标识
- 加密密钥

### 不建议存储

- 大体积文件
- 高频变化的缓存数据
- 可公开的普通配置

***

## 十四、典型使用示例

```ts
// 写入
Keychain.set("token", "abcdef")
Keychain.setBool("is_login", true)
Keychain.setData("avatar", avatarData)

// 读取
const token = Keychain.get("token")
const isLogin = Keychain.getBool("is_login")
const avatar = Keychain.getData("avatar")

// 删除
Keychain.remove("token")

// 判断是否存在
Keychain.contains("token")

// 获取所有 Key
Keychain.keys()

// 清空
Keychain.clear()
```



---
url: /zh/guide/Changelog/2.4.5/LivePhotoView.md
---

# LivePhotoView

LivePhoto 表示一张 **系统级 Live Photo**，它由以下两部分组成：

- 一张高分辨率静态图片
- 一段与图片绑定的短视频（通常为 MOV）

在 Scripting 中，LivePhoto 是一个 **不可直接 new 的系统对象**，通常来源于：

- 照片选择器返回的结果
- 使用本地图片与视频文件动态构建

LivePhoto 的主要用途包括：

- 在界面中实时展示 Live Photo
- 读取并处理其底层资源（图片 / 视频）
- 将其拆解、重建或重新保存到系统相册

***

## LivePhoto 类

### LivePhoto.size

```
readonly size: Size
```

表示 Live Photo 的尺寸信息，对应其 **主图像（静态图片）** 的像素宽高。

该属性常用于：

- UI 布局约束
- 计算缩放比例
- 判断 Live Photo 的原始分辨率

***

### LivePhoto.getAssetResources()

```
getAssetResources(): Promise<{
  data: Data
  assetLocalIdentifier: string
  contentType: UTType
  originalFilename: string
  pixelHeight: number
  pixelWidth: number
}[]>
```

用于获取 Live Photo 的 **底层资源列表**。

一个 Live Photo 通常至少包含以下资源：

- 静态图片资源（JPEG / HEIC）
- 视频资源（QuickTime MOV）

返回数组中每一项代表一个资源，其字段含义如下：

- `data`
  资源的二进制数据，可直接用于写入文件、保存或传输

- `assetLocalIdentifier`
  Photos 框架中该资源的本地唯一标识

- `contentType`
  资源的统一类型标识（UTType），用于区分图片或视频类型

- `originalFilename`
  系统中该资源的原始文件名

- `pixelWidth` / `pixelHeight`
  该资源的实际像素尺寸

典型使用场景包括：

- 手动保存 Live Photo（避免中间临时文件）
- 将 Live Photo 拆解为独立的图片与视频
- 对 Live Photo 进行自定义导出或重建

***

### LivePhoto.from(options)

```
static from(options: {
  imagePath: string
  videoPath: string
  targetSize?: Size | null
  placeholderImage: UIImage | null
  contentMode?: "aspectFit" | "aspectFill"
  onResult: (result: LivePhoto | null, info: {
    error: string | null
    degraded: boolean | null
    cancelled: boolean | null
  }) => void
}): Promise<() => void>
```

用于 **从本地图片文件与视频文件异步构建 Live Photo**。

该方法的特点如下：

- 构建过程是异步的
- `onResult` 可能会被调用多次
- 支持降级结果（低质量预览）
- 支持主动取消请求

#### 参数说明

- `imagePath`
  静态图片文件路径，通常为 JPEG 或 HEIC

- `videoPath`
  与图片对应的视频文件路径，通常为 MOV

- `targetSize`
  指定返回 Live Photo 的目标尺寸
  传入 `null` 表示使用原始尺寸

- `placeholderImage`
  Live Photo 尚未加载完成时用于占位显示的 UIImage

- `contentMode`
  占位图的显示方式

  - `aspectFit`：完整显示，保持比例
  - `aspectFill`：填满区域，可能裁剪

- `onResult(result, info)`
  Live Photo 加载完成或状态更新时触发的回调

#### info 参数说明

- `error`
  构建失败时的错误信息

- `degraded`
  表示当前结果是否为低质量版本

- `cancelled`
  表示请求是否被取消

#### 返回值

该方法返回一个 Promise，成功后解析为一个 **可取消函数**：

```
() => void
```

调用该函数可立即取消 Live Photo 的加载过程。

***

## LivePhotoView 组件

LivePhotoView 是用于 **在界面中展示 Live Photo 的原生视图组件**，行为与系统 Photos App 中的 Live Photo 播放体验一致。

***

### LivePhotoViewProps

```
type LivePhotoViewProps = {
  livePhoto: Observable<LivePhoto | null>
}
```

#### livePhoto

- 类型：`Observable<LivePhoto | null>`
- 必填

该属性用于绑定当前要显示的 Live Photo。

设计为 `Observable` 的原因是：

- Live Photo 通常是异步获取的
- 允许在同一个视图中动态切换 Live Photo
- 便于与选择器、加载逻辑解耦

当 Observable 的值发生变化时，LivePhotoView 会自动更新显示内容。

***

## 使用示例说明

以下示例展示了一个典型使用流程：

- 用户选择一张 Live Photo
- 将 Live Photo 存入 Observable
- LivePhotoView 自动展示并播放该 Live Photo

```tsx
import { LivePhotoView, Button, useObservable } from "scripting"

function Example() {
  const livePhoto = useObservable<LivePhoto | null>(null)

  return <>
    <Button
      title="Set Live Photo"
      action={async () => {
        const lp = await getLivePhotoSomehow()
        livePhoto.setValue(lp)
      }}
    />

    <LivePhotoView
      livePhoto={livePhoto}
      frame={{ idealHeight: 300 }}
    />
  </>
}
```

### 核心流程说明

- 使用 `useObservable<LivePhoto | null>` 创建可观察状态
- 在用户选择 Live Photo 后，通过 `setValue` 更新状态
- LivePhotoView 自动响应状态变化并展示内容

LivePhotoView 不负责：

- Live Photo 的获取
- 权限处理
- 数据保存

它仅专注于 **展示与交互体验**。

***

## 设计原则与注意事项

- LivePhoto 是系统资源对象，生命周期由系统管理
- LivePhotoView 必须绑定 Observable，而不是直接传值
- 同一个 LivePhoto 实例可被多个 LivePhotoView 使用
- Live Photo 的加载与 UI 渲染解耦，推荐始终通过 Observable 驱动

***

## 总结

LivePhoto 相关能力在 Scripting 中主要由两部分组成：

- **LivePhoto 数据模型**
  用于表示、构建和解析系统 Live Photo

- **LivePhotoView 展示组件**
  用于以原生方式展示 Live Photo，并支持动态更新



---
url: /zh/guide/Changelog/2.4.5/NavigationStack with path.md
---

# NavigationStack 配合 path

`NavigationStack.path` 用于为 `NavigationStack` 提供**可观察的导航路径控制能力**，用于实现：

- 编程式导航（Programmatic Navigation）
- 多级页面堆栈控制
- 页面回退到指定层级或根视图
- 与 `NavigationDestination` 的动态页面映射联动

***

## 一、API 定义

```ts
type NavigationStackProps = {
  path?: Observable<string[]>
  ...
}

declare const NavigationStack: FunctionComponent<NavigationStackProps>
```

***

## 二、path 的类型与含义

```ts
path?: Observable<string[]>
```

`path` 是一个字符串数组的可观察对象，用于表示当前导航栈中的**页面路径序列**。

其语义规则如下：

- 每一个 `string` 表示一个页面标识
- 数组顺序表示页面入栈顺序
- 数组末尾元素表示当前显示的页面
- 数组为空表示回到根页面（Root）

示例说明：

```ts
[]
```

表示当前在根视图

```ts
["a"]
```

表示已导航到页面 `a`

```ts
["a", "b"]
```

表示先进入页面 `a`，再进入页面 `b`

***

## 三、基础使用示例

```tsx
function Page() {
  const path = useObservable<string[]>(["a"])

  return <NavigationStack
    path={path}
  >
    <VStack
      navigationTitle="Navigation Demo"
      navigationDestination={
        <NavigationDestination>
          {(page) =>
            <VStack>
              <Text>
                Current page:
                {page}
              </Text>
              {path.value.length > 1
                && <Button
                  title="Go to Root"
                  action={() => {
                    path.setValue([])
                  }}
                />}
            </VStack>
          }
        </NavigationDestination>
      }
    >
      <Button
        title="Show page a"
        action={() => {
          path.setValue(["a"])
        }}
      />
      <Button
        title="Show page b"
        action={() => {
          path.setValue(["b"])
        }}
      />
      <Button
        title="Show page a then b"
        action={() => {
          path.setValue(["a", "b"])
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 四、path 的工作机制说明

### 1. path 作为导航状态的唯一数据源

当 `NavigationStack` 绑定了 `path` 后：

- 当前页面层级将完全由 `path.value` 决定
- UI 导航状态将与 `path` 保持双向同步
- 不再依赖隐式的 Push / Pop 状态管理

***

### 2. 页面入栈规则

当执行：

```ts
path.setValue(["a"])
```

系统行为：

- 根页面入栈
- 跳转至页面 `a`

当执行：

```ts
path.setValue(["a", "b"])
```

系统行为：

- 先进入页面 `a`
- 再进入页面 `b`
- 当前显示页面为 `b`

***

### 3. 页面出栈与回到根页面

当执行：

```ts
path.setValue([])
```

系统行为：

- 清空整个导航路径
- 立即回到根页面

***

## 五、NavigationDestination 与 path 的关系

`NavigationDestination` 用于根据 `path` 中的当前值动态构建目标页面。

```tsx
<NavigationDestination>
  {(page) => ...}
</NavigationDestination>
```

其中：

- `page` 参数来自 `path.value` 的当前末尾元素
- 当 `path` 发生变化时：

  - `page` 会自动更新
  - 对应的页面内容会重新渲染

示例逻辑：

```ts
["a"]  -> page === "a"
["a","b"] -> page === "b"
```

***

## 六、通过按钮控制 path 进行导航

跳转到页面 `a`：

```ts
path.setValue(["a"])
```

跳转到页面 `b`：

```ts
path.setValue(["b"])
```

连续跳转两个页面：

```ts
path.setValue(["a", "b"])
```

返回根页面：

```ts
path.setValue([])
```

***

## 七、path 与手势返回的同步关系

当用户通过系统返回手势或导航栏返回按钮返回时：

- `path.value` 会自动同步更新
- 显示页面与 `path` 始终保持一致
- 不需要额外监听返回事件进行手动同步

***

## 八、path 的典型使用场景

`NavigationStack.path` 适用于以下场景：

- 深层页面跳转
- 跨页面编程式导航控制
- 统一的路由状态管理
- 脚本控制页面跳转
- 恢复上次浏览路径
- 多步骤流程（向导式界面）

***

## 九、常见错误说明

### 1. path 未初始化为空数组

错误：

```ts
const path = useObservable<string[]>(null)
```

正确：

```ts
const path = useObservable<string[]>([])
```

***

### 2. path 中的值类型错误

错误：

```ts
path.setValue([1, 2])
```

正确：

```ts
path.setValue(["1", "2"])
```

当前 `path` 仅支持 `string[]` 作为路径类型。

***

## 十、与不使用 path 的 NavigationStack 的区别

| 功能      | 不使用 path | 使用 path |
| ------- | -------- | ------- |
| 手动 Push | 支持       | 不建议     |
| 编程式跳转   | 不支持      | 支持      |
| 多层跳转    | 受限       | 完全支持    |
| 状态恢复    | 困难       | 简单      |
| 路由统一管理  | 不可控      | 完全可控    |



---
url: /zh/guide/Changelog/2.4.5/Photos/index.md
---

# 照片

`Photos` 模块为 Scripting 提供了对系统相册与相机能力的统一访问接口，用于：

- 使用系统相机拍照或录制视频
- 从系统照片库中选择图片、视频或 Live Photo
- 获取最近拍摄的照片
- 将图片或视频保存到系统 Photos 应用

所有 API 均基于 iOS 原生框架（Photos、PHPicker、UIImagePicker 等）封装，并遵循以下设计原则：

- 系统级权限管理
- Promise 异步接口
- 系统 UI 托管，不可自定义
- 媒体数据访问安全、受控

***

## CaptureInfo

```ts
type CaptureInfo = {
  cropRect: {
    x: number
    y: number
    width: number
    height: number
  } | null
  originalImage: UIImage | null
  editedImage: UIImage | null
  imagePath: string | null
  mediaMetadata: Record<string, any> | null
  mediaPath: string | null
  mediaType: string | null
}
```

`CaptureInfo` 描述了一次拍摄操作（照片或视频）的完整返回信息。

### 字段说明

- `cropRect`
  用户在编辑阶段应用的裁剪区域
  若未裁剪则为 `null`

- `originalImage`
  拍摄得到的原始图片（未编辑）

- `editedImage`
  用户编辑后的图片
  仅在 `allowsEditing` 启用且实际编辑后存在

- `imagePath`
  图片在磁盘中的文件路径

- `mediaMetadata`
  媒体的元数据，如 EXIF、方向信息等

- `mediaPath`
  视频文件在磁盘中的路径

- `mediaType`
  媒体的 UTType 字符串标识

***

## availableMediaTypes()

```ts
function availableMediaTypes(): string[] | null
```

返回当前设备相机支持的媒体类型（UTType 字符串数组）。

常用于：

- 判断设备是否支持视频拍摄
- 根据设备能力动态配置拍摄参数

当信息不可获取时返回 `null`。

***

## capture(options)

```ts
function capture(options: {
  mode: "photo" | "video"
  mediaTypes: UTType[]
  allowsEditing?: boolean
  cameraDevice?: "rear" | "front"
  cameraFlashMode?: "auto" | "on" | "off"
  videoMaximumDuration?: DurationInSeconds
  videoQuality?: 
    | "low"
    | "medium"
    | "high"
    | "640x480"
    | "iFrame960x540"
    | "iFrame1280x720"
}): Promise<CaptureInfo | null>
```

展示系统相机界面以进行拍照或视频录制。

### 参数说明

- `mode`
  拍摄模式

  - `"photo"`：拍照
  - `"video"`：录制视频

- `mediaTypes`
  允许拍摄的媒体类型（UTType 数组）

- `allowsEditing`
  是否允许用户在完成拍摄后编辑媒体

- `cameraDevice`
  使用的摄像头
  默认为 `"rear"`

- `cameraFlashMode`
  闪光灯模式
  默认为 `"auto"`

- `videoMaximumDuration`
  视频最长录制时长（秒）

- `videoQuality`
  视频分辨率与编码质量设置

### 行为说明

- 拍摄界面完全由系统管理
- Promise 在用户完成或取消操作后返回
- 权限请求由系统自动处理

***

## pick(options)

```ts
function pick(options?: {
  mode?: "default" | "compact"
  filter?: PHPickerFilter
  limit?: number
}): Promise<PHPickerResult[]>
```

展示系统照片选择器，用于从相册中选择媒体资源。

### 参数说明

- `mode`
  选择器布局模式

  - `default`：网格布局
  - `compact`：线性紧凑布局

- `filter`
  用于限制可选择资源类型的 `PHPickerFilter`

- `limit`
  最大选择数量
  默认为 `1`

### 返回值

返回 `PHPickerResult` 数组。
每个结果必须显式调用对应方法解析为具体资源。

***

## PHPickerFilter

`PHPickerFilter` 用于描述 **Photos.pick** 可选择的资源类型。
它是一个不可实例化的类，仅通过静态方法构建。

### 基础过滤器

- `PHPickerFilter.images()`
  仅允许选择普通图片

- `PHPickerFilter.videos()`
  仅允许选择视频

- `PHPickerFilter.livePhotos()`
  仅允许选择 Live Photo

- `PHPickerFilter.bursts()`
  连拍照片

- `PHPickerFilter.panoramas()`
  全景照片

- `PHPickerFilter.screenshots()`
  屏幕截图

- `PHPickerFilter.screenRecordings()`
  屏幕录制视频

- `PHPickerFilter.depthEffectPhotos()`
  含景深效果的照片（人像）

- `PHPickerFilter.cinematicVideos()`
  电影效果视频

- `PHPickerFilter.slomoVideos()`
  慢动作视频

- `PHPickerFilter.timelapseVideos()`
  延时摄影视频

***

### 组合过滤器

- `PHPickerFilter.all(filters)`
  同时满足所有过滤条件
  相当于逻辑 AND

- `PHPickerFilter.any(filters)`
  满足任意一个过滤条件
  相当于逻辑 OR

- `PHPickerFilter.not(filter)`
  排除指定过滤条件
  相当于逻辑 NOT

### 示例说明

```ts
// 仅允许选择 Live Photo 或普通图片
const filter = PHPickerFilter.any([
  PHPickerFilter.livePhotos(),
  PHPickerFilter.images()
])

await Photos.pick({ filter })
```

***

## PHPickerResult

表示照片选择器返回的单个选择结果。

### itemProvider: ItemProvider

获取结果的 `ItemProvider`对象，是一个Swift 的 `NSItemProvider` 对象的包装。

### livePhoto()

```ts
livePhoto(): Promise<LivePhoto | null>
```

尝试将结果解析为 Live Photo。
若资源不支持 Live Photo，则返回 `null`。

***

### uiImage()

```ts
uiImage(): Promise<UIImage | null>
```

尝试将结果解析为 `UIImage`。
若资源不是图片，则返回 `null`。

***

### imagePath()

```ts
imagePath(): Promise<string | null>
```

尝试将结果解析为图片。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回图片路径。
你应该在使用完成后删除该文件。

#### 示例

```ts
const filePath = await result.imagePath()
```

***

### videoPath()

```ts
videoPath(): Promise<string | null>
```

尝试将结果解析为视频。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回视频路径。
你应该在使用完成后删除该文件。

***

## getLatestPhotos(count)

```ts
function getLatestPhotos(count: number): Promise<UIImage[] | null>
```

获取相册中最新的若干张照片。

### 行为说明

- 仅返回图片
- 顺序为从最新到最旧
- 无权限时返回 `null`

***

## pickPhotos(count)

```ts
function pickPhotos(count: number): Promise<UIImage[]>
```

旧版便捷 API，用于快速选择固定数量的照片。

直接返回 `UIImage` 数组，不包含路径或元数据。

***

## takePhoto()

```ts
function takePhoto(): Promise<UIImage | null>
```

快速拍照接口。

- 不支持高级配置
- 用户取消时返回 `null`

***

## savePhoto(path, options)

```ts
function savePhoto(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将磁盘中的图片文件保存到系统 Photos 应用。

***

## savePhoto(image, options)

```ts
function savePhoto(
  image: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将图片二进制数据直接写入系统相册，避免创建临时文件。

***

## saveVideo(path, options)

```ts
function saveVideo(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频文件保存到系统 Photos 应用。

***

## saveVideo(video, options)

```ts
function saveVideo(
  video: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频二进制数据直接写入系统相册。

***

## 设计说明

- 所有 API 均为异步 Promise 接口
- 所有 UI 均由系统托管
- Picker 返回的结果为惰性对象，需显式解析
- 保存接口仅返回成功状态，不暴露系统资源标识



---
url: /zh/guide/Changelog/2.4.5/Photos/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Photos"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Get the latest specified number of photos from the Photos app.</Text>
        }
      >
        <Button
          title={"Photos.getLatestPhotos"}
          action={async () => {
            const images = await Photos.getLatestPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Present a photo picker dialog and pick limited number of photos.</Text>
        }
      >

        <Button
          title={"Photos.pickPhotos"}
          action={async () => {
            const images = await Photos.pickPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Take a photo and return a UIImage instance.</Text>
        }
      >
        <Button
          title={"Photos.takePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Save an image to the Photos app. Returns a boolean value indicates that whether the operation is successful.</Text>
        }
      >
        <Button
          title={"Photos.savePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              const success = await Photos.savePhoto(Data.fromJPEG(image, 0.5)!)
              Dialog.alert({
                message: "The photo has been saved: " + success
              })
            } else {
              Dialog.alert({
                message: "Canceled"
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.5/Picture in Pictuer View Modifiers.md
---

# Picture in Picture （画中画）

Scripting 提供了一组 PiP（Picture in Picture，画中画）相关的 View Modifiers，用于将任意 SwiftUI View 以系统级 PiP 窗口的形式呈现。
开发者无需直接接触底层 AVPictureInPicture API，即可完整控制 PiP 的展示、隐藏、交互行为及生命周期。

PiP 适用于以下典型场景：

- 实时状态展示（计时、运动、任务进度）
- 音频 / 视频播放的辅助 UI
- 应用进入后台后仍需持续展示的轻量信息视图

***

## 一、PiPProps API 定义

```ts
type PiPProps = {
  pip?: {
    isPresented: Observable<boolean>
    maximumUpdatesPerSecond?: number
    content: VirtualNode
  }
  
  onPipStart?: () => void
  onPipStop?: () => void
  onPipPlayPauseToggle?: (isPlaying: boolean) => void
  onPipSkip?: (isForward: boolean) => void
  onPipRenderSizeChanged?: (size: Size) => void

  pipHideOnForeground?: boolean
  pipShowOnBackground?: boolean
}
```

***

## 二、核心属性详解

### 1. `pip.isPresented`

```ts
isPresented: Observable<boolean>
```

- PiP 的**唯一控制开关**
- `true`：系统 PiP 窗口展示
- `false`：PiP 窗口关闭

通常由用户操作（按钮、手势）或应用生命周期驱动。

***

### 2. `pip.content`

```ts
content: VirtualNode
```

- 指定 PiP 窗口中实际渲染的视图
- 强烈建议使用**专门为 PiP 设计的 View**
- 视图结构应尽量简单、稳定、可预测

***

### 3. `pip.maximumUpdatesPerSecond`

```ts
maximumUpdatesPerSecond?: number
```

- **默认值：30**
- 用于限制 PiP 视图每秒最大刷新次数
- 是影响 PiP 稳定性和性能的关键参数

#### 使用建议

- **无动画 / 低频更新场景**
  建议设置为 `1 ~ 5`

- **包含动画的 PiP 视图**
  可设置为 `60`

**重要提示**
将该值设置为 `60` 会显著增加 CPU 与 GPU 压力，对系统性能影响非常明显，应谨慎使用，仅适用于确有必要的动画场景。

***

## 三、PiP 生命周期回调（仅限 PipView 使用）

### `onPipStart`

```ts
onPipStart?: () => void
```

- 当 PiP 窗口**成功开始展示**时触发
- 适合执行以下操作：

  - 启动定时器
  - 开始状态更新
  - 订阅数据流

***

### `onPipStop`

```ts
onPipStop?: () => void
```

- 当 PiP 被关闭或系统回收时调用
- 必须在此清理所有副作用：

  - 定时器
  - 订阅
  - 长时间运行任务

***

## 四、PiP 交互回调（仅限 PipView 使用）

### 1. 播放 / 暂停切换

```ts
onPipPlayPauseToggle?: (isPlaying: boolean) => void
```

- 当用户点击 PiP 控制区的播放 / 暂停按钮
- `isPlaying` 表示切换后的状态
- 常用于音频、视频、运动记录等场景

***

### 2. 快进 / 快退按钮

```ts
onPipSkip?: (isForward: boolean) => void
```

- `true`：向前
- `false`：向后

***

## 五、PiP 渲染尺寸变化

### `onPipRenderSizeChanged`

```ts
onPipRenderSizeChanged?: (size: Size) => void
```

- 当 PiP 窗口尺寸发生变化时触发
- 可根据尺寸动态调整布局
- 适用于横竖屏切换或系统自动调整 PiP 大小时

***

## 六、前后台行为控制（仅限 PipView 使用）

### `pipHideOnForeground`

```ts
pipHideOnForeground?: boolean
```

- 当应用进入前台时：

  - 若 PiP 正在运行，是否自动关闭
- 默认：`false`

***

### `pipShowOnBackground`

```ts
pipShowOnBackground?: boolean
```

- 当应用进入后台时是否自动启动 PiP
- 常用于音频播放、实时状态展示类场景

***

## 七、完整代码示例

### 1. PiP 内容视图（PipView）

```tsx
function PipView() {
  const started = useObservable(false)
  const count = useObservable(0)

  useEffect(() => {
    if (!started.value) {
      return
    }

    let timerId: number

    function startTimer() {
      timerId = setTimeout(() => {
        count.setValue(count.value + 1)
        startTimer()
      }, 1000)
    }

    startTimer()

    return () => {
      clearTimeout(timerId)
    }
  }, [started.value])

  return <HStack
    onPipStart={() => {
      started.setValue(true)
    }}
    frame={{
      width: Device.screen.width,
      height: 50
    }}
    background="systemBlue"
  >
    <Image
      systemName="figure.walk"
      font="title"
    />
    <Text foregroundStyle="white">
      Count: {count.value}
    </Text>
  </HStack>
}
```

***

### 2. 页面中启用 PiP

```tsx
function PageView() {
  const dismiss = Navigation.useDismiss()
  const pipPresented = useObservable(false)

  return <NavigationStack>
    <List
      navigationTitle="PiP Demo"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
      pip={{
        isPresented: pipPresented,
        content: <PipView />
      }}
    >
      <Button
        title="Toggle PiP"
        action={() => {
          pipPresented.setValue(!pipPresented.value)
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 八、重要注意事项（必须阅读）

### 1. PiPView 在 `isPresented = false` 时仍会被构建

- PiPView **不可见**
- 但仍然参与状态绑定与生命周期
- 不应在构建阶段执行任何重计算或副作用

**推荐做法**

- 所有逻辑延迟到 `onPipStart`
- 在 `onPipStop` 中彻底释放资源

***

### 2. PiP 专用修饰符只能在 PipView 中使用

以下属性和回调：

- `onPipStart`
- `onPipStop`
- `onPipPlayPauseToggle`
- `onPipSkip`
- `onPipRenderSizeChanged`
- `pipHideOnForeground`
- `pipShowOnBackground`

**只能定义在 PiP 内容视图（PipView）中**

如果定义在普通页面 View 中：

- 不会触发
- 无法获取正确状态
- 行为不可预测

***

### 3. PiP 不适合复杂 UI

不建议在 PiP 中使用：

- `List`、`ScrollView`
- 复杂动画
- 高频状态更新
- 网络请求驱动的 UI

PiP 的设计目标是：

> 轻量、稳定、可持续展示的系统级辅助视图

***

## 九、推荐实践总结

- 为 PiP 单独设计一个最小化 View
- 控制更新频率，合理设置 `maximumUpdatesPerSecond`
- 所有副作用延迟到 `onPipStart`
- 始终在 `onPipStop` 中清理资源
- 不在 PiP 中复用页面级复杂视图



---
url: /zh/guide/Changelog/2.4.5/Reminder.md
---

`Reminder` API 用于在 iOS 日历系统中创建、编辑和管理提醒事项。
它支持通过 `DateComponents` 设置截止日期、管理完成状态、设置优先级、添加备注、配置重复规则，以及使用提醒的各种相关属性，例如闹钟（EventAlarm）、参与者信息、状态检测属性等。

***

## 类：`Reminder`

`Reminder` 类用于操作单个提醒事项，包括读取与修改其属性、管理重复规则与闹钟，以及执行保存或删除操作。

***

# 一、属性说明

### identifier: string

唯一标识符，由系统分配（只读）。

### calendar: Calendar

提醒所属的日历。必须为有效的日历对象。

### title: string

提醒的标题或摘要。

### notes: string | null

备注信息，用于补充提醒内容。

***

## 完成状态相关属性

### isCompleted: boolean

记录提醒是否已完成。

- 设置为 `true` 时，会自动将 `completionDate` 设为当前时间。
- 设置为 `false` 时，会将 `completionDate` 设为 `null`。

说明：如果在其他设备完成了提醒，系统可能出现 `isCompleted = true` 但 `completionDate = null` 的情况。

### completionDate: Date | null

提醒被完成的时间。

- 设置为某个日期时，会自动令 `isCompleted = true`。
- 设置为 `null` 会将提醒标记为未完成。

***

## 截止时间相关属性

### dueDateComponents: DateComponents | null

表示提醒的截止时间，使用 `DateComponents` 可只设置日期部分或同时包含时间部分。

可使用 `DateComponents.isValidDate` 检查是否为有效日期组合。

### dueDate: Date | null

（已被替代的旧字段）

请使用 `dueDateComponents?.date` 获取实际日期。

### dueDateIncludesTime: boolean

（遗留字段）

可通过以下判断是否包含时间字段：
`dueDateComponents?.hour != null && dueDateComponents?.minute != null`

***

## 优先级

### priority: number

提醒的优先级，数值越大表示越重要或紧急。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

重复规则数组。

### hasRecurrenceRules: boolean

是否存在重复规则（只读）。

***

## 闹钟（Alarm）相关

### alarms: EventAlarm\[] | null

提醒绑定的提醒闹钟列表。

支持：

- 绝对时间闹钟
- 相对截止时间的闹钟（基于事件开始时间时使用）
- 地理围栏位置提醒

### hasAlarm: boolean

是否包含闹钟。

***

## 参与者相关

### attendees: EventParticipant\[] | null

提醒可包含参与者对象（只读）。

说明：并非所有来源的提醒都支持参与者。

### hasAttendees: boolean

指示是否存在参与者。

***

## 状态标识属性

### hasNotes: boolean

是否包含备注信息。

### hasChanges: boolean

当前实例或其内部对象是否含有尚未保存的更改。

***

# 二、实例方法

### addAlarm(alarm: EventAlarm): void

为提醒添加一个闹钟。

### removAlarm(alarm: EventAlarm): void

移除提醒中的某个闹钟。
（方法名称为 `removAlarm`）

***

### addRecurrenceRule(rule: RecurrenceRule): void

向提醒添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除指定的重复规则。

***

### `save(): Promise<void>`

保存提醒的修改。若为新建提醒，将自动添加到所属日历。

### `remove(): Promise<void>`

从日历中删除该提醒事项。

***

# 三、静态方法

### `Reminder.getAll(calendars?: Calendar[]): Promise<Reminder[]>`

获取所有提醒，可选指定日历列表。

***

### `Reminder.getIncompletes(options?): Promise<Reminder[]>`

获取未完成的提醒事项，可按截止时间与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含截止时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含截止时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

说明：
该方法不会展开重复提醒实例，仅返回基础提醒条目。

***

### `Reminder.getCompleteds(options?): Promise<Reminder[]>`

获取已完成的提醒事项，可按完成日期范围与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含完成时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含完成时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

***

# 四、示例

## 使用 DateComponents 设置提醒

```ts
const reminder = new Reminder()
reminder.title = "准备会议资料"
reminder.notes = "周一会议前完成"

reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
  hour: 9,
  minute: 30,
})

reminder.priority = 2
await reminder.save()
```

***

## 创建仅包含日期的提醒（无时间）

```ts
reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
})
```

***

## 从 Date 创建 DateComponents

```ts
const now = new Date()
reminder.dueDateComponents = DateComponents.fromDate(now)
```

***

## 获取提醒事项

```ts
const reminders = await Reminder.getAll()
for (const r of reminders) {
  console.log(`提醒：${r.title}`)
}
```

***

## 获取未完成的提醒

```ts
const incompletes = await Reminder.getIncompletes({
  startDate: new Date("2025-01-01"),
  endDate: new Date("2025-01-31"),
})
```

***

## 标记提醒完成

```ts
reminder.isCompleted = true
await reminder.save()
```

***

## 删除提醒

```ts
await reminder.remove()
```

***

# 五、补充说明

### 日期管理

建议使用 `dueDateComponents` 统一处理截止时间相关逻辑。
支持：

- 仅日期
- 完整日期与时间
- 部分字段指定（如只指定小时与分钟）

可使用 `.isValidDate` 判断组件组合是否有效。

***

### 重复提醒

查询方法不展开重复实例，而是返回提醒对象本身。
可通过 `addRecurrenceRule` 与 `removeRecurrenceRule` 管理重复模式。

***

### 闹钟（EventAlarm）

Reminder 与 CalendarEvent 均可使用 `EventAlarm`。
闹钟可基于绝对时间、相对时间或地理位置触发。

***

### 参与者字段

部分提醒来源不一定支持参与者，因此 `attendees` 可能为 `null`。



---
url: /zh/guide/Changelog/2.4.5/ReorderableForEach/index.md
---

# 可拖拽的 ForEach (ReorderableForEach)

`ReorderableForEach` 是 Scripting 提供的一个支持 **拖拽排序（Drag to Reorder）** 的高级渲染组件。
它在保持 `ForEach` 使用方式的同时，内置了拖拽手势识别、激活态管理、排序回调等能力，使开发者可以非常低成本地实现 **可拖拽排序的列表或网格布局**。

该组件特别适用于以下场景：

- 拖拽调整排序的卡片布局
- 拖拽调整顺序的网格（`LazyVGrid` / `LazyHGrid`）
- 脚本驱动的可交互功能模块编排界面

***

## 一、组件定义

```ts
type ReorderableForEachProps<T extends {
  id: string
}> = {
  active: Observable<T | null>
  data: T[]
  builder: (item: T, index: number) => VirtualNode
  onMove: (indices: number[], newOffset: number) => void
}

interface ReorderableForEachComponent {
  <T extends {
    id: string
  }>(props: ReorderableForEachProps<T>): VirtualNode
}

declare const ReorderableForEach: ReorderableForEachComponent
```

***

## 二、泛型约束说明

### 必须包含 `id` 字段

`ReorderableForEach` 的泛型参数 `T` 必须满足：

```ts
T extends { id: string }
```

也就是说，每一项数据必须具备：

- 唯一的 `id` 值
- 稳定不变的标识

该 `id` 用于：

- 识别当前被拖拽的元素
- 维持拖拽过程中的元素一致性
- 正确计算排序变更位置

如果 `id` 不唯一或在拖拽过程中发生变化，将导致排序错乱。

***

## 三、Props 参数说明

### 1. `active`

```ts
active: Observable<T | null>
```

用于表示 **当前正在被拖拽的元素状态**。

行为说明：

- 拖拽开始时，当前项会被写入 `active.value`
- 拖拽结束时，`active.value` 会恢复为 `null`
- 你可以利用它实现：

  - 拖拽元素高亮
  - 透明度变化
  - 联动动画
  - 状态辅助 UI

***

### 2. `data`

```ts
data: T[]
```

当前参与排序的数据数组。

重要说明：

- `ReorderableForEach` **不会自动修改该数组**
- 拖拽完成后，必须在 `onMove` 中手动更新该数组顺序
- 推荐与 `useObservable` 配合使用：

```ts
const data = useObservable<T[]>(...)
```

***

### 3. `builder`

```ts
builder: (item: T, index: number) => VirtualNode
```

用于渲染每一项的 UI 视图。

参数说明：

| 参数      | 含义                 |
| ------- | ------------------ |
| `item`  | 当前数据项              |
| `index` | 当前项在 `data` 中的实时索引 |

返回值必须是一个合法的 `VirtualNode`。

注意：

- 这里的 `index` 是拖拽后的实时索引
- 不应在此依赖旧索引逻辑做安全判断

***

### 4. `onMove`

```ts
onMove: (indices: number[], newOffset: number) => void
```

当用户完成一次拖拽排序后触发。

参数含义：

| 参数          | 类型         | 说明              |
| ----------- | ---------- | --------------- |
| `indices`   | `number[]` | 被拖动元素在原数组中的索引集合 |
| `newOffset` | `number`   | 新插入的起始位置        |

你必须在此方法中：

1. 根据 `indices` 取出被移动的元素
2. 从原数据中移除它们
3. 按 `newOffset` 重新插入
4. 使用 `Observable.setValue` 提交新顺序

标准实现如下：

```ts
const onMove = (indices: number[], newOffset: number) => {
  const movingItems = indices.map(index => data.value[index])
  const newValue = data.value.filter((_, index) => !indices.includes(index))
  newValue.splice(newOffset, 0, ...movingItems)
  data.setValue(newValue)
}
```

***

## 四、`contentShape` 的真实作用说明

在你的示例代码中：

```tsx
.contentShape({
  kind: 'dragPreview',
  shape: {
    type: 'rect',
    cornerRadius: 16
  }
})
```

该配置的核心作用是：

> **设置拖拽时的预览形状，使拖拽时显示的形状与非拖拽状态下保持一致（RoundedRectangle）。**

它并不是简单地“开启拖拽”，而是用于：

- 定义拖拽时的命中区域
- 同步拖拽预览的视觉形状
- 避免：

  - 拖拽时出现矩形裁切
  - 与原有圆角样式不一致的问题

如果不配置 `dragPreview` 形状，拖拽时可能会退化为默认矩形预览，破坏一致性。

***

## 五、完整使用流程说明

### 1. 数据模型定义

```ts
type Item = {
  id: string
  color: Color
}
```

***

### 2. 初始化可排序数据源

```ts
const data = useObservable<Item[]>(() => {
  return new Array(30)
    .fill(0)
    .map((_, index) => ({
      id: String(index),
      color: colors[index % colors.length]
    }))
})
```

***

### 3. 声明拖拽激活态

```ts
const active = useObservable<Item | null>(null)
```

***

### 4. 单项拖拽视图（保持拖拽前后外观一致）

```tsx
<VStack
  modifiers={
    modifiers()
      .frame({ height: 80 })
      .frame({ maxWidth: 'infinity' })
      .background(
        <RoundedRectangle
          cornerRadius={16}
          fill={item.color}
        />
      )
      .contentShape({
        kind: 'dragPreview',
        shape: {
          type: 'rect',
          cornerRadius: 16
        }
      })
  }
>
```

***

### 5. 在 `LazyVGrid` 中使用 ReorderableForEach

```tsx
<ReorderableForEach
  active={active}
  data={data.value}
  builder={(item) =>
    <ItemView item={item} />
  }
  onMove={onMove}
/>
```

***

## 六、关于在 `List` 中使用的限制说明

虽然从技术上讲，`ReorderableForEach` 可以放入 `List` 内部使用，但 **整体上并不推荐在 `List` 中使用该组件**，原因如下：

1. `List` 自带：

   - 行分隔线
   - 行高计算
   - 选中态
   - 系统滑动手势
   - 系统编辑模式

2. 这些系统行为会与：

   - 自定义拖拽动画
   - 自定义排序逻辑
   - 拖拽命中区域计算

   产生不可控的冲突。

3. 可能带来的问题包括：

- 拖拽过程中跳动
- 命中区域错位
- 拖拽排序时系统进入编辑态
- 行复用与拖拽状态不同步

因此推荐的使用容器是：

- `ScrollView`
- `LazyVGrid`
- `LazyHGrid`
- 纯自定义布局容器

而不是 `List`。

***

## 七、组件工作机制总结

`ReorderableForEach` 的行为逻辑可以总结为：

1. 依据 `data` 构建可拖拽子节点
2. 依据 `dragPreview contentShape` 确定拖拽命中区域与预览形状
3. 拖拽过程中：

   - 自动维护 `active`
   - 实时计算目标插入位置
4. 拖拽结束后：

   - 通过 `onMove` 将排序结果交给开发者处理
   - 由开发者负责最终数据顺序更新

***

## 八、适用场景

- 功能模块拖拽排序
- 工具栏按钮排序
- 卡片式任务优先级调整
- 桌面组件布局排序
- 视觉网格自由排序



---
url: /zh/guide/Changelog/2.4.5/ReorderableForEach/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, ScrollView, useObservable, LazyVGrid, ReorderableForEach, RoundedRectangle, VStack, Toolbar, ToolbarItem, modifiers, Color } from "scripting"

type Item = {
  id: string
  color: Color
}

const colors: Color[] = [
  'systemRed',
  'systemBlue',
  'systemGreen',
  'systemPink',
  'systemOrange',
  'systemPurple',
]

function ItemView({
  item
}: {
  item: Item
}) {

  return <VStack
    modifiers={
      modifiers()
        .frame({
          height: 80
        })
        .frame({
          maxWidth: 'infinity'
        })
        .background(
          <RoundedRectangle
            cornerRadius={16}
            fill={item.color}
          />
        )
        .contentShape({
          kind: 'dragPreview',
          shape: {
            type: 'rect',
            cornerRadius: 16
          }
        })
    }
  >
    <Text
      foregroundStyle="white"
      font="title"
    >{item.id}</Text>
  </VStack>
}

function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  const data = useObservable<Item[]>(() => {
    return new Array(30)
      .fill(0)
      .map((_, index) => ({
        id: String(index),
        color: colors[index % colors.length]
      }))
  })

  const active = useObservable<Item | null>(null)

  const onMove = (indices: number[], newOffset: number) => {
    const movingItems = indices.map(index => data.value[index])
    const newValue = data.value.filter((_, index) => !indices.includes(index))
    newValue.splice(newOffset, 0, ...movingItems)
    data.setValue(newValue)
  }

  return <NavigationStack>
    <ScrollView
      navigationTitle="ReorderableForEach demo"
      toolbar={
        <Toolbar>
          <ToolbarItem
            placement="topBarLeading"
          >
            <Button
              title="Close"
              action={dismiss}
            />
          </ToolbarItem>
        </Toolbar>
      }
    >
      <LazyVGrid
        columns={[
          {
            size: {
              type: 'flexible'
            }
          },
          {
            size: {
              type: 'flexible'
            }
          }
        ]}
        padding={{
          horizontal: true
        }}
      >
        <ReorderableForEach
          active={active}
          data={data.value}
          builder={(item) =>
            <ItemView
              item={item}
            />
          }
          onMove={onMove}
        />
      </LazyVGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  // Present view.
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.5/Selectable List.md
---

# 可选择的列表

`List.selection` 用于为 `List` 组件提供**选择状态绑定能力**，用于实现列表的：

- 单选模式（Single Selection）
- 多选模式（Multiple Selection）
- 与编辑模式（`EditButton`）联动的批量选择行为

***

## 一、API 定义

```ts
type ListProps = {
  selection?: Observable<string | null> | Observable<string[]>
  ...
}

declare const List: FunctionComponent<ListProps>
```

***

## 二、selection 类型说明

`selection` 通过 `Observable` 的泛型类型自动区分选择模式：

| 模式 | Observable 类型                | 说明         |
| -- | ---------------------------- | ---------- |
| 单选 | `Observable<string \| null>` | 仅允许选中一个元素  |
| 多选 | `Observable<string[]>`       | 允许同时选中多个元素 |

***

## 三、selection 与 ForEach 的自动绑定规则

当 `List` 绑定 `selection` 时，`ForEach` 的 `data` **必须满足以下规则**：

```ts
ForEach 的 data 数组中，每一个元素都必须包含：

{
  id: string
}
```

系统行为规则如下：

1. `id` 会被自动作为该行的 **唯一选择标识**
2. 当用户点击某一行时：

   - 单选模式：`selected.value` 会被自动设置为该行的 `id`
   - 多选模式：该 `id` 会被自动加入或移出 `selected.value` 数组
3. 不需要手动在 `onTap` 中处理选中逻辑
4. `id` 必须唯一且稳定，否则会导致选择状态错乱或失效

***

## 四、单选模式（Single Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string | null>(null)
```

### 2. 使用示例

```tsx
function View() {
  const selected = useObservable<string | null>(null)

  const options = useObservable<{ id: string }[]>(() =>
    new Array(10).fill(0).map((_, i) => ({ id: i.toString() }))
  )

  return <NavigationStack>
    <List selection={selected}>
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

- `null`：当前没有选中任何项
- `"3"`：当前选中 `id === "3"` 的项

***

## 五、多选模式（Multiple Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string[]>([])
```

### 2. 使用示例

```tsx
function View() {
  const dismiss = Navigation.useDismiss()
  const selected = useObservable<string[]>([])

  const options = useObservable<{ id: string }[]>(() =>
    new Array(30).fill(0).map((_, i) => ({
      id: i.toString() 
    }))
  )

  console.log(selected.value)

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />,
        topBarTrailing: <EditButton />
      }}
      selection={selected}
    >
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

`selected.value` 始终为一个字符串数组，例如：

```ts
["2", "5", "8"]
```

表示当前有 3 项被同时选中。

***

## 六、selection 与 EditButton 的编辑模式行为

当 `List` 绑定了 `selection` 后：

1. `EditButton` 会自动启用选择编辑模式
2. 进入编辑模式后：

   - 单选：点击某一项即切换选中项
   - 多选：支持多项同时勾选
3. 退出编辑模式后：

   - `selected.value` 会被 **自动重置**

     - 单选模式重置为 `null`
     - 多选模式重置为空数组 `[]`

该行为与 SwiftUI 原生编辑模式保持一致。

***

## 七、selection 的程序化控制

除了用户交互以外，也可以通过代码主动修改选中状态。

### 单选模式

```ts
selected.setValue("5")
```

### 多选模式

```ts
selected.setValue(["1", "3", "7"])
```

设置后 UI 会自动同步对应的勾选状态。

***

## 八、selection 与 NavigationStack 的兼容性

`List.selection` 可以安全地在 `NavigationStack` 内使用，不会影响：

- 页面导航行为
- Toolbar 显示
- EditButton 编辑模式
- 页面返回逻辑

标准推荐结构如下：

```tsx
<NavigationStack>
  <List selection={selected}>
    ...
  </List>
</NavigationStack>
```

***

## 九、常见错误说明

### 1. selection 类型错误

错误：

```ts
const selected = useObservable<number | null>(null)
```

正确：

```ts
const selected = useObservable<string | null>(null)
```

目前 `selection` 仅支持 `string` 作为选择标识类型。

***

### 2. 多选模式初始化错误

错误：

```ts
const selected = useObservable<string[]>(null)
```

正确：

```ts
const selected = useObservable<string[]>([])
```

***

### 3. data 未包含 id:string

错误示例：

```tsx
const options = [{ name: "A" }, { name: "B" }]
```

该写法将导致：

- selection 无法正常工作
- 勾选状态丢失
- 列表复用异常

***

## 十、适用场景

`List.selection` 适用于以下场景：

- 单选设置项（主题、语言、偏好）
- 批量删除
- 批量导出
- 批量分享
- 文件管理器
- 通讯录选择
- 任务列表勾选



---
url: /zh/guide/Changelog/2.4.5/VideoPreviewView.md
---

# 视频预览视图（VideoPreviewView）

`VideoPreviewView` 用于实时展示 `VideoRecorder` 当前相机会话的预览画面（camera preview）。
它是 UI 层组件，不负责录制控制逻辑；录制的准备、开始、暂停、恢复与停止由 `VideoRecorder` 负责。

`VideoPreviewView` 的核心职责是：将录制器内部的预览输出渲染到界面中，并支持通过通用 View props（如 `frame`、`aspectRatio` 等）进行布局。

***

## 组件定义

```ts
type VideoPreviewViewProps = {
  recorder: VideoRecorder
}

declare const VideoPreviewView: FunctionComponent<VideoPreviewViewProps>
```

***

## Props 说明

### recorder

```ts
recorder: VideoRecorder
```

绑定的 `VideoRecorder` 实例。`VideoPreviewView` 会从该实例获取预览画面来源。

#### 行为约定

- 当 `recorder.prepare()` 成功后，预览画面可用并开始更新。
- 当 `recorder.dispose()` 被调用后，预览画面停止并释放底层资源。
- `VideoPreviewView` 不会自动调用 `prepare()` 或自动开始录制。

***

## 与 VideoRecorder 状态的关系

`VideoPreviewView` 的显示效果通常与 `VideoRecorder.state` 对应如下（具体表现可能受系统行为影响）：

| Recorder 状态 | 预览表现           |
| ----------- | -------------- |
| `idle`      | 尚未准备，可能为空画面    |
| `preparing` | 正在准备中，画面可能尚不可用 |
| `ready`     | 预览可用           |
| `recording` | 正常实时预览         |
| `paused`    | 通常停留在暂停时的最后一帧  |
| `finishing` | 停止更新或逐步停止      |
| `finished`  | 不再更新           |
| `failed`    | 不可用            |

***

## 推荐用法与生命周期管理

建议将 `VideoRecorder` 作为页面级对象创建，并在页面卸载时调用 `dispose()` 释放资源。
同时，使用 `onStateChanged` 监听状态，以驱动 UI 文案、按钮可用性、错误提示等。

要点：

- `VideoRecorder` 建议通过 `useMemo` 创建，避免每次渲染重复构造。
- 在 `useEffect` 中绑定 `onStateChanged`，并在 cleanup 中调用 `dispose()`。
- 录制前必须 `await recorder.prepare()`。

***

## 完整示例

```tsx
function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()
  const recorder = useMemo(() => {
    return new VideoRecorder({
      camera: {
        position: "front",
      },
      frameRate: 30,
      audioEnabled: true,
      orientation: "portrait",
      sessionPreset: "hd1280x720",
      videoCodec: "hevc"
    })
  }, [])
  const [state, setState] = useState<VideoRecorderState>("idle")

  useEffect(() => {
    recorder.onStateChanged = (state, details) => {
      setState(state)

      if (state === "failed") {
        Dialog.alert(details!)
      }
    }

    return () => {
      recorder.dispose()
    }
  }, [])

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <Text>State: {state}</Text>

      <Button
        title="Start"
        action={async () => {
          await recorder.prepare()
          recorder.startRecording(
            Path.join(
              FileManager.documentsDirectory,
              "test.mov"
            )
          )
        }}
      />

      <Button
        title="Pause"
        action={() => {
          recorder.pauseRecording()
        }}
      />

      <Button
        title="Resume"
        action={() => {
          recorder.resumeRecording()
        }}
      />

      <Button
        title="Stop"
        action={async () => {
          await recorder.stopRecording()
        }}
      />

      <VideoPreviewView
        recorder={recorder}
        frame={{
          width: 300
        }}
        aspectRatio={{
          value: 3 / 4,
          contentMode: "fill"
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 布局与渲染建议

### 使用 frame 控制尺寸

`VideoPreviewView` 支持通过通用的 `frame` 属性约束宽高。例如：

- 仅指定 `width`：配合 `aspectRatio` 确定最终高度
- 指定 `width` + `height`：强制固定大小（可能导致裁剪或拉伸，取决于 aspect ratio 与 content mode）

### 使用 aspectRatio 控制比例与填充策略

示例：

```tsx
<VideoPreviewView
  recorder={recorder}
  aspectRatio={{ value: 3 / 4, contentMode: "fill" }}
/>
```

- `value`：宽高比
- `contentMode: "fill"`：按比例填充并裁剪
- 若你希望完整显示画面且允许留边，可使用 `contentMode: "fit"`（如果你们的通用 props 支持该值）

***

## 常见注意事项

### 必须 prepare 才能稳定显示预览

`VideoPreviewView` 绑定 `recorder` 并不意味着会自动启动会话。若未 `prepare()`：

- 预览可能为空
- 或短时间内不可用
- 不建议依赖隐式行为

最佳实践：在 Start 按钮中 `await recorder.prepare()` 后再 `startRecording()`，如示例所示。

### 释放资源

- 页面关闭或不再需要预览时，务必调用 `recorder.dispose()`。
- 建议使用 `useEffect` cleanup 释放，避免相机占用导致后续页面无法打开摄像头或耗电。

### 错误处理

当 `state === "failed"` 时，建议：

- 立即提示 `details`（如示例 `Dialog.alert(details!)`）
- 同时在 UI 上禁用录制按钮，或提供重试逻辑（例如 `await recorder.reset()` 后再 `prepare()`）

***

## 组件职责边界

- `VideoRecorder`：负责录制控制与状态机（prepare/start/pause/resume/stop/reset/dispose）
- `VideoPreviewView`：负责画面显示与 UI 布局（通过 `frame` / `aspectRatio` 等通用属性）



---
url: /zh/guide/Changelog/2.4.5/VideoRecorder.md
---

# 视频录制（VideoRecorder）

`VideoRecorder` 用于在 Scripting 中创建和控制一个可编程的视频录制会话，完整封装了相机选择、音视频采集、编码、暂停/恢复、缩放、对焦、补光灯控制以及最终文件写入流程。

该 API 适用于自定义相机界面、视频采集工具、自动化录制脚本等场景。

***

## 核心能力概览

- 支持前置与后置摄像头
- 支持指定摄像头类型（广角、超广角、长焦等）
- 支持多种帧率（24 / 30 / 60 / 120）
- 支持音频录制的启用与禁用
- 支持多种系统 Session Preset
- 支持多种视频编码格式（HEVC / H.264 / ProRes 等）
- 支持录制过程中的暂停与恢复
- 支持对焦点、曝光点独立控制
- 支持变焦与平滑变焦（ramp）
- 支持补光灯（Torch）控制
- 明确的状态机与状态回调
- 明确的生命周期管理（prepare / reset / dispose）

***

## 类型定义

### CameraPosition

```ts
type CameraPosition = "front" | "back"
```

表示使用的摄像头朝向。

***

### CameraType

```ts
type CameraType =
  | "wide"
  | "ultraWide"
  | "telephoto"
  | "trueDepth"
  | "dual"
  | "dualWide"
  | "triple"
```

表示摄像头的物理类型。
是否支持某一类型取决于设备硬件能力。

***

### VideoRecorderState

```ts
type VideoRecorderState =
  | "idle"
  | "preparing"
  | "ready"
  | "recording"
  | "paused"
  | "finishing"
  | "finished"
  | "failed"
```

#### 状态说明

| 状态          | 含义             |
| ----------- | -------------- |
| `idle`      | 初始状态，尚未配置资源    |
| `preparing` | 正在配置相机会话与音视频管线 |
| `ready`     | 已准备完成，可以开始录制   |
| `recording` | 正在录制           |
| `paused`    | 录制已暂停          |
| `finishing` | 正在结束录制并写入文件    |
| `finished`  | 录制完成           |
| `failed`    | 发生错误，录制失败      |

***

### VideoCaptureSessionPreset

```ts
type VideoCaptureSessionPreset =
  | "high"
  | "medium"
  | "low"
  | "cif352x288"
  | "vga640x480"
  | "iFrame960x540"
  | "iFrame1280x720"
  | "hd1280x720"
  | "hd1920x1080"
  | "hd4K3840x2160"
```

表示捕捉会话的分辨率预设。

***

### VideoCodec

```ts
type VideoCodec =
  | "hevc"
  | "h264"
  | "jpeg"
  | "JPEGXL"
  | "proRes4444"
  | "appleProRes4444XQ"
  | "proRes422"
  | "proRes422HQ"
  | "proRes422LT"
  | "proRes422Proxy"
  | "proResRAW"
  | "proResRAWHQ"
  | "hevcWithAlpha"
```

表示视频编码格式。
具体是否可用取决于设备与系统支持情况。

***

### VideoOrientation

```ts
type VideoOrientation =
  | "portrait"
  | "landscapeLeft"
  | "landscapeRight"
```

表示输出视频的方向。

***

## 构造函数

```ts
new VideoRecorder(settings?)
```

### settings 参数

```ts
{
  camera?: {
    position: CameraPosition
    preferredTypes?: CameraType[]
  }
  frameRate?: number
  audioEnabled?: boolean
  sessionPreset?: VideoCaptureSessionPreset
  videoCodec?: VideoCodec
  videoBitRate?: number
  orientation?: VideoOrientation
  mirrorFrontCamera?: boolean
}
```

#### 参数说明

- **camera**

  - `position`
    使用的摄像头位置，默认 `"back"`
  - `preferredTypes`
    偏好的摄像头类型列表
    如果未提供，内部将根据摄像头位置自动选择合适的类型

- **frameRate**
  目标帧率，支持 24 / 30 / 60 / 120，默认 30
  实际帧率受设备与分辨率限制

- **audioEnabled**
  是否录制音频，默认 `true`

- **sessionPreset**
  捕捉会话分辨率预设，默认 `"high"`

- **videoCodec**
  视频编码格式，默认 `"hevc"`

- **videoBitRate**
  视频平均码率（bit/s），未指定时由系统自动选择

- **orientation**
  输出视频方向，默认 `"portrait"`

- **mirrorFrontCamera**
  前置摄像头是否镜像，默认 `true`
  仅在使用前置摄像头时生效

***

## 只读属性

### minZoomFactor

```ts
readonly minZoomFactor: number
```

当前设备支持的最小变焦倍率。

***

### maxZoomFactor

```ts
readonly maxZoomFactor: number
```

当前设备支持的最大变焦倍率。

***

### currentZoomFactor

```ts
readonly currentZoomFactor: number
```

当前变焦倍率。

***

### displayZoomFactor

```ts
readonly displayZoomFactor: number
```

用户可读的变焦倍率。

***

### hasTorch

```ts
readonly hasTorch: boolean
```

当前摄像头是否支持补光灯。

***

### torchMode

```ts
readonly torchMode: "auto" | "on" | "off"
```

当前补光灯模式。

***

## 状态与回调

### state

```ts
state: VideoRecorderState
```

表示当前录制器所处的状态。

***

### onStateChanged

```ts
onStateChanged?: (
  state: VideoRecorderState,
  details?: string
) => void
```

状态变化回调。

- 当 `state === "failed"`
  `details` 为错误信息描述

- 当 `state === "finished"`
  `details` 为最终视频文件的完整保存路径

***

## 方法说明

### prepare()

```ts
prepare(): Promise<void>
```

准备录制器资源，包括相机会话、输入输出与音视频管线配置。

#### 使用约束

- 必须在 `startRecording` 之前调用
- 成功后状态变为 `ready`
- 失败会进入 `failed` 状态

***

### startRecording(toPath)

```ts
startRecording(toPath: string): void
```

开始录制视频。

#### 参数

- **toPath**
  视频文件保存路径（完整路径）

#### 使用约束

- 仅允许在 `ready` 状态下调用
- 调用后状态变为 `recording`

***

### pauseRecording()

```ts
pauseRecording(): void
```

暂停当前录制。

#### 使用约束

- 仅允许在 `recording` 状态下调用
- 调用后状态变为 `paused`
- 时间线会被正确压缩，不产生空白帧

***

### resumeRecording()

```ts
resumeRecording(): void
```

恢复已暂停的录制。

#### 使用约束

- 仅允许在 `paused` 状态下调用
- 调用后状态回到 `recording`

***

### stopRecording()

```ts
stopRecording(): Promise<void>
```

停止录制并生成最终视频文件。

#### 行为说明

- 状态先进入 `finishing`
- 文件写入完成后进入 `finished`
- 最终文件路径通过 `onStateChanged` 回调返回

***

### reset()

```ts
reset(): Promise<void>
```

重置录制器状态，用于开始新一轮录制。

#### 使用场景

- 已完成一次录制
- 或录制失败后希望复用同一实例

#### 行为说明

- 成功后状态回到 `idle`
- 可再次调用 `prepare`

***

### setTorchMode()

```ts
setTorchMode(mode: "auto" | "off" | "on"): void
```

设置补光灯模式。

***

### setFocusPoint()

```ts
setFocusPoint(point: { x: number; y: number }): void
```

设置对焦点。

- 坐标为归一化值，范围 `0.0 ~ 1.0`
- `(0,0)` 表示画面左上角，`(1,1)` 表示右下角

***

### setExposurePoint()

```ts
setExposurePoint(point: { x: number; y: number }): void
```

设置曝光点，坐标规则与对焦点一致。

***

### resetFocus()

```ts
resetFocus(): void
```

恢复自动对焦模式。

***

### resetExposure()

```ts
resetExposure(): void
```

恢复自动曝光模式。

***

### setZoomFactor()

```ts
setZoomFactor(factor: number): void
```

立即设置变焦倍率。

- 值应位于 `minZoomFactor` 与 `maxZoomFactor` 之间

***

### rampZoomFactor()

```ts
rampZoomFactor(toFactor: number, rate: number): void
```

以平滑方式调整变焦倍率。

- `toFactor` 为目标倍率
- `rate` 为变化速率，单位为每秒的 2 次幂变化

***

### resetZoom()

```ts
resetZoom(): void
```

将变焦倍率恢复为默认值（通常为 1.0）。

***

### dispose()

```ts
dispose(): Promise<void>
```

释放并销毁录制器。

#### 使用约束

- 调用后实例不可再使用
- 会释放相机、音频与底层系统资源
- 建议在页面或脚本生命周期结束时调用

***

## 典型使用流程

```ts
const recorder = new VideoRecorder({
  camera: { position: "back" },
  frameRate: 60,
  videoCodec: "hevc"
})

recorder.onStateChanged = (state, details) => {
  if (state === "finished") {
    console.log("Video saved at:", details)
  }
}

await recorder.prepare()
recorder.startRecording("/path/to/tmp/demo.mov")
```

***

## 使用建议

- 始终监听 `onStateChanged` 以掌握完整状态变化
- 不要在未调用 `prepare` 的情况下开始录制
- 每次完成录制后，如需复用实例，应先调用 `reset`
- 生命周期结束时务必调用 `dispose` 释放资源



---
url: /zh/guide/Changelog/2.4.5/WebViewController.md
---

# WebView 控制器

`WebViewController` 是一个用于显示和交互网页内容的控制器。它允许你在脚本中加载 HTML、展示 Web 页面、执行 JavaScript 脚本，并与页面中的 JavaScript 进行消息通信。你可以将它作为浏览器使用，也可以嵌入应用功能页面。

***

## 类：`WebViewController`

```ts
const webView = new WebViewController()
```

***

## 属性

### `shouldAllowRequest?: (request) => Promise<boolean>`

一个可选回调，用于决定是否允许或拦截 WebView 发起的请求。每次加载资源之前都会调用此函数，例如导航到新页面或提交表单时。

适用于拦截跳转行为、自定义安全策略或过滤广告等不需要的请求。

#### 参数

回调函数接收一个 `request` 对象，包含以下字段：

- `url: string`
  请求的完整 URL。

- `method: string`
  HTTP 方法，如 `GET`、`POST`。

- `body?: Data | null`
  可选，请求体数据（通常用于 `POST` 请求）。

- `headers: Record<string, string>`
  请求头信息。

- `timeoutInterval: number`
  请求的超时时间（单位为秒）。

- `navigationType: "linkActivated" | "reload" | "backForward" | "formResubmitted" | "formSubmitted" | "other"`
  触发导航的上下文。

#### 返回值

一个 `Promise<boolean>`，用于指示是否允许该请求：

- `true`：允许请求继续
- `false`：阻止该请求

#### 示例

```ts
const webView = new WebViewController()

webView.shouldAllowRequest = async (request) => {
  console.log('拦截到请求：', request.url)

  // 拦截所有访问 example.com 的请求
  if (request.url.includes('example.com')) {
    return false
  }

  return true
}

await webView.loadURL('https://www.wikipedia.org')
await webView.present({ navigationTitle: '已过滤的网页视图' })
```

***

## 方法

### `loadURL(url: string): Promise<boolean>`

加载指定 URL 的网页内容。

- **参数**：

  - `url`：要加载的网页完整地址。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadFile(path: string, allowingReadAccessTo?: string): Promise<boolean>`

加载文件内容作为网页。

- **参数**:

  - `path`：要加载的文件路径。
  - `allowingReadAccessTo`（可选）：允许读取文件的路径，默认为 `path`。
- **返回**：`Promise<boolean>`

### `loadHTML(html: string, baseURL?: string): Promise<boolean>`

加载原始 HTML 字符串内容。

- **参数**：

  - `html`：要渲染的 HTML 字符串。
  - `baseURL`（可选）：用于解析相对路径的基础 URL。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadData(data: Data, mimeType: string, encoding: string, baseURL: string): Promise<boolean>`

加载原始数据作为网页内容。

- **参数**：

  - `data`：要加载的二进制内容。
  - `mimeType`：内容的 MIME 类型，例如 `"text/html"`。
  - `encoding`：字符编码，例如 `"utf-8"`。
  - `baseURL`：用于解析相对路径的基础地址。
- **返回**：`Promise<boolean>`

***

### `waitForLoad(): Promise<boolean>`

等待 WebView 加载完成。

- **返回**：`Promise<boolean>`

***

### `getHTML(): Promise<string | null>`

获取当前页面的 HTML 内容。

- **返回**：`Promise<string | null>`

***

### `evaluateJavaScript<T = any>(javascript: string): Promise<T>`

在 WebView 中执行指定的 JavaScript 代码。

- **参数**：

  - `javascript`：要执行的 JavaScript 代码字符串。若希望返回值，必须在代码中使用 `return`。
- **返回**：`Promise<T>` — JavaScript 执行结果将作为 Promise 的值返回。

#### 示例

```ts
const webView = new WebViewController()
await webView.loadURL("https://example.com")
const title = await webView.evaluateJavaScript("return document.title")
console.log(title) // "Example Domain"
webView.dispose()
```

或：

```ts
const webView = new WebViewController()
await webView.loadHTML(`
  <html>
    <body>
      <script>
        window.myValue = 42
      </script>
    </body>
  </html>
`)

await webView.waitForLoad()

const result = await webView.evaluateJavaScript('return window.myValue')
console.log(result) // 42
```

***

### `addScriptMessageHandler<P = any, R = any>(name: string, handler: (params?: P) => R): Promise<void>`

添加一个脚本消息处理器，可在网页中通过 JavaScript 调用，并接收原生代码返回的结果。

- **参数**：

  - `name`：消息处理器名称，必须唯一且非空。
  - `handler`：处理函数，接收来自网页的参数并返回一个值，作为 Promise 的结果回传给网页。
- **返回**：`Promise<void>` — 添加成功后完成。

#### 示例

```ts
let webView = new WebViewController()

await webView.addScriptMessageHandler("sayHi", (greeting: string) => {
  console.log("收到消息", greeting)
  return "你好！"
})

await webView.loadHTML(`
  <html>
    <body>
      <script>
        (async () => {
          const response = await window.webkit.messageHandlers.sayHi.postMessage("Hi!")
          alert(response) // 弹出 "你好！"
        })()
      </script>
    </body>
  </html>
`)
```

***

### `present(options?: { fullscreen?: boolean, navigationTitle?: string }): Promise<void>`

以模态窗口形式展示 WebView。

- **选项**：

  - `fullscreen`：是否以全屏模式展示。
  - `navigationTitle`：导航栏标题（可选）。
- **返回**：`Promise<void>`

***

### `canGoBack(): Promise<boolean>`

判断 WebView 是否可以后退。

***

### `canGoForward(): Promise<boolean>`

判断 WebView 是否可以前进。

***

### `goBack(): Promise<boolean>`

返回上一页。

***

### `goForward(): Promise<boolean>`

前进到下一页。

***

### `reload(): Promise<void>`

重新加载当前网页。

***

### `dismiss(): void`

关闭 WebView 页面（若当前正在展示）。

***

### `dispose(): void`

释放 WebView 实例并清理资源。

- 如果 WebView 正在展示，将先自动关闭。
- **重要**：请务必调用此方法以避免内存泄漏。

***

## 完整示例

```ts
const webView = new WebViewController()

await webView.addScriptMessageHandler('greet', (name) => {
  return `你好，${name}`
})

await webView.loadHTML(`
  <html>
    <body>
      <h1>自定义网页视图</h1>
      <button onclick="sendMessage()">打招呼</button>
      <script>
        async function sendMessage() {
          const response = await window.webkit.messageHandlers.greet.postMessage("Alice")
          alert(response)
        }
      </script>
    </body>
  </html>
`)

await webView.present({ navigationTitle: '网页视图示例' })
webView.dispose()
```



---
url: /zh/guide/Changelog/2.4.6/Device/index.md
---

# 设备

`Device` 命名空间提供当前运行设备的基础信息、系统环境、屏幕与电池状态、语言与地区设置，以及部分与设备能力相关的方法（如唤醒锁、网络接口信息）。

该 API 常用于：

- 设备差异化逻辑（iPhone / iPad / Mac）
- UI 布局与适配
- 多语言与本地化判断
- 网络调试与诊断
- 防止脚本执行期间设备休眠

***

## 设备与系统信息

### `Device.model: string`

设备型号名称，例如 `"iPhone"`、`"iPad"`。

***

### `Device.systemName: string`

当前操作系统名称，例如 `"iOS"`、`"iPadOS"`、`"macOS"`。

***

### `Device.systemVersion: string`

当前操作系统版本号，例如 `"17.2"`。

***

### `Device.isiPhone: boolean`

当前设备是否为 iPhone。

***

### `Device.isiPad: boolean`

当前设备是否为 iPad。

***

### `Device.isiOSAppOnMac: boolean`

当前进程是否为 **iPhone / iPad App 运行在 Mac 上**（Mac Catalyst / Apple Silicon Mac）。

***

## 屏幕信息

### `Device.screen`

当前主屏幕的信息。

```ts
{
  width: number
  height: number
  scale: number
}
```

字段说明：

- `width`：屏幕逻辑宽度（pt）
- `height`：屏幕逻辑高度（pt）
- `scale`：屏幕缩放因子（如 2 / 3）

常用于布局计算、画布尺寸、截图或渲染比例控制。

***

## 方向与姿态

### `Device.isPortrait: boolean`

当前设备是否处于竖屏方向。

***

### `Device.isLandscape: boolean`

当前设备是否处于横屏方向。

***

### `Device.isFlat: boolean`

设备是否平放（例如放在桌面上）。

该值通常基于设备姿态传感器，用于高级交互或方向判断。

***

## 外观与主题

### `Device.colorScheme: ColorScheme`

当前系统外观模式。

可能的值通常包括：

- `light`
- `dark`

可用于根据系统外观自动调整 UI 主题或样式。

***

## 电池信息

### `Device.batteryState`

当前电池状态：

```ts
"full" | "charging" | "unplugged" | "unknown"
```

说明：

- `full`：电池已充满
- `charging`：正在充电
- `unplugged`：未连接电源
- `unknown`：状态不可用

***

### `Device.batteryLevel: number`

当前电量百分比，取值范围：

- `0.0` \~ `1.0`
- 当电量不可用时，可能返回 `-1`

***

## 语言与地区设置

### `Device.systemLocale: string`

系统当前使用的 Locale，例如：

```text
"en_US"
```

***

### `Device.preferredLanguages: string[]`

用户偏好的语言列表（按优先级排序），例如：

```ts
["en-US", "zh-Hans-CN"]
```

推荐用于多语言内容选择。

***

### `Device.systemLocales: string[]` （已废弃）

用户偏好的 Locale 列表。

> 已废弃，请使用 `Device.preferredLanguages`。

***

### `Device.systemLanguageTag: string`

当前语言的 BCP-47 语言标签，例如：

```text
"en-US"
```

***

### `Device.systemLanguageCode: string`

当前语言代码，例如：

```text
"en"
```

***

### `Device.systemCountryCode: string | undefined`

当前国家 / 地区代码，例如：

```text
"US"
```

如果系统未设置国家信息，可能为 `undefined`。

***

### `Device.systemScriptCode: string | undefined`

当前语言的书写系统代码，例如：

```text
"Hans"   // zh_CN_Hans
```

常用于区分简体 / 繁体等书写系统。

***

## 唤醒锁（Wake Lock）

唤醒锁用于防止设备在脚本运行期间自动休眠。

### `Device.isWakeLockEnabled: Promise<boolean>`

获取当前是否启用了唤醒锁。

```ts
const enabled = await Device.isWakeLockEnabled
```

***

### `Device.setWakeLockEnabled(enabled: boolean): void`

启用或关闭唤醒锁。

```ts
Device.setWakeLockEnabled(true)
```

说明：

- 仅在 **Scripting App** 中可用
- 启用后可防止屏幕自动熄灭或设备进入休眠
- 建议在不需要时及时关闭，以节省电量

***

## 网络接口信息

### `Device.NetworkInterface`

网络接口对象结构：

```ts
type NetworkInterface = {
  address: string
  netmask: string | null
  family: 'IPv4' | 'IPv6'
  mac: string | null
  isInternal: boolean
  cidr: string | null
}
```

字段说明：

- `address`：IP 地址
- `netmask`：子网掩码
- `family`：地址类型（IPv4 / IPv6）
- `mac`：MAC 地址（部分系统可能为 null）
- `isInternal`：是否为内部接口（如回环接口）
- `cidr`：CIDR 表示法（如 `192.168.1.10/24`）

***

### `Device.networkInterfaces(): Record<string, NetworkInterface[]>`

获取设备当前的网络接口信息。

返回值结构：

```ts
{
  [interfaceName: string]: NetworkInterface[]
}
```

示例：

```ts
const interfaces = Device.networkInterfaces()

for (const name in interfaces) {
  for (const info of interfaces[name]) {
    console.log(name, info.address, info.family)
  }
}
```

常见用途：

- 获取本地 IP 地址
- 区分 Wi-Fi / 蜂窝网络 / 回环接口
- 网络调试与诊断
- 模拟 Node.js `os.networkInterfaces()` 行为

***

## 使用建议

- 语言与地区相关逻辑优先使用 `preferredLanguages`
- 唤醒锁应在任务完成后及时关闭
- 网络接口信息可能因系统权限或网络状态变化而不同
- 不要假设某个接口名称一定存在（如 `en0`）



---
url: /zh/guide/Changelog/2.4.6/Device/index_example.md
---

# 示例

```tsx
import { Button, Device, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

 function Example() {
  const dismiss = Navigation.useDismiss()

  const details: {
    name: string
    value: string | boolean | number
  }[] = [
      {
        name: "Device.isiPhone",
        value: Device.isiPhone
      },
      {
        name: "Device.isiPad",
        value: Device.isiPad,
      },
      {
        name: "Device.systemVersion",
        value: Device.systemVersion,
      },
      {
        name: "Device.systemName",
        value: Device.systemName,
      },
      {
        name: "Device.isPortrait",
        value: Device.isPortrait,
      },
      {
        name: "Device.isLandscape",
        value: Device.isLandscape,
      },
      {
        name: "Device.isFlat",
        value: Device.isFlat,
      },
      {
        name: "Device.batteryLevel",
        value: Device.batteryLevel,
      },
      {
        name: "Device.batteryState",
        value: Device.batteryState,
      }
    ]

  return <NavigationStack>
    <List
      navigationTitle={"Device"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      {details.map(item =>
        <VStack
          badge={item.value.toString()}
          alignment={"leading"}
        >
          <Text font={"headline"}>{item.name}</Text>
          <Text font={"caption"}>{typeof item.value}</Text>
        </VStack>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Changelog/2.4.6/Intent.md
---

# Intent

Scripting 支持通过 `intent.tsx` 文件创建 iOS Intents，实现脚本与系统分享扩展（Share Sheet）和快捷指令（Shortcuts）的深度集成。你可以接收来自用户的文本、图片、文件和 URL 等输入，并返回结果供调用方使用。通过 UI 展示、数据处理与结果返回，可构建灵活且强大的自动化流程。

***

## 一、创建和配置 Intent

### 1. 创建 Intent 脚本

1. 在 Scripting 中新建一个脚本项目。
2. 添加名为 `intent.tsx` 的文件，并编写处理逻辑和可选的 UI 组件。

### 2. 配置支持的输入类型

点击编辑器顶部标题栏中的项目名称，打开 **Intent 设置页面**，选择该脚本支持的输入类型，如：

- 文本（Text）
- 图片（Image）
- 文件路径（File URL）
- URL

配置后，该脚本就能在分享扩展或 Shortcuts 中处理相应类型的数据。

***

## 二、处理输入数据

在 `intent.tsx` 中，可通过以下 API 访问用户传入的数据：

| 属性名                        | 说明                                       |
| -------------------------- | ---------------------------------------- |
| `Intent.shortcutParameter` | Shortcuts 中传入的单个参数，包含 `.type` 和 `.value` |
| `Intent.textsParameter`    | 文本字符串数组                                  |
| `Intent.urlsParameter`     | URL 字符串数组                                |
| `Intent.imagesParameter`   | 图片数组（UIImage 实例）                         |
| `Intent.fileURLsParameter` | 文件路径数组（本地 URL）                           |

示例：

```ts
if (Intent.shortcutParameter) {
  if (Intent.shortcutParameter.type === "text") {
    console.log(Intent.shortcutParameter.value)
  }
}
```

***

## 三、返回结果

使用 `Script.exit(result)` 结束脚本执行并返回结果给调用方，例如 Shortcuts 或另一个脚本。支持的返回类型包括：

- 文本：`Intent.text(value)`
- 富文本：`Intent.attributedText(value)`
- URL：`Intent.url(value)`
- JSON 数据：`Intent.json(value)`
- 文件路径：`Intent.file(value)` 或 `Intent.fileURL(value)`

示例：

```ts
import { Script, Intent } from "scripting"

Script.exit(Intent.text("处理完成"))
```

***

## 四、展示交互式 UI

你可以使用 `Navigation.present()` 呈现一个自定义界面，展示输入信息或收集用户反馈。在 UI 交互结束后调用 `Script.exit()` 返回结果。

示例：

```ts
import { Intent, Script, Navigation, VStack, Text } from "scripting"

function MyIntentView() {
  return (
    <VStack>
      <Text>{Intent.textsParameter?.[0]}</Text>
    </VStack>
  )
}

async function run() {
  await Navigation.present(<MyIntentView />)
  Script.exit()
}

run()
```

***

## 五、在分享扩展中使用

当脚本项目启用了对应类型的输入支持，Scripting 会自动集成到系统分享菜单：

1. 用户选中内容（如 Safari 中的文字或图片），点击分享按钮。
2. 分享列表中选择 **Scripting**。
3. 显示支持当前输入类型的脚本列表，供用户执行。

***

## 六、与 Shortcuts 集成

你可以在 Shortcuts 应用中调用 Scripting 脚本：

- **运行脚本（Run Script）**：后台执行，无 UI。
- **在 App 中运行脚本（Run Script in App）**：前台执行，支持 UI 展示。

操作步骤：

1. 在 Shortcuts 中添加 “Run Script” 或 “Run Script in App” 操作。
2. 选择目标脚本。
3. 配置参数，执行脚本。

***

## 七、Intent API 参考

### `Intent` 类属性

| 属性                  | 类型                  | 说明                                    |
| ------------------- | ------------------- | ------------------------------------- |
| `shortcutParameter` | `ShortcutParameter` | Shortcuts 传入的参数对象，包含 `type` 和 `value` |
| `textsParameter`    | `string[]`          | 文本输入数组                                |
| `urlsParameter`     | `string[]`          | URL 字符串数组                             |
| `imagesParameter`   | `UIImage[]`         | 图片数组（路径或图片对象）                         |
| `fileURLsParameter` | `string[]`          | 文件路径数组（本地 URL）                        |

### `Intent` 类方法

| 方法                             | 返回类型                        | 示例                                    |
| ------------------------------ | --------------------------- | ------------------------------------- |
| `Intent.text(value)`           | `IntentTextValue`           | `Intent.text("内容")`                   |
| `Intent.attributedText(value)` | `IntentAttributedTextValue` | `Intent.attributedText("富文本")`        |
| `Intent.url(value)`            | `IntentURLValue`            | `Intent.url("https://example.com")`   |
| `Intent.json(value)`           | `IntentJsonValue`           | `Intent.json({ key: "value" })`       |
| `Intent.file(filePath)`        | `IntentFileValue`           | `Intent.file("/path/to/file.txt")`    |
| `Intent.fileURL(filePath)`     | `IntentFileURLValue`        | `Intent.fileURL("/path/to/file.pdf")` |
| `Intent.image(UIImage)`        | `IntentImageValue`          | `Intent.image(uiImage)`               |

***

## 八、最佳实践与注意事项

- 所有脚本应显式调用 `Script.exit()` 以确保内存安全。
- 推荐在 UI 脚本中使用 `await Navigation.present()` 之后再调用 `Script.exit()`。
- 对于大文件或图像，建议使用 “Run Script in App” 模式，以避免系统内存限制导致的崩溃。
- 如果脚本需要共享数据，可通过 URL Scheme 或 `queryParameters` 实现。



---
url: /zh/guide/Changelog/2.4.6/ItemProvider.md
---

# ItemProvider

`ItemProvider` 用于表示一个**可按需加载的数据提供者**，常见于拖放、文件导入、Photos 选择等场景。
它并不直接包含数据本身，而是描述**可以如何、安全地获取数据**。

`ItemProvider` 支持加载对象、文本、URL、原始数据以及文件路径，并对文件访问施加了明确的安全访问边界。

***

## 核心概念

- `ItemProvider` 描述的是能力，而不是数据
- 所有加载行为都必须遵循系统的安全作用域规则
- 文件类资源只能在受控的回调作用域内访问
- 是否支持原地访问（in-place）由底层系统决定

***

## 属性

### registeredTypes

```ts
readonly registeredTypes: UTType[]
```

表示该 `ItemProvider` 在语义上可以提供的所有类型。

- 包含直接类型以及可推导的父类型
- 用于判断内容大类或调试用途
- 不保证一定存在对应的底层文件表示

***

### registeredInPlaceTypes

```ts
readonly registeredInPlaceTypes: UTType[]
```

表示该 `ItemProvider` 支持原地访问（open-in-place）的类型集合。

- 常见于视频、音频、文档等大文件
- 是否真正原地访问需以加载结果为准

***

## 能力判断方法

### hasItemConforming

```ts
hasItemConforming(type: UTType): boolean
```

判断内容在语义上是否符合指定类型。

- 判断宽松
- 会考虑 UTType 的继承关系
- 适合用于业务分支判断

***

### hasRepresentationConforming

```ts
hasRepresentationConforming(type: UTType): boolean
```

判断是否存在一个真实的、可加载的底层表示符合指定类型。

- 判断严格
- 适合用于文件处理或精确格式要求的场景

***

### hasInPlaceRepresentationConforming

```ts
hasInPlaceRepresentationConforming(type: UTType): boolean
```

判断是否存在支持原地访问的底层表示。

- 常用于大文件加载策略选择

***

## 对象加载能力判断

### canLoadUIImage

```ts
canLoadUIImage(): boolean
```

判断是否可以加载为 `UIImage` 对象。

- 适合 UI 展示
- 不保证原始文件格式或元数据

***

### canLoadLivePhoto

```ts
canLoadLivePhoto(): boolean
```

判断是否可以加载为 `LivePhoto` 对象。

- 用于区分静态图片与 Live Photo
- 返回 `true` 时可调用 `loadLivePhoto`

***

## 加载方法

### loadUIImage

```ts
loadUIImage(): Promise<UIImage | null>
```

加载一个 `UIImage` 对象。

- 适合轻量展示
- 不适合用于文件级处理或资源保真

***

### loadLivePhoto

```ts
loadLivePhoto(): Promise<LivePhoto | null>
```

加载一个 `LivePhoto` 对象。

- 包含图片与配对视频
- 适合展示、保存或进一步处理

***

### loadURL

```ts
loadURL(): Promise<string | null>
```

加载一个 URL 字符串。

- 可能是网页 URL
- 也可能是文件 URL

***

### loadText

```ts
loadText(): Promise<string | null>
```

加载纯文本内容。

- 支持 plain text
- 富文本会被降级为纯文本

***

### loadData

```ts
loadData(type: UTType): Promise<Data | null>
```

加载指定类型的原始二进制数据。

- 数据会整体加载进内存
- 适合 JSON、配置文件、小体积资源
- 不适合视频、音频等大文件

***

## 文件路径加载（安全作用域）

文件路径的加载需要遵循系统的安全限制，所有文件访问都必须在指定的回调作用域内完成。

***

### loadFilePath

```ts
loadFilePath(type: UTType): Promise<string | null>
```

加载指定类型的文件路径，如果文件不存在或无法加载，返回 `null`。如果可以加载，文件会被复制到应用组的临时目录中，并返回文件路径。
如果你不再需要文件，请删除它。

示例：

```ts
const filePath = provider.loadFilePath("public.movie")
```

***

## 创建 ItemProvider

### fromUIImage

```ts
ItemProvider.fromUIImage(image: UIImage): ItemProvider
```

从 `UIImage` 创建 `ItemProvider`。

- 仅提供静态图片能力
- 不包含 Live Photo 或原始资源信息

***

### fromText

```ts
ItemProvider.fromText(text: string): ItemProvider
```

从文本创建 `ItemProvider`。

***

### fromURL

```ts
ItemProvider.fromURL(url: string): ItemProvider | null
```

从 URL 字符串创建 `ItemProvider`。

- URL 不合法时返回 `null`
- 支持网页 URL 与文件 URL

***

### fromFilePath

```ts
ItemProvider.fromFilePath(path: string): ItemProvider
```

从文件路径创建 `ItemProvider`。

- 保留原始文件
- 适合视频、音频、文档等资源
- 支持原地访问能力判断

***

## 使用建议

- 使用 `hasItemConforming` 进行内容类型判断
- 使用对象加载方法进行 UI 展示
- 使用文件路径加载方法处理大文件
- 文件路径只能在 `perform` 回调作用域内访问
- 不应在回调外部延迟访问安全作用域文件



---
url: /zh/guide/Changelog/2.4.6/MediaComposer/MediaComposer Example.md
---

# MediaComposer 示例

本示例演示如何使用 `MediaComposer` 将 **视频 + 图片 + 音频** 组合成一个最终视频文件，并导出到脚本目录中。

示例流程包括：

1. 选择音频文件
2. 选择一张图片
3. 选择一个视频
4. 构建视频时间线（Video + Image）
5. 在指定时间点插入音频
6. 导出合成后的视频

***

## 示例代码

```tsx
import { Path, Script } from "scripting"

console.present().then(() => Script.exit())

async function run() {
  try {

    const audioPath = (await DocumentPicker.pickFiles({
      types: ["public.audio"]
    })).at(0)

    if (audioPath == null) {
      console.error("no audio")
      return
    }

    console.log("Audio Picked")

    const imageResult = (await Photos.pick({
      filter: PHPickerFilter.images()
    })).at(0)

    const imagePath = await imageResult?.itemProvider.loadFilePath("public.image")

    if (!imagePath) {
      console.log("No image")
      return
    }

    console.log("Image picked")

    const videoResult = (await Photos.pick({
      filter: PHPickerFilter.videos()
    })).at(0)

    const videoPath = await videoResult?.itemProvider.loadFilePath("public.movie")

    if (videoPath == null) {
      console.log("No video")
      return
    }

    console.log("Video Picked")

    console.log("Start composing...")

    const exportPath = Path.join(
      Script.directory,
      "dest.mp4"
    )

    const exportResult = await MediaComposer.composeAndExport({
      exportPath,
      timeline: {
        videoItems: [{
          videoPath: videoPath
        }, {
          imagePath: imagePath,
          duration: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }],
        audioClips: [{
          path: audioPath,
          at: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }]
      }
    })

    console.log(
      "Result:",
      exportResult.exportPath,
      "\n",
      exportResult.duration.getSeconds()
    )

  } catch (e) {
    console.error(e)
  }
}

run()
```

***

## 时间线解析

### 视频 / 图片时间线（videoItems）

```ts
videoItems: [
  { videoPath },
  {
    imagePath,
    duration: MediaTime.make({
      seconds: 5,
      preferredTimescale: 600
    })
  }
]
```

- 第一个 `VideoItem` 是完整视频
- 第二个 `VideoItem` 是一张图片，显示 5 秒
- 所有 `videoItems` **按顺序依次拼接**
- 最终视频总时长 = 视频时长 + 图片 5 秒

***

### 音频时间线（audioClips）

```ts
audioClips: [{
  path: audioPath,
  at: MediaTime.make({
    seconds: 5,
    preferredTimescale: 600
  })
}]
```

- 音频在最终视频的 **第 5 秒开始播放**
- 不指定 `at` 时，音频会顺序接在前一个外部音频之后
- 音频不会影响最终视频时长

***

## 导出结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- `exportPath`：导出文件的完整路径
- `duration`：最终视频时长（仅由 `videoItems` 决定）

***

## 常见错误与边界情况

### 1. ImageClip 未指定 duration

```ts
{
  imagePath: "...",
  //  缺少 duration
}
```

**问题：**

- ImageClip 没有天然时长
- 不指定 `duration` 会导致合成失败

**解决方案：**

- 必须显式提供 `MediaTime`

***

### 2. 使用浮点秒数而非 MediaTime

```ts
// 错误
at: 5
```

**正确做法：**

```ts
at: MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

MediaComposer 中 **所有时间必须使用 MediaTime**。

***

### 3. 混合不同 timescale 导致精度问题

**问题：**

- 不同音视频资源使用不同 timescale
- 在剪辑、拼接、淡入淡出时可能出现边界误差

**建议：**

- 在脚本中统一使用 `preferredTimescale: 600`
- 对外部时间先做 `convertScale`

***

### 4. 音频超出视频范围

**行为说明：**

- 音频即使超过视频末尾，也不会延长最终视频
- 超出部分会被自动截断

***

### 5. 同时存在视频原音与外部音频但音量异常

**原因：**

- 默认情况下，外部音频与视频原音会同时混合
- 未配置 ducking 时，可能出现人声被盖住的问题

***

## 音频 Ducking 行为说明

### 什么是 Ducking

Ducking 指的是：

> 当视频原音（如人声）存在时，自动降低外部音频（如背景音乐）的音量

***

### Ducking 配置

```ts
exportOptions: {
  ducking: {
    enabled: true,
    duckedVolume: 0.25,
    attackSeconds: 0.15,
    releaseSeconds: 0.25
  }
}
```

#### 参数说明

- **enabled**
  是否启用 ducking，默认 `true`

- **duckedVolume**
  被压低后的外部音频音量（0…1）

- **attackSeconds**
  在视频原音开始前，音量下降的过渡时间

- **releaseSeconds**
  在视频原音结束后，音量恢复的过渡时间

***

### Ducking 生效条件

Ducking 仅在以下条件同时满足时生效：

1. `VideoClip.keepOriginalAudio === true`
2. 存在外部 `audioClips`
3. `exportOptions.ducking.enabled !== false`

***

## 音频混音规则总结

1. **视频原音**

   - 只有在 `keepOriginalAudio: true` 时才参与混音

2. **外部音频**

   - 可指定时间点或顺序拼接
   - 可设置 `volume`、`fade`、`loopToFitVideoDuration`

3. **最终混音顺序**

   - 所有音频会被混合到单一音轨
   - 不会改变视频时长
   - Ducking 在混音阶段自动应用



---
url: /zh/guide/Changelog/2.4.6/MediaComposer/MediaTime.md
---

# MediaTime

`MediaTime` 用于表示音视频处理中的**精确时间点或时间长度**，是 Scripting 中 MediaComposer 时间系统的基础类型。
它在语义上对应于底层媒体框架中的“带时间基准的时间值”（如 AVFoundation 的 `CMTime`），但对脚本侧提供了更安全、可读、可计算的抽象。

`MediaTime` 既可以表示**确定的数值时间**，也可以表示**无效、无限或不确定时间**，并支持严格的时间运算与比较。

***

## 核心特性

- 使用 **value + timescale** 或 **seconds + preferredTimescale** 精确构造时间
- 支持时间缩放（convertScale）及多种舍入策略
- 支持加减运算与大小比较
- 明确区分有效时间、无效时间、无限时间和不确定时间
- 适用于时间线计算、剪辑、对齐、放置（at）、淡入淡出等所有时间相关场景

***

## 时间精度模型

`MediaTime` 的底层模型基于以下概念：

- **value**：整数时间值
- **timescale**：每秒的时间单位数
  例如：

  - `value = 300`, `timescale = 600` 表示 0.5 秒
  - `value = 18000`, `timescale = 600` 表示 30 秒

通过 timescale，`MediaTime` 可以精确表达帧级或采样级时间，而不依赖浮点数。

***

## 只读属性

### secondes

```ts
readonly secondes: number
```

当前时间对应的秒数（浮点数形式）。
这是一个**派生值**，主要用于展示或调试，不建议用于时间计算。

***

### isValid

```ts
readonly isValid: boolean
```

表示该时间是否是一个有效、可用于计算的时间值。
当时间为 `invalid`、`indefinite` 或无穷大时，该值为 `false`。

***

### isPositiveInfinity / isNegativeInfinity

```ts
readonly isPositiveInfinity: boolean
readonly isNegativeInfinity: boolean
```

表示该时间是否为正无穷或负无穷。
常用于内部边界标记或时间线计算中的极值判断。

***

### isIndefinite

```ts
readonly isIndefinite: boolean
```

表示该时间是否为“不确定时间”。
通常用于尚未解析出真实时长的媒体资源。

***

### isNumeric

```ts
readonly isNumeric: boolean
```

表示该时间是否是一个可参与数值计算的时间。
只有在该值为 `true` 时，才应进行加减或比较操作。

***

### hasBeenRounded

```ts
readonly hasBeenRounded: boolean
```

表示该时间是否在构造或转换过程中发生过舍入。
对于帧精度或采样精度要求较高的场景，该属性可用于调试或验证。

***

## 时间转换

### convertScale

```ts
convertScale(newTimescale: number, method: MediaTimeRoundingMethod): MediaTime
```

将当前时间转换为新的 timescale，并使用指定的舍入策略。

**典型用途：**

- 对齐视频帧时间（如 600、90000）
- 对齐音频采样时间（如 44100、48000）
- 避免不同时间基准混用导致的误差

***

## 时间值获取

### getSeconds

```ts
getSeconds(): number
```

返回当前时间对应的秒数（浮点数）。
该方法等价于读取 `secondes`，但在语义上更明确。

***

## 时间运算

### plus / minus

```ts
plus(other: MediaItem): MediaItem
minus(other: MediaItem): MediaItem
```

执行时间加法或减法运算，返回新的 `MediaTime`。

- 运算双方必须为可计算时间
- 不会修改原对象
- 运算结果遵循内部时间基准规则

***

## 时间比较

```ts
lt(other: MediaItem): boolean
gt(other: MediaItem): boolean
lte(other: MediaItem): boolean
gte(other: MediaItem): boolean
eq(other: MediaItem): boolean
neq(other: MediaItem): boolean
```

用于比较两个时间的大小或相等性。

- 支持严格比较
- 对无效或非数值时间的比较结果是确定性的
- 推荐在进行时间线排序、裁剪判断、边界检测时使用

***

## 静态构造方法

### make

```ts
static make(options: {
  value: number
  timescale: number
} | {
  seconds: number
  preferredTimescale: number
}): MediaTime
```

用于创建一个 `MediaTime` 实例。

#### 使用 value + timescale

```ts
MediaTime.make({
  value: 300,
  timescale: 600
})
```

适用于需要精确控制时间单位的场景。

#### 使用 seconds + preferredTimescale

```ts
MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

适用于脚本层以“秒”为主的时间描述方式。

***

### zero

```ts
static zero(): MediaTime
```

返回一个表示 **0 秒** 的时间。

***

### invalid

```ts
static invalid(): MediaTime
```

返回一个无效时间。
用于显式表示错误、缺失或不可用的时间值。

***

### indefinite

```ts
static indefinite(): MediaTime
```

返回一个不确定时间。
通常用于媒体尚未加载完成、时长未知的状态。

***

### positiveInfinity / negativeInfinity

```ts
static positiveInfinity(): MediaTime
static negativeInfinity(): MediaTime
```

返回正无穷或负无穷时间。
主要用于内部时间线边界控制，不建议在普通脚本逻辑中使用。

***

## 使用建议与注意事项

- **避免直接使用浮点秒数进行时间计算**，应始终使用 `MediaTime`
- 不同媒体资源可能使用不同的 timescale，必要时显式调用 `convertScale`
- 在比较或运算前，建议检查 `isNumeric`
- 在构建时间线（如 `at`、`sourceTimeRange`）时，统一 timescale 可减少误差

***

## 在 MediaComposer 中的典型用途

- 指定音频或视频片段的放置时间（`AudioClip.at`）
- 定义剪辑的起点与时长（`TimeRange`）
- 计算最终导出视频的精确时长
- 控制淡入淡出、对齐、循环等时间行为



---
url: /zh/guide/Changelog/2.4.6/MediaComposer/Quick Start.md
---

# 快速开始

`MediaComposer` 用于在 Scripting 中 **组合视频、图片与音频时间线并导出最终媒体文件**。
它封装了一套稳定的时间线模型，支持视频剪辑、图片片段、音频叠加、淡入淡出、音频 ducking、导出参数控制等高级能力。

该模块适用于：

- 视频与图片混合生成短片
- 给视频添加背景音乐、配音或音效
- 使用图片序列生成视频
- 自动化视频处理与内容生成脚本

***

## 设计概览

MediaComposer 的核心由三部分组成：

1. **时间模型**
   使用 `MediaTime` / `TimeRange` 精确描述时间点与时长

2. **时间线模型**

   - `VideoItem[]`：视频或图片片段（顺序拼接）
   - `AudioClip[]`：音频轨道（可指定时间点或自动顺序放置）

3. **导出系统**
   通过统一的 `composeAndExport` 接口完成渲染与导出

***

## 时间线结构

```ts
timeline: {
  videoItems: VideoItem[]
  audioClips: AudioClip[]
}
```

- **videoItems**
  定义视觉时间线，视频与图片会严格按数组顺序依次排列
- **audioClips**
  定义音频时间线，可自由指定放置时间（`at`），或顺序追加

最终导出的视频时长由 **videoItems 决定**。

***

## VideoItem

```ts
type VideoItem = XOR<VideoClip, ImageClip>
```

`VideoItem` 表示时间线中的一个“视觉片段”，可以是 **视频** 或 **图片**，但不能同时是两者。

***

## VideoClip（视频片段）

```ts
type VideoClip = {
  videoPath: string
  sourceTimeRange?: TimeRange | null
  keepOriginalAudio?: boolean
  fade?: FadeConfig | null
}
```

### videoPath

- 视频文件路径
- 支持本地视频文件

***

### sourceTimeRange

```ts
sourceTimeRange?: TimeRange | null
```

- 指定从源视频中使用的时间范围
- 不提供时，默认使用整个视频

**常见用途：**

- 裁剪视频片段
- 只取某一段作为素材

***

### keepOriginalAudio

```ts
keepOriginalAudio?: boolean
```

- 是否保留视频自带的音频
- 默认值：`false`

**说明：**

- 为 `true` 时，视频原音会参与混音
- 可与外部 `audioClips` 同时存在
- 是否对外部音频进行 ducking 由 `ExportOptions.ducking` 控制

***

### fade

```ts
fade?: FadeConfig | null
```

- 视频片段的淡入淡出配置
- 会覆盖全局视频淡入淡出设置（如果存在）

***

## ImageClip（图片片段）

```ts
type ImageClip = {
  imagePath: string
  duration: MediaTime
  contentMode?: "fit" | "crop"
  backgroundColor?: Color
  fade?: FadeConfig | null
}
```

`ImageClip` 用于将一张静态图片作为视频时间线中的一个片段。

***

### imagePath

- 图片文件路径
- 支持常见图片格式（JPEG / PNG / HEIC 等）

***

### duration

```ts
duration: MediaTime
```

- 图片片段在视频中的显示时长
- 必须显式指定

***

### contentMode

```ts
contentMode?: "fit" | "crop"
```

- 控制图片如何适配渲染尺寸
- 默认值：`fit`

说明：

- `fit`：完整显示图片，可能留黑边
- `crop`：填满画面，超出部分裁剪

***

### backgroundColor

```ts
backgroundColor?: Color
```

- 图片未覆盖区域的背景色
- 通常与 `fit` 模式搭配使用

***

### fade

```ts
fade?: FadeConfig | null
```

- 图片片段的淡入淡出配置
- 支持与视频片段统一使用

***

## AudioClip（音频片段）

```ts
type AudioClip = {
  path: string
  sourceTimeRange?: TimeRange | null
  at?: MediaTime
  volume?: number
  fade?: FadeConfig | null
  loopToFitVideoDuration?: boolean
}
```

音频片段用于在最终视频中添加背景音乐、配音或音效。

***

### path

- 音频文件路径

***

### sourceTimeRange

- 指定使用音频的某一时间段
- 默认使用整个音频文件

***

### at

```ts
at?: MediaTime
```

- 指定音频在最终时间线中的放置时间
- 不指定时：

  - 按顺序接在前一个外部音频片段之后

***

### volume

```ts
volume?: number
```

- 单个音频片段的音量（0…1）
- 默认值：1

***

### fade

- 音频淡入淡出配置
- 常用于背景音乐的自然过渡

***

### loopToFitVideoDuration

```ts
loopToFitVideoDuration?: boolean
```

- 是否循环音频以匹配视频总时长
- 常用于背景音乐

***

## FadeConfig（淡入淡出）

```ts
type FadeConfig = {
  fadeInSeconds?: number
  fadeOutSeconds?: number
}
```

- 单位：秒
- 可用于视频、图片、音频
- 未指定时默认为 0

***

## ExportOptions（导出配置）

```ts
type ExportOptions = {
  renderSize?: Size
  frameRate?: number
  scaleMode?: VideoScaleMode
  globalVideoFade?: FadeConfig | null
  externalAudioBaseVolume?: number
  ducking?: DuckingConfig
  presetName?: ExportPreset
  outputFileType?: ExportFileType
}
```

### 常用说明

- **renderSize**
  最终视频分辨率，默认 1080×1920

- **frameRate**
  渲染帧率，默认 30

- **globalVideoFade**
  全局视频淡入淡出（可被单个 clip 覆盖）

- **ducking**
  当视频存在原音时，自动降低外部音频音量

- **presetName / outputFileType**
  控制编码质量与文件格式

***

## composeAndExport

```ts
function composeAndExport(options: {
  exportPath: string
  timeline: {
    videoItems: VideoItem[]
    audioClips: AudioClip[]
  }
  exportOptions?: ExportOptions
  overwrite?: boolean
}): Promise<{
  exportPath: string
  duration: MediaTime
}>
```

### 参数说明

- **exportPath**
  导出文件路径

- **timeline.videoItems**
  视频 / 图片时间线（顺序执行）

- **timeline.audioClips**
  音频时间线（可自由放置）

- **exportOptions**
  导出配置，可选

- **overwrite**
  是否覆盖已有文件，默认 `true`

***

### 返回结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- **exportPath**：最终导出路径
- **duration**：最终视频时长（由 videoItems 决定）

***

## 使用建议与最佳实践

- 始终使用 `MediaTime` 描述时间，避免直接使用浮点秒数
- 图片片段必须显式指定 `duration`
- 音频与视频的时间线是 **独立但最终混合** 的
- 对复杂项目，建议统一 timescale（如 600）
- 背景音乐推荐使用 `loopToFitVideoDuration`

***

## 典型使用场景

- 图片 + 视频混合短片
- 自动生成带背景音乐的视频
- 视频剪辑与配音合成
- 内容创作与自动化视频生成



---
url: /zh/guide/Changelog/2.4.6/SharedAudioSession.md
---

# SharedAudioSession

通过 `SharedAudioSession`，你可以在脚本中方便地管理和操作共享音频会话（audio session）。音频会话充当脚本、Scripting 应用、操作系统和底层音频硬件之间的中介，允许你有效地配置和控制音频的行为。

***

## 功能简介

- 获取和设置音频会话的类别（category）、模式（mode）和选项（options）。
- 配置音频输入和输出的首选采样率（sample rate）。
- 处理音频中断事件。
- 查询设备所支持的类别和模式。
- 根据具体的应用场景（如视频录制、语音聊天、后台播放等）来定制音频行为。

***

## 方法和属性

### 1. **会话类别与选项**

#### `category`

获取当前音频会话的类别（Category）。

```typescript
const category = await SharedAudioSession.category
console.log(category) // 示例输出：'playback'
```

#### `categoryOptions`

获取当前音频会话类别的选项（Options）。

```typescript
const options = await SharedAudioSession.categoryOptions
console.log(options) // 示例输出：['mixWithOthers', 'allowAirPlay']
```

#### `setCategory(category: AudioSessionCategory, options: AudioSessionCategoryOptions[])`

设置音频会话的类别并指定其选项。

```typescript
await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
```

***

### 2. **会话模式**

#### `mode`

获取当前音频会话模式（Mode）。

```typescript
const mode = await SharedAudioSession.mode
console.log(mode) // 示例输出：'videoChat'
```

#### `setMode(mode: AudioSessionMode)`

设置音频会话模式。

```typescript
await SharedAudioSession.setMode('voiceChat')
```

***

### 3. **采样率 (Sample Rate)**

#### `preferredSampleRate`

获取当前首选采样率（单位为 Hz）。

```typescript
const sampleRate = await SharedAudioSession.preferredSampleRate
console.log(sampleRate) // 示例输出：44100
```

#### `setPreferredSampleRate(sampleRate: number)`

设置音频输入和输出的首选采样率。

```typescript
await SharedAudioSession.setPreferredSampleRate(48000)
```

***

### 4. **音频中断处理**

#### `addInterruptionListener(listener: AudioSessionInterruptionListener)`

监听音频中断事件。

```typescript
SharedAudioSession.addInterruptionListener((type) => {
  if (type === 'began') {
    console.log('音频中断开始')
  } else if (type === 'ended') {
    console.log('音频中断结束')
  }
})
```

#### `removeInterruptionListener(listener: AudioSessionInterruptionListener)`

移除音频中断监听器。

```typescript
SharedAudioSession.removeInterruptionListener(myListener)
```

***

### 5. **设备功能查询**

#### `availableCategories`

获取设备上可用的音频会话类别列表。

```typescript
const categories = await SharedAudioSession.availableCategories
console.log(categories) // 示例输出：['playback', 'record', 'soloAmbient']
```

#### `availableModes`

获取设备上可用的音频会话模式列表。

```typescript
const modes = await SharedAudioSession.availableModes
console.log(modes) // 示例输出：['default', 'videoChat', 'voiceChat']
```

***

### 6. **其他属性**

#### `isOtherAudioPlaying`

检查设备上是否有其他音频正在播放。

```typescript
const isPlaying = await SharedAudioSession.isOtherAudioPlaying
console.log(isPlaying) // 示例输出：true
```

#### `secondaryAudioShouldBeSilencedHint`

检查次要音频是否应该被静音。

```typescript
const shouldSilence = await SharedAudioSession.secondaryAudioShouldBeSilencedHint
console.log(shouldSilence) // 示例输出：false
```

#### `allowHapticsAndSystemSoundsDuringRecording`

检查录音期间是否允许触觉反馈和系统声音。

```typescript
const allowHaptics = await SharedAudioSession.allowHapticsAndSystemSoundsDuringRecording
console.log(allowHaptics) // 示例输出：true
```

#### `prefersNoInterruptionsFromSystemAlerts`

检查音频会话是否偏好不被系统警报打断。

```typescript
const prefersNoInterruptions = await SharedAudioSession.prefersNoInterruptionsFromSystemAlerts
console.log(prefersNoInterruptions) // 示例输出：false
```

***

### 7. **会话激活**

#### `setActive(active: boolean, options?: AudioSessionSetActiveOptions[])`

激活或停用共享音频会话，可指定激活选项。

```typescript
await SharedAudioSession.setActive(
  true,
  ['notifyOthersOnDeactivation']
)
```

***

### 8. **系统设置**

#### `setAllowHapticsAndSystemSoundsDuringRecording(value: boolean)`

启用或禁用在录音期间允许触觉反馈和系统声音。

```typescript
await SharedAudioSession.setAllowHapticsAndSystemSoundsDuringRecording(true)
```

#### `setPrefersNoInterruptionsFromSystemAlerts(value: boolean)`

设置是否偏好不被系统警报打断。

```typescript
await SharedAudioSession.setPrefersNoInterruptionsFromSystemAlerts(true)
```

***

### 9. **系统输出音量**

#### `outputVolume: number`

获取当前系统输出音量（范围为 0 到 1）。

#### outputVolume 监听事件

类型类型

```ts
type AudioSessionOutputVolumeListener = (newValue: number, oldValue: number) => void
```

##### `addOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

添加系统输出音量监听器。

##### `removeOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

移除系统输出音量监听器。

***

## 枚举（Enumerations）

### **AudioSessionSetActiveOptions**

定义激活选项：

- `'notifyOthersOnDeactivation'`

### **AudioSessionCategory**

定义音频会话的类别：

- `'ambient'`
- `'multiRoute'`
- `'playAndRecord'`
- `'playback'`
- `'record'`
- `'soloAmbient'`

### **AudioSessionCategoryOptions**

定义类别的可选行为：

- `'mixWithOthers'`
- `'duckOthers'`
- `'interruptSpokenAudioAndMixWithOthers'`
- `'allowBluetooth'`
- `'allowBluetoothA2DP'`
- `'allowAirPlay'`
- `'defaultToSpeaker'`
- `'overrideMutedMicrophoneInterruption'`

### **AudioSessionMode**

指定会话模式：

- `'default'`
- `'gameChat'`
- `'measurement'`
- `'moviePlayback'`
- `'spokenAudio'`
- `'videoChat'`
- `'videoRecording'`
- `'voiceChat'`
- `'voicePrompt'`

### **AudioSessionInterruptionType**

指定中断类型：

- `'began'`
- `'ended'`
- `'unknown'`

***

通过此接口，你可以在 Scripting 应用中对音频会话进行深度管理，非常适合构建对音频依赖较高的脚本，如音乐播放器和视频会议工具等。



---
url: /zh/guide/Changelog/2.4.6/VideoRecorder.md
---

# 视频录制（VideoRecorder）

`VideoRecorder` 用于在 Scripting 中创建和控制一个可编程的视频录制会话，完整封装了相机选择、音视频采集、编码、暂停/恢复、缩放、对焦、补光灯控制以及最终文件写入流程。

该 API 适用于自定义相机界面、视频采集工具、自动化录制脚本等场景。

***

## 核心能力概览

- 支持前置与后置摄像头
- 支持指定摄像头类型（广角、超广角、长焦等）
- 支持多种帧率（24 / 30 / 60 / 120）
- 支持音频录制的启用与禁用
- 支持多种系统 Session Preset
- 支持多种视频编码格式（HEVC / H.264 / ProRes 等）
- 支持录制过程中的暂停与恢复
- 支持对焦点、曝光点独立控制
- 支持变焦与平滑变焦（ramp）
- 支持补光灯（Torch）控制
- 明确的状态机与状态回调
- 明确的生命周期管理（prepare / reset / dispose）

***

## 类型定义

### CameraPosition

```ts
type CameraPosition = "front" | "back"
```

表示使用的摄像头朝向。

***

### CameraType

```ts
type CameraType =
  | "wide"
  | "ultraWide"
  | "telephoto"
  | "trueDepth"
  | "dual"
  | "dualWide"
  | "triple"
```

表示摄像头的物理类型。
是否支持某一类型取决于设备硬件能力。

***

### VideoRecorderState

```ts
type VideoRecorderState =
  | "idle"
  | "preparing"
  | "ready"
  | "recording"
  | "paused"
  | "finishing"
  | "finished"
  | "failed"
```

#### 状态说明

| 状态          | 含义             |
| ----------- | -------------- |
| `idle`      | 初始状态，尚未配置资源    |
| `preparing` | 正在配置相机会话与音视频管线 |
| `ready`     | 已准备完成，可以开始录制   |
| `recording` | 正在录制           |
| `paused`    | 录制已暂停          |
| `finishing` | 正在结束录制并写入文件    |
| `finished`  | 录制完成           |
| `failed`    | 发生错误，录制失败      |

***

### VideoCaptureSessionPreset

```ts
type VideoCaptureSessionPreset =
  | "high"
  | "medium"
  | "low"
  | "cif352x288"
  | "vga640x480"
  | "iFrame960x540"
  | "iFrame1280x720"
  | "hd1280x720"
  | "hd1920x1080"
  | "hd4K3840x2160"
```

表示捕捉会话的分辨率预设。

***

### VideoCodec

```ts
type VideoCodec =
  | "hevc"
  | "h264"
  | "jpeg"
  | "JPEGXL"
  | "proRes4444"
  | "appleProRes4444XQ"
  | "proRes422"
  | "proRes422HQ"
  | "proRes422LT"
  | "proRes422Proxy"
  | "proResRAW"
  | "proResRAWHQ"
  | "hevcWithAlpha"
```

表示视频编码格式。
具体是否可用取决于设备与系统支持情况。

***

### VideoOrientation

```ts
type VideoOrientation =
  | "portrait"
  | "landscapeLeft"
  | "landscapeRight"
```

表示输出视频的方向。

***

## 构造函数

```ts
new VideoRecorder(settings?)
```

### settings 参数

```ts
{
  camera?: {
    position: CameraPosition
    preferredTypes?: CameraType[]
  }
  frameRate?: number
  audioEnabled?: boolean
  sessionPreset?: VideoCaptureSessionPreset
  videoCodec?: VideoCodec
  videoBitRate?: number
  orientation?: VideoOrientation
  mirrorFrontCamera?: boolean
}
```

#### 参数说明

- **camera**

  - `position`
    使用的摄像头位置，默认 `"back"`
  - `preferredTypes`
    偏好的摄像头类型列表
    如果未提供，内部将根据摄像头位置自动选择合适的类型

- **frameRate**
  目标帧率，支持 24 / 30 / 60 / 120，默认 30
  实际帧率受设备与分辨率限制

- **audioEnabled**
  是否录制音频，默认 `true`

- **sessionPreset**
  捕捉会话分辨率预设，默认 `"high"`

- **videoCodec**
  视频编码格式，默认 `"hevc"`

- **videoBitRate**
  视频平均码率（bit/s），未指定时由系统自动选择

- **orientation**
  输出视频方向，默认 `"portrait"`

- **mirrorFrontCamera**
  前置摄像头是否镜像，默认 `true`
  仅在使用前置摄像头时生效

***

## 只读属性

### minZoomFactor

```ts
readonly minZoomFactor: number
```

当前设备支持的最小变焦倍率。

***

### maxZoomFactor

```ts
readonly maxZoomFactor: number
```

当前设备支持的最大变焦倍率。

***

### currentZoomFactor

```ts
readonly currentZoomFactor: number
```

当前变焦倍率。

***

### displayZoomFactor

```ts
readonly displayZoomFactor: number
```

用户可读的变焦倍率。

***

### hasTorch

```ts
readonly hasTorch: boolean
```

当前摄像头是否支持补光灯。

***

### torchMode

```ts
readonly torchMode: "auto" | "on" | "off"
```

当前补光灯模式。

***

## 状态与回调

### state

```ts
state: VideoRecorderState
```

表示当前录制器所处的状态。

***

### onStateChanged

```ts
onStateChanged?: (
  state: VideoRecorderState,
  details?: string
) => void
```

状态变化回调。

- 当 `state === "failed"`
  `details` 为错误信息描述

- 当 `state === "finished"`
  `details` 为最终视频文件的完整保存路径

***

## 方法说明

### prepare()

```ts
prepare(): Promise<void>
```

准备录制器资源，包括相机会话、输入输出与音视频管线配置。

#### 使用约束

- 必须在 `startRecording` 之前调用
- 成功后状态变为 `ready`
- 失败会进入 `failed` 状态

***

### startRecording(toPath)

```ts
startRecording(toPath: string): void
```

开始录制视频。

#### 参数

- **toPath**
  视频文件保存路径（完整路径）

#### 使用约束

- 仅允许在 `ready` 状态下调用
- 调用后状态变为 `recording`

***

### pauseRecording()

```ts
pauseRecording(): void
```

暂停当前录制。

#### 使用约束

- 仅允许在 `recording` 状态下调用
- 调用后状态变为 `paused`
- 时间线会被正确压缩，不产生空白帧

***

### resumeRecording()

```ts
resumeRecording(): void
```

恢复已暂停的录制。

#### 使用约束

- 仅允许在 `paused` 状态下调用
- 调用后状态回到 `recording`

***

### stopRecording()

```ts
stopRecording(): Promise<void>
```

停止录制并生成最终视频文件。

#### 行为说明

- 状态先进入 `finishing`
- 文件写入完成后进入 `finished`
- 最终文件路径通过 `onStateChanged` 回调返回

***

### reset()

```ts
reset(): Promise<void>
```

重置录制器状态，用于开始新一轮录制。

#### 使用场景

- 已完成一次录制
- 或录制失败后希望复用同一实例

#### 行为说明

- 成功后状态回到 `idle`
- 可再次调用 `prepare`

***

### setTorchMode()

```ts
setTorchMode(mode: "auto" | "off" | "on"): void
```

设置补光灯模式。

***

### setFocusPoint()

```ts
setFocusPoint(point: { x: number; y: number }): void
```

设置对焦点。

- 坐标为归一化值，范围 `0.0 ~ 1.0`
- `(0,0)` 表示画面左上角，`(1,1)` 表示右下角

***

### setExposurePoint()

```ts
setExposurePoint(point: { x: number; y: number }): void
```

设置曝光点，坐标规则与对焦点一致。

***

### resetFocus()

```ts
resetFocus(): void
```

恢复自动对焦模式。

***

### resetExposure()

```ts
resetExposure(): void
```

恢复自动曝光模式。

***

### setZoomFactor()

```ts
setZoomFactor(factor: number): void
```

立即设置变焦倍率。

- 值应位于 `minZoomFactor` 与 `maxZoomFactor` 之间

***

### rampZoomFactor()

```ts
rampZoomFactor(toFactor: number, rate: number): void
```

以平滑方式调整变焦倍率。

- `toFactor` 为目标倍率
- `rate` 为变化速率，单位为每秒的 2 次幂变化

***

### resetZoom()

```ts
resetZoom(): void
```

将变焦倍率恢复为默认值（通常为 1.0）。

***

### dispose()

```ts
dispose(): Promise<void>
```

释放并销毁录制器。

#### 使用约束

- 调用后实例不可再使用
- 会释放相机、音频与底层系统资源
- 建议在页面或脚本生命周期结束时调用

***

## 典型使用流程

```ts
const recorder = new VideoRecorder({
  camera: { position: "back" },
  frameRate: 60,
  videoCodec: "hevc"
})

recorder.onStateChanged = (state, details) => {
  if (state === "finished") {
    console.log("Video saved at:", details)
  }
}

await recorder.prepare()
recorder.startRecording("/path/to/tmp/demo.mov")
```

***

## 使用建议

- 始终监听 `onStateChanged` 以掌握完整状态变化
- 不要在未调用 `prepare` 的情况下开始录制
- 每次完成录制后，如需复用实例，应先调用 `reset`
- 生命周期结束时务必调用 `dispose` 释放资源



---
url: /zh/guide/Changelog/2.4.6/onDrag and onDrop View Modifiers.md
---

# onDrag 和 onDrop 修饰符

Scripting 提供了一套与 SwiftUI Drag & Drop 行为模型高度一致的 API，用于在脚本中实现视图间、应用内或跨应用的拖拽与放置操作。

该能力主要由以下三部分构成：

- **onDrag**：将当前视图声明为拖拽源
- **onDrop**：将当前视图声明为放置目标
- **DropInfo / ItemProvider / UTType**：描述拖拽内容与状态的上下文对象

拖拽与放置是一个严格受系统控制的交互流程，部分 API 只能在特定回调中调用，文档中会明确指出这些限制。

***

## 核心数据类型

### DropInfo

`DropInfo` 描述一次拖拽在当前放置视图上的实时状态。该对象仅在 `onDrop` 相关回调中有效。

#### 属性

##### location: Point

- 表示拖拽当前位置
- 坐标空间为 **放置视图自身的本地坐标系**
- 可用于实现基于位置的高亮、插入指示线、排序逻辑等

#### 方法

##### hasItemsConforming(types: UTType\[]): boolean

- 用于判断拖拽内容中，是否至少有一个项目符合指定的 UTType
- 常用于：

  - `validateDrop`
  - `dropEntered`
  - `dropUpdated`
- 不会实际加载数据，仅用于能力判断

##### itemProviders(types: UTType\[]): ItemProvider\[]

- 返回符合指定 UTType 的 `ItemProvider` 列表
- **仅允许在 `performDrop` 回调中调用**
- 在该方法返回后，系统将撤销对拖拽数据的访问权限

> 重要约束
> 必须在 `performDrop` 方法作用域内 **立即开始** 对 ItemProvider 的数据加载（如 `loadData`、`loadText`）。
> 不允许延迟到其他回调或异步逻辑中再发起加载。

***

## DropOperation

`DropOperation` 用于描述当前拖拽更新阶段，目标视图期望执行的操作类型。

可选值如下：

- `"copy"`
  表示复制数据（最常见，用于文件、文本、图片等）

- `"move"`
  表示移动数据（通常仅用于应用内部拖拽）

- `"cancel"`
  取消本次拖拽，不执行任何数据传输

- `"forbidden"`
  明确禁止当前拖拽行为，系统通常会显示禁止指示

`DropOperation` 通常由 `dropUpdated` 回调返回，用于动态控制拖拽行为。

***

## DragDropProps

`DragDropProps` 是所有支持拖拽与放置能力的视图可选属性集合。

***

## onDrag

### 用途

将当前视图声明为 **拖拽源**，允许用户从该视图开始一次拖拽操作。

### 定义

```ts
onDrag?: {
  data: () => ItemProvider
  preview: VirtualNode
}
```

### 参数说明

#### data

```ts
data: () => ItemProvider
```

- 返回一个 `ItemProvider`
- 用于描述拖拽时传递的数据内容
- 支持文本、图片、文件、URL、自定义类型等
- 每次拖拽开始时调用

> 建议
> 仅在该回调中构造 ItemProvider，不要复用旧实例，以确保数据状态正确。

#### preview

```ts
preview: VirtualNode
```

- 指定拖拽开始后显示的预览视图
- 系统会自动将其渲染为拖拽浮层
- 预览视图默认居中于源视图

***

## onDrop

### 用途

将当前视图声明为 **放置目标**，并通过一组回调精细控制拖拽验证、状态变化与最终数据接收。

### 定义

```ts
onDrop?: {
  types: UTType[]
  validateDrop?: (info: DropInfo) => boolean
  dropEntered?: (info: DropInfo) => void
  dropUpdated?: (info: DropInfo) => DropOperation | null
  dropExited?: (info: DropInfo) => void
  performDrop: (info: DropInfo) => boolean
}
```

***

### onDrop.types

```ts
types: UTType[]
```

- 声明该视图 **允许接收的内容类型**
- 如果拖拽内容不包含任意一个匹配类型：

  - 放置区域不会激活
  - `validateDrop` 不会被调用
  - 视觉高亮不会出现

***

### validateDrop

```ts
validateDrop?: (info: DropInfo) => boolean
```

- 用于判断是否允许开始一次放置操作
- 返回 `false` 将直接拒绝拖拽
- 常见用途：

  - 检查类型数量
  - 校验业务状态（如只允许空列表接收）

默认行为：始终返回 `true`

***

### dropEntered

```ts
dropEntered?: (info: DropInfo) => void
```

- 当拖拽进入放置区域时触发
- 通常用于：

  - 显示高亮
  - 显示插入占位符
  - 触发动画状态

***

### dropUpdated

```ts
dropUpdated?: (info: DropInfo) => DropOperation | null
```

- 当拖拽在放置区域内部移动时反复调用
- 用于动态返回期望的 `DropOperation`

返回值说明：

- 返回具体的 `DropOperation`：更新当前拖拽行为
- 返回 `null`：

  - 使用上一次返回的有效值
  - 若没有历史值，默认使用 `"copy"`

***

### dropExited

```ts
dropExited?: (info: DropInfo) => void
```

- 当拖拽离开放置区域时触发
- 常用于清理高亮、移除占位 UI

***

### performDrop

```ts
performDrop: (info: DropInfo) => boolean
```

- **最关键的回调**
- 表示用户已松手，系统允许你读取拖拽数据
- 返回值：

  - `true`：表示成功接收并处理了拖拽
  - `false`：表示放置失败

#### 重要约束（必须遵守）

- 必须在该方法作用域内：

  - 调用 `info.itemProviders(...)`
  - 并立即开始数据加载
- 不允许：

  - 将 ItemProvider 保存到外部
  - 在异步回调中延迟访问拖拽数据

这是系统级安全限制，不遵守将导致数据无法访问。

***

## 典型使用流程总结

1. 用户从 `onDrag` 视图开始拖拽
2. 系统根据 `onDrop.types` 判断是否激活目标
3. 调用 `validateDrop`
4. 进入放置区域 → `dropEntered`
5. 移动过程中 → 多次 `dropUpdated`
6. 离开区域 → `dropExited`
7. 松手 → `performDrop`
8. 在 `performDrop` 中读取并处理数据

***

## 设计建议与最佳实践

- 始终精确声明 `UTType`，避免过于宽泛
- 在 `dropUpdated` 中返回 `"forbidden"` 可显式阻止非法拖拽
- 复杂数据解析逻辑应在 `ItemProvider` 加载完成后的异步回调中完成，而不是在 `performDrop` 中同步阻塞
- 跨应用拖拽时，优先使用系统标准类型（text、image、file、url）



---
url: /zh/guide/Changelog/2.4.6/onDropContent.md
---

# 接收外部拖拽内容

`onDropContent` 是 Scripting 提供的一个视图修饰符，用于将当前视图设置为**拖放目标（Drop Target）**，以接收从其他 App 拖拽进入的文件、图片或文本内容。

***

## 功能说明

通过 `onDropContent`，你可以实现以下能力：

- 接收来自其他 App 的拖拽内容
- 使用 UTType 精确限制可接收的数据类型
- 实时感知拖拽指针是否悬停在视图上方
- 在内容被放下时，通过 `ItemProvider` 启动数据加载流程
- 对安全作用域文件建立持久访问权限

***

## 修饰符定义

```ts
onDropContent?: {
  types: UTType[]
  isTarget: {
    value: boolean
    onChanged: (value: boolean) => void
  } | Observable<boolean>
  perform: (attachments: ItemProvider[]) => boolean
}
```

***

## 参数说明

### types

用于指定当前视图**可以接收的内容类型列表**，类型值为 UTType 字符串。

当拖拽内容不包含任意匹配的类型时：

- 当前视图不会激活为放置目标
- `isTarget` 不会发生变化
- `perform` 不会被调用

示例：

```ts
types: ["public.image", "public.movie"]
```

***

### isTarget

用于表示拖拽操作是否悬停在当前视图上方。

- 当拖拽进入视图区域时，值为 `true`
- 当拖拽移出视图区域时，值为 `false`

支持以下两种形式：

- 绑定对象形式

  ```ts
  {
    value: boolean
    onChanged: (value: boolean) => void
  }
  ```

- Observable 形式

  ```ts
  Observable<boolean>
  ```

Observable 形式适合与 `useObservable` 搭配使用，语义更简洁。

***

### perform

当符合 `types` 要求的内容被成功放下时触发。

```ts
perform: (attachments: ItemProvider[]) => boolean
```

- 参数 `attachments` 为 `ItemProvider` 数组
- 每一个 `ItemProvider` 表示一个被拖入的内容项
- 函数返回值表示是否成功处理了此次拖放操作

返回值说明：

- 返回 `true` 表示拖放被成功接收
- 返回 `false` 表示未处理该拖放内容

***

## perform 的执行规则（重要）

在 `perform` 中需要遵循以下规则：

- 必须在 `perform` 函数的同步执行过程中**启动对 ItemProvider 的加载**
- 允许使用 `Promise` / `then` 等方式延迟完成加载
- 不允许在 `perform` 返回之后，再通过其他回调或事件启动加载
- 返回 `false` 时，系统会认为该拖放未被接受

原因说明：

- 拖放内容受系统安全机制保护
- 只有在 `perform` 执行期间，脚本才拥有对拖放数据的访问权限
- 若未在此期间启动加载，后续将无法访问对应资源

***

## ItemProvider 的使用方式

在 `perform` 中，开发者应当通过 `ItemProvider` 判断类型并启动加载。

常见流程包括：

- 使用 `hasItemConforming` 判断内容类型
- 根据内容类型选择合适的加载方式
- 对文件类资源获取路径并进行后续处理

***

## 示例用法

```tsx
const isTarget = useObservable(false)

return <VStack
  onDropContent={{
    types: ["public.image", "public.movie"],
    isTarget: isTarget,
    perform: (attachments) => {
      const images: UIImage[] = []
      const videos: string[] = []

      let found = false

      for (const attachment of attachments) {
        if (attachment.hasItemConforming("public.png")) {
          found = true
          attachment.loadUIImage().then(image => {
            if (image != null) {
              images.push(image)
            }
          })
        } else if (attachment.hasItemConforming("public.movie")) {
          found = true
          attachment.loadFilePath("public.movie").then(filePath => {
            if (filePath != null) {
              // 为安全作用域文件创建书签
              FileManager.addFileBookmark(filePath)
              videos.push(filePath)
            }
          })
        }
      }

      return found
    }
  }}
>
  ...
</VStack>
```

***

## 安全作用域文件访问

通过 `onDropContent` 获取的文件路径，通常属于**安全作用域资源**。

这类路径在以下情况下可能失效：

- `perform` 返回之后
- App 重启
- 脚本生命周期结束

为保证后续仍可访问文件，建议在获取路径后创建文件书签。

***

## FileManager.addFileBookmark

```ts
FileManager.addFileBookmark(path: string, name?: string): string | null
```

说明：

- 为指定文件或文件夹创建安全作用域书签
- 适用于通过 `Photos`、`onDropContent` 等 API 获取的路径
- 返回书签名称，用于后续访问或移除

示例：

```ts
const bookmarkName = FileManager.addFileBookmark(filePath)
```

***

## FileManager.removeFileBookmark

```ts
FileManager.removeFileBookmark(name: string): boolean
```

说明：

- 移除指定名称的文件书签
- 当不再需要访问对应文件时应及时调用
- 返回是否成功移除

示例：

```ts
FileManager.removeFileBookmark(bookmarkName)
```

***

## 使用建议

- 在 `types` 中尽量明确声明可接收的内容类型
- 在 `perform` 中只负责启动加载，不要等待加载完成
- 对图片等轻量内容可直接加载为对象
- 对视频、音频、文档等资源优先使用文件路径
- 对需要长期访问的文件务必创建书签
- 在资源不再使用时移除对应书签



---
url: /zh/guide/Control Widget.md
---

# 控制中心的小组件

Scripting 支持用户在控制中心或锁屏界面添加按钮（Button）或开关（Toggle）控件，并通过绑定脚本 `AppIntent` 实现自定义逻辑。控件支持状态反馈、图标动态切换、隐私显示控制等能力。

***

## 控件标签类型定义

### `ControlWidgetLabel`

表示控件主标签或状态标签的信息结构。

| 字段名                | 类型         | 描述                   |
| ------------------ | ---------- | -------------------- |
| `title`            | `string`   | 标签的文本标题。             |
| `systemImage`      | `string?`  | 可选的 SF Symbols 图标名称。 |
| `privacySensitive` | `boolean?` | 控件在设备锁定时是否隐藏该标签内容。   |

***

## 一、按钮控件：`ControlWidgetButton`

用于添加一个点击后触发指定意图的按钮控件。

```ts
function ControlWidgetButton(props: ControlWidgetButtonProps): JSX.Element
```

### `ControlWidgetButtonProps`

| 字段名                  | 类型                            | 描述                                                   |
| -------------------- | ----------------------------- | ---------------------------------------------------- |
| `privacySensitive`   | `boolean?`                    | 控件是否在锁屏状态下隐藏其内容与状态。                                  |
| `intent`             | `AppIntent<any>`              | 点击按钮后触发的意图（AppIntent 实例）。                            |
| `label`              | `ControlWidgetLabel`          | 按钮主标签，显示标题与图标。                                       |
| `activeValueLabel`   | `ControlWidgetLabel \| null?` | 按钮激活（Active）状态时显示的标签。设置后需同时提供 `inactiveValueLabel`。  |
| `inactiveValueLabel` | `ControlWidgetLabel \| null?` | 按钮非激活（Inactive）状态时显示的标签。设置后需同时提供 `activeValueLabel`。 |

> 若提供了 `activeValueLabel` 或 `inactiveValueLabel`，建议同时提供两者，以确保状态一致性。此类状态标签的图标会覆盖 `label` 中的图标。

***

## 二、开关控件：`ControlWidgetToggle`

用于添加一个可切换状态的开关控件，自动将布尔值通过绑定意图传入。

```ts
function ControlWidgetToggle<T extends { value: boolean }>(props: ControlWidgetToggleProps<T>): JSX.Element
```

### `ControlWidgetToggleProps<T>`

| 字段名                  | 类型                            | 描述                                            |
| -------------------- | ----------------------------- | --------------------------------------------- |
| `privacySensitive`   | `boolean?`                    | 控件是否在锁屏状态下隐藏其内容与状态。                           |
| `intent`             | `AppIntent<T>`                | 控件状态切换时触发的意图。泛型参数 `T` 必须包含 `value: boolean`。  |
| `label`              | `ControlWidgetLabel`          | 控件主标签。                                        |
| `activeValueLabel`   | `ControlWidgetLabel \| null?` | 控件激活（开）状态时显示的标签。需与 `inactiveValueLabel` 搭配使用。 |
| `inactiveValueLabel` | `ControlWidgetLabel \| null?` | 控件非激活（关）状态时显示的标签。需与 `activeValueLabel` 搭配使用。  |

***

## 三、ControlWidget 命名空间

```ts
namespace ControlWidget
```

### `ControlWidget.parameter: string`

用户在控件配置界面中设置的参数值，通常用于标识目标对象，如设备 ID、门编号等。

***

### `ControlWidget.present(element: VirtualNode): void`

设置控件的显示内容。仅允许传入 `ControlWidgetButton` 或 `ControlWidgetToggle` 元素。

#### 注意：

- 若使用 `control_widget_button.tsx`，只能呈现 `ControlWidgetButton`；
- 若使用 `control_widget_toggle.tsx`，只能呈现 `ControlWidgetToggle`；
- 若控件需要在锁屏隐藏，可在顶层组件上设置 `privacySensitive`；
- 如果仅需要隐藏标签或状态信息，可在相应的 `ControlWidgetLabel` 中设置 `privacySensitive`。

#### 示例：

```tsx
/// app_intents.tsx
export const ToggleDoorIntent = AppIntentManager.register({
  name: "ToggleDoorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async ({ id, value }: { id: string; value: boolean }) => {
    await setDoorState(id, value)
    ControlWidget.reloadToggles()
  }
})

/// control_widget_toggle.tsx
async function run() {
  const doorId = ControlWidget.parameter || "default"
  const data = await fetchDoorData(doorId)

  ControlWidget.present(
    <ControlWidgetToggle
      privacySensitive
      intent={ToggleDoorIntent({ id: doorId, value: !data.doorOpened })}
      label={{
        title: `门 ${doorId}`,
        systemImage: data.doorOpened ? "door.garage.opened" : "door.garage.closed"
      }}
      activeValueLabel={{ title: "门已打开" }}
      inactiveValueLabel={{ title: "门已关闭" }}
    />
  )
}

run()
```

***

### `ControlWidget.reloadButtons(): void`

重新加载所有按钮控件。用于意图执行后刷新状态显示。

***

### `ControlWidget.reloadToggles(): void`

重新加载所有切换控件。常用于状态变更后触发 UI 更新。

***

## 四、开发建议

1. 所有控件必须绑定一个 `AppIntent`，用于定义交互逻辑。
2. 切换(Toggle)控件的参数必须包含 `{ value: boolean }`，可使用`AppIntentProtocol.AppIntent`协议，内部会强制切换为 `SetValueIntent` 协议。
3. 若为控件提供状态标签，建议提供完整的 `activeValueLabel` 与 `inactiveValueLabel` 配对，以提升可读性。
4. 图标使用 SF Symbols 命名的系统图标。
5. 在意图执行中变更控件状态时，应调用 `ControlWidget.reloadButtons()` 或 `reloadToggles()` 以触发前端刷新。



---
url: /zh/guide/Custom Keyboard.md
---

# 自定义键盘

`CustomKeyboard` 是 Scripting 提供的全局命名空间，用于开发 iOS 自定义键盘扩展。在 `keyboard.tsx` 脚本中使用该 API，可以渲染自定义键盘 UI，并访问当前输入状态、插入文本、控制光标、监听输入事件、调整高度，并在多个脚本之间导航切换。

## 一、使用环境与前提

### 环境要求

- 必须在脚本项目中创建名为 **`keyboard.tsx`** 的文件；
- 所有 `CustomKeyboard` 方法 **仅可在键盘扩展环境中使用**；
- 在 **App 脚本、Intent (`intent.tsx`)、小组件 (`widget.tsx`) 中无法使用此 API**；
- 系统设置路径：

  ```
  设置 > 通用 > 键盘 > 键盘 > 添加新键盘 > 选择 Scripting
  ```

  添加后，进入 Scripting 键盘详情页，开启 **允许完全访问**，以启用网络请求、剪贴板访问等高级功能。

***

## 二、展示键盘 UI

### `present(node: VirtualNode): void`

用于展示自定义键盘界面。必须在 `keyboard.tsx` 中调用一次。

```tsx
function MyKeyboard() {
  return <Text>你好，世界</Text>
}

CustomKeyboard.present(<MyKeyboard />)
```

***

## 三、输入状态查询

| 属性名                | 类型                        | 说明          |
| ------------------ | ------------------------- | ----------- |
| `textBeforeCursor` | `Promise<string \| null>` | 光标前的文本      |
| `textAfterCursor`  | `Promise<string \| null>` | 光标后的文本      |
| `selectedText`     | `Promise<string \| null>` | 当前选中的文本（如有） |
| `hasText`          | `Promise<boolean>`        | 输入框是否包含文本内容 |

***

## 四、输入特征（traits）

### `useTraits(): TextInputTraits`

获取当前输入框的系统特征（如键盘类型、返回键样式等）。值在 `textDidChange` 和 `selectionDidChange` 事件中自动更新。

### `traits: TextInputTraits`

为静态快照，不会自动更新。建议在组件中使用 `useTraits()`。

常见字段包括：

- `keyboardType`：如 `'default'`, `'emailAddress'`, `'numberPad'`
- `returnKeyType`：如 `'done'`, `'go'`, `'search'`
- `textContentType`：如 `'username'`, `'password'`, `'oneTimeCode'`
- `keyboardAppearance`：`'light'`, `'dark'` 等

***

## 五、文本操作

### `insertText(text: string): Promise<void>`

在光标处插入文本。

### `deleteBackward(): Promise<void>`

删除光标前的一个字符。

### `moveCursor(offset: number): Promise<void>`

移动光标位置。负数为向左，正数为向右。

### `setMarkedText(text, location, length): Promise<void>`

设置标记文本（用于拼音输入等组合输入）。

### `unmarkText(): Promise<void>`

取消当前标记文本。

***

## 六、键盘行为控制

### `dismiss(): Promise<void>`

关闭键盘。

### `nextKeyboard(): Promise<void>`

切换至系统中的下一个键盘。

### `requestHeight(height: number): Promise<void>`

请求调整键盘高度（单位为 pt）。推荐范围为 **216\~360pt**，超出范围可能被系统忽略。

### `setHasDictationKey(value: boolean): Promise<void>`

设置是否显示语音输入按钮（麦克风图标）。

### `setToolbarVisible(visible: boolean): Promise<void>`

控制顶部工具栏的显示/隐藏。默认显示，适用于调试等场景。

***

## 七、导航控制

### `dismissToHome(): Promise<void>`

关闭当前键盘脚本，返回 Scripting 键盘首页（脚本列表）。适用于用户在多个脚本之间自由切换的场景。

```ts
await CustomKeyboard.dismissToHome()
```

***

## 八、用户反馈

### `playInputClick(): void`

播放标准键盘按键音，建议在模拟按键操作时调用，提升交互体验。

```ts
CustomKeyboard.playInputClick()
```

***

## 九、事件监听

### `addListener(event, callback): void`

注册事件监听器：

| 事件名                   | 回调参数                                | 说明     |
| --------------------- | ----------------------------------- | ------ |
| `textWillChange`      | `() => void`                        | 文本将要变更 |
| `textDidChange`       | `(traits: TextInputTraits) => void` | 文本已变更  |
| `selectionWillChange` | `() => void`                        | 光标将变更  |
| `selectionDidChange`  | `(traits: TextInputTraits) => void` | 光标已变更  |

### `removeListener(event, callback): void`

移除指定监听器。

### `removeAllListeners(event): void`

移除指定事件的所有监听器。

***

## 十、完整示例

```tsx
function MyKeyboard() {
  const traits = CustomKeyboard.useTraits()

  const insert = async (text: string) => {
    CustomKeyboard.playInputClick()
    await CustomKeyboard.insertText(text)
  }

  return (
    <VStack spacing={12}>
      <Text>输入类型：{traits.keyboardType}</Text>
      <HStack spacing={10}>
        <Button title="你" action={() => insert("你")} />
        <Button title="好" action={() => insert("好")} />
        <Button title="← 删除" action={() => CustomKeyboard.deleteBackward()} />
        <Button title="返回首页" action={() => CustomKeyboard.dismissToHome()} />
      </HStack>
    </VStack>
  )
}

CustomKeyboard.present(<MyKeyboard />)
```

***

## 十一、开发建议

- **必须调用 `present()` 并且仅调用一次**；
- 合理设置键盘高度，避免 UI 被遮挡；
- 使用 `useTraits()` 获取输入上下文信息；
- 调用 `dismissToHome()` 可以让用户在多个键盘脚本之间切换；
- 通过 `playInputClick()` 提升按键交互体验；
- 删除文本前请先判断 `hasText` 是否为 true；
- 监听事件时注意避免重复注册和内存泄漏；



---
url: /zh/guide/Device Capabilities/AVMetadataItem.md
---

# AVMetadataItem

`AVMetadataItem` 类用于表示媒体文件（如音频或视频）中的单个元数据条目。
此类通常通过 `AVPlayer.loadMetadata()` 或 `AVPlayer.loadCommonMetadata()` 方法返回，用于访问媒体文件中嵌入的标准或自定义元数据信息。

元数据项可以包含标题、艺术家、专辑、封面图片、编码信息、语言标签等。
每个 `AVMetadataItem` 实例都表示一个独立的键值对，并且提供多种类型化访问方式。

***

## 类定义

### `class AVMetadataItem`

***

### **属性（Properties）**

#### `key: string`

元数据项的键（Key）。
该值通常与具体的媒体格式相关（例如 ID3、QuickTime、iTunes 等）。

**示例**

```ts
console.log(item.key) // 例如： "id3/TIT2"
```

***

#### `commonKey?: string`

元数据项的**通用键**。
此属性表示与 `key` 对应的“通用命名空间”键，用于跨格式访问常用元数据。
即使底层媒体格式不同，你仍然可以通过 `commonKey` 访问相同意义的字段。

**示例**

```ts
console.log(item.commonKey) // 例如： "title"
```

***

#### `identifier?: string`

元数据项的唯一标识符（Identifier）。
可用于区分相同类型的多个元数据条目。

***

#### `extendedLanguageTag?: string`

元数据项使用的语言扩展标签（如 `"en-US"` 或 `"zh-Hans"`）。
如果元数据内容与语言相关，则该值指示其语言环境。

***

#### `locale?: string`

表示与该元数据关联的地区或本地化信息。

***

#### `time?: number`

元数据项在媒体中的时间戳（以秒为单位）。
适用于时间相关的元数据，如字幕或歌词。

**示例**

```ts
console.log(item.time) // 输出例如：12.53
```

***

#### `duration?: number`

元数据项的持续时间（以秒为单位）。
例如某些可视化元数据（如图片、歌词）具有有效时长。

***

#### `startDate?: Date`

元数据项的起始时间（如果存在）。
若该项没有具体日期信息，则返回 `null`。

***

#### `dataType?: string`

元数据项值的数据类型（如 `"com.apple.metadata.datatype.UTF-8"`, `"public.jpeg"` 等）。

该属性可用于判断 `value` 的原始数据类型。

***

#### `extraAttributes: Promise<Record<string, any> | null>`

额外属性，包含特定元数据容器或键空间的附加信息。
例如 ID3 标签中 `"APIC"` 帧（封面图片）可能包含描述性文本、图片类型等额外属性。

**示例**

```ts
const extras = await item.extraAttributes
console.log(extras)
// 可能输出： { description: "Cover (front)", pictureType: 3 }
```

***

#### `dataValue: Promise<Data | null>`

将元数据项的值以 `Data` 类型返回。
适用于二进制内容（如封面图片、嵌入数据等）。

**示例**

```ts
const imageData = await item.dataValue
if (imageData) {
  const image = UIImage.fromData(imageData)
  // 使用 image
}
```

***

#### `stringValue: Promise<string | null>`

将元数据项的值以 `string` 类型返回。
常用于文本元数据（标题、艺术家、专辑等）。

**示例**

```ts
const title = await item.stringValue
console.log("标题：", title)
```

***

#### `numberValue: Promise<number | null>`

将元数据项的值以数字形式返回。
适用于数值型元数据（如比特率、采样率、音量等）。

**示例**

```ts
const bitrate = await item.numberValue
console.log("比特率：", bitrate)
```

***

#### `dateValue: Promise<Date | null>`

将元数据项的值以 `Date` 类型返回。
适用于时间相关的元数据（如录制日期、发布日期等）。

**示例**

```ts
const date = await item.dateValue
console.log("发布日期：", date?.toISOString())
```

***

## 使用示例

```ts
const metadata = await player.loadMetadata()
for (const item of metadata) {
  const key = item.commonKey ?? item.key
  const value = await item.stringValue ?? await item.numberValue
  console.log(`${key}: ${value}`)
}
```

**说明：**

- 若 `commonKey` 存在，建议优先使用，以保持跨格式一致性。
- 异步属性（如 `stringValue`、`dataValue`、`extraAttributes`）都以 Promise 形式提供，便于按需加载。
- 可结合 `AVPlayer.loadCommonMetadata()` 获取标准化元数据（如标题、专辑、艺术家、封面等）。

***

## 常见用途

| 用途   | 示例字段 (`commonKey`) | 说明              |
| ---- | ------------------ | --------------- |
| 标题   | `"title"`          | 媒体文件标题          |
| 艺术家  | `"artist"`         | 表演者或作者          |
| 专辑   | `"albumName"`      | 专辑名称            |
| 封面图片 | `"artwork"`        | 通常为 JPEG/PNG 数据 |
| 编码信息 | `"encoder"`        | 媒体编码器或软件        |
| 录制时间 | `"creationDate"`   | 录制或生成时间         |



---
url: /zh/guide/Device Capabilities/AppStore.md
---

# AppStore

`AppStore` API 用于在 **不离开 Scripting 应用** 的情况下，展示 App Store 中某个应用的详情页面。
该能力基于系统原生的 App Store 展示组件，适合用于实现 **应用推荐、应用收藏夹、关联应用跳转、生态扩展入口** 等场景。

***

## 命名空间：`AppStore`

```ts
namespace AppStore
```

***

## 功能概述

- 在 Scripting App 内以 **模态窗口（Modal）** 方式展示指定 App 的 App Store 页面
- 用户可直接查看应用介绍、截图、评分、更新日志
- 用户可在该页面中完成 **下载 / 更新 / 打开应用**
- 关闭后自动返回当前脚本页面
- 不会跳转到系统 App Store 应用

***

## 方法一览

| 方法                       | 说明                      |
| ------------------------ | ----------------------- |
| `presentApp(id: string)` | 打开指定 App 的 App Store 页面 |
| `dismissApp()`           | 主动关闭当前展示的 App Store 页面  |

***

## 方法说明

### `presentApp(id: string): Promise<void>`

在 Scripting App 内展示指定 App 的 App Store 页面。

#### 参数

| 参数   | 类型       | 说明                              |
| ---- | -------- | ------------------------------- |
| `id` | `string` | App 的 **App Store 标识符（App ID）** |

- 该 ID 是 App Store 中的数字 ID
- 通常可从 App Store URL 中获取
  例如：
  `https://apps.apple.com/app/id123456789`
  则 `id` 为 `"123456789"`

#### 返回值

- 返回一个 `Promise<void>`
- 当用户 **关闭 App Store 模态页面** 时，Promise resolve
- 如果当前已经有一个 App Store 页面在展示中，则会抛出错误

#### 行为说明

- 以模态方式打开 App Store 页面
- 同一时间 **只能存在一个 App Store 模态窗口**
- 如果重复调用 `presentApp`，将导致 Promise reject

#### 示例

```ts
await AppStore.presentApp("123456789")
```

***

### `dismissApp(): Promise<void>`

关闭当前通过 `presentApp` 打开的 App Store 页面。

#### 返回值

- 返回一个 `Promise<void>`
- 当模态页面成功关闭后 resolve

#### 使用说明

- 一般情况下不需要手动调用
- 适用于：

  - 自定义 UI 控制关闭行为
  - 脚本中需要在特定逻辑点强制关闭 App Store 页面

#### 示例

```ts
await AppStore.dismissApp()
```

***

## 使用示例

### 示例一：应用推荐入口

```ts
import { Button } from "scripting"

function AppRecommendation() {
  return (
    <Button
      title="查看推荐应用"
      action={() => {
        AppStore.presentApp("123456789")
      }}
    />
  )
}
```

***

### 示例二：应用收藏夹

```ts
const favoriteApps = [
  { name: "App A", id: "123456789" },
  { name: "App B", id: "987654321" }
]

function AppList() {
  return favoriteApps.map(app => (
    <Button
      title={app.name}
      action={() => {
        AppStore.presentApp(app.id)
      }}
    />
  ))
}
```

***

## 错误与注意事项

### 常见错误

- **已有 App Store 页面正在展示**

  - 再次调用 `presentApp` 会抛出错误
  - 建议在逻辑层控制调用时机

### 使用限制

- 仅支持 App Store 应用页面
- 不支持展示订阅页、开发者主页等其他 App Store 内容
- 必须传入有效的 App Store App ID



---
url: /zh/guide/Device Capabilities/Audio Player.md
---

# 音频播放器

`AVPlayer` 提供播放音频或视频的能力，并支持播放控制、循环播放、回调事件和元数据读取等功能。你可以通过 `setSource()` 设置媒体源（本地文件或远程 URL），然后使用 `play()` 开始播放。

***

## 入门指南

以下示例展示了 `AVPlayer` 的基本用法：

```typescript
const player = new AVPlayer()

// 设置媒体源（本地文件或远程 URL）
if (player.setSource("https://example.com/audio.mp3")) {
    player.onReadyToPlay = () => {
        player.play()
    }
    player.onEnded = () => {
        console.log("播放完成。")
    }
} else {
    console.error("设置媒体源失败。")
}
```

***

## API 参考

### 属性

#### `volume: number`

控制播放音量，范围为 `0.0`（静音）到 `1.0`（最大音量）。

```typescript
player.volume = 0.5 // 设置为 50% 音量
```

***

#### `duration: DurationInSeconds`

媒体总时长（单位：秒）。在媒体加载完成前，该值为 `0`。

```typescript
console.log(`媒体时长：${player.duration} 秒`)
```

***

#### `currentTime: DurationInSeconds`

当前播放时间（单位：秒）。可通过设置该值跳转播放位置。

```typescript
player.currentTime = 30 // 跳转到第 30 秒
```

***

#### `rate: number`

控制播放速率。`1.0` 为正常速度，值小于 `1.0` 为减速播放，大于 `1.0` 为加速播放。

```typescript
player.rate = 1.5 // 以 1.5 倍速播放
```

***

#### `timeControlStatus: TimeControlStatus`

指示播放状态。可取值：

- `paused`: 暂停中
- `waitingToPlayAtSpecifiedRate`: 正在等待可播放状态（如网络缓冲）
- `playing`: 正在播放

***

#### `numberOfLoops: number`

设置循环播放次数。

- `0`：不循环
- 正数：指定循环次数
- 负数：无限循环

```typescript
player.numberOfLoops = -1 // 无限循环播放
```

***

### 方法

#### `setSource(filePathOrURL: string): boolean`

设置播放源，可以是本地文件路径或远程 URL。

返回：

- `true`: 设置成功
- `false`: 设置失败

***

#### `play(): boolean`

开始播放媒体。

返回：

- `true`: 成功开始播放
- `false`: 失败

***

#### `pause()`

暂停播放。

***

#### `stop()`

停止播放并重置到起始位置。

***

#### `dispose()`

释放播放器资源、移除观察者。
应在播放器不再使用时调用以避免资源泄露。

***

#### `loadMetadata(): Promise<AVMetadataItem[] | null>`

加载当前媒体的完整元数据。

返回：

- 一个包含 `AVMetadataItem` 对象的数组
- 若媒体未加载或无元数据，则返回 `null`

示例：

```typescript
const metadata = await player.loadMetadata()
if (metadata) {
  for (const item of metadata) {
    console.log(item.key, await item.stringValue)
  }
}
```

***

#### `loadCommonMetadata(): Promise<AVMetadataItem[] | null>`

加载当前媒体的通用元数据（common metadata），这些元数据的 `commonKey` 属性提供跨格式可识别的键名。

示例：

```typescript
const commonMetadata = await player.loadCommonMetadata()
if (commonMetadata) {
  const titleItem = commonMetadata.find(i => i.commonKey === "title")
  console.log("标题：", await titleItem?.stringValue)
}
```

***

### 回调事件

#### `onReadyToPlay?: () => void`

媒体准备就绪、可播放时触发。

***

#### `onTimeControlStatusChanged?: (status: TimeControlStatus) => void`

播放状态变更时触发，例如从“等待中”到“播放中”。

***

#### `onEnded?: () => void`

媒体播放完成时触发。

***

#### `onError?: (message: string) => void`

播放过程中发生错误时触发，参数为错误信息。

***

## 使用音频会话

`AVPlayer` 依赖系统的共享音频会话。你可以通过 `SharedAudioSession` 进行配置，以确保播放行为符合预期。

```typescript
await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
await SharedAudioSession.setActive(true)
```

处理系统中断（如电话）：

```typescript
SharedAudioSession.addInterruptionListener((type) => {
  if (type === 'began') player.pause()
  else if (type === 'ended') player.play()
})
```

***

## 常见用例

### 播放远程音频

```typescript
player.setSource("https://example.com/audio.mp3")
player.onReadyToPlay = () => player.play()
```

***

### 播放本地文件

```typescript
player.setSource("/path/to/audio.mp3")
player.play()
```

***

### 循环播放

```typescript
player.numberOfLoops = 3 // 循环播放 3 次
player.play()
```

***

### 获取元数据

```typescript
const metadata = await player.loadCommonMetadata()
if (metadata) {
  const artist = metadata.find(i => i.commonKey === "artist")
  console.log("演唱者：", await artist?.stringValue)
}
```

***

## 最佳实践

1. **资源管理**
   使用完毕后务必调用 `dispose()` 释放资源。

2. **错误处理**
   实现 `onError` 回调，优雅地处理播放错误。

3. **中断管理**
   通过音频会话监听中断事件，自动暂停或恢复播放。

4. **UI 状态更新**
   使用 `onTimeControlStatusChanged` 更新播放状态显示。

5. **元数据使用**
   通过 `loadCommonMetadata()` 获取通用信息，如标题、艺术家、封面等，用于显示在 UI 上。

***

## 完整示例

```typescript
const player = new AVPlayer()

await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
await SharedAudioSession.setActive(true)

if (player.setSource("https://example.com/audio.mp3")) {
  player.onReadyToPlay = () => player.play()
  player.onEnded = () => {
    console.log("播放完成")
    player.dispose()
  }
  player.onError = (message) => {
    console.error("播放错误：", message)
    player.dispose()
  }

  // 读取元数据
  const commonMetadata = await player.loadCommonMetadata()
  if (commonMetadata) {
    const titleItem = commonMetadata.find(i => i.commonKey === "title")
    console.log("标题：", await titleItem?.stringValue)
  }
} else {
  console.error("设置媒体源失败")
}
```



---
url: /zh/guide/Device Capabilities/AudioRecorder.md
---

# 录音

`AudioRecorder` 类允许您将音频数据录制到文件。它提供了开始、停止、暂停和管理音频录制的功能，并可配置音频质量、采样率、格式等。

## 功能

- 从系统的活跃输入设备录制音频。
- 可以录制指定时长，或在手动停止前一直录制。
- 暂停并恢复录制。
- 删除已录制的音频文件。

***

## 用法

### 设置 SharedAudioSession

在创建 `AudioRecorder` 实例之前，需要先设置 `SharedAudioSession`。因为音频会话与硬件相关，因此需要确保正确激活会话。

```ts
await SharedAudioSession.setActive(true)
await SharedAudioSession.setCategory(
  "playAndRecord",
  ["defaultToSpeaker"]
)
```

### 创建 AudioRecorder 实例

使用 `create` 方法来创建一个音频录制器实例：

```ts
async function createRecorder() {
  try {
    const filePath = Path.join(
      FileManager.documentsDirectory,
      "recording.m4a"
    )
    const recorder = await AudioRecorder.create(filePath, {
      format: "MPEG4AAC",
      sampleRate: 44100,
      numberOfChannels: 2,
      encoderAudioQuality: AVAudioQuality.high
    })
    return recorder
  } catch (error) {
    console.error("Failed to create recorder: ", error)
  }
}
```

### 录制音频

您可以使用 `record()` 方法开始录制：

```ts
async function startRecording() {
  const recorder = await createRecorder()
  if (recorder) {
    const success = recorder.record()
    console.log("Recording started: ", success)
  }
}
```

也可以提供额外的选项来控制录制开始的时间及录制时长：

```ts
function startSynchronizedRecording(recorderOne, recorderTwo) {
  let timeOffset = recorderOne.deviceCurrentTime + 0.01
  
  // 使两个 recorder 的录制时间同步
  recorderOne.record({ atTime: timeOffset })
  recorderTwo.record({ atTime: timeOffset })
}
```

### 暂停和停止录制

暂停录制：

```ts
function pauseRecording(recorder) {
  recorder.pause()
  console.log("Recording paused.")
}
```

停止录制：

```ts
function stopRecording(recorder) {
  recorder.stop()
  console.log("Recording stopped.")
}
```

### 删除录音文件

要删除已经录制好的文件：

```ts
function deleteRecording(recorder) {
  const success = recorder.deleteRecording()
  console.log("Recording deleted: ", success)
}
```

### 释放 Recorder

当不再需要使用录制器时，应调用 `dispose()` 来释放资源：

```ts
function disposeRecorder(recorder) {
  recorder.dispose()
  console.log("Recorder disposed.")
}
```

### 事件处理

可以使用 `onFinish` 和 `onError` 回调来处理录制完成和错误情况：

```ts
async function setupRecorder() {
  const recorder = await createRecorder()
  if (recorder) {
    recorder.onFinish = (success) => {
      console.log("Recording finished successfully: ", success)
    }

    recorder.onError = (message) => {
      console.error("Recording error: ", message)
    }
  }
}
```

***

## API 参考

### `AudioRecorder.create(filePath, settings?)`

使用指定的设置创建一个 `AudioRecorder` 实例。

- **filePath** (string): 要录制到的文件系统路径。
- **settings** (可选对象): 录音的音频设置：
  - **format** (AudioFormat): 音频数据的格式，可选值包括 `"LinearPCM"`, `"MPEG4AAC"`, `"AppleLossless"`, `"AppleIMA4"`, `"iLBC"`, `"ULaw"`。
  - **sampleRate** (number): 采样率，单位为赫兹 (范围 8000 到 192000)。
  - **numberOfChannels** (number): 声道数量 (1 到 64)。
  - **encoderAudioQuality** (AVAudioQuality): 音频编码质量 (从 `AVAudioQuality.min` 到 `AVAudioQuality.max`)。

**返回值**: 一个 `Promise`，解析后返回 `AudioRecorder` 实例。

### `AudioRecorder.isRecording`

一个布尔值，用于指示录制器当前是否正在录音。

### `AudioRecorder.currentTime`

从录音开始到当前的时间（单位为秒）。

### `AudioRecorder.deviceCurrentTime`

主机音频设备的当前时间（单位为秒）。

### `AudioRecorder.record(options?)`

开始录制音频。

- **options** (可选对象):
  - **atTime** (number): 相对于 `deviceCurrentTime`，指定开始录制的时间。
  - **duration** (number): 录音时长（单位为秒）。

**返回值**: 一个布尔值，表示录制是否成功开始。

### `AudioRecorder.pause()`

暂停当前录制。

### `AudioRecorder.stop()`

停止录制并关闭音频文件。

### `AudioRecorder.deleteRecording()`

删除已经录制的音频文件。

**返回值**: 一个布尔值，表示删除操作是否成功。

### `AudioRecorder.dispose()`

释放录制器所使用的资源。

### `AudioRecorder.onFinish`

录音完成后调用的回调函数。

- **success** (boolean): 表示录制是否成功完成。

### `AudioRecorder.onError`

在录制或编码出现错误时调用的回调函数。

- **message** (string): 描述错误的字符串。

***

## 使用示例

```ts
import { Path } from 'scripting'

async function run() {

  await SharedAudioSession.setActive(true)
  await SharedAudioSession.setCategory(
    "playAndRecord",
    ["defaultToSpeaker"]
  )

  try {
    const filePath = Path.join(
      FileManager.documentsDirectory,
      "recording.m4a"
    )
    const recorder = await AudioRecorder.create(filePath, {
      format: "MPEG4AAC",
      sampleRate: 48000,
      numberOfChannels: 2,
      encoderAudioQuality: AVAudioQuality.high
    })

    recorder.onFinish = (success) => console.log("Recording finished successfully: ", success)
    recorder.onError = (message) => console.error("Recording error: ", message)

    recorder.record()
    setTimeout(() => {
      recorder.stop()
    }, 5000) // 5秒后停止录制
  } catch (error) {
    console.error("Error: ", String(error))
  }
}

run()
```

使用 `AudioRecorder` 类，您可以在脚本中轻松管理音频录制操作，并灵活控制音频录制流程。



---
url: /zh/guide/Device Capabilities/BackgroundKeeper.md
---

# 后台保活

`BackgroundKeeper` API 用于控制 **Scripting App** 的后台保活行为，使脚本在应用切换到后台后，能够在一定时间内继续运行。
这在需要保持持续操作（如网络连接、数据同步或后台任务）的场景中非常有用。

> **可用性：**
> 仅当脚本在主应用中运行 (即`Script.env === "index"`) 时可用。
> 请谨慎使用此功能，因为长时间保持后台运行可能会增加设备的电量消耗。

***

## 概述

当应用进入后台（例如由于系统事件触发状态切换）时，可以调用 `BackgroundKeeper.keepAlive()` 来请求保持 Scripting App 的运行。
当应用重新回到前台时，应调用 `BackgroundKeeper.stopKeepAlive()` 来停止后台保活进程并释放资源。

多个脚本可以同时请求后台保活。系统内部维护一个 **保活请求队列**：

- 每次调用 `keepAlive()` 会将当前脚本加入保活队列；
- 每次调用 `stopKeepAlive()` 会将当前脚本从队列中移除；
- 只有当队列为空时，后台保活进程才会真正停止。

> **注意：**
> 即使开启了保活，系统在某些情况下（如内存占用过高、电量过低等）仍可能终止 Scripting App。

***

## 命名空间：`BackgroundKeeper`

### 属性

#### `isActive: Promise<boolean>`

返回一个 Promise，用于指示当前后台保活进程是否处于激活状态。

**示例：**

```ts
const active = await BackgroundKeeper.isActive
if (active) {
  console.log("后台保活已激活")
} else {
  console.log("后台保活未启用")
}
```

***

### 方法

#### `keepAlive(): Promise<boolean>`

启动后台保活进程。

- 如果保活进程已处于激活状态，返回 `true`；
- 如果启动成功，返回 `true`；
- 如果系统拒绝保活请求，可能返回 `false`。

**返回值：**
`Promise<boolean>` — 表示后台保活是否成功启动。

**示例：**

```ts
const started = await BackgroundKeeper.keepAlive()
if (started) {
  console.log("后台保活已成功启动")
} else {
  console.log("无法启动后台保活")
}
```

***

#### `stopKeepAlive(): Promise<void>`

停止当前脚本的后台保活请求。
此操作并不保证整个保活进程立即停止，因为其他脚本可能仍在请求保活。只有当所有请求都被释放后，后台保活才会完全停止。

**返回值：**
`Promise<void>` — 在请求处理完成后 resolve。

**示例：**

```ts
await BackgroundKeeper.stopKeepAlive()
console.log("当前脚本的后台保活请求已释放")
```

***

## 示例用法

```ts
async function runBackgroundTask() {
  const started = await BackgroundKeeper.keepAlive()
  if (!started) {
    console.log("无法保持后台运行")
    return
  }

  try {
    console.log("正在后台执行任务...")
    // 在后台执行任务（例如同步数据、监听蓝牙设备等）
    await new Promise(resolve => setTimeout(resolve, 10000))
  } finally {
    await BackgroundKeeper.stopKeepAlive()
    console.log("已停止后台保活")
  }
}
```

***

## 注意事项与最佳实践

- **请谨慎使用**：持续的后台运行可能显著增加电量消耗。
- **任务完成后务必调用 `stopKeepAlive()`**，或在应用回到前台时停止保活。
- **不要依赖后台保活实现无限后台执行**，系统可能随时挂起或终止应用。
- **多个脚本可共享保活进程**：当所有脚本都调用 `stopKeepAlive()` 后，保活才会真正结束。



---
url: /zh/guide/Device Capabilities/Bluetooth/BluetoothCentralManager.md
---

# 蓝牙中央设备管理器

`BluetoothCentralManager` 提供了用于操作 BLE 中央设备的核心接口，包括扫描附近蓝牙设备、连接外设、获取已知设备、断开连接等能力。适用于实现如外设控制、数据采集、IoT通信等典型蓝牙场景。

***

## 成员属性

### `isScanning: Promise<boolean>`

> 获取当前是否正在扫描外围设备。

- **类型**：`Promise<boolean>`
- **示例**：

  ```ts
  const scanning = await BluetoothCentralManager.isScanning
  console.log(scanning ? "正在扫描" : "未扫描")
  ```

***

## 方法

### `startScan(onDiscoverPeripheral, options?): Promise<void>`

> 启动 BLE 设备扫描，直到调用 `stopScan()` 结束。每发现一个设备都会触发 `onDiscoverPeripheral` 回调。

#### 参数

- `onDiscoverPeripheral: (peripheral, advertisementData, rssi) => void`

  - 每发现一个外围设备时调用
  - 参数说明：

    - `peripheral`: `BluetoothPeripheral` 外设对象
    - `advertisementData`: `BluetoothAdvertisementData` 广播数据
    - `rssi`: `number` 信号强度（dBm）

- `options?: { services?: string[]; allowDuplicates?: boolean; solicitedServiceUUIDs?: string[] }`

  - `services`: 只扫描包含指定服务 UUID 的外设
  - `allowDuplicates`: 是否允许重复回调同一设备，默认 `false`
  - `solicitedServiceUUIDs`: 一个包含外设请求的服务 UUID 的数组，表明希望由中央设备提供哪些服务

##### BluetoothAdvertisementData 广播数据结构

在使用 `BluetoothCentralManager.startScan()` 进行蓝牙扫描时，每次发现设备都会返回包含该设备广播数据的 `advertisementData` 对象。该对象包含设备在广播包中附带的多种信息字段，用于识别、过滤、分类外设。

***

###### 数据结构说明

```ts
type BluetoothAdvertisementData = {
  localName?: string
  txPowerLevel?: number
  manufacturerData?: Data
  serviceData?: Record<string, Data>
  serviceUUIDs?: string[]
  overflowServiceUUIDs?: string[]
  isConnectable?: boolean
  solicitedServiceUUIDs?: string[]
}
```

***

###### 字段详解

| 字段名                     | 类型                         | 说明                                            |
| ----------------------- | -------------------------- | --------------------------------------------- |
| `localName`             | `string`（可选）               | 外设广播的本地名称（若有）。用于展示用户可识别的设备名称。                 |
| `txPowerLevel`          | `number`（可选）               | 发射功率（单位 dBm）。用于估算设备距离，RSSI + TxPower 可用于计算距离。 |
| `manufacturerData`      | `Data`（可选）                 | 厂商自定义数据，常用于识别设备型号、序列号等。需自行解析 `Data`。          |
| `serviceData`           | `Record<string, Data>`（可选） | 服务数据字段，键为服务 UUID，值为对应的服务内容（`Data` 类型）。        |
| `serviceUUIDs`          | `string[]`（可选）             | 广播中声明支持的服务 UUID 列表。可用于快速判断设备功能类型。             |
| `overflowServiceUUIDs`  | `string[]`（可选）             | 当 `serviceUUIDs` 超出广播数据包大小限制时，会将溢出部分放入该字段。    |
| `isConnectable`         | `boolean`（可选）              | 该设备是否支持连接。扫描结果中用于快速过滤无法连接的广播型设备。              |
| `solicitedServiceUUIDs` | `string[]`（可选）             | 外设请求的服务 UUID，表明希望由中央设备提供哪些服务。                 |

***

###### 常见用途

- 根据 `localName` 或 `serviceUUIDs` 进行设备筛选
- 解析 `manufacturerData` 判断厂商/设备类型
- 结合 `txPowerLevel` 和 `RSSI` 估算设备距离
- 利用 `isConnectable` 判断是否需要尝试连接

***

###### 注意事项

- 所有字段均为可选项，某些设备可能不广播特定字段
- `manufacturerData` 和 `serviceData` 是原始二进制数据（`Data` 类型），需根据厂商协议解析
- `serviceUUIDs` 仅代表广播包中声明的服务，完整服务需通过 `discoverServices()` 获取

#### 返回值

- `Promise<void>`：扫描启动成功时 resolve，失败时 reject

#### 示例

```ts
await BluetoothCentralManager.startScan((peripheral, adv, rssi) => {
  console.log(`发现设备: ${peripheral.name}, 信号: ${rssi} dBm`)
}, {
  services: ["180D"], // 只扫描支持心率服务的设备
  allowDuplicates: false
})
```

***

### `stopScan(): Promise<void>`

> 停止正在进行的扫描操作。

#### 返回值

- `Promise<void>`：成功停止时 resolve

#### 示例

```ts
await BluetoothCentralManager.stopScan()
console.log("已停止扫描")
```

***

### `retrievePeripherals(ids: string[]): Promise<BluetoothPeripheral[]>`

> 根据设备 UUID 获取已知的蓝牙设备（可能已连接或已配对）。

#### 参数

- `ids: string[]`：设备的唯一标识符数组

#### 返回值

- `Promise<BluetoothPeripheral[]>`：返回符合 ID 的设备列表

#### 示例

```ts
const knownDevices = await BluetoothCentralManager.retrievePeripherals(["A1-B2-C3-D4"])
```

***

### `retrieveConnectedPeripherals(serviceUUIDs: string[]): Promise<BluetoothPeripheral[]>`

> 获取当前连接中并提供指定服务的外围设备。

#### 参数

- `serviceUUIDs: string[]`：过滤条件，仅返回包含这些服务 UUID 的设备

#### 返回值

- `Promise<BluetoothPeripheral[]>`：匹配的设备列表

#### 示例

```ts
const connected = await BluetoothCentralManager.retrieveConnectedPeripherals(["180F"])
console.log(`发现 ${connected.length} 个已连接电池服务设备`)
```

***

### `connect(peripheral, options?): Promise<void>`

> 与指定外围设备建立连接。

#### 参数

- `peripheral: BluetoothPeripheral`：要连接的设备
- `options?:` 可选连接配置：

  - `startDelay?: number`：延迟连接（秒）
  - `enableTransportBridging?: boolean`：启用传输桥接（用于特殊外设）
  - `requiresANCS?: boolean`：是否需要 ANCS 支持（苹果通知服务）
  - `enableAutoReconnect?: boolean`：是否自动重连
  - `notifyOnConnection?: boolean` - 是否通知app连接成功
  - `notifyOnDisconnection?: boolean` - 是否通知app连接已断开
  - `notifyOnNotification?: boolean` - 是否通知app收到通知

#### 返回值

- `Promise<void>`：连接成功 resolve，失败 reject

#### 示例

```ts
await BluetoothCentralManager.connect(peripheral, {
  startDelay: 100,
  enableAutoReconnect: true
})
console.log("已连接到外设")
```

***

### `disconnect(peripheral): Promise<void>`

> 断开与指定外围设备的连接。此操作是非阻塞的，部分尚未完成的操作可能无法继续。

#### 参数

- `peripheral: BluetoothPeripheral`：要断开的设备

#### 返回值

- `Promise<void>`

#### 注意事项

- 并不能保证物理连接立即断开（系统层面可能仍被其他 App 占用）
- 但从 Scripting 角度来看，设备即视为断开，`onDisconnected` 回调将被调用

#### 示例

```ts
await BluetoothCentralManager.disconnect(peripheral)
console.log("已断开连接")
```

***

## 注意事项

- 所有蓝牙方法需要在已授权蓝牙权限的前提下执行。
- 设备连接后请调用 `discoverServices()` 发现服务，然后通过 `discoverCharacteristics()` 获取特征值后再读写。
- 建议在扫描结束后手动调用 `stopScan()`，避免后台持续运行。

***

## 示例工作流程

```ts
await BluetoothCentralManager.startScan((peripheral) => {
  BluetoothCentralManager.stopScan()
  BluetoothCentralManager.connect(peripheral)
    .then(() => peripheral.discoverServices())
    .then(() => console.log("服务已发现"))
})
```



---
url: /zh/guide/Device Capabilities/Bluetooth/BluetoothCharacteristic.md
---

# 蓝牙服务特征值

`BluetoothCharacteristic` 表示蓝牙服务（`BluetoothService`）中的一个特征值，是 BLE 设备数据交互的核心单元。每个特征值由唯一 UUID 标识，并定义了支持的操作类型、当前值、通知状态等属性。

***

## 一、属性字段

### `uuid: string`

特征值的 UUID（统一唯一标识符），用于识别特征的类型。

- 示例：

  - `"2A37"` 表示标准心率测量特征
  - `"6E400002-B5A3-F393-E0A9-E50E24DCCA9E"` 是一个自定义特征 UUID

***

### `serviceUUID: string | null`

当前特征值所属服务的 UUID，如果服务未被发现则可能为 `null`。

***

### `properties: BluetoothCharacteristicProperty[]`

当前特征值支持的操作类型，是以下字符串枚举值组成的数组（可能同时包含多个）：

#### 可用的属性（`BluetoothCharacteristicProperty` 枚举）：

| 属性名                            | 说明                      |
| ------------------------------ | ----------------------- |
| `"broadcast"`                  | 支持广播（较少使用）              |
| `"read"`                       | 支持读取特征值                 |
| `"writeWithoutResponse"`       | 支持写入但不要求响应（更快，适用于高频率写入） |
| `"write"`                      | 支持写入并要求响应（更安全）          |
| `"notify"`                     | 支持通知（value 变化时主动推送）     |
| `"indicate"`                   | 支持指示（带确认的通知）            |
| `"authenticatedSignedWrites"`  | 支持认证写入（安全性更高）           |
| `"extendedProperties"`         | 包含扩展属性（由额外属性描述符定义）      |
| `"notifyEncryptionRequired"`   | 通知需加密（必须加密连接才能启用通知）     |
| `"indicateEncryptionRequired"` | 指示需加密（同上）               |

#### 示例判断：

```ts
if (characteristic.properties.includes("read")) {
  const value = await peripheral.readValue(characteristic)
}
```

***

### `isNotifying: boolean`

当前是否处于通知（`notify`）或指示（`indicate`）订阅状态。

- `true`: 已启用订阅，设备会推送值变化
- `false`: 未启用订阅

> 可通过 `peripheral.subscribe()` 和 `unsubscribe()` 控制通知状态。

***

### `value: Data | null`

当前特征值的内容，通常在调用 `readValue()` 或接收到通知时更新。

- `Data` 为 Scripting 提供的二进制数据类型
- 若尚未读取或写入，此字段可能为 `null`

***

## 二、特征权限

虽然 `BluetoothCharacteristic` 接口本身不包含权限字段，但在创建或定义特征值（如 Peripheral 模式）时可用下列权限枚举类型：

### `BluetoothAttributePermissions` 枚举（权限类型）

| 权限值                         | 说明      |
| --------------------------- | ------- |
| `"readable"`                | 可被读取    |
| `"writeable"`               | 可被写入    |
| `"readEncryptionRequired"`  | 读取需加密连接 |
| `"writeEncryptionRequired"` | 写入需加密连接 |

***

## 三、操作示例

### 读取特征值（需支持 `"read"`）

```ts
if (characteristic.properties.includes("read")) {
  const value = await peripheral.readValue(characteristic)
  console.log("读取到内容:", value?.toRawString())
}
```

***

### 写入特征值（需支持 `"write"` 或 `"writeWithoutResponse"`）

```ts
const data = Data.fromRawString("COMMAND")
if (characteristic.properties.includes("writeWithoutResponse")) {
  await peripheral.writeValue(characteristic, data, "withoutResponse")
} else if (characteristic.properties.includes("write")) {
  await peripheral.writeValue(characteristic, data, "withResponse")
}
```

***

### 订阅通知（需支持 `"notify"` 或 `"indicate"`）

```ts
if (characteristic.properties.includes("notify")) {
  await peripheral.subscribe(characteristic, (error, value) => {
    if (!error && value) {
      console.log("收到通知:", value.toHexString())
    }
  })
}
```

***

### 取消通知订阅

```ts
await peripheral.unsubscribe(characteristic)
```

***

## 四、使用建议与注意事项

- 特征值操作前必须调用 `discoverCharacteristics(service)` 获取特征值列表。
- **不要假设**所有特征值都支持读写，请根据 `properties` 判断支持的操作。
- 通知（Notify）和指示（Indicate）必须先调用 `subscribe()`，停止时需配套调用 `unsubscribe()`。
- 使用 `"writeWithoutResponse"` 时，建议配合 `canSendWriteWithoutResponse` 状态控制频率。
- 写入前建议调用 `maxWriteValueLength()` 获取最大支持长度。



---
url: /zh/guide/Device Capabilities/Bluetooth/BluetoothPeripheral.md
---

# 蓝牙外设

`BluetoothPeripheral` 表示一个 BLE 外围设备对象，支持读取设备信息、连接状态、发现服务与特征值、读取写入数据、订阅通知等。它是蓝牙通信的主要交互对象。

***

## 属性（只读）

### `id: string`

设备唯一标识符（UUID 格式），可用于标识并连接该设备。此值在 App 生命周期中保持不变。

***

### `name: string | null`

设备的名称，可能为 `null`（例如设备未广播名称）。

***

### `isConnected: boolean`

是否已连接到设备：

- `true`: 已连接，可以进行数据交互
- `false`: 未连接或已断开

***

### `canSendWriteWithoutResponse: boolean`

是否允许进行无响应写入：

- `true`: 可发送无响应数据（`writeWithoutResponse`）
- `false`: 需等待写入响应（使用 `write`）

当该值变为 `true` 时会触发 `onReadyToSendWriteWithoutResponse` 事件。

***

### `ancsAuthorized: boolean`

是否已授权使用 Apple Notification Center Service（仅适用于支持 ANCS 的设备）。

***

### `services: BluetoothService[] | null`

已发现的服务列表，如果尚未调用 `discoverServices()`，此值为 `null`。

***

## 事件回调（可选）

### `onConnected: (() => void) | null`

连接成功时触发。

***

### `onDisconnected: ((error: Error | null, isReconnecting: boolean) => void) | null`

断开连接时触发。

- `error`: 若为非主动断开，则包含错误信息；否则为 `null`
- `isReconnecting`: 是否正在尝试重连

***

### `onConnectFailed: ((error: Error) => void) | null`

连接失败时触发。

***

### `onNameChanged: ((name: string | null) => void) | null`

设备名称发生变更时触发。

***

### `onDiscoverServices: ((error: Error | null, services: BluetoothService[] | null) => void) | null`

调用 `discoverServices()` 后，服务发现完成时触发。

***

### `onDiscoverCharacteristics: ((error: Error | null, characteristics: BluetoothCharacteristic[] | null) => void) | null`

调用 `discoverCharacteristics()` 后，特征值发现完成时触发。

***

### `onDiscoverIncludedServices: ((error: Error | null, services: BluetoothService[] | null) => void) | null`

调用 `discoverIncludedServices()` 后，包含服务发现完成时触发。

***

### `onReadyToSendWriteWithoutResponse: (() => void) | null`

设备准备好接收新的无响应写入时触发。

***

## 方法

### `readValue(characteristic: BluetoothCharacteristic): Promise<Data>`

读取指定特征值的内容。

- **参数**：

  - `characteristic`: 要读取的特征值对象
- **返回**：`Promise<Data>`，表示读取到的数据

***

### `maxWriteValueLength(writeType: "withResponse" | "withoutResponse"): number`

获取设备支持的最大写入字节数。

- **参数**：

  - `writeType`: `"withResponse"` 或 `"withoutResponse"`
- **返回**：可写入的最大字节数（`number`）

***

### `writeValue(characteristic, value, writeType): Promise<void>`

向特征值写入数据。

- **参数**：

  - `characteristic`: 要写入的特征值对象
  - `value`: 要写入的 `Data` 数据
  - `writeType`: 写入类型 `"withResponse"` 或 `"withoutResponse"`
- **返回**：`Promise<void>`

***

### `subscribe(characteristic, handler): Promise<void>`

订阅特征值通知或指示。

- **要求**：该特征值必须包含 `"notify"` 或 `"indicate"` 属性
- **参数**：

  - `characteristic`: 要订阅的特征值
  - `handler(error, value)`: 通知触发时回调函数

    - `error`: 出错时为 `Error`，否则为 `null`
    - `value`: 通知传递的 `Data` 数据，可能为 `null`
- **返回**：`Promise<void>`

***

### `unsubscribe(characteristic): Promise<void>`

取消特征值的通知订阅。

- **参数**：

  - `characteristic`: 要取消订阅的特征值
- **返回**：`Promise<void>`

***

### `discoverServices(serviceUUIDs?: string[]): Promise<void>`

发现设备提供的服务。

- **参数**：

  - `serviceUUIDs`: 可选服务 UUID 列表，用于筛选
- **返回**：`Promise<void>`

***

### `discoverIncludedServices(service, includedServiceUUIDs?): Promise<void>`

发现指定服务中嵌套的服务。

- **参数**：

  - `service`: 要发现的服务
  - `includedServiceUUIDs`: 可选的服务 UUID 筛选
- **返回**：`Promise<void>`

***

### `discoverCharacteristics(service, characteristicUUIDs?): Promise<void>`

发现指定服务中的特征值。

- **参数**：

  - `service`: 要发现的服务
  - `characteristicUUIDs`: 可选的特征值 UUID 筛选
- **返回**：`Promise<void>`

***

### `readRSSI(): Promise<number>`

读取当前设备的信号强度（RSSI，单位 dBm）。

- **返回**：`Promise<number>`

***

## 示例

### 连接设备并读取特征值

```ts
await BluetoothCentralManager.connect(peripheral)
await peripheral.discoverServices()

for (const service of peripheral.services ?? []) {
  await peripheral.discoverCharacteristics(service)
  for (const char of service.characteristics ?? []) {
    if (char.properties.includes("read")) {
      const value = await peripheral.readValue(char)
      console.log("读取到值:", value?.toRawString())
    }
  }
}
```

***

### 写入数据并订阅通知

```ts
const data = Data.fromRawString("hello")
await peripheral.writeValue(characteristic, data, "withResponse")

await peripheral.subscribe(characteristic, (error, value) => {
  if (!error && value) {
    console.log("收到通知:", value.toHexString())
  }
})
```

***

## 注意事项

- 所有操作前必须确保设备已连接，并通过 `discoverServices()` 和 `discoverCharacteristics()` 获取服务和特征值。
- 订阅通知后应在合适时机调用 `unsubscribe()` 释放资源。
- `canSendWriteWithoutResponse` 为 `false` 时不应进行无响应写入。



---
url: /zh/guide/Device Capabilities/Bluetooth/BluetoothPeripheralManager.md
---

# 蓝牙外设管理器

`BluetoothPeripheralManager` 提供将设备作为 BLE 外设运行的能力，允许你：

- 广播设备名称与服务 UUID
- 添加并移除服务
- 处理来自中央设备的读写请求
- 发送通知给已订阅的中央设备
- 管理连接参数（如连接延迟）

该 API 适用于构建如自定义传感器设备、蓝牙外设模拟器、控制器等场景。

***

## 基本状态属性

### `isAdvertising: Promise<boolean>`

查询当前是否正在进行广播。

- **类型**：`Promise<boolean>`
- **示例**：

```ts
const advertising = await BluetoothPeripheralManager.isAdvertising
console.log(advertising ? "正在广播" : "已停止广播")
```

***

## 广播控制

### `startAdvertising(advertisementData): Promise<void>`

启动蓝牙广播。

- **参数**：

  - `advertisementData`（对象）：

    - `localName?: string`：设备名称
    - `serviceUUIDs?: string[]`：要广播的服务 UUID

- **示例**：

```ts
await BluetoothPeripheralManager.startAdvertising({
  localName: "MyPeripheral",
  serviceUUIDs: ["1234", "ABCD"]
})
```

***

### `stopAdvertising(): Promise<void>`

停止当前的广播。

```ts
await BluetoothPeripheralManager.stopAdvertising()
```

***

## 服务管理

### `addService(service): Promise<void>`

向外设添加服务及其特征值。

- **参数**：

  - `service` 对象：

    - `uuid`: 服务 UUID
    - `characteristics`: 特征值列表，每项包含：

      - `uuid`
      - `properties`: 如 `"read"`, `"writeWithoutResponse"` 等
      - `permissions`: 如 `"readable"`, `"writeEncryptionRequired"` 等
      - `value?`: 初始值（`Data` 类型）

- **示例**：

```ts
await BluetoothPeripheralManager.addService({
  uuid: "180F",
  characteristics: [
    {
      uuid: "2A19",
      properties: ["read", "notify"],
      permissions: ["readable"],
      value: Data.fromIntArray([85]) // 初始电量 85%
    }
  ]
})
```

***

### `removeService(serviceUUID: string): Promise<void>`

移除指定 UUID 的服务（仅移除由当前脚本添加的实例）。

***

### `removeAllServices(): Promise<void>`

移除所有由脚本添加的服务。

***

## 中央设备交互事件

### `onRestoreState: ((state) => void) | null`

当系统因后台 BLE 任务恢复脚本时调用，用于恢复已添加的服务和广播状态。

#### 类型定义：

```ts
var onRestoreState: ((state: {
  services: BluetoothServiceInfo[]
  advertisementData: BluetoothAdvertisementData
}) => void) | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onRestoreState = (state) => {
  console.log("恢复状态，已注册服务数：", state.services.length)
}
```

***

### `onReadyToUpdateSubscribers: (() => void) | null`

如果调用 `updateValue()` 发送通知时因底层队列已满而失败，系统会在队列恢复后调用此回调，你可在此时重试发送。

#### 类型定义：

```ts
var onReadyToUpdateSubscribers: (() => void) | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onReadyToUpdateSubscribers = () => {
  console.log("队列已空，准备重新发送通知")
}
```

***

### `onReadCharacteristicValue: (characteristicId, offset, central) => Promise<{result, value}>`

当远程中央设备请求读取某个特征值时调用此回调。如果你未实现该回调，则该读取请求将以 `readNotPermitted` 响应失败。

#### 类型定义：

```ts
var onReadCharacteristicValue: (
  characteristicId: string,
  offset: number,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => Promise<{
  result: BluetoothATTResponseCode
  value?: Data | null
}> | null
```

#### 参数说明：

- `characteristicId`：请求读取的特征值 UUID 字符串。
- `offset`：从哪个偏移位置开始读取（通常为 0）。
- `central`：发起请求的中央设备信息：

  - `id`：中央设备的标识符。
  - `maximumUpdateValueLength`：该中央设备可接受的最大数据长度。

#### 返回：

一个 `Promise`，解析为对象：

- `result`：读取结果的响应码（参见 `BluetoothATTResponseCode` 枚举）。
- `value`：如果读取成功，返回一个 `Data` 对象；否则为 `null`。

#### 示例：

```ts
BluetoothPeripheralManager.onReadCharacteristicValue = async (id, offset, central) => {
  if (id === "2A19") {
    const batteryLevel = 85
    return {
      result: BluetoothATTResponseCode.success,
      value: Data.fromIntArray([batteryLevel])
    }
  }
  return { result: BluetoothATTResponseCode.attributeNotFound }
}
```

***

### `onWriteCharacteristicValue: (characteristicId, offset, value, central) => Promise<BluetoothATTResponseCode>`

当远程中央设备请求写入某个特征值时调用此回调。如果你未实现该回调，则写入请求将以 `writeNotPermitted` 响应失败。

#### 类型定义：

```ts
var onWriteCharacteristicValue: (
  characteristicId: string,
  offset: number,
  value: Data,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => Promise<BluetoothATTResponseCode> | null
```

#### 参数说明：

- `characteristicId`：请求写入的特征值 UUID。
- `offset`：写入偏移（一般为 0）。
- `value`：远程写入的数据（`Data` 类型）。
- `central`：发起写入请求的中央设备。

#### 返回：

一个 `Promise`，解析为响应码，表示写入是否成功。

#### 示例：

```ts
BluetoothPeripheralManager.onWriteCharacteristicValue = async (id, offset, value, central) => {
  console.log(`收到写入请求：${id}`, value.toIntArray())
  if (id === "2A19") {
    // 可存储或响应更新
    return BluetoothATTResponseCode.success
  }
  return BluetoothATTResponseCode.attributeNotFound
}
```

***

### `onSubscribe: (characteristicId, central) => void`

当远程中央设备订阅某个支持 notify 或 indicate 的特征值时调用。

#### 类型定义：

```ts
var onSubscribe: (
  characteristicId: string,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => void | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onSubscribe = (id, central) => {
  console.log(`设备 ${central.id} 订阅了 ${id}`)
}
```

***

### `onUnsubscribe: (characteristicId, central) => void`

当远程中央设备取消订阅某个特征值时调用。

#### 类型定义：

```ts
var onUnsubscribe: (
  characteristicId: string,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => void | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onUnsubscribe = (id, central) => {
  console.log(`设备 ${central.id} 取消订阅了 ${id}`)
}
```

***

## 通知与订阅管理

### `getSubscribers(characteristicId: string): Promise<Central[]>`

获取当前订阅某个特征值的所有中央设备。

- 返回项结构：

  - `id: string`
  - `maximumUpdateValueLength: number`

***

### `updateValue(characteristicId, value, options?): Promise<boolean>`

更新特征值并向订阅者发送通知或指示。

- `options.centrals`：指定要发送的中央设备 ID（否则广播给所有已订阅设备）

- 返回值：

  - `true`: 发送成功
  - `false`: 传输队列满，需等待 `onReadyToUpdateSubscribers`

***

## 连接参数设置

### `setDesiredConnectionLatency(centralId, latency): Promise<void>`

设置与指定中央设备的期望连接延迟等级：

- `latency` 取值：

  - `"low"`：高频率交互（更快但更耗电）
  - `"medium"`：平衡模式
  - `"high"`：低频率交互（省电）

***

## 响应码枚举：BluetoothATTResponseCode

用于表示对读取/写入操作的响应结果：

| 名称                              | 数值 | 含义           |
| ------------------------------- | -- | ------------ |
| `success`                       | 0  | 操作成功         |
| `invalidHandle`                 | 1  | 无效的句柄        |
| `readNotPermitted`              | 2  | 不允许读取        |
| `writeNotPermitted`             | 3  | 不允许写入        |
| `invalidPdu`                    | 4  | 无效的 PDU      |
| `insufficientAuthentication`    | 5  | 未通过身份验证      |
| `requestNotSupported`           | 6  | 不支持该请求       |
| `invalidOffset`                 | 7  | 偏移量无效        |
| `insufficientAuthorization`     | 8  | 授权不足         |
| `prepareQueueFull`              | 9  | Prepare 队列已满 |
| `attributeNotFound`             | 10 | 未找到指定属性      |
| `attributeNotLong`              | 11 | 属性不支持长读写     |
| `insufficientEncryptionKeySize` | 12 | 加密密钥长度不足     |
| `invalidAttributeValueLength`   | 13 | 属性值长度无效      |
| `unlikelyError`                 | 14 | 发生了不太可能的错误   |
| `insufficientEncryption`        | 15 | 未加密或加密级别不足   |
| `unsupportedGroupType`          | 16 | 不支持的组类型      |
| `insufficientResources`         | 17 | 系统资源不足       |

***

## 示例：构建一个广播电量的外围设备

```ts
await BluetoothPeripheralManager.addService({
  uuid: "180F",
  characteristics: [
    {
      uuid: "2A19",
      properties: ["read", "notify"],
      permissions: ["readable"],
      value: Data.fromIntArray([100]) // 电量 100%
    }
  ]
})

await BluetoothPeripheralManager.startAdvertising({
  localName: "BatteryPeripheral",
  serviceUUIDs: ["180F"]
})

BluetoothPeripheralManager.onReadCharacteristicValue = async (id, offset, central) => {
  return { result: BluetoothATTResponseCode.success, value: Data.fromIntArray([90]) }
}
```



---
url: /zh/guide/Device Capabilities/Bluetooth/BluetoothService.md
---

# 蓝牙服务

`BluetoothService` 表示一个 BLE（低功耗蓝牙）服务。服务是外围设备中功能的逻辑分组，包含一个或多个特征值（`Characteristic`），也可以包含对其他服务的引用（包含服务）。

***

## 概述

每个服务都由一个唯一的 UUID 标识，用于描述设备提供的某项功能，例如：

- 标准服务，如 `"180F"` 表示电池服务
- 自定义服务，通常为厂商自定义的 UUID

服务的主要用途是组织设备提供的数据和操作。

***

## 属性说明

### `uuid: string`

服务的 UUID。

- 用于唯一标识服务类型
- 可通过此字段识别标准服务或自定义服务

***

### `peripheralId: string | null`

所属外围设备的标识符（UUID 字符串）。

- 如果上下文丢失或设备未记录，则可能为 `null`

***

### `isPrimary: boolean`

是否为主服务。

- `true`: 主服务，表示设备核心功能
- `false`: 次服务，通常被其他服务引用（嵌套）

***

### `includedServices: BluetoothService[] | null`

包含服务（referenced services）的数组。

- 这些服务可能是主服务或次服务
- 若尚未调用 `discoverIncludedServices()`，此值为 `null`
- 可通过 `BluetoothPeripheral.discoverIncludedServices(service)` 方法获取

***

### `characteristics: BluetoothCharacteristic[] | null`

当前服务下包含的特征值数组。

- 特征值用于实际的数据交互（读、写、通知等）
- 若尚未调用 `discoverCharacteristics()`，此值为 `null`
- 可通过 `BluetoothPeripheral.discoverCharacteristics(service)` 方法获取

***

## 使用示例

### 发现服务并列出特征值

```ts
await peripheral.discoverServices()
for (const service of peripheral.services ?? []) {
  console.log("服务 UUID:", service.uuid)

  await peripheral.discoverCharacteristics(service)
  for (const char of service.characteristics ?? []) {
    console.log("特征值 UUID:", char.uuid)
  }
}
```

***

### 发现包含服务（嵌套服务）

```ts
await peripheral.discoverServices()
for (const service of peripheral.services ?? []) {
  await peripheral.discoverIncludedServices(service)
  for (const included of service.includedServices ?? []) {
    console.log("包含服务 UUID:", included.uuid)
  }
}
```

***

## 注意事项

- 所有属性均为只读。
- 必须先调用 `discoverServices()` 才能访问 `characteristics` 和 `includedServices`。
- 包含服务可能嵌套更深层级，若需深入访问需递归调用发现方法。



---
url: /zh/guide/Device Capabilities/Calendar.md
---

# 日历

Scripting 应用中的 `Calendar` API 提供了与 iOS 日历账户、日历对象、事件和提醒事项交互的能力。\
开发者可以通过此 API 获取默认日历、创建新的日历、列出支持特定实体类型（日程、提醒）的日历，以及管理日历属性。

***

## 类型定义

### CalendarType

定义日历的种类：

| 值                | 描述            |
| :--------------- | :------------ |
| `"birthday"`     | 生日日历          |
| `"calDAV"`       | CalDAV 协议日历   |
| `"exchange"`     | Exchange 账户日历 |
| `"local"`        | 本地日历          |
| `"subscription"` | 订阅日历          |

### CalendarSourceType

定义日历账户源的种类：

| 值              | 描述          |
| :------------- | :---------- |
| `"birthdays"`  | 生日账户        |
| `"calDAV"`     | CalDAV 协议账户 |
| `"exchange"`   | Exchange 账户 |
| `"local"`      | 本地账户        |
| `"mobileMe"`   | MobileMe 账户 |
| `"subscribed"` | 订阅账户        |

### CalendarEventAvailability

定义事件的可用性状态：

| 值               | 描述  |
| :-------------- | :-- |
| `"busy"`        | 忙碌  |
| `"free"`        | 空闲  |
| `"tentative"`   | 暂定  |
| `"unavailable"` | 不可用 |

### CalendarEntityType

定义日历中可管理的实体类型：

| 值            | 描述   |
| :----------- | :--- |
| `"event"`    | 日程事件 |
| `"reminder"` | 提醒事项 |

***

## 类：CalendarSource

代表一个日历账户源，例如本地账户、Exchange账户等。

### 属性

| 属性名          | 类型                   | 描述        |
| :----------- | :------------------- | :-------- |
| `type`       | `CalendarSourceType` | 账户源的类型    |
| `title`      | `string`             | 账户源的标题    |
| `identifier` | `string`             | 账户源的唯一标识符 |

### 方法

#### `getCalendars(entityType: CalendarEntityType): Promise<Calendar[]>`

获取该账户下指定实体类型（事件或提醒事项）支持的所有日历。

- **参数**
  - `entityType: CalendarEntityType` — 需要获取的日历实体类型。
- **返回**
  - `Promise<Calendar[]>` — 日历对象数组。

***

## 类：Calendar

代表一个具体的日历对象，可用于管理日程、提醒事项等。

### 属性

| 属性名                            | 类型                          | 描述                 |
| :----------------------------- | :-------------------------- | :----------------- |
| `identifier`                   | `string`                    | 日历的唯一标识符           |
| `title`                        | `string`                    | 日历标题               |
| `color`                        | `Color`                     | 日历颜色               |
| `type`                         | `CalendarType`              | 日历种类               |
| `source`                       | `CalendarSource`            | 日历帐户源              |
| `allowedEntityTypes`           | `CalendarEntityType`        | 日历允许包含的实体类型（事件或提醒） |
| `isForEvents`                  | `boolean`                   | 是否用于存储事件           |
| `isForReminders`               | `boolean`                   | 是否用于存储提醒事项         |
| `allowsContentModifications`   | `boolean`                   | 是否允许修改日历内容         |
| `isSubscribed`                 | `boolean`                   | 是否为订阅日历            |
| `supportedEventAvailabilities` | `CalendarEventAvailability` | 日历支持的事件可用性类型       |

### 方法

#### `remove(): Promise<void>`

删除该日历。

#### `save(): Promise<void>`

保存对该日历的更改。

#### `static defaultForEvents(): Promise<Calendar | null>`

获取当前系统设置的默认事件日历。

#### `static defaultForReminders(): Promise<Calendar | null>`

获取当前系统设置的默认提醒事项日历。

#### `static forEvents(): Promise<Calendar[]>`

列出所有支持事件的日历。

#### `static forReminders(): Promise<Calendar[]>`

列出所有支持提醒事项的日历。

#### `static create(options: { title: string, entityType: CalendarEntityType, sourceType: CalendarSourceType, color?: Color }): Promise<Calendar>`

创建一个新的日历。

- **参数**
  - `title: string` — 新日历的标题
  - `entityType: CalendarEntityType` — 支持的实体类型
  - `sourceType: CalendarSourceType` — 日历账户源类型
  - `color?: Color` — （可选）日历颜色
- **返回**
  - `Promise<Calendar>` — 新创建的日历对象。

#### `static presentChooser(allowMultipleSelection?: boolean): Promise<Calendar[]>`

展示一个日历选择器界面，供用户选择一个或多个日历。

- **参数**
  - `allowMultipleSelection?: boolean` — 是否允许多选，默认 `false`。
- **返回**
  - `Promise<Calendar[]>` — 用户选择的日历列表。

#### `static getSources(): CalendarSource[]`

获取当前设备上所有的日历账户源。

***

## 示例代码

### 获取默认事件日历

```tsx
const defaultEventCalendar = await Calendar.defaultForEvents()
if (defaultEventCalendar) {
  console.log(`默认事件日历: ${defaultEventCalendar.title}`)
} else {
  console.log('未找到默认事件日历')
}
```

### 创建新的本地事件日历

```tsx
const newCalendar = await Calendar.create({
  title: '锻炼计划',
  entityType: 'event',
  sourceType: 'local',
  color: '#FF5733'
})

await newCalendar.save()
console.log(`创建了新的日历: ${newCalendar.title}`)
```

### 列出所有支持事件的日历

```tsx
const eventCalendars = await Calendar.forEvents()
for (const calendar of eventCalendars) {
  console.log(`日历: ${calendar.title}`)
}
```

### 删除第一个事件日历

```tsx
const eventCalendars = await Calendar.forEvents()
if (eventCalendars.length > 0) {
  const calendarToRemove = eventCalendars[0]
  await calendarToRemove.remove()
  console.log(`已删除日历: ${calendarToRemove.title}`)
}
```

### 展示日历选择器并处理用户选择

```tsx
const selectedCalendars = await Calendar.presentChooser(true)
for (const calendar of selectedCalendars) {
  console.log(`选择了日历: ${calendar.title}`)
}
```



---
url: /zh/guide/Device Capabilities/CalendarEvent.md
---

`CalendarEvent` API 用于在 iOS 日历中创建、读取、编辑与管理事件。
开发者可以操作事件的标题、时间、地点、参与者、重复规则、提醒（EventAlarm）、事件可用性以及地理位置信息，并且可以使用系统提供的创建/编辑界面。

***

# 一、类型说明

## EventParticipant

表示事件的参与者：

- `isCurrentUser: boolean`：是否为当前用户
- `name?: string`：姓名
- `role: ParticipantRole`：角色
- `type: ParticipantType`：类型
- `status: ParticipantStatus`：出席状态

### ParticipantRole

- `chair`（主持人）
- `nonParticipant`（非参与者）
- `optional`（可选）
- `required`（必需）
- `unknown`（未知）

### ParticipantType

- `group`（群组）
- `person`（个人）
- `resource`（资源）
- `room`（房间）
- `unknown`（未知）

### ParticipantStatus

- `unknown`（未知）
- `pending`（待定）
- `accepted`（接受）
- `declined`（拒绝）
- `tentative`（暂定）
- `delegated`（已委托）
- `completed`（已完成）
- `inProcess`（处理中）

***

## EventAvailability

用于表明事件在日程中的可用性状态：

- `notSupported`：日历不支持可用性设置
- `busy`：忙碌
- `free`：空闲
- `tentative`：暂定
- `unavailable`：不可用

***

## EventStructuredLocation

用于地理位置提醒的结构化位置：

- `title: string | null`：名称
- `geoLocation: LocationInfo | null`：地理位置（经纬度）
- `radius: number`：触发半径（米）

此结构与 `EventAlarm.structuredLocation` 配合使用。

***

## AlarmProximity

位置提醒的触发方式：

- `none`：不使用位置触发
- `enter`：进入区域时触发
- `leave`：离开区域时触发

***

# 二、EventAlarm（事件提醒）

CalendarEvent 支持添加多个 `EventAlarm`，包括：

- **绝对时间提醒**
- **相对事件开始时间提醒**
- **位置提醒（geofence）**

详细说明请参考独立的 EventAlarm 文档。

***

# 三、CalendarEvent 类

## 构造函数

```ts
new(): CalendarEvent
```

创建一个新的事件实例（尚未保存到日历）。

***

# 四、属性说明

## 基本信息

### identifier: string

事件的唯一标识符。

### title: string

事件标题。

### notes: string | null

事件备注。

### url: string | null

关联 URL。

### calendar: Calendar | null

事件所属的日历。
不可设为 `null`。
如果需要删除事件，请使用 `remove()`。

***

## 时间与地点

### isAllDay: boolean

是否为全天事件。

### startDate: Date

开始时间。

### endDate: Date

结束时间。

### timeZone: string | null

事件使用的时区。

### location: string | null

纯文本地点信息。

### structuredLocation: EventStructuredLocation | null

结构化位置（支持 geofence 提醒）。

***

## 事件状态与生成信息（新增）

### creationDate: Date | null

事件创建日期（只读）。

### lastModifiedDate: Date | null

事件最后修改时间（只读）。

### occurrenceDate: Date

对于重复事件中的“单个实例”，此属性表示该实例原始发生日期。

### isDetached: boolean

是否为重复事件的“脱离实例”。
例如用户单独修改某一发生日期的事件时，该实例会成为 detached instance。

***

## 参与者与可用性（新增相关属性）

### attendees: EventParticipant\[] | null

参与者数组（只读）。

### organizer: EventParticipant | null

事件组织者（只读）。

### hasAttendees: boolean

是否包含参与者。

### availability: EventAvailability

事件在日程中的可用性状态。

***

## 提醒（Alarm）相关

### alarms: EventAlarm\[] | null

事件绑定的提醒列表。

### hasAlarm: boolean

事件是否包含提醒。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

事件的重复规则数组。

### hasRecurrenceRules: boolean

是否包含重复规则。

***

## 其他状态属性（新增）

### hasNotes: boolean

是否包含备注。

### hasChanges: boolean

事件或其内部对象是否有未保存的更改。

***

# 五、实例方法

## 1. 提醒管理

### addAlarm(alarm: EventAlarm): void

为事件添加一个提醒。

### removAlarm(alarm: EventAlarm): void

从事件移除一个提醒。
（注意拼写：API 为 `removAlarm`）

***

## 2. 重复规则

### addRecurrenceRule(rule: RecurrenceRule): void

添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除一条重复规则。

***

## 3. 事件保存与删除

### `save(): Promise<void>`

保存事件（或重复事件的变化）。

### `remove(): Promise<void>`

从日历中移除事件。

***

## 4. 显示编辑界面

### `presentEditView(): Promise<EventEditViewAction>`

显示系统提供的事件编辑界面，并返回用户执行的操作：

- `"saved"`
- `"deleted"`
- `"canceled"`

***

# 六、静态方法

## `getAll(startDate: Date, endDate: Date, calendars?: Calendar[]): Promise<CalendarEvent[]>`

获取指定日期范围内的事件。

- 可传入 `calendars` 数组过滤事件
- 若不传或传 `null`，则搜索所有可访问的日历

***

## `presentCreateView(): Promise<CalendarEvent | null>`

显示事件创建界面。

- 用户点击保存时返回创建的事件
- 用户取消时返回 `null`

***

# 七、使用示例

## 1. 创建并保存事件

```ts
const defaultCalendar = await Calendar.defaultForEvents()
const event = new CalendarEvent()
event.title = "团队会议"
event.calendar = defaultCalendar!
event.startDate = new Date("2024-01-15T09:00:00")
event.endDate = new Date("2024-01-15T10:00:00")
event.location = "会议室"

await event.save()
```

***

## 2. 添加重复规则

```ts
const rule = RecurrenceRule.create({
  frequency: "weekly",
  interval: 1,
  daysOfTheWeek: ["monday", "wednesday", "friday"],
  end: RecurrenceEnd.fromDate(new Date("2024-12-31")),
})

event.addRecurrenceRule(rule)
await event.save()
```

***

## 3. 添加提醒（Alarm）

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
event.addAlarm(alarm)
await event.save()
```

***

## 4. 获取日期范围内的事件

```ts
const events = await CalendarEvent.getAll(
  new Date("2024-01-01"),
  new Date("2024-01-31")
 )

for (const e of events) {
  console.log(`事件: ${e.title} 开始时间: ${e.startDate}`)
}
```

***

## 5. 使用事件创建界面

```ts
const created = await CalendarEvent.presentCreateView()
if (created) {
  console.log("新事件已创建:", created.title)
}
```

***

## 6. 编辑事件

```ts
const result = await event.presentEditView()
console.log("编辑操作:", result)
```

***

## 7. 删除事件

```ts
await event.remove()
console.log("事件已移除")
```

***

# 八、补充说明

### 时区处理

当处理跨时区事件时，请务必设置 `timeZone`，否则可能出现偏移时间或显示错误。

### 重复事件编辑

- 修改单个重复事件实例会创建一个 detached instance
- `occurrenceDate` 可用于识别该实例对应的原始日期

### 参与者

参与者信息由系统从日历源（如 iCloud、Exchange）读取。
部分字段可能因日历源不同而缺失。

### structuredLocation 与 geofence

若使用位置提醒，请确保用户授权位置权限。



---
url: /zh/guide/Device Capabilities/Contact/index.md
---

# 通讯录

Scripting 提供 `Contact` 模块，允许在脚本中访问和管理设备上的联系人数据，包括创建、查询、更新、删除联系人，以及操作联系人组和容器。

## 基本概念

| 类型                               | 描述                                |
| -------------------------------- | --------------------------------- |
| **ContactInfo**                  | 表示单个联系人的完整信息。                     |
| **ContactContainer**             | 联系人存储容器，来源如本地、Exchange、CardDAV 等。 |
| **ContactGroup**                 | 联系人组，用于将联系人分类管理。                  |
| **ContactLabeledValue**          | 带标签的值，如电话、邮箱。                     |
| **ContactPostalAddress**         | 邮寄地址信息。                           |
| **ContactSocialProfile**         | 社交账号信息。                           |
| **ContactInstantMessageAddress** | 即时通讯信息。                           |

***

## 创建联系人

```ts
try {
  const contact = await Contact.createContact({
    givenName: 'John',
    familyName: 'Doe',
    phoneNumbers: [{ label: 'mobile', value: '+1234567890' }],
    emailAddresses: [{ label: 'work', value: 'john.doe@example.com' }]
  })
  console.log('联系人创建成功:', contact)
} catch (error) {
  console.error('创建联系人失败:', error)
}
```

说明：

- `givenName` 或 `familyName` 至少填写一项
- 可指定 `containerIdentifier`，否则加入默认容器
- 建议捕获异常，避免因权限或参数问题导致脚本崩溃

***

## 更新联系人

```ts
try {
  const updated = await Contact.updateContact({
    identifier: contact.identifier,
    phoneNumbers: [{ label: 'home', value: '+9876543210' }]
  })
  console.log('联系人更新成功:', updated)
} catch (error) {
  console.error('更新联系人失败:', error)
}
```

更新说明：

- 必须传入 `identifier`
- 仅修改提供的字段，其他信息不变

***

## 查询联系人

### 通过唯一标识符查询

```ts
try {
  const contact = await Contact.fetchContact(contactId, { fetchImageData: true })
  console.log('联系人信息:', contact)
} catch (error) {
  console.error('查询联系人失败:', error)
}
```

### 查询所有联系人

```ts
try {
  const contacts = await Contact.fetchAllContacts({ fetchImageData: false })
  console.log('联系人列表:', contacts)
} catch (error) {
  console.error('获取联系人列表失败:', error)
}
```

### 查询指定容器或组内的联系人

```ts
try {
  const contacts = await Contact.fetchContactsInContainer(containerId)
  console.log('容器内联系人:', contacts)
} catch (error) {
  console.error('查询容器内联系人失败:', error)
}

try {
  const groupContacts = await Contact.fetchContactsInGroup(groupId)
  console.log('组内联系人:', groupContacts)
} catch (error) {
  console.error('查询组内联系人失败:', error)
}
```

***

## 删除联系人

```ts
try {
  await Contact.deleteContact(contactId)
  console.log('联系人已删除')
} catch (error) {
  console.error('删除联系人失败:', error)
}
```

***

## 容器管理

### 获取所有容器

```ts
try {
  const containers = await Contact.fetchContainers()
  console.log('联系人容器:', containers)
} catch (error) {
  console.error('获取容器失败:', error)
}
```

### 获取默认容器

```ts
try {
  const defaultContainerId = await Contact.defaultContainerIdentifier
  console.log('默认容器ID:', defaultContainerId)
} catch (error) {
  console.error('获取默认容器失败:', error)
}
```

***

## 联系人组管理

### 创建联系人组

```ts
try {
  const group = await Contact.createGroup('Friends', defaultContainerId)
  console.log('联系人组创建成功:', group)
} catch (error) {
  console.error('创建联系人组失败:', error)
}
```

### 获取联系人组

```ts
try {
  const groups = await Contact.fetchGroups()
  console.log('联系人组列表:', groups)
} catch (error) {
  console.error('获取联系人组失败:', error)
}
```

### 删除联系人组

```ts
try {
  await Contact.deleteGroup(groupId)
  console.log('联系人组已删除')
} catch (error) {
  console.error('删除联系人组失败:', error)
}
```

***

## 联系人与组的关系管理

### 添加联系人到指定组

```ts
try {
  await Contact.addContactToGroup(contactId, groupId)
  console.log('联系人已添加到组')
} catch (error) {
  console.error('添加联系人到组失败:', error)
}
```

### 从组中移除联系人

```ts
try {
  await Contact.removeContactFromGroup(contactId, groupId)
  console.log('联系人已从组中移除')
} catch (error) {
  console.error('从组中移除联系人失败:', error)
}
```

***

## ContactInfo 数据结构示例

```json
{
  "identifier": "XXXX-XXXX",
  "givenName": "John",
  "familyName": "Doe",
  "phoneNumbers": [{ "label": "mobile", "value": "+1234567890" }],
  "emailAddresses": [{ "label": "work", "value": "john@example.com" }],
  "postalAddresses": [{
    "label": "home",
    "street": "123 Apple St.",
    "city": "Cupertino",
    "state": "CA",
    "postalCode": "95014",
    "country": "USA",
    "isoCountryCode": "US"
  }]
}
```

***

## 注意事项

- 所有 API 操作都可能因权限、数据错误等原因失败，建议统一加上 `try-catch`
- 访问联系人前，请确保获取用户授权
- `imageData` 建议按需加载，避免性能问题
- 更新和删除操作必须确保 `identifier` 正确有效

***

## 完整示例：创建并查询联系人

```ts
try {
  const contact = await Contact.createContact({
    givenName: 'Alice',
    familyName: 'Smith',
    phoneNumbers: [{ label: 'mobile', value: '+19876543210' }]
  })
  console.log('联系人创建成功:', contact)

  const fetched = await Contact.fetchContact(contact.identifier)
  console.log('查询到联系人:', fetched.givenName)
} catch (error) {
  console.error('操作失败:', error)
}
```



---
url: /zh/guide/Device Capabilities/Contact/index_example.md
---

# 示例

```tsx
import { Script } from "scripting"

async function run() {
  console.present().then(() => {
    Script.exit()
  })

  console.log("Start to fetch contacts")
  try {
    const contacts = await Contact.fetchAllContacts()

    const first = contacts.at(0)

    if (!first) {
      console.log("No contacts found")
    } else {
      console.log("There are " + contacts.length + " contacts")

      const name = [
        first.givenName,
        first.familyName
      ].join(" ")
      
      console.log("First contact name: " + name)
    }
  } catch (e) {
    console.error(e)
  }
}

run()
```



---
url: /zh/guide/Device Capabilities/Device/index.md
---

# 设备

`Device` 命名空间提供当前运行设备的基础信息、系统环境、屏幕与电池状态、语言与地区设置，以及部分与设备能力相关的方法（如唤醒锁、网络接口信息）。

该 API 常用于：

- 设备差异化逻辑（iPhone / iPad / Mac）
- UI 布局与适配
- 多语言与本地化判断
- 网络调试与诊断
- 防止脚本执行期间设备休眠

***

## 设备与系统信息

### `Device.model: string`

设备型号名称，例如 `"iPhone"`、`"iPad"`。

***

### `Device.systemName: string`

当前操作系统名称，例如 `"iOS"`、`"iPadOS"`、`"macOS"`。

***

### `Device.systemVersion: string`

当前操作系统版本号，例如 `"17.2"`。

***

### `Device.isiPhone: boolean`

当前设备是否为 iPhone。

***

### `Device.isiPad: boolean`

当前设备是否为 iPad。

***

### `Device.isiOSAppOnMac: boolean`

当前进程是否为 **iPhone / iPad App 运行在 Mac 上**（Mac Catalyst / Apple Silicon Mac）。

***

## 屏幕信息

### `Device.screen`

当前主屏幕的信息。

```ts
{
  width: number
  height: number
  scale: number
}
```

字段说明：

- `width`：屏幕逻辑宽度（pt）
- `height`：屏幕逻辑高度（pt）
- `scale`：屏幕缩放因子（如 2 / 3）

常用于布局计算、画布尺寸、截图或渲染比例控制。

***

## 方向与姿态

### `Device.isPortrait: boolean`

当前设备是否处于竖屏方向。

***

### `Device.isLandscape: boolean`

当前设备是否处于横屏方向。

***

### `Device.isFlat: boolean`

设备是否平放（例如放在桌面上）。

该值通常基于设备姿态传感器，用于高级交互或方向判断。

***

## 外观与主题

### `Device.colorScheme: ColorScheme`

当前系统外观模式。

可能的值通常包括：

- `light`
- `dark`

可用于根据系统外观自动调整 UI 主题或样式。

***

## 电池信息

### `Device.batteryState`

当前电池状态：

```ts
"full" | "charging" | "unplugged" | "unknown"
```

说明：

- `full`：电池已充满
- `charging`：正在充电
- `unplugged`：未连接电源
- `unknown`：状态不可用

***

### `Device.batteryLevel: number`

当前电量百分比，取值范围：

- `0.0` \~ `1.0`
- 当电量不可用时，可能返回 `-1`

***

## 语言与地区设置

### `Device.systemLocale: string`

系统当前使用的 Locale，例如：

```text
"en_US"
```

***

### `Device.preferredLanguages: string[]`

用户偏好的语言列表（按优先级排序），例如：

```ts
["en-US", "zh-Hans-CN"]
```

推荐用于多语言内容选择。

***

### `Device.systemLocales: string[]` （已废弃）

用户偏好的 Locale 列表。

> 已废弃，请使用 `Device.preferredLanguages`。

***

### `Device.systemLanguageTag: string`

当前语言的 BCP-47 语言标签，例如：

```text
"en-US"
```

***

### `Device.systemLanguageCode: string`

当前语言代码，例如：

```text
"en"
```

***

### `Device.systemCountryCode: string | undefined`

当前国家 / 地区代码，例如：

```text
"US"
```

如果系统未设置国家信息，可能为 `undefined`。

***

### `Device.systemScriptCode: string | undefined`

当前语言的书写系统代码，例如：

```text
"Hans"   // zh_CN_Hans
```

常用于区分简体 / 繁体等书写系统。

***

## 唤醒锁（Wake Lock）

唤醒锁用于防止设备在脚本运行期间自动休眠。

### `Device.isWakeLockEnabled: Promise<boolean>`

获取当前是否启用了唤醒锁。

```ts
const enabled = await Device.isWakeLockEnabled
```

***

### `Device.setWakeLockEnabled(enabled: boolean): void`

启用或关闭唤醒锁。

```ts
Device.setWakeLockEnabled(true)
```

说明：

- 仅在 **Scripting App** 中可用
- 启用后可防止屏幕自动熄灭或设备进入休眠
- 建议在不需要时及时关闭，以节省电量

***

## 网络接口信息

### `Device.NetworkInterface`

网络接口对象结构：

```ts
type NetworkInterface = {
  address: string
  netmask: string | null
  family: 'IPv4' | 'IPv6'
  mac: string | null
  isInternal: boolean
  cidr: string | null
}
```

字段说明：

- `address`：IP 地址
- `netmask`：子网掩码
- `family`：地址类型（IPv4 / IPv6）
- `mac`：MAC 地址（部分系统可能为 null）
- `isInternal`：是否为内部接口（如回环接口）
- `cidr`：CIDR 表示法（如 `192.168.1.10/24`）

***

### `Device.networkInterfaces(): Record<string, NetworkInterface[]>`

获取设备当前的网络接口信息。

返回值结构：

```ts
{
  [interfaceName: string]: NetworkInterface[]
}
```

示例：

```ts
const interfaces = Device.networkInterfaces()

for (const name in interfaces) {
  for (const info of interfaces[name]) {
    console.log(name, info.address, info.family)
  }
}
```

常见用途：

- 获取本地 IP 地址
- 区分 Wi-Fi / 蜂窝网络 / 回环接口
- 网络调试与诊断
- 模拟 Node.js `os.networkInterfaces()` 行为

***

## 使用建议

- 语言与地区相关逻辑优先使用 `preferredLanguages`
- 唤醒锁应在任务完成后及时关闭
- 网络接口信息可能因系统权限或网络状态变化而不同
- 不要假设某个接口名称一定存在（如 `en0`）



---
url: /zh/guide/Device Capabilities/Device/index_example.md
---

# 示例

```tsx
import { Button, Device, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

 function Example() {
  const dismiss = Navigation.useDismiss()

  const details: {
    name: string
    value: string | boolean | number
  }[] = [
      {
        name: "Device.isiPhone",
        value: Device.isiPhone
      },
      {
        name: "Device.isiPad",
        value: Device.isiPad,
      },
      {
        name: "Device.systemVersion",
        value: Device.systemVersion,
      },
      {
        name: "Device.systemName",
        value: Device.systemName,
      },
      {
        name: "Device.isPortrait",
        value: Device.isPortrait,
      },
      {
        name: "Device.isLandscape",
        value: Device.isLandscape,
      },
      {
        name: "Device.isFlat",
        value: Device.isFlat,
      },
      {
        name: "Device.batteryLevel",
        value: Device.batteryLevel,
      },
      {
        name: "Device.batteryState",
        value: Device.batteryState,
      }
    ]

  return <NavigationStack>
    <List
      navigationTitle={"Device"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      {details.map(item =>
        <VStack
          badge={item.value.toString()}
          alignment={"leading"}
        >
          <Text font={"headline"}>{item.name}</Text>
          <Text font={"caption"}>{typeof item.value}</Text>
        </VStack>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/DocumentPicker.md
---

# 文档选择器

`DocumentPicker` 类为 iOS 的文档选择器提供接口，允许用户在 Files App 中选择文件或目录，或者将文件导出到 Files App。这对于需要访问用户文件、共享内容或将资源有序保存在指定目录中的脚本非常有用。

***

## 类型定义

### `PickFilesOption`

用于配置 `pickFiles` 文件选择功能的选项。

- **`initialDirectory`** (可选)
  - **类型**: `string`
  - **描述**: 指定文档选择器初次显示的目录。

- **`types`** (可选)
  - **类型**: `string[]`
  - **描述**: 要在文档选择器中显示的统一类型标识符（UTI）数组。更多信息可参考 [Uniform Type Identifiers](https://developer.apple.com/documentation/uniformtypeidentifiers/uttype-swift.struct)。

- **`shouldShowFileExtensions`** (可选)
  - **类型**: `boolean`
  - **描述**: 是否显示文件扩展名。默认为 `true`。

- **`allowsMultipleSelection`** (可选)
  - **类型**: `boolean`
  - **描述**: 是否允许选择多个文件。默认为 `false`。

***

### `ExportFilesOptions`

用于通过 `exportFiles` 导出文件的选项。

- **`initialDirectory`** (可选)
  - **类型**: `string`
  - **描述**: 指定文档选择器初次显示的目录。

- **`files`**
  - **类型**: `Array<{ data: Data; name: string }>`
  - **描述**: 要导出的文件数组。数组中的每个文件对象必须包含：
    - **`data`**: 文件的 `Data` 数据对象。
    - **`name`**: 文件名。

***

## 类方法

### `DocumentPicker.pickFiles(options?: PickFilesOption): Promise<string[]>`

允许用户从 Files App 中选择文件。

#### 参数

- **`options`** (可选): `PickFilesOption`
  - 用于文件选择的配置选项。

#### 返回值

- 一个 Promise，当用户完成选择后，返回文件路径数组（`string[]`）。

#### 示例

```typescript
async function run() {
  const imageFilePath = await DocumentPicker.pickFiles()
  if (imageFilePath != null) {
    // 处理用户选择的文件路径
  }
}
run()
```

***

### `DocumentPicker.pickDirectory(initialDirectory?: string): Promise<string | null>`

允许用户从 Files App 中选择一个目录。

#### 参数

- **`initialDirectory`** (可选): `string`
  - 文档选择器初次显示的目录。

#### 返回值

- 一个 Promise，解析后返回用户所选目录的路径（`string`），如果用户取消选择，则返回 `null`。

#### 示例

```typescript
const selectedDirectory = await DocumentPicker.pickDirectory()
if (selectedDirectory == null) {
  // 用户取消了选择
}
```

***

### `DocumentPicker.exportFiles(options: ExportFilesOptions): Promise<string[]>`

将文件导出到 Files App。

#### 参数

- **`options`**: `ExportFilesOptions`
  - 用于配置文件导出的选项，包括文件数据和文件名。

#### 返回值

- 一个 Promise，解析后返回导出的文件路径数组（`string[]`）。

#### 示例

```typescript
async function run() {
  const textContent = "Hello Scripting!"
  const result = await DocumentPicker.exportFiles({
    files: [
      {
        data: Data.fromString(textContent)!,
        name: 'greeting.txt',
      }
    ]
  });

  if (result.length > 0) {
    console.log('导出的文件: ', result)
  }
}
run()
```

***

### `DocumentPicker.stopAcessingSecurityScopedResources(): void`

放弃对安全范围资源（Security-Scoped Resources）的访问，例如通过文档选择器访问到的文件或目录。当不再需要访问这些资源时，请调用此方法以确保您的应用能够高效地管理资源。

```typescript
DocumentPicker.stopAcessingSecurityScopedResources()
```



---
url: /zh/guide/Device Capabilities/EventAlarm.md
---

# 事件闹钟

`EventAlarm` 用于为 **日历事件（CalendarEvent）** 和 **提醒事项（Reminder）** 设置提醒规则。
通过该类，开发者可以创建：

- 基于绝对时间触发的提醒
- 基于事件开始时间的相对提醒
- 基于地理围栏（Geofence）触发的提醒

此类为 Scripting Calendar/Reminder API 的基础能力，用于构建灵活的提醒行为。

***

## 一、创建 Alarm

### 1. `EventAlarm.fromAbsoluteDate(date: Date): EventAlarm`

创建一个基于绝对时间触发的提醒。

- 不依赖事件的开始时间
- 在系统时间到达指定时刻时触发

示例：

```ts
const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-01-01T09:00:00"))
```

***

### 2. `EventAlarm.fromRelativeOffset(offset: DurationInSeconds): EventAlarm`

创建一个以「事件开始时间」为基准的提醒。

`offset`（秒）含义如下：

- 负数：事件开始前触发
- 正数：事件开始后触发

示例（事件开始前 10 分钟提醒）：

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
```

***

## 二、属性说明

### 1. `absoluteDate: Date | null`

提醒的绝对触发时间。

行为规则：

- 如果为相对提醒设置 `absoluteDate`，提醒会自动转换为绝对提醒，同时 `relativeOffset` 会被清除。
- 如果为 `null`，表示提醒可能为相对提醒或位置提醒。

***

### 2. `relativeOffset: number`

事件开始时间的偏移量（秒）。

行为规则：

- 若为绝对提醒设置该属性，则提醒会转换为相对提醒，且 `absoluteDate` 会被置空。
- 相对提醒永远以 CalendarEvent 或 Reminder 的开始时间为基准。

示例：

```ts
alarm.relativeOffset = -300  // 提前 5 分钟触发
```

***

### 3. `structuredLocation: EventStructuredLocation | null`

位置提醒的触发地点。

`EventStructuredLocation` 包含：

- `title: string | null`：地点名称
- `geoLocation: LocationInfo | null`：经纬度位置
- `radius: number`：地理围栏触发半径（米）

示例：

```ts
alarm.structuredLocation = {
  title: "公司",
  geoLocation: { latitude: 37.332, longitude: -122.030 },
  radius: 100
}
```

***

### 4. `proximity: AlarmProximity`

位置提醒的触发方式。

支持的值：

| 值       | 含义         |
| ------- | ---------- |
| `none`  | 默认，不使用位置触发 |
| `enter` | 进入该地点范围时触发 |
| `leave` | 离开该地点范围时触发 |

示例：

```ts
alarm.proximity = AlarmProximity.enter
```

***

## 三、EventAlarm 在不同 API 中的使用方式

### 1. 在 CalendarEvent 中使用

```ts
const event = new CalendarEvent()
event.title = "会议"
event.startDate = ...
event.endDate = ...

const alarm = EventAlarm.fromRelativeOffset(-900)
event.addAlarm(alarm)

await event.save()
```

***

### 2. 在 Reminder 中使用

`Reminder` 与 `CalendarEvent` 均支持添加 `EventAlarm`：

```ts
const reminder = new Reminder()
reminder.title = "交电费"

const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-02-01T10:00:00"))
reminder.addAlarm(alarm)

await reminder.save()
```

位置提醒同样适用于 `Reminder`。

***

## 四、使用建议

1. **绝对提醒适合作为固定时间提醒**
   如生日、账单日等。

2. **相对提醒适用于基于事件开始时间的通知**
   如会议开始前十分钟提醒。

3. **地理围栏提醒适用于“到达某地时执行某事”**
   如到家提醒拿快递。

4. 使用位置提醒时，应确保用户授予定位权限。



---
url: /zh/guide/Device Capabilities/FontPicker.md
---

# FontPicker（字体选择器）

`FontPicker` 命名空间提供了在系统中选择字体的能力。
它会调用系统字体选择器，让用户从可用字体列表中选取字体，并返回所选字体的 **PostScript 名称**。

***

## 概述

在某些场景中（如自定义编辑器、文本渲染、样式设置等），需要用户选择字体。
`FontPicker` 提供了一个简洁的接口，可在脚本中异步调用系统字体选择器并获取结果。

***

## 方法

### `pickFont(): Promise<string | null>`

打开系统字体选择器，允许用户选择字体。
返回一个 Promise，当用户选择完成或取消时解析为结果。

**返回值：**

- `string`：所选字体的 **PostScript 名称**（例如 `"Helvetica-Bold"`、`"KaitiSC-Regular"` 等）。
- `null`：用户取消选择时返回。

***

## 示例

```ts
const fontPostscriptName = await FontPicker.pickFont()
if (fontPostscriptName == null) {
  // 用户取消了字体选择
  console.log("Font selection canceled")
} else {
  console.log("Selected font:", fontPostscriptName)
}
```

示例输出：

```
Selected font: HelveticaNeue-Bold
```

***

## 使用说明

- 返回的字体名称可直接用于需要指定字体的场景，如文本渲染或 UI 显示。
- 若用户取消选择，返回值为 `null`，调用方应当进行相应处理。
- 字体选择器展示的字体取决于系统中已安装的字体，包括系统预装与用户导入字体。

***

## 小结

| 方法           | 返回值                       | 说明                                    |
| ------------ | ------------------------- | ------------------------------------- |
| `pickFont()` | `Promise<string \| null>` | 打开系统字体选择器，返回字体的 PostScript 名称或 `null` |



---
url: /zh/guide/Device Capabilities/HapticFeedback.md
---

# 触觉反馈

```tsx
import { Button, List, Navigation, NavigationStack, Script, } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"HapticFeedback"}
    >
      <Button
        title={"HapticFeedback.vibrate"}
        action={() => {
          HapticFeedback.vibrate()
        }}
      />

      <Button
        title={"HapticFeedback.lightImpact"}
        action={() => {
          HapticFeedback.lightImpact()
        }}
      />

      <Button
        title={"HapticFeedback.mediumImpact"}
        action={() => {
          HapticFeedback.mediumImpact()
        }}
      />

      <Button
        title={"HapticFeedback.heavyImpact"}
        action={() => {
          HapticFeedback.heavyImpact()
        }}
      />

      <Button
        title={"HapticFeedback.softImpact"}
        action={() => {
          HapticFeedback.softImpact()
        }}
      />

      <Button
        title={"HapticFeedback.rigidImpact"}
        action={() => {
          HapticFeedback.rigidImpact()
        }}
      />

      <Button
        title={"HapticFeedback.selection"}
        action={() => {
          HapticFeedback.selection()
        }}
      />

      <Button
        title={"HapticFeedback.notificationSuccess"}
        action={() => {
          HapticFeedback.notificationSuccess()
        }}
      />

      <Button
        title={"HapticFeedback.notificationError"}
        action={() => {
          HapticFeedback.notificationError()
        }}
      />

      <Button
        title={"HapticFeedback.notificationWarning"}
        action={() => {
          HapticFeedback.notificationWarning()
        }}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/Health/HealthActivitySummary.md
---

# 健康活动摘要（HealthActivitySummary）

`HealthActivitySummary` 类用于访问用户每日健康活动的汇总数据，包括活跃能量消耗、锻炼时间、站立小时数等。该类支持不同的移动模式（如消耗能量或移动时间），可用于显示活动圆环的进度或生成自定义的健康日报表。

***

## 使用场景

- 展示每日 Apple 活动圆环（移动、锻炼、站立）进度
- 比较用户每日活动与其设定的目标
- 构建自定义健康看板或健身追踪 UI
- 提供趋势分析或活动达成提醒功能

***

## 类：`HealthActivitySummary`

### 属性

| 属性名                | 类型                       | 描述                                                                  |
| ------------------ | ------------------------ | ------------------------------------------------------------------- |
| `dateComponents`   | `DateComponents`         | 当前活动摘要所对应的日期信息。                                                     |
| `activityMoveMode` | `HealthActivityMoveMode` | 表示该摘要使用的移动模式，可能为 `activeEnergy`（活跃能量）或 `appleMoveTime`（Apple 移动时间）。 |

***

### 方法

以下方法都返回指定单位下的数值（`HealthUnit`），表示当前日期的实际数据或目标值：

#### `activeEnergyBurned(unit: HealthUnit): number`

返回当天的活跃能量消耗（例如千卡），适用于 `activeEnergy` 移动模式。

#### `activeEnergyBurnedGoal(unit: HealthUnit): number`

返回当天的活跃能量目标值（例如千卡），仅在 `activityMoveMode` 为 `activeEnergy` 时有效。

***

#### `appleMoveTime(unit: HealthUnit): number`

返回 Apple Watch 记录的当天移动时间（单位通常为分钟），适用于 `appleMoveTime` 移动模式。

#### `appleMoveTimeGoal(unit: HealthUnit): number`

返回当天的移动时间目标，仅在 `activityMoveMode` 为 `appleMoveTime` 时有效。

***

#### `appleExerciseTime(unit: HealthUnit): number`

返回当天的锻炼时间总长，通常以分钟为单位。

#### `appleExerciseTimeGoal(unit: HealthUnit): number`

返回当天的锻炼时间目标。

***

#### `appleStandHours(unit: HealthUnit): number`

返回当天站立小时数（即每小时至少活动1分钟的小时数）。

#### `appleStandHoursGoal(unit: HealthUnit): number`

返回当天的站立目标小时数（通常为12小时）。

***

## 示例用法

```ts
async function showTodaySummary() {
  const startDate = new Date()
  startDate.setHours(0, 0, 0, 0)

  const start = DateComponents.fromDate(startDate)
  const end = DateComponents.fromDate(startDate)
  end.date += 1

  const summaries = await Health.queryActivitySummaries({
    start, // today
    end,
  })

  if (summaries.length === 0) {
    console.log('今天暂无活动摘要')
    return
  }

  const summary = summaries[0]

  console.log('日期:', summary.dateComponents)
  console.log('移动模式:', summary.activityMoveMode)

  const kcal = summary.activeEnergyBurned(HealthUnit.kilocalorie())
  const kcalGoal = summary.activeEnergyBurnedGoal(HealthUnit.kilocalorie())

  console.log(`活跃能量消耗: ${kcal} / ${kcalGoal} 千卡`)
  console.log(`锻炼时间: ${summary.appleExerciseTime(HealthUnit.minute())} 分钟`)
  console.log(`站立小时数: ${summary.appleStandHours(HealthUnit.count())} 小时`)
}
```

***

## 注意事项

- `HealthActivitySummary` 表示单日的活动摘要，若需趋势分析需查询多个摘要。
- 不同用户可能启用了不同的移动目标模式：基于能量或移动时间。
- `HealthUnit` 必须匹配目标字段类型。例如时间应使用 `minute()` 或 `second()`，计数使用 `count()`。
- 可搭配 `Health.queryActivitySummaries()` 方法查询指定日期范围内的摘要数组。



---
url: /zh/guide/Device Capabilities/Health/HealthCategorySample.md
---

# 健康分类数据（HealthCategorySample）

`HealthCategorySample` 表示一条基于分类的健康事件记录，例如睡眠分析、月经流量、排卵测试结果等。每条样本通常具有一个时间区间以及一个类别值，适用于记录健康相关事件的状态或发生情况。

***

## 适用场景

- 记录用户在某段时间内发生的健康事件（如睡觉、排卵、饮酒等）
- 存储和显示事件类型及其状态
- 手动添加健康事件数据
- 跟踪时间段型的健康行为

***

## 属性说明

| 属性名            | 类型                            | 说明                                           |
| -------------- | ----------------------------- | -------------------------------------------- |
| `uuid`         | `string`                      | 唯一标识该健康样本的 UUID。                             |
| `categoryType` | `HealthCategoryType`          | 样本的分类类型，例如 `sleepAnalysis`、`sexualActivity`。 |
| `startDate`    | `Date`                        | 事件开始时间。                                      |
| `endDate`      | `Date`                        | 事件结束时间。                                      |
| `value`        | `number`                      | 分类值，使用相应的 `HealthCategoryValue*` 枚举类型。       |
| `metadata`     | `Record<string, any> \| null` | 可选的元数据，可包含事件来源、自定义标签等。                       |

***

## 方法说明

### `static create(options): HealthCategorySample | null`

创建一条新的 `HealthCategorySample` 健康分类样本。

#### 参数说明

```ts
{
  type: HealthCategoryType               // 分类类型，例如 'sleepAnalysis'
  startDate: Date                        // 事件起始时间
  endDate: Date                          // 事件结束时间
  value: HealthCategoryValueXxx          // 分类值，根据类型不同需传入不同枚举
  metadata?: Record<string, any> | null  // 可选元数据
}
```

#### 返回值

- 创建成功时返回一个 `HealthCategorySample` 实例；
- 如果参数无效（例如类型与值不匹配），返回 `null`。

***

## 使用示例

### 示例 1：创建一条睡眠记录

```ts
const sample = HealthCategorySample.create({
  type: 'sleepAnalysis',
  startDate: new Date('2025-07-01T23:00:00'),
  endDate: new Date('2025-07-02T06:00:00'),
  value: HealthCategoryValueSleepAnalysis.asleep,
  metadata: { source: 'manual entry' }
})

if (sample) {
  console.log(`已创建睡眠样本：从 ${sample.startDate} 到 ${sample.endDate}`)
}
```

***

### 示例 2：记录一次性行为事件

```ts
const event = HealthCategorySample.create({
  type: 'sexualActivity',
  startDate: new Date('2025-07-03T22:30:00'),
  endDate: new Date('2025-07-03T22:40:00'),
  value: HealthCategoryValuePresence.present
})
```

***

### 示例 3：记录一次排卵测试结果

```ts
const result = HealthCategorySample.create({
  type: 'ovulationTestResult',
  startDate: new Date('2025-07-05T08:00:00'),
  endDate: new Date('2025-07-05T08:05:00'),
  value: HealthCategoryValueOvulationTestResult.positive
})
```

***

## 值的使用说明

`value` 参数必须使用对应类型的枚举值，示例如下：

| 类型 (`type`)                       | 所需枚举类型                                               |
| --------------------------------- | ---------------------------------------------------- |
| `sleepAnalysis`                   | `HealthCategoryValueSleepAnalysis`                   |
| `sexualActivity`                  | `HealthCategoryValuePresence`                        |
| `menstrualFlow`                   | `HealthCategoryValueSeverity`                        |
| `ovulationTestResult`             | `HealthCategoryValueOvulationTestResult`             |
| `appleStandHour`                  | `HealthCategoryValueAppleStandHour`                  |
| `environmentalAudioExposureEvent` | `HealthCategoryValueEnvironmentalAudioExposureEvent` |

如果类型与值不匹配，将导致创建失败返回 `null`。

***

## 常见使用场景

| 类型                    | 值枚举类型                                    | 示例用途      |
| --------------------- | ---------------------------------------- | --------- |
| `sleepAnalysis`       | `HealthCategoryValueSleepAnalysis`       | 睡眠记录      |
| `sexualActivity`      | `HealthCategoryValuePresence`            | 性行为记录     |
| `menstrualFlow`       | `HealthCategoryValueSeverity`            | 月经记录      |
| `pregnancyTestResult` | `HealthCategoryValuePregnancyTestResult` | 排卵或怀孕测试结果 |
| `appleStandHour`      | `HealthCategoryValueAppleStandHour`      | 久坐提醒记录    |

***

## 相关方法

- `Health.queryCategorySamples()`：用于查询分类健康样本的 API。
- `HealthCategoryType`：定义所有支持的分类类型。
- `HealthCategoryValue*`：不同类型的分类值枚举定义。



---
url: /zh/guide/Device Capabilities/Health/HealthCategoryType.md
---

# 健康分类数据（HealthCategoryType）

`HealthCategoryType` 用于表示离散型的健康状态或事件。它们通常为“是否发生”的记录（如：是否怀孕、是否进行正念训练、是否存在某种症状），适用于症状追踪、睡眠分析、生殖健康记录、环境暴露监测等场景。

***

## 1. Apple 系统事件与健康警示

| 标识符                               | 用途说明                     |
| --------------------------------- | ------------------------ |
| `appleStandHour`                  | 是否在当前小时内站立过（Apple Watch） |
| `environmentalAudioExposureEvent` | 环境噪音过高事件（例如超过 80 分贝）     |
| `headphoneAudioExposureEvent`     | 耳机音量暴露过高事件               |
| `highHeartRateEvent`              | 静息状态下心率异常升高              |
| `lowHeartRateEvent`               | 心率低于正常值                  |
| `irregularHeartRhythmEvent`       | 心律不齐检测（如房颤）              |
| `lowCardioFitnessEvent`           | 心肺适能过低事件                 |
| `appleWalkingSteadinessEvent`     | 步态稳定性过低，可能存在跌倒风险         |

***

## 2. 正念与健康行为记录

| 标识符                  | 用途说明                     |
| -------------------- | ------------------------ |
| `mindfulSession`     | 正念冥想记录                   |
| `handwashingEvent`   | 洗手行为记录（Apple Watch 自动识别） |
| `toothbrushingEvent` | 刷牙行为记录（如连接智能牙刷）          |

***

## 3. 生殖与月经周期健康

| 标识符                                | 用途说明            |
| ---------------------------------- | --------------- |
| `menstrualFlow`                    | 经期流量记录          |
| `intermenstrualBleeding`           | 经期之间的异常出血       |
| `prolongedMenstrualPeriods`        | 经期持续时间异常延长      |
| `infrequentMenstrualCycles`        | 经期频率过低          |
| `irregularMenstrualCycles`         | 经期时间不规律         |
| `persistentIntermenstrualBleeding` | 经间出血持续时间过长      |
| `bleedingDuringPregnancy`          | 怀孕期间出血          |
| `bleedingAfterPregnancy`           | 分娩后出血           |
| `pregnancy`                        | 是否怀孕            |
| `lactation`                        | 是否哺乳/泌乳         |
| `sexualActivity`                   | 性行为记录           |
| `ovulationTestResult`              | 排卵测试结果（阳性/阴性）   |
| `pregnancyTestResult`              | 验孕测试结果          |
| `progesteroneTestResult`           | 孕酮水平检测结果        |
| `contraceptive`                    | 使用的避孕方式         |
| `cervicalMucusQuality`             | 宫颈黏液质地（用于排卵期追踪） |

***

## 4. 睡眠与呼吸相关事件

| 标识符               | 用途说明               |
| ----------------- | ------------------ |
| `sleepAnalysis`   | 睡眠阶段记录（如：在床、入睡、清醒） |
| `sleepApneaEvent` | 睡眠呼吸暂停事件           |

***

## 5. 症状与身体状况

| 标识符                                  | 用途说明        |
| ------------------------------------ | ----------- |
| `abdominalCramps`                    | 腹部或经期腹痛     |
| `acne`                               | 青春痘严重程度     |
| `appetiteChanges`                    | 食欲变化（增加或减少） |
| `bladderIncontinence`                | 尿失禁         |
| `bloating`                           | 腹胀感         |
| `breastPain`                         | 乳房疼痛或不适     |
| `chestTightnessOrPain`               | 胸口紧绷或疼痛     |
| `chills`                             | 发冷、寒颤       |
| `constipation`                       | 便秘          |
| `coughing`                           | 咳嗽          |
| `diarrhea`                           | 腹泻          |
| `dizziness`                          | 头晕          |
| `drySkin`                            | 皮肤干燥        |
| `fainting`                           | 昏厥          |
| `fatigue`                            | 疲惫、乏力       |
| `fever`                              | 发烧          |
| `generalizedBodyAche`                | 全身酸痛        |
| `hairLoss`                           | 脱发          |
| `headache`                           | 头痛          |
| `heartburn`                          | 胃灼热、胃酸倒流    |
| `hotFlashes`                         | 潮热（如更年期症状）  |
| `lossOfSmell`                        | 嗅觉丧失        |
| `lossOfTaste`                        | 味觉丧失        |
| `lowerBackPain`                      | 下背部疼痛       |
| `memoryLapse`                        | 记忆模糊、短暂性遗忘  |
| `moodChanges`                        | 情绪波动        |
| `nausea`                             | 恶心感         |
| `nightSweats`                        | 夜间出汗        |
| `pelvicPain`                         | 骨盆区域疼痛      |
| `rapidPoundingOrFlutteringHeartbeat` | 心悸、心跳过快     |
| `runnyNose`                          | 流鼻涕         |
| `shortnessOfBreath`                  | 呼吸困难        |
| `sinusCongestion`                    | 鼻窦阻塞        |
| `skippedHeartbeat`                   | 心跳中断或跳拍     |
| `sleepChanges`                       | 睡眠质量或习惯变化   |
| `soreThroat`                         | 喉咙痛         |
| `vaginalDryness`                     | 阴道干涩        |
| `vomiting`                           | 呕吐          |
| `wheezing`                           | 呼吸时发出喘鸣声    |

***

## 应用场景举例

- **生殖健康应用**：可使用如 `menstrualFlow`、`ovulationTestResult`、`pregnancy`、`lactation` 等类型追踪月经、排卵、孕期及哺乳情况。
- **日常行为与习惯追踪**：通过 `mindfulSession`、`handwashingEvent`、`toothbrushingEvent` 引导用户建立良好生活习惯。
- **睡眠与心率监测**：结合 `sleepAnalysis`、`sleepApneaEvent` 与心律相关类型，为用户提供全面夜间与心血管健康评估。
- **症状记录与疾病管理**：适用于日记类、康复类 App，记录如 `fatigue`、`nausea`、`fever` 等症状，便于观察病情趋势。

***

## 示例：写入睡眠阶段记录

```ts
const sample = HealthCategorySample.create({
  type: "sleepAnalysis",
  startDate: new Date("2025-07-03T22:30:00"),
  endDate: new Date("2025-07-04T06:30:00"),
  value: HealthCategoryValueSleepAnalysis.asleepDeep
})

await Health.saveCategorySample(sample)
```

***

## 示例：查询冥想记录

```ts
const results = await Health.queryCategorySamples({
  type: "mindfulSession",
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-05")
})

for (const session of results) {
  console.log("开始：", session.startDate)
  console.log("结束：", session.endDate)
}
```

***

## 注意事项

- `value` 值必须使用与类型匹配的枚举类型，否则 `create()` 会返回 `null`。
- `endDate` 必须大于 `startDate`，即事件需持续至少 1 秒。
- 分类样本适合用于表示有状态变化或事件发生的健康记录。



---
url: /zh/guide/Device Capabilities/Health/HealthCategoryValue Types.md
---

# 健康分类值类型（HealthCategoryValue）

本文档列出了 `HealthCategorySample.create()` 及相关 API 中支持的所有 `HealthCategoryValue` 枚举类型。每个枚举值用于表示特定 `HealthCategoryType` 的分类结果。

***

## 1. `HealthCategoryValuePresence`

**适用类型：**

- `mindfulSession`（正念训练）
- `intermenstrualBleeding`（经间出血）
- `sexualActivity`（性行为）
- `pregnancy`（怀孕）
- `lactation`（哺乳）

**说明：** 用于表示事件是否发生。

| 值            | 含义    |
| ------------ | ----- |
| `present`    | 事件已发生 |
| `notPresent` | 事件未发生 |

***

## 2. `HealthCategoryValueSeverity`

**适用类型：**

- `menstrualFlow`（月经流量）
- `acneSeverity`（痤疮严重程度）
- `hairLossSeverity`（脱发严重程度）
- `abdominalCramps`（腹痛）
- `headache`（头痛）
- `nausea`（恶心）

**说明：** 表示症状的严重程度。

| 值             | 含义   |
| ------------- | ---- |
| `unspecified` | 未指定  |
| `notPresent`  | 无此症状 |
| `mild`        | 轻度   |
| `moderate`    | 中度   |
| `severe`      | 重度   |

***

## 3. `HealthCategoryValueSleepAnalysis`

**适用类型：**

- `sleepAnalysis`（睡眠分析）

**说明：** 描述某时间段内的睡眠状态。

| 值                   | 含义          |
| ------------------- | ----------- |
| `inBed`             | 在床上（不一定在睡觉） |
| `asleepUnspecified` | 睡着（阶段未知）    |
| `awake`             | 醒着          |
| `asleepCore`        | 核心睡眠        |
| `asleepDeep`        | 深度睡眠        |
| `asleepREM`         | 快速眼动睡眠      |

***

## 4. `HealthCategoryValueOvulationTestResult`

**适用类型：**

- `ovulationTestResult`（排卵测试）

| 值                         | 含义           |
| ------------------------- | ------------ |
| `negative`                | 未检测到 LH 激增   |
| `luteinizingHormoneSurge` | LH 激增，可能即将排卵 |
| `indeterminate`           | 结果不明确        |
| `estrogenSurge`           | 检测到雌激素激增     |

***

## 5. `HealthCategoryValuePregnancyTestResult`

**适用类型：**

- `pregnancyTestResult`（怀孕测试）

| 值               | 含义    |
| --------------- | ----- |
| `negative`      | 阴性    |
| `positive`      | 阳性    |
| `indeterminate` | 结果不明确 |

***

## 6. `HealthCategoryValueProgesteroneTestResult`

**适用类型：**

- `progesteroneTestResult`（孕酮测试）

| 值               | 含义    |
| --------------- | ----- |
| `negative`      | 阴性    |
| `positive`      | 阳性    |
| `indeterminate` | 结果不明确 |

***

## 7. `HealthCategoryValueCervicalMucusQuality`

**适用类型：**

- `cervicalMucusQuality`（宫颈黏液质量）

| 值          | 含义  |
| ---------- | --- |
| `dry`      | 干燥  |
| `sticky`   | 黏稠  |
| `creamy`   | 乳霜状 |
| `watery`   | 水样  |
| `eggWhite` | 蛋清状 |

***

## 8. `HealthCategoryValueContraceptive`

**适用类型：**

- `contraceptive`（避孕方式）

| 值                    | 含义         |
| -------------------- | ---------- |
| `unspecified`        | 未指定        |
| `implant`            | 植入型避孕棒     |
| `injection`          | 注射型避孕      |
| `intrauterineDevice` | 宫内节育器（IUD） |
| `intravaginalRing`   | 阴道环        |
| `oral`               | 口服避孕药      |
| `patch`              | 皮肤贴片       |

***

## 9. `HealthCategoryValueVaginalBleeding`（仅 iOS 18 及以上支持）

**适用类型：**

- `vaginalBleeding`（阴道出血）

| 值             | 含义   |
| ------------- | ---- |
| `unspecified` | 未指定  |
| `light`       | 轻度出血 |
| `medium`      | 中度出血 |
| `heavy`       | 重度出血 |
| `none`        | 无出血  |

***

## 10. `HealthCategoryValueAppetiteChanges`

**适用类型：**

- `appetiteChanges`（食欲变化）

| 值             | 含义   |
| ------------- | ---- |
| `unspecified` | 未指定  |
| `noChange`    | 无变化  |
| `decreased`   | 食欲减退 |
| `increased`   | 食欲增加 |

***

## 11. `HealthCategoryValueAppleStandHour`

**适用类型：**

- `appleStandHour`（Apple 久坐提醒）

| 值       | 含义       |
| ------- | -------- |
| `stood` | 用户起身活动过  |
| `idle`  | 用户一直保持静止 |

***

## 12. `HealthCategoryValueAppleWalkingSteadinessEvent`

**适用类型：**

- `appleWalkingSteadinessEvent`（步态稳定性事件）

| 值                | 含义         |
| ---------------- | ---------- |
| `initialLow`     | 初次检测到低稳定性  |
| `initialVeryLow` | 初次检测到极低稳定性 |
| `repeatLow`      | 重复检测到低稳定性  |
| `repeatVeryLow`  | 重复检测到极低稳定性 |

***

## 13. `HealthCategoryValueEnvironmentalAudioExposureEvent`

**适用类型：**

- `environmentalAudioExposureEvent`（环境音暴露事件）

| 值                | 含义       |
| ---------------- | -------- |
| `momentaryLimit` | 瞬间超过暴露限制 |

***

## 14. `HealthCategoryValueHeadphoneAudioExposureEvent`

**适用类型：**

- `headphoneAudioExposureEvent`（耳机音量暴露事件）

| 值               | 含义              |
| --------------- | --------------- |
| `sevenDayLimit` | 超过推荐的 7 天音量暴露上限 |

***

## 15. `HealthCategoryValueLowCardioFitnessEvent`

**适用类型：**

- `lowCardioFitnessEvent`（心肺适能不足事件）

| 值            | 含义           |
| ------------ | ------------ |
| `lowFitness` | 检测到较低的心肺适能水平 |

***

## 使用示例

```ts
const sample = HealthCategorySample.create({
  type: "menstrualFlow",
  startDate: new Date("2025-07-03T10:00:00"),
  endDate: new Date("2025-07-03T12:00:00"),
  value: HealthCategoryValueSeverity.moderate
})

await Health.saveCategorySample(sample)
```

***

## 注意事项

- `value` 的值必须与 `type` 对应的枚举类型一致，类型不符会导致错误。
- 请确保已获得 HealthKit 权限后再调用读取或保存方法。
- 所有枚举值最终会映射为 Apple HealthKit 的 `HKCategoryValue` 存储。



---
url: /zh/guide/Device Capabilities/Health/HealthCharacteristicType.md
---

# 健康特征类型（HealthCharacteristicType）

本文档介绍与 HealthKit 中“个人健康档案”及“活动摘要”相关的枚举类型，主要用于获取或表示用户的静态健康特征信息（如性别、血型、皮肤类型、轮椅使用情况）以及运动模式设定。

***

## 1. `HealthBiologicalSex`

表示用户的生物性别（Biological Sex）。

| 枚举值      | 描述   |
| -------- | ---- |
| `notSet` | 未设置  |
| `female` | 女性   |
| `male`   | 男性   |
| `other`  | 其他性别 |

***

## 2. `HealthBloodType`

表示用户的血型信息。

| 枚举值          | 描述         |
| ------------ | ---------- |
| `notSet`     | 未设置        |
| `aPositive`  | A 型 Rh 阳性  |
| `aNegative`  | A 型 Rh 阴性  |
| `bPositive`  | B 型 Rh 阳性  |
| `bNegative`  | B 型 Rh 阴性  |
| `abPositive` | AB 型 Rh 阳性 |
| `abNegative` | AB 型 Rh 阴性 |
| `oPositive`  | O 型 Rh 阳性  |
| `oNegative`  | O 型 Rh 阴性  |

***

## 3. `HealthFitzpatrickSkinType`

表示 Fitzpatrick 皮肤类型，用于评估个体对阳光暴露的反应。

| 枚举值      | 类型     | 描述              |
| -------- | ------ | --------------- |
| `notSet` | 未设置    | 无皮肤类型信息         |
| `I`      | 类型 I   | 非常白皙，极易晒伤，几乎不晒黑 |
| `II`     | 类型 II  | 白皙，容易晒伤，难以晒黑    |
| `III`    | 类型 III | 中等肤色，有时晒伤，逐渐晒黑  |
| `IV`     | 类型 IV  | 深肤色，罕见晒伤，容易晒黑   |
| `V`      | 类型 V   | 深棕色皮肤，很少晒伤，晒黑明显 |
| `VI`     | 类型 VI  | 深黑色皮肤，从不晒伤      |

***

## 4. `HealthWheelchairUse`

表示用户是否使用轮椅。

| 枚举值      | 描述    |
| -------- | ----- |
| `notSet` | 未设置   |
| `no`     | 不使用轮椅 |
| `yes`    | 使用轮椅  |

***

## 5. `HealthActivityMoveMode`

表示用户 Apple 健康活动摘要的“移动环”目标计算模式。

| 枚举值             | 描述                   |
| --------------- | -------------------- |
| `activeEnergy`  | 传统模式：根据“主动消耗的卡路里”计算  |
| `appleMoveTime` | 时间模式：根据“活动时间”计算目标完成度 |

***

## 示例代码

```ts
// 获取用户是否使用轮椅
const wheelchair = await Health.wheelchairUse()
if (wheelchair === HealthWheelchairUse.yes) {
  console.log("用户使用轮椅")
}

// 获取用户皮肤类型
const skinType = await Health.fitzpatrickSkinType()
switch (skinType) {
  case HealthFitzpatrickSkinType.III:
    console.log("中等肤色，逐渐晒黑")
    break
}

// 获取用户活动模式
const mode = await Health.activityMoveMode()
if (mode === HealthActivityMoveMode.appleMoveTime) {
  console.log("用户使用 Apple Move Time 模式")
}
```



---
url: /zh/guide/Device Capabilities/Health/HealthCorrelation.md
---

# 健康关联数据（HealthCorrelation）

`HealthCorrelation` 类表示一组彼此相关的健康样本。它提供接口用于访问和创建健康关联记录，这些记录将多个健康数据类型组合成一个整体，例如将饮食摄入与血压读数关联，或将排卵测试结果与月经流量数据相关联。

***

## 适用场景

- 将血压的收缩压和舒张压值组合为一条记录
- 将食物摄入与营养成分相关联
- 将多个月经追踪事件合并为一个周期相关事件

***

## 属性说明

| 属性名                         | 类型                                                                                                                   | 描述                                     |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| `uuid`                      | `string`                                                                                                             | 该关联样本的唯一标识符。                           |
| `correlationType`           | `HealthCorrelationType`                                                                                              | 关联的类型，例如 `"bloodPressure"` 或 `"food"`。 |
| `startDate`                 | `Date`                                                                                                               | 该关联事件的起始时间。                            |
| `endDate`                   | `Date`                                                                                                               | 该关联事件的结束时间。                            |
| `metadata`                  | `Record<string, any> \| null`                                                                                        | 可选元数据，例如用户的注释。                         |
| `samples`                   | `(HealthQuantitySample \| HealthCumulativeQuantitySample \| HealthDiscreteQuantitySample \| HealthCategorySample)[]` | 此关联包含的所有健康样本。                          |
| `quantitySamples`           | `HealthQuantitySample[]`                                                                                             | 所有基于数量类型的样本（包含累积和离散类型）。                |
| `cumulativeQuantitySamples` | `HealthCumulativeQuantitySample[]`                                                                                   | 仅包含累积数量样本。                             |
| `discreteQuantitySamples`   | `HealthDiscreteQuantitySample[]`                                                                                     | 仅包含离散数量样本。                             |
| `categorySamples`           | `HealthCategorySample[]`                                                                                             | 所有基于类别的健康样本。                           |

***

## 静态方法

### `HealthCorrelation.create(options): HealthCorrelation | null`

创建一个新的健康数据关联。

#### 参数

| 参数名         | 类型                                                 | 是否必填 | 描述                                        |
| ----------- | -------------------------------------------------- | ---- | ----------------------------------------- |
| `type`      | `HealthCorrelationType`                            | 是    | 要创建的关联类型，例如 `"bloodPressure"` 或 `"food"`。 |
| `startDate` | `Date`                                             | 是    | 关联的开始时间。                                  |
| `endDate`   | `Date`                                             | 是    | 关联的结束时间。                                  |
| `metadata`  | `Record<string, any> \| null`                      | 否    | 可选元数据，例如附加说明或标记。                          |
| `objects`   | `(HealthQuantitySample \| HealthCategorySample)[]` | 是    | 要包含在该关联中的健康样本。                            |

#### 返回值

- 如果参数合法，返回新的 `HealthCorrelation` 实例；
- 如果类型与样本不兼容或参数无效，则返回 `null`。

***

## 使用示例

### 示例 1：创建一条血压关联记录

```ts
const systolic = HealthQuantitySample.create({
  type: "bloodPressureSystolic",
  startDate: new Date("2025-07-04T08:00:00"),
  endDate: new Date("2025-07-04T08:01:00"),
  value: 120,
  unit: HealthUnit.millimeterOfMercury()
})

const diastolic = HealthQuantitySample.create({
  type: "bloodPressureDiastolic",
  startDate: new Date("2025-07-04T08:00:00"),
  endDate: new Date("2025-07-04T08:01:00"),
  value: 80,
  unit: HealthUnit.millimeterOfMercury()
})

const correlation = HealthCorrelation.create({
  type: "bloodPressure",
  startDate: systolic.startDate,
  endDate: systolic.endDate,
  objects: [systolic, diastolic]
})

if (correlation) {
  // 保存记录...
}
```

***

### 示例 2：遍历关联中的样本

```ts
for (const sample of correlation.quantitySamples) {
  const value = sample.quantityValue(HealthUnit.millimeterOfMercury())
  console.log(`${sample.quantityType}: ${value}`)
}
```

***

## 注意事项

- `objects` 参数中的样本类型必须符合该关联类型所支持的数据类型。
- 当前支持的关联类型包括 `"bloodPressure"` 和 `"food"`。
- 使用此类可以在视图中更完整地展示一次健康事件的相关信息，或用于分析多个数据之间的关系。



---
url: /zh/guide/Device Capabilities/Health/HealthHeartbeatSeriesSample.md
---

# 健康心跳序列数据（HealthHeartbeatSeriesSample）

`HealthHeartbeatSeriesSample` 类用于访问 **心跳序列样本（heartbeat series samples）**，它表示一段时间内记录的一系列心跳间隔（RR 间期），通常用于分析心律，识别心律不齐等情况。

该类的实例由公共接口 `Health.queryHeartbeatSeriesSamples()` 返回。

***

## 使用场景

- **监测运动过程中的心律变化**
- **识别异常心律（如房颤）**
- **记录休息或睡眠期间的心跳模式**
- **生成健康数据分析与研究报告**

***

## 类：`HealthHeartbeatSeriesSample`

### 属性说明

| 属性名          | 类型                            | 描述                                           |
| ------------ | ----------------------------- | -------------------------------------------- |
| `uuid`       | `string`                      | 此样本的唯一标识符                                    |
| `sampleType` | `string`                      | 样本类型，通常为 `"HKHeartbeatSeriesTypeIdentifier"` |
| `startDate`  | `Date`                        | 该系列数据的开始时间                                   |
| `endDate`    | `Date`                        | 该系列数据的结束时间                                   |
| `count`      | `number`                      | 序列中包含的心跳次数（即 RR 间期数量）                        |
| `metadata`   | `Record<string, any> \| null` | 可选的元数据，如记录设备、来源信息等                           |

> 注意：目前此类不暴露具体的 RR 间期数据，仅表示整体序列信息。

***

## 方法：`Health.queryHeartbeatSeriesSamples(options?)`

### 方法定义

```ts
function queryHeartbeatSeriesSamples(
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "count"
      order?: "forward" | "reverse"
    }>
    requestPermissions?: HealthQuantityType[]
  }
): Promise<HealthHeartbeatSeriesSample[]>
```

### 参数说明

- `startDate` _(可选)_：筛选起始时间之后的样本
- `endDate` _(可选)_：筛选截止时间之前的样本
- `limit` _(可选)_：最多返回的样本数量
- `strictStartDate` _(可选)_：是否仅返回开始时间等于 `startDate` 的样本
- `strictEndDate` _(可选)_：是否仅返回结束时间等于 `endDate` 的样本
- `sortDescriptors` _(可选)_：设置排序字段，如 `startDate`、`endDate` 或 `count`，可指定顺序为 `"forward"` 或 `"reverse"`
- `requestPermissions`: _(可选)_`: 设置需要请求授权的数据类型，默认只请求了 `heartbeat`, `heartRateVariabilitySDNN`and`heartRate\` 等类型，如果需要访问更新相关数据必须要设置对应数据的类型授权

### 返回值

一个 Promise 对象，解析为 `HealthHeartbeatSeriesSample` 实例数组，结果按指定排序返回。

***

## 使用示例

```ts
async function fetchHeartbeatSeries() {
  const samples = await Health.queryHeartbeatSeriesSamples({
    startDate: new Date('2024-01-01'),
    endDate: new Date(),
    sortDescriptors: [
      { key: 'startDate', order: 'reverse' }
    ],
    limit: 5,
  })

  for (const sample of samples) {
    console.log('UUID:', sample.uuid)
    console.log('开始时间:', sample.startDate)
    console.log('结束时间:', sample.endDate)
    console.log('心跳次数:', sample.count)
    console.log('元数据:', sample.metadata)
  }
}
```

***

## 注意事项

- 如果用户未授权读取心跳序列数据，将返回空数组。
- 心跳序列通常由 Apple Watch 等设备记录，表示某段时间内的连续心跳间隔数据。



---
url: /zh/guide/Device Capabilities/Health/HealthKit Permission Behavior.md
---

# HealthKit 权限行为

在使用 Scripting 提供的 Health 模块访问 iOS 健康数据时，开发者需要了解 iOS HealthKit 特有的授权机制，以及 Scripting API 的行为设计。本说明文档将帮助你正确处理无权限时的情况，并提供开发建议。

***

## iOS HealthKit 授权机制特性

1. **无法主动查询授权状态**
   iOS 不提供 API 用于判断某个健康数据类型是否已授权或被拒绝。授权状态不可直接获知。

2. **授权弹窗仅在首次请求时弹出**
   系统只会在数据类型的授权状态为 `notDetermined` 时自动弹出授权弹窗。一旦用户做出决定（允许或拒绝），后续请求不会再次触发弹窗。

3. **无权限不会返回系统错误**
   如果请求了未被授权的数据，HealthKit 不会抛出错误。部分接口会返回空数据，部分接口则通过 `Promise.reject` 报错。

***

## Scripting 中的权限处理逻辑

### 自动请求权限

当你调用任意需要健康数据权限的方法时，Scripting 会根据接口涉及的数据类型，自动触发系统授权弹窗（如果该类型尚未请求过权限）。

例如：

```ts
await Health.dateOfBirth()
await Health.bloodType()
await Health.queryQuantitySamples("stepCount", { startDate: ..., endDate: ... })
```

***

## 不同方法的行为对比

| 方法                              | 无权限时行为     | 是否触发 `Promise.reject` |
| ------------------------------- | ---------- | --------------------- |
| `Health.queryQuantitySamples()` | 返回空数组 `[]` | 否                     |
| `Health.queryCategorySamples()` | 返回空数组 `[]` | 否                     |
| `Health.dateOfBirth()`          | 无返回值       | 是                     |
| `Health.bloodType()` 等档案方法      | 无返回值       | 是                     |

***

## 示例代码

### 示例 1：读取样本数据（无权限返回空数组）

```ts
const samples = await Health.queryQuantitySamples('stepCount')

if (samples.length === 0) {
  console.log("未返回步数数据，可能未授权或无记录")
}
```

### 示例 2：读取用户档案（无权限时 Promise 会 reject）

```ts
try {
  const dob = await Health.dateOfBirth()
  console.log(`出生日期：${dob.year}-${dob.month}-${dob.day}`)
} catch (err) {
  console.warn("未能读取出生日期，用户可能未授权")
}
```

***

## 多接口同时调用时的权限合并

当你同时调用多个需要健康权限的方法（例如通过 `Promise.all()`），Scripting 会自动合并这些接口所需的权限，并在**同一个系统弹窗中**请求授权。这样可以避免多次弹窗打断用户体验。

```ts
try {
  const [dob, blood] = await Promise.all([
    Health.dateOfBirth(),
    Health.bloodType()
  ])
  console.log(dob, blood)
} catch (err) {
  console.warn("用户可能拒绝了部分或全部权限")
}
```

***

## 开发建议与提示

| 场景                      | 建议处理方式                           |
| ----------------------- | -------------------------------- |
| 首次请求健康数据                | 在 UI 中预告权限用途，引导用户理解授权目的          |
| 接口返回空数组                 | 判断数据长度，提示“可能未授权或无数据记录”           |
| 接口发生异常（如 `dateOfBirth`） | 使用 `try...catch` 捕获异常并提示用户手动检查权限 |

***

## 如何开启授权

前往「健康」App，依次打开「数据访问与设备 > Scripting」，确认是否已授予相关权限。



---
url: /zh/guide/Device Capabilities/Health/HealthQuantitySample.md
---

`HealthQuantitySample` 表示一条健康数量类型的数据样本，例如一次心率测量、记录的步数或摄入的热量。它包含了关于该数据的类型、数值、时间区间、单位和可选的元数据信息。

该类是两个更具体子类的基类：

- `HealthCumulativeQuantitySample`（累计型样本）
- `HealthDiscreteQuantitySample`（离散型样本）

***

## 基本信息

此类用于：

- 读取单条健康数据记录
- 写入新的健康数据记录
- 按单位转换样本数值

***

## 属性说明

| 属性名            | 类型                            | 描述          |
| -------------- | ----------------------------- | ----------- |
| `uuid`         | `string`                      | 样本的唯一标识符    |
| `quantityType` | `HealthQuantityType`          | 健康指标的类型     |
| `startDate`    | `Date`                        | 测量开始时间      |
| `endDate`      | `Date`                        | 测量结束时间      |
| `count`        | `number`                      | 样本数量（通常为 1） |
| `metadata`     | `Record<string, any> \| null` | 可选的元数据      |

***

## 方法说明

### `quantityValue(unit: HealthUnit): number`

以指定单位返回该样本的数值。

**参数：**

- `unit`: 单位对象（如 `HealthUnit.kilocalorie()`）

**返回：**

- 转换后的数值（number）

**示例：**

```ts
const bpm = sample.quantityValue(HealthUnit.count().divided(HealthUnit.minute()))
console.log(`心率: ${bpm} 次/分钟`)
```

***

## 静态方法

### `HealthQuantitySample.create(options): HealthQuantitySample | null`

创建一条新的健康样本数据。

**参数结构：**

```ts
{
  type: HealthQuantityType
  startDate: Date
  endDate: Date
  value: number
  unit: HealthUnit
  metadata?: Record<string, any> | null
}
```

**返回：**

- 成功则返回 `HealthQuantitySample` 实例，否则为 `null`

**示例：**

```ts
const sample = HealthQuantitySample.create({
  type: 'stepCount',
  startDate: new Date('2025-07-01T09:00:00'),
  endDate: new Date('2025-07-01T09:01:00'),
  value: 200,
  unit: HealthUnit.count(),
  metadata: { source: 'manualEntry' }
})
```

***

# 子类：HealthCumulativeQuantitySample

`HealthCumulativeQuantitySample` 表示累计型的健康数据，例如总步数、总距离或总能量消耗等。

## 新增属性

| 属性名                       | 类型        | 描述          |
| ------------------------- | --------- | ----------- |
| `hasUndeterminedDuration` | `boolean` | 是否为不确定时长的样本 |

## 新增方法

### `sumQuantity(unit: HealthUnit): number`

以指定单位返回该样本的累计值。

**示例：**

```ts
const totalKcal = cumulativeSample.sumQuantity(HealthUnit.kilocalorie())
console.log(`总活动能量: ${totalKcal} 千卡`)
```

### `quantityValue(unit: HealthUnit): number`

返回值同 `sumQuantity()`，用于兼容统一接口。

***

# 子类：HealthDiscreteQuantitySample

`HealthDiscreteQuantitySample` 表示一系列离散时间点上的测量值，例如心率、步数或温度变化等。

## 新增属性

| 属性名                              | 类型                           | 描述            |
| -------------------------------- | ---------------------------- | ------------- |
| `mostRecentQuantityDateInterval` | `HealthDateInterval \| null` | 最近一次数值对应的时间范围 |

## 新增方法

| 方法名                        | 描述              |
| -------------------------- | --------------- |
| `averageQuantity(unit)`    | 返回平均值           |
| `maximumQuantity(unit)`    | 返回最大值           |
| `minimumQuantity(unit)`    | 返回最小值           |
| `mostRecentQuantity(unit)` | 返回最近一次记录的值（若存在） |

**示例：**

```ts
const avg = discreteSample.averageQuantity(HealthUnit.count())
const max = discreteSample.maximumQuantity(HealthUnit.count())
const recent = discreteSample.mostRecentQuantity(HealthUnit.count())
console.log(`平均: ${avg}, 最大: ${max}, 最近: ${recent}`)
```

***

## 使用场景对比

| 场景               | 推荐使用的类                           | 示例          |
| ---------------- | -------------------------------- | ----------- |
| 记录或读取单条测量数据      | `HealthQuantitySample`           | 手动输入体重      |
| 处理总量（如总步数、总能量）   | `HealthCumulativeQuantitySample` | 1 小时内的总步数   |
| 进行统计分析（最小值/最大值等） | `HealthDiscreteQuantitySample`   | 心率记录的最大/平均值 |

***

## 相关类型

- `HealthUnit`: 表示测量单位（如 kg、bpm、kcal 等）
- `HealthQuantityType`: 指定测量的数据类型（如步数、心率等）
- `HealthDateInterval`: 表示一个时间区间（start + end + duration）



---
url: /zh/guide/Device Capabilities/Health/HealthQuantityType.md
---

# 健康数量型数据（HealthQuantityType）

`HealthQuantityType` 用于指定你希望读取或写入的健康数据类型。每个标识符代表一种可度量的健康指标，涵盖身体测量、运动、营养、生理信号、环境暴露等多个维度。

***

## 1. 身体测量

| 类型标识符                           | 用途说明                     |
| ------------------------------- | ------------------------ |
| `bodyMass`                      | 体重（kg 或磅）                |
| `bodyMassIndex`                 | 身体质量指数（BMI）              |
| `height`                        | 身高                       |
| `bodyFatPercentage`             | 体脂百分比                    |
| `leanBodyMass`                  | 去脂体重（不包括脂肪、骨骼、器官）        |
| `waistCircumference`            | 腰围，常用于代谢健康分析             |
| `appleSleepingWristTemperature` | 睡眠期间的手腕皮肤温度（Apple Watch） |
| `bodyTemperature`               | 核心体温                     |
| `basalBodyTemperature`          | 基础体温，常用于生理周期追踪           |

***

## 2. 活动与运动

| 类型标识符                         | 用途说明              |
| ----------------------------- | ----------------- |
| `stepCount`                   | 步数                |
| `distanceWalkingRunning`      | 步行与跑步距离           |
| `flightsClimbed`              | 登楼层数              |
| `activeEnergyBurned`          | 主动能量消耗（卡路里）       |
| `basalEnergyBurned`           | 基础代谢能量消耗          |
| `appleExerciseTime`           | Apple 定义的锻炼时间     |
| `appleMoveTime`               | 活动时间（Move 环）      |
| `appleStandTime`              | 站立时间（Apple Watch） |
| `pushCount`                   | 轮椅推进次数            |
| `distanceWheelchair`          | 轮椅行进距离            |
| `nikeFuel`                    | Nike 活动得分（已弃用）    |
| `estimatedWorkoutEffortScore` | 锻炼努力估算分值          |
| `workoutEffortScore`          | 实际锻炼努力分值          |
| `physicalEffort`              | 锻炼期间的身体努力强度       |

***

## 3. 运动专项指标

| 类型标识符                             | 用途说明        |
| --------------------------------- | ----------- |
| `cyclingSpeed`                    | 骑行速度        |
| `cyclingPower`                    | 骑行输出功率      |
| `cyclingCadence`                  | 骑行踏频        |
| `cyclingFunctionalThresholdPower` | 功能性阈值功率（骑行） |
| `distanceCycling`                 | 骑行距离        |
| `distanceRowing`                  | 划船距离        |
| `rowingSpeed`                     | 划船速度        |
| `distanceSwimming`                | 游泳距离        |
| `swimmingStrokeCount`             | 游泳划水次数      |
| `distancePaddleSports`            | 划桨类运动距离     |
| `paddleSportsSpeed`               | 划桨运动速度      |
| `distanceSkatingSports`           | 滑冰运动距离      |
| `distanceDownhillSnowSports`      | 高山滑雪运动距离    |
| `distanceCrossCountrySkiing`      | 越野滑雪距离      |
| `crossCountrySkiingSpeed`         | 越野滑雪速度      |

***

## 4. 步态与跑步分析

| 类型标识符                            | 用途说明            |
| -------------------------------- | --------------- |
| `runningSpeed`                   | 跑步速度            |
| `runningPower`                   | 跑步功率            |
| `runningStrideLength`            | 步幅长度            |
| `runningVerticalOscillation`     | 垂直振幅（跑步中身体上下波动） |
| `runningGroundContactTime`       | 跑步着地接触时间        |
| `walkingStepLength`              | 步行步长            |
| `walkingSpeed`                   | 步行速度            |
| `walkingAsymmetryPercentage`     | 步态不对称百分比        |
| `walkingDoubleSupportPercentage` | 双脚同时着地的步行时间百分比  |
| `appleWalkingSteadiness`         | 苹果步态稳定性指标       |
| `walkingHeartRateAverage`        | 步行平均心率          |
| `sixMinuteWalkTestDistance`      | 六分钟步行测试距离       |
| `stairAscentSpeed`               | 上楼速度            |
| `stairDescentSpeed`              | 下楼速度            |

***

## 5. 心率与生命体征

| 类型标识符                        | 用途说明           |
| ---------------------------- | -------------- |
| `heartRate`                  | 心率（bpm）        |
| `restingHeartRate`           | 静息心率           |
| `walkingHeartRateAverage`    | 步行平均心率         |
| `heartRateVariabilitySDNN`   | 心率变异性（标准差）     |
| `heartRateRecoveryOneMinute` | 运动后 1 分钟心率恢复值  |
| `peripheralPerfusionIndex`   | 外周灌注指数         |
| `atrialFibrillationBurden`   | 房颤负荷（AFib 百分比） |
| `vo2Max`                     | 最大摄氧量，衡量有氧能力   |
| `bloodPressureSystolic`      | 收缩压            |
| `bloodPressureDiastolic`     | 舒张压            |
| `oxygenSaturation`           | 血氧饱和度          |
| `bloodGlucose`               | 血糖浓度           |
| `insulinDelivery`            | 胰岛素输送量         |
| `inhalerUsage`               | 吸入器使用次数        |
| `respiratoryRate`            | 呼吸频率（次/分钟）     |
| `forcedExpiratoryVolume1`    | 第1秒用力呼气量       |
| `forcedVitalCapacity`        | 用力肺活量          |
| `peakExpiratoryFlowRate`     | 呼气峰流速          |

***

## 6. 声音与环境暴露

| 类型标识符                         | 用途说明          |
| ----------------------------- | ------------- |
| `environmentalAudioExposure`  | 环境噪音暴露（分贝）    |
| `environmentalSoundReduction` | 降噪程度（耳机）      |
| `headphoneAudioExposure`      | 耳机音量暴露（时间与分贝） |
| `uvExposure`                  | 紫外线暴露水平       |
| `timeInDaylight`              | 曝晒在日光下的时间     |
| `underwaterDepth`             | 水下深度          |
| `waterTemperature`            | 水温（如游泳、潜水）    |

***

## 7. 营养摄入（饮食追踪）

| 类型标识符                       | 用途说明        |
| --------------------------- | ----------- |
| `dietaryEnergyConsumed`     | 摄入能量（卡路里）   |
| `dietaryProtein`            | 蛋白质摄入量      |
| `dietaryCarbohydrates`      | 碳水化合物摄入量    |
| `dietaryFatTotal`           | 总脂肪摄入量      |
| `dietaryFatSaturated`       | 饱和脂肪        |
| `dietaryFatMonounsaturated` | 单不饱和脂肪      |
| `dietaryFatPolyunsaturated` | 多不饱和脂肪      |
| `dietarySugar`              | 糖分摄入        |
| `dietaryFiber`              | 膳食纤维        |
| `dietaryWater`              | 水分摄入        |
| `dietaryCaffeine`           | 咖啡因摄入       |
| `dietaryCholesterol`        | 胆固醇摄入       |
| `dietarySodium`             | 钠摄入         |
| `dietaryPotassium`          | 钾摄入         |
| `dietaryCalcium`            | 钙摄入         |
| `dietaryIron`               | 铁摄入         |
| `dietaryMagnesium`          | 镁摄入         |
| `dietaryZinc`               | 锌摄入         |
| `dietaryIodine`             | 碘摄入         |
| `dietaryVitaminA`           | 维生素 A       |
| `dietaryVitaminB6`          | 维生素 B6      |
| `dietaryVitaminB12`         | 维生素 B12     |
| `dietaryVitaminC`           | 维生素 C       |
| `dietaryVitaminD`           | 维生素 D       |
| `dietaryVitaminE`           | 维生素 E       |
| `dietaryVitaminK`           | 维生素 K       |
| `dietaryThiamin`            | 维生素 B1（硫胺素） |
| `dietaryRiboflavin`         | 维生素 B2（核黄素） |
| `dietaryNiacin`             | 维生素 B3（烟酸）  |
| `dietaryPantothenicAcid`    | 泛酸（维生素 B5）  |
| `dietaryFolate`             | 叶酸          |
| `dietaryCopper`             | 铜摄入         |
| `dietarySelenium`           | 硒摄入         |
| `dietaryChromium`           | 铬摄入         |
| `dietaryManganese`          | 锰摄入         |
| `dietaryMolybdenum`         | 钼摄入         |
| `dietaryPhosphorus`         | 磷摄入         |
| `dietaryBiotin`             | 生物素         |

***

## 8. 生活方式与其他

| 类型标识符                                | 用途说明              |
| ------------------------------------ | ----------------- |
| `bloodAlcoholContent`                | 血液酒精含量            |
| `numberOfAlcoholicBeverages`         | 饮酒次数              |
| `numberOfTimesFallen`                | 跌倒次数（Apple Watch） |
| `appleSleepingBreathingDisturbances` | 睡眠期间呼吸干扰次数        |

***

## 使用示例

### 查询步数样本：

```ts
const samples = await Health.queryQuantitySamples({
  type: "stepCount",
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02"),
  limit: 20
})

for (const sample of samples) {
  const value = sample.quantity?.valueForUnit(HealthUnit.count())
  console.log("步数：", value)
}
```

### 写入体重数据：

```ts
const sample = HealthQuantitySample.create({
  type: "bodyMass",
  unit: HealthUnit.gramUnit(HealthUnitPrefix.kilo),
  value: 70.0,
  startDate: new Date("2025-07-01 00:00:00"),
  endDate: new Date("2025-07-02 00:00:00"),
})

await Health.saveQuantitySample(sample)
```

### 读取锻炼中的平均心率：

```ts
const stat = workout.allStatistics["heartRate"]
const avg = stat?.averageQuantity(HealthUnit.count().divided(HealthUnit.minute()))
```



---
url: /zh/guide/Device Capabilities/Health/HealthStatistics.md
---

`HealthStatistics` 类提供了对特定健康数量类型在指定时间范围内的**统计数据访问**。通过此类，你可以获取以下汇总信息：

- 总持续时间（duration）
- 平均值（average）
- 总和（sum）
- 最小值和最大值（min/max）
- 最近一次的值及其时间范围

该类适用于生成每日、每周或任意自定义区间的健康数据统计信息。

***

## 概览

- 每个 `HealthStatistics` 实例表示一个 `HealthQuantityType` 的统计数据。
- 所有统计信息都基于一个时间段内的样本数据。
- 可选地，你可以通过 `HealthSource` 过滤样本来源，只计算特定来源的统计结果。

***

## 属性说明

| 属性名            | 类型                       | 描述                              |
| -------------- | ------------------------ | ------------------------------- |
| `quantityType` | `HealthQuantityType`     | 当前统计数据所针对的健康数量类型（如 `stepCount`） |
| `startDate`    | `Date`                   | 当前统计数据所涵盖时间范围的开始时间              |
| `endDate`      | `Date`                   | 当前统计数据所涵盖时间范围的结束时间              |
| `sources`      | `HealthSource[] \| null` | 提供当前统计数据的所有健康数据来源（如设备、应用等）      |

***

## 方法说明

### `duration(unit: HealthUnit, source?: HealthSource): number | null`

返回符合条件的所有样本的总持续时间。

- `unit`: 使用的时间单位（如秒、分钟）
- `source`: （可选）只统计指定来源的样本

无匹配样本时返回 `null`。

***

### `averageQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回所有样本的**平均值**。

***

### `sumQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回所有样本的数值总和。

***

### `minimumQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回样本中的最小数值。

***

### `maximumQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回样本中的最大数值。

***

### `mostRecentQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回指定范围内最近记录的一条样本的值。

***

### `mostRecentQuantityDateInterval(source?: HealthSource): HealthDateInterval | null`

返回最近一条样本的时间区间（开始和结束时间）。

***

## 示例代码

```ts
const stats = await Health.queryStatistics({
  type: "stepCount",
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02")
})

const totalSteps = stats.sumQuantity(HealthUnit.count())
const average = stats.averageQuantity(HealthUnit.count())
const mostRecent = stats.mostRecentQuantity(HealthUnit.count())
const recentInterval = stats.mostRecentQuantityDateInterval()

console.log("步数统计：")
console.log("总步数：", totalSteps)
console.log("平均步数：", average)
console.log("最近记录：", mostRecent)
console.log("记录时间区间：", recentInterval)
```

***

# `HealthSource` 类

`HealthSource` 表示一个健康数据的来源，如某个 app 或设备（例如 iPhone、Apple Watch 等）。

***

## 属性说明

| 属性名                | 类型       | 描述                                         |
| ------------------ | -------- | ------------------------------------------ |
| `bundleIdentifier` | `string` | 来源的 bundle ID，例如 `"com.apple.Health"`      |
| `name`             | `string` | 来源的可读名称，例如 `"Apple Watch"` 或 `"Scripting"` |

***

## 静态方法

### `HealthSource.forCurrentApp(): HealthSource`

返回当前应用（Scripting）对应的 `HealthSource` 对象，可用于筛选由当前应用写入的健康数据。

***

## 示例：按来源过滤统计结果

```ts
const stats = await Health.queryStatistics("heartRate"， {
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02")
})

const currentAppSource = HealthSource.forCurrentApp()
const averageHR = stats.averageQuantity(HealthUnit.countPerMinute(), currentAppSource)

console.log("当前 App 的心率数据：", averageHR)
```

***

## 总结

- `HealthStatistics` 可用于获取健康数据的统计汇总，支持单位转换和数据来源过滤。
- 搭配 `HealthSource` 可以精确控制数据分析的来源，适用于可视化分析和报表功能。
- 常见场景包括：展示日均步数、记录最近一次体重、分析指定设备或 app 的活跃时间等。



---
url: /zh/guide/Device Capabilities/Health/HealthStatisticsCollection.md
---

# 健康统计集合（HealthStatisticsCollection）

`HealthStatisticsCollection` 类用于表示按时间分组的健康统计数据集合，如每日、每周或每月的汇总统计。集合中的每一项代表一个时间区间，并对应一个 `HealthStatistics` 实例，包含该时间段内的统计信息。

该类特别适用于：

- 绘制健康数据的**时间趋势图**
- 生成**按日/周/月分组的报告**
- 按日期区间访问统计数据

***

## 总览

每一个 `HealthStatisticsCollection`：

- 是通过按时间查询健康数据获得的
- 基于 anchorDate 和 intervalComponents（如每日、每周）进行时间对齐
- 可选支持按来源（如设备、App）聚合

***

## 方法说明

### `sources(): HealthSource[]`

返回一个数组，包含所有为此集合提供数据的 `HealthSource`（数据来源）。

每个 `HealthSource` 表示一个设备或 App（如 Apple Watch、iPhone、第三方健康应用等）。

#### 示例：

```ts
const sources = collection.sources()
sources.forEach(source => {
  console.log("来源：", source.name, source.bundleIdentifier)
})
```

***

### `statistics(): HealthStatistics[]`

返回此集合中所有时间区间的统计数据，每一项为一个 `HealthStatistics` 实例。

这些统计数据是根据查询时提供的 anchorDate 和 intervalComponents 进行时间对齐的。

#### 示例：

```ts
const allStats = collection.statistics()
allStats.forEach(stat => {
  const value = stat.sumQuantity(HealthUnit.count())
  console.log(`从 ${stat.startDate} 到 ${stat.endDate}：共计 ${value} 步`)
})
```

***

### `statisticsFor(date: Date): HealthStatistics | null`

根据指定的日期查找该日期所在的时间区间对应的 `HealthStatistics` 实例。

如果该日期不属于任何时间区间，将返回 `null`。

#### 示例：

```ts
const stat = collection.statisticsFor(new Date("2025-07-01"))
if (stat) {
  const value = stat.averageQuantity(HealthUnit.count())
  console.log("7月1日的平均值：", value)
} else {
  console.log("7月1日无数据")
}
```

***

## 使用场景

当你需要：

- 将健康数据**按日/周/月分组展示**
- **分析健康趋势**
- 为用户生成**历史数据图表或报告**

时，推荐使用 `HealthStatisticsCollection`。



---
url: /zh/guide/Device Capabilities/Health/HealthUnit.md
---

# 健康单位（HealthUnit）

`HealthUnit` 类用于表示 HealthKit 中各种度量单位。你可以使用它来构建基本单位（如公斤、米、升等）、带前缀的单位（如毫克、千米等），并支持进行乘法、除法、次方等单位组合运算。

## 枚举：HealthMetricPrefix

表示公制单位前缀：

| 枚举值     | 前缀符号 | 示例         |
| ------- | ---- | ---------- |
| `none`  | -    | gram()     |
| `milli` | m    | milligram  |
| `centi` | c    | centimeter |
| `kilo`  | k    | kilometer  |
| `mega`  | M    | megajoule  |
| `micro` | μ    | microliter |
| `nano`  | n    | nanometer  |

完整枚举见 API 定义。

***

## 1. 创建单位

### 使用静态方法创建基本单位

```ts
const weight = HealthUnit.gram()
const length = HealthUnit.meter()
const energy = HealthUnit.kilocalorie()
```

### 创建带前缀的单位

```ts
const mg = HealthUnit.gramUnit(HealthMetricPrefix.milli)
const km = HealthUnit.meterUnit(HealthMetricPrefix.kilo)
const mL = HealthUnit.literUnit(HealthMetricPrefix.milli)
```

### 从字符串构建单位

```ts
const unit = HealthUnit.fromString('kg')
```

***

## 2. 单位运算

### 单位乘法

用于构建复合单位，例如能量密度、速度单位等。

```ts
const meter = HealthUnit.meter()
const second = HealthUnit.second()
const speedUnit = meter.divided(second)  // 表示 m/s
```

### 单位除法

```ts
const bpm = HealthUnit.count().divided(HealthUnit.minute()) // 次/分钟
```

### 单位乘方

```ts
const m2 = HealthUnit.meter().raisedToPower(HealthMetricPrefix.none) // 平方米
```

### 倒数单位

```ts
const perLiter = HealthUnit.liter().reciprocal() // 表示每升 (1/L)
```

***

## 3. 单位属性

| 属性名          | 类型        | 说明                |
| ------------ | --------- | ----------------- |
| `unitString` | `string`  | 单位的字符串表示，如 `"kg"` |
| `isNull`     | `boolean` | 表示该单位是否为空或无效      |

***

## 4. 与 HealthQuantitySample 联合使用

配合 `HealthUnit`，你可以创建或读取 `HealthQuantitySample` 实例的值。

### 创建样本示例

```ts
const unit = HealthUnit.kilocalorie()

const sample = HealthQuantitySample.create({
  type: 'activeEnergyBurned',
  startDate: new Date('2025-07-04T10:00:00'),
  endDate: new Date('2025-07-04T10:30:00'),
  value: 150,
  unit: unit,
})
```

### 读取样本值（使用自定义单位）

```ts
const valueInJoules = sample.quantityValue(HealthUnit.joule())
```

***

## 5. 常用单位参考

| 类别  | 示例方法                             |
| --- | -------------------------------- |
| 重量  | `gram()`, `ounce()`, `pound()`   |
| 长度  | `meter()`, `inch()`, `mile()`    |
| 体积  | `liter()`, `fluidOunceUS()`      |
| 时间  | `second()`, `minute()`, `hour()` |
| 能量  | `kilocalorie()`, `joule()`       |
| 电压  | `volt()`, `voltUnit(prefix)`     |
| 温度  | `degreeCelsius()`, `kelvin()`    |
| 无量纲 | `percent()`, `count()`           |
| 光照  | `lux()`, `luxUnit(prefix)`       |

***

## 6. 示例：构建复合单位样本

```ts
// 构建一个速率单位 (steps / minute)
const stepsPerMinute = HealthUnit.count().divided(HealthUnit.minute())

const stepSample = HealthQuantitySample.create({
  type: 'stepCount',
  startDate: new Date(),
  endDate: new Date(),
  value: 120,
  unit: stepsPerMinute,
})
```

***

## 7. 示例：单位字符串解析和检查

```ts
const unit = HealthUnit.fromString('g/mL')
console.log(unit.unitString) // 输出: g/mL
console.log(unit.isNull)     // false
```

***

## 8. `Health.preferredUnits()` 方法

用于获取系统或用户在健康应用中为一个或多个 `HealthQuantityType` 设置的**首选显示单位**。此方法可帮助你在界面中展示符合用户习惯的健康数据（例如体重显示为公斤或磅）。

***

### 方法签名

```ts
function preferredUnits(
  quantityTypes: HealthQuantityType[]
): Promise<Record<HealthQuantityType, HealthUnit>>
```

***

### 参数

| 参数名             | 类型                     | 说明                                    |
| --------------- | ---------------------- | ------------------------------------- |
| `quantityTypes` | `HealthQuantityType[]` | 健康数量类型数组，例如 `"bodyMass"`、`"height"` 等 |

***

### 返回值

返回一个 `Promise`，解析后是一个对象 (`Record`)，每个键为 `HealthQuantityType`，对应的值为该类型的 `HealthUnit`（单位），代表用户设置的首选单位。

***

### 错误处理

如果无法获取首选单位，则会抛出异常。

***

### 示例代码

```ts
const types: HealthQuantityType[] = ["bodyMass", "height", "dietaryEnergyConsumed"]

const preferred = await Health.preferredUnits(types)

const bodyMassUnit = preferred["bodyMass"]         // 可能为 kilogram 或 pound
const heightUnit = preferred["height"]             // 可能为 meter 或 inch
const energyUnit = preferred["dietaryEnergyConsumed"] // 可能为 kilocalorie

console.log("用户首选单位：")
console.log("体重：", bodyMassUnit)
console.log("身高：", heightUnit)
console.log("能量摄入：", energyUnit)
```

***

### 使用提示

- 首选单位可能因用户的区域设置或设备偏好而异。
- 若要提供符合用户期望的健康数据展示，建议在界面展示前调用此方法。
- 如果某些类型不被支持，返回的结果中可能会省略对应的键。



---
url: /zh/guide/Device Capabilities/Health/HealthWorkout.md
---

# 健康锻炼数据（HealthWorkout）

`HealthWorkout` 类提供了访问和分析 Apple 健康应用中锻炼数据的接口。每个锻炼实例代表一次完整的锻炼会话，包括活动类型、开始与结束时间、持续时长，以及相关的事件与统计数据。

***

## 使用场景

- 获取用户的锻炼历史记录
- 分析锻炼类型与锻炼时间
- 结合锻炼期间采集的健康数据（如心率、卡路里、距离等）进行评估
- 可视化锻炼过程中的事件（如暂停、恢复、圈数、分段）
- 获取锻炼期间的统计指标，如平均心率或总能量消耗

***

## 属性说明

| 属性名                   | 类型                                                     | 描述                         |
| --------------------- | ------------------------------------------------------ | -------------------------- |
| `uuid`                | `string`                                               | 此锻炼实例的唯一标识符                |
| `workoutActivityType` | `HealthWorkoutActivityType`                            | 此次锻炼的活动类型，如跑步、骑行、游泳、瑜伽等    |
| `startDate`           | `Date`                                                 | 锻炼的开始时间                    |
| `endDate`             | `Date`                                                 | 锻炼的结束时间                    |
| `duration`            | `number`                                               | 锻炼的总时长，单位为秒                |
| `metadata`            | `Record<string, any> \| null`                          | 可选的元数据，如记录来源、设备信息或用户自定义标签等 |
| `workoutEvents`       | `HealthWorkoutEvent[] \| null`                         | 相关锻炼事件，如暂停、恢复、圈数等          |
| `allStatistics`       | `Record<HealthQuantityType, HealthStatistics \| null>` | 每种健康指标对应的统计数据，例如心率、步数、卡路里等 |

***

## 相关类型说明

### `HealthWorkoutActivityType`

表示此次锻炼的具体类型，例如：

- `running`（跑步）
- `walking`（步行）
- `cycling`（骑行）
- `swimming`（游泳）
- `yoga`（瑜伽）
- 等其他 Apple Health 支持的活动类型（参考 `HealthWorkoutActivityType` 文档）

### `HealthWorkoutEvent`

锻炼过程中记录的事件类型，例如：

- 暂停 (`pause`)
- 恢复 (`resume`)
- 运动暂停/恢复 (`motionPaused` / `motionResumed`)
- 圈数标记 (`lap`)
- 分段标记 (`segment`)

### `HealthStatistics`

统计锻炼期间采集到的健康数据，可用的方法包括：

- `averageQuantity()`：平均值
- `sumQuantity()`：总和
- `maximumQuantity()`：最大值
- `minimumQuantity()`：最小值
- `mostRecentQuantity()`：最近一次的值

***

## 示例代码

```ts
function showWorkout(workout: HealthWorkout) {
  console.log(`锻炼 ID: ${workout.uuid}`)
  console.log(`活动类型: ${workout.workoutActivityType}`)
  console.log(`开始时间: ${workout.startDate.toISOString()}`)
  console.log(`结束时间: ${workout.endDate.toISOString()}`)
  console.log(`持续时长: ${(workout.duration / 60).toFixed(1)} 分钟`)

  if (workout.metadata) {
    console.log(`元数据: ${JSON.stringify(workout.metadata)}`)
  }

  if (workout.workoutEvents) {
    for (const event of workout.workoutEvents) {
      console.log(`事件: ${HealthWorkoutEventType[event.type]} 时间: ${event.dateInterval.start.toISOString()}`)
    }
  }

  const stats = workout.allStatistics["heartRate"]
  if (stats) {
    console.log(`平均心率: ${stats.averageQuantity("count/min")} bpm`)
  }
}
```

***

## 补充说明

- `HealthWorkout` 实例通常由类似 `Health.queryWorkouts()` 的方法获取（取决于框架支持的 API）。
- `allStatistics` 属性可快速访问锻炼期间的聚合数据，避免手动查询每个样本。
- `workoutEvents` 可用于还原锻炼过程中的行为轨迹，例如暂停与恢复的时间点。



---
url: /zh/guide/Device Capabilities/Health/HealthWorkoutActivityType.md
---

# 健康锻炼活动类型（HealthWorkoutActivityType）

此枚举定义了所有支持的锻炼活动类型，常用于创建或读取 HealthKit 中的健身记录。

| 枚举值                             | 说明                                       |
| ------------------------------- | ---------------------------------------- |
| `americanFootball`              | 美式足球，常用于高强度的团队对抗训练。                      |
| `archery`                       | 射箭，主要记录手部稳定性与站立时间。                       |
| `australianFootball`            | 澳式足球，类似橄榄球的对抗性运动。                        |
| `badminton`                     | 羽毛球，适合记录轻中强度的有氧运动。                       |
| `baseball`                      | 棒球，包括打击与投球等动作训练。                         |
| `basketball`                    | 篮球，包含有氧、爆发力与跳跃运动。                        |
| `bowling`                       | 保龄球，记录站立、手臂动作与步行。                        |
| `boxing`                        | 拳击，可用于训练或比赛中的身体运动记录。                     |
| `climbing`                      | 攀岩，包括室内外的垂直或攀爬活动。                        |
| `cricket`                       | 板球，一种团队对抗型球类运动。                          |
| `crossTraining`                 | 混合训练，如交叉训练营（CrossFit）。                   |
| `curling`                       | 冰壶运动，滑冰与战术性投掷结合。                         |
| `cycling`                       | 骑自行车，包含室内或户外骑行。                          |
| `dance`                         | 舞蹈类锻炼，含各种风格（如现代舞、街舞）。                    |
| `danceInspiredTraining`         | 灵感舞动训练，如 Zumba、舞动健身。                     |
| `elliptical`                    | 椭圆机训练，常用于有氧耐力锻炼。                         |
| `equestrianSports`              | 马术类活动，如骑马。                               |
| `fencing`                       | 击剑，记录快速的刺击与步伐移动。                         |
| `fishing`                       | 钓鱼，主要用于记录久坐或站立的时长。                       |
| `functionalStrengthTraining`    | 功能性力量训练，例如壶铃、高强度训练。                      |
| `golf`                          | 高尔夫，包括走动与挥杆动作。                           |
| `gymnastics`                    | 体操，包括自由体、平衡木等训练。                         |
| `handball`                      | 手球，一种快速节奏的团队球类运动。                        |
| `hiking`                        | 徒步，适用于山地或自然步道行走。                         |
| `hockey`                        | 冰球或草地曲棍球等。                               |
| `hunting`                       | 狩猎，记录长时间步行和瞄准姿态。                         |
| `lacrosse`                      | 长曲棍球，结合了跑动与投掷。                           |
| `martialArts`                   | 武术，包括空手道、跆拳道等。                           |
| `mindAndBody`                   | 身心结合锻炼，如冥想或气功。                           |
| `mixedMetabolicCardioTraining`  | 混合代谢性有氧训练，通常包含冲刺与恢复交替。                   |
| `paddleSports`                  | 桨类运动，如皮划艇、独木舟。                           |
| `play`                          | 户外活动、自由玩耍等非正式锻炼。                         |
| `preparationAndRecovery`        | 热身或恢复训练，如伸展或泡沫轴。                         |
| `racquetball`                   | 壁球，室内高速球类运动。                             |
| `rowing`                        | 划船运动，含室内划船机或水上划艇。                        |
| `rugby`                         | 英式橄榄球，高对抗强度运动。                           |
| `running`                       | 跑步，含慢跑、快跑、竞赛等。                           |
| `sailing`                       | 帆船运动，结合操作与核心稳定训练。                        |
| `skatingSports`                 | 滑冰运动，如溜冰、滑板。                             |
| `snowSports`                    | 雪上运动，如滑雪、滑雪板。                            |
| `soccer`                        | 足球，广泛应用的有氧和技巧运动。                         |
| `softball`                      | 垒球，类似棒球但球更大。                             |
| `squash`                        | 壁球，快速反应和体能需求高。                           |
| `stairClimbing`                 | 爬楼梯，含楼梯机或实际楼梯。                           |
| `surfingSports`                 | 冲浪类运动，如海浪板。                              |
| `swimming`                      | 游泳，包括蛙泳、自由泳等。                            |
| `tableTennis`                   | 乒乓球，适合反应与协调训练。                           |
| `tennis`                        | 网球，记录对打和挥拍等动作。                           |
| `trackAndField`                 | 田径类项目，如短跑、跳高等。                           |
| `traditionalStrengthTraining`   | 传统力量训练，如举重、哑铃训练。                         |
| `volleyball`                    | 排球，包含场上移动与击球。                            |
| `walking`                       | 步行，适合日常轻强度记录。                            |
| `waterFitness`                  | 水中有氧，如水中舞蹈或操课。                           |
| `waterPolo`                     | 水球，结合游泳与团队战术。                            |
| `waterSports`                   | 各类水上运动，如风筝冲浪、摩托艇。                        |
| `wrestling`                     | 摔跤，包含格斗和摔投动作。                            |
| `yoga`                          | 瑜伽，注重拉伸、呼吸与冥想。                           |
| `barre`                         | 芭蕾塑形，结合舞蹈和力量训练。                          |
| `coreTraining`                  | 核心训练，如平板支撑、卷腹等。                          |
| `crossCountrySkiing`            | 越野滑雪，适合冬季耐力训练。                           |
| `downhillSkiing`                | 高速滑雪，记录滑行与肌群负荷。                          |
| `flexibility`                   | 柔韧性训练，主要用于伸展放松。                          |
| `highIntensityIntervalTraining` | 高强度间歇训练（HIIT）。                           |
| `jumpRope`                      | 跳绳，快速有氧训练。                               |
| `kickboxing`                    | 踢拳训练，结合力量与耐力。                            |
| `pilates`                       | 普拉提，强调核心控制和姿态。                           |
| `snowboarding`                  | 单板滑雪，雪地运动的一种。                            |
| `stairs`                        | 楼梯行走，类似 stair climber 训练机。               |
| `stepTraining`                  | 有氧踏板训练。                                  |
| `wheelchairWalkPace`            | 轮椅行走训练。                                  |
| `wheelchairRunPace`             | 轮椅快跑训练。                                  |
| `taiChi`                        | 太极，柔和节奏，注重呼吸与动静结合。                       |
| `mixedCardio`                   | 混合有氧训练，如跑步与单车交替。                         |
| `handCycling`                   | 手动脚踏车运动。                                 |
| `discSports`                    | 飞盘类运动，如极限飞盘。                             |
| `fitnessGaming`                 | 健身游戏，如 Apple Fitness+、Nintendo Ring Fit。 |
| `cardioDance`                   | 有氧舞蹈，节奏快速、锻炼心肺。                          |
| `socialDance`                   | 社交舞，如交谊舞、探戈。                             |
| `pickleball`                    | 匹克球，结合羽毛球和网球特点。                          |
| `cooldown`                      | 放松运动，帮助心率恢复与身体降温。                        |
| `swimBikeRun`                   | 铁人三项中的综合活动。                              |
| `transition`                    | 比赛中的过渡阶段（如游泳到骑行的切换）。                     |
| `underwaterDiving`              | 潜水运动，如自由潜或水肺潜水。                          |
| `other`                         | 其他无法归类的运动项目。                             |

***

如需在创建 `HealthWorkout` 实例时指定活动类型，可使用：

```ts
const workoutType = HealthWorkoutActivityType.running
```

本枚举与 Apple HealthKit 的 `HKWorkoutActivityType` 保持一致，确保系统对锻炼类型的识别与记录。若需在自定义健身记录中支持更多类型，请参考 [Apple 官方文档](https://developer.apple.com/documentation/healthkit/hkworkoutactivitytype)。



---
url: /zh/guide/Device Capabilities/Health/HealthWorkoutEvent.md
---

# 健康锻炼事件（HealthWorkoutEvent）

`HealthWorkoutEvent` 类用于访问 Apple 健康中记录的锻炼事件。每个事件表示一次锻炼过程中的特定动作或时刻，例如暂停、继续、圈数记录、标记、或自动运动检测。

***

## 使用场景

- 分析锻炼流程：判断用户何时暂停或恢复锻炼。
- 统计锻炼中活跃与静止的时间段。
- 记录跑步、游泳等项目中的圈数。
- 用于可视化锻炼记录和事件时间轴。

***

## 枚举：`HealthWorkoutEventType`

定义了各种类型的锻炼事件。

| 值   | 名称                     | 描述                       |
| --- | ---------------------- | ------------------------ |
| `1` | `pause`                | 用户手动暂停了锻炼。               |
| `2` | `resume`               | 用户在暂停后恢复了锻炼。             |
| `3` | `lap`                  | 表示一圈锻炼结束，常用于跑步、游泳等。      |
| `4` | `marker`               | 一个用户或系统添加的标记点。           |
| `5` | `motionPaused`         | 因无动作被系统自动暂停。             |
| `6` | `motionResumed`        | 系统因检测到动作自动恢复锻炼。          |
| `7` | `segment`              | 表示一个新的锻炼分段开始，常用于间歇训练等场景。 |
| `8` | `pauseOrResumeRequest` | 系统提出的暂停或继续请求，但不一定实际执行。   |

***

## 类：`HealthWorkoutEvent`

### 属性说明

| 属性名            | 类型                            | 描述                                            |
| -------------- | ----------------------------- | --------------------------------------------- |
| `type`         | `HealthWorkoutEventType`      | 当前事件的类型，例如暂停、圈数、自动恢复等。                        |
| `dateInterval` | `HealthDateInterval`          | 该事件发生的时间区间，包含 `start`、`end` 和 `duration`（秒数）。 |
| `metadata`     | `Record<string, any> \| null` | 可选的附加信息，例如记录来源、设备等。                           |

> 说明：`HealthDateInterval` 是一个对象，包含：
>
> - `start: Date`：事件开始时间
> - `end: Date`：事件结束时间
> - `duration: number`：事件持续时间（单位为秒）

***

## 示例代码

### 记录锻炼事件日志

```ts
function logWorkoutEvent(event: HealthWorkoutEvent) {
  const { type, dateInterval, metadata } = event
  const start = dateInterval.start.toISOString()
  const end = dateInterval.end.toISOString()
  const duration = dateInterval.duration

  console.log(`事件类型：${HealthWorkoutEventType[type]}`)
  console.log(`开始时间：${start}`)
  console.log(`结束时间：${end}`)
  console.log(`持续时长（秒）：${duration}`)

  if (metadata) {
    console.log(`元数据：${JSON.stringify(metadata)}`)
  }
}
```

***

## 说明与提示

- `HealthWorkoutEvent` 实例通常包含在 `HealthWorkout` 中的 `events` 数组内。
- 可结合多个事件分析锻炼的完整时序、自动暂停/恢复、间歇训练分段等信息。
- 在无操作或锻炼设备脱离身体时，系统会自动生成 motionPaused / motionResumed 事件。



---
url: /zh/guide/Device Capabilities/Health/Query Statistics Collection.md
---

# 查询统计数据集合（HealthStatisticsCollection）

`Health.queryStatisticsCollection()` 方法用于按时间区间查询指定 `HealthQuantityType` 类型的**聚合统计数据**，例如每天、每周或每月的步数、心率等。它返回一个 `HealthStatisticsCollection` 实例，其中包含多个按时间间隔对齐的 `HealthStatistics` 对象。

此方法非常适合：

- 分析健康趋势
- 构建图表
- 生成历史报告

***

## 方法签名

```ts
function queryStatisticsCollection(
  quantityType: HealthQuantityType,
  options: {
    startDate?: Date
    endDate?: Date
    strictStartDate?: boolean
    strictEndDate?: boolean
    statisticsOptions?: HealthStatisticsOptions | Array<HealthStatisticsOptions>
    anchorDate: Date
    intervalComponents: DateComponents
  }
): Promise<HealthStatisticsCollection>
```

***

## 参数说明

| 参数名称                         | 类型                                | 必填  | 说明                                                                                                                                           |
| ---------------------------- | --------------------------------- | --- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `quantityType`               | `HealthQuantityType`              | Yes | 要查询的健康数据类型，如 `"stepCount"`、`"heartRate"` 等                                                                                                   |
| `options.startDate`          | `Date`                            | No  | 查询范围的起始日期，查询结果不包含此日期之前的数据                                                                                                                    |
| `options.endDate`            | `Date`                            | No  | 查询范围的结束日期，查询结果不包含此日期之后的数据                                                                                                                    |
| `options.strictStartDate`    | `boolean`                         | No  | 若为 `true`，仅包含精确从 `startDate` 开始的区间                                                                                                           |
| `options.strictEndDate`      | `boolean`                         | No  | 若为 `true`，仅包含精确在 `endDate` 结束的区间                                                                                                             |
| `options.statisticsOptions`  | `HealthStatisticsOptions[]` 或单个选项 | No  | 指定要计算的统计类型，可包含： `"cumulativeSum"`, `"discreteAverage"`, `"discreteMin"`, `"discreteMax"`, `"mostRecent"`, `"duration"`, `"separateBySource"` |
| `options.anchorDate`         | `Date`                            | Yes | 用于对齐时间间隔的锚点日期，通常设为当天零点                                                                                                                       |
| `options.intervalComponents` | `DateComponents`                  | Yes | 定义时间间隔，例如每日、每周等。通过 `new DateComponents({ day: 1 })`、`new DateComponents({ weekOfYear: 1 })` 等方式创建                                            |

***

## 返回值

返回一个 `Promise`，解析为 `HealthStatisticsCollection` 对象。该集合按时间间隔组织，每个区间包含一个 `HealthStatistics` 实例。

***

## 示例：获取过去 7 天每日步数统计

```ts
const now = new Date()
const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)

const collection = await Health.queryStatisticsCollection("stepCount", {
  startDate: sevenDaysAgo,
  endDate: now,
  anchorDate: new Date(), // 通常为当天零点
  intervalComponents: new DateComponents({ day: 1 }),
  statisticsOptions: ["cumulativeSum"]
})

const stats = collection.statistics()
for (const stat of stats) {
  const steps = stat.sumQuantity(HealthUnit.count())
  console.log(`从 ${stat.startDate.toDateString()} 开始：${steps} 步`)
}
```

***

## 注意事项

- 如果某个时间区间没有任何样本数据，该区间对应的 `HealthStatistics` 对象可能会返回 `null`。
- 所有统计数据基于 `anchorDate` 对齐，区间由 `intervalComponents` 定义。
- 如果只需查询整个时间范围的汇总统计（不按时间拆分），可使用 `Health.queryStatistics()` 方法代替。



---
url: /zh/guide/Device Capabilities/Health/Query Statistics.md
---

# 查询统计数据（HealthStatistics）

`queryStatistics` 方法用于查询某个健康数量类型在指定时间范围内的**聚合统计数据**，包括：

- 总和（sum）
- 平均值（average）
- 最小值、最大值
- 最近一条记录
- 总持续时间（duration）

你也可以选择**按来源（设备或应用）分开统计**。

此方法非常适合生成**每日、每周或历史健康数据的摘要**。

***

## 方法签名

```ts
function queryStatistics(
  quantityType: HealthQuantityType,
  options?: {
    startDate?: Date
    endDate?: Date
    strictStartDate?: boolean
    strictEndDate?: boolean
    statisticsOptions?: HealthStatisticsOptions | Array<HealthStatisticsOptions>
  }
): Promise<HealthStatistics | null>
```

***

## 参数说明

### `quantityType: HealthQuantityType`（必填）

要查询的健康数量类型，例如：

- `"stepCount"`（步数）
- `"heartRate"`（心率）
- `"bodyMass"`（体重）
- `"activeEnergyBurned"`（活动能量消耗）

请使用支持的 `HealthQuantityType` 值。

***

### `options`（可选）

用于配置查询范围和结果的选项对象：

| 参数名                 | 类型                              | 说明                                  |
| ------------------- | ------------------------------- | ----------------------------------- |
| `startDate`         | `Date`                          | 查询起始时间                              |
| `endDate`           | `Date`                          | 查询结束时间                              |
| `strictStartDate`   | `boolean`                       | 若为 `true`，仅包含从 `startDate` 精确开始的统计项 |
| `strictEndDate`     | `boolean`                       | 若为 `true`，仅包含在 `endDate` 精确结束的统计项   |
| `statisticsOptions` | `HealthStatisticsOptions` 或数组形式 | 指定要包含哪些统计指标（详见下方）                   |

***

## 可用的 `HealthStatisticsOptions`

| 选项名                  | 描述                |
| -------------------- | ----------------- |
| `"cumulativeSum"`    | 总和（适用于步数、卡路里等累计值） |
| `"discreteAverage"`  | 平均值（适用于心率等离散值）    |
| `"discreteMin"`      | 最小值               |
| `"discreteMax"`      | 最大值               |
| `"mostRecent"`       | 最近一条记录的值          |
| `"duration"`         | 所有样本的总持续时间        |
| `"separateBySource"` | 按来源（设备或 App）分开统计  |

***

## 返回值

返回一个 `Promise`，解析为 `HealthStatistics` 对象，或在没有数据时返回 `null`。

你可以通过 `HealthStatistics` 提供的方法来获取聚合值，例如：

- `sumQuantity(...)`
- `averageQuantity(...)`
- `mostRecentQuantity(...)`
- `duration(...)`

***

## 示例：查询每日步数汇总

```ts
const stats = await Health.queryStatistics("stepCount", {
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02"),
  statisticsOptions: ["cumulativeSum", "mostRecent", "duration"]
})

if (stats) {
  const steps = stats.sumQuantity(HealthUnit.count())
  const last = stats.mostRecentQuantity(HealthUnit.count())
  const time = stats.duration(HealthUnit.second())

  console.log("步数：", steps)
  console.log("最近一次记录：", last)
  console.log("总持续时间（秒）：", time)
} else {
  console.log("未找到步数数据")
}
```

***

## 示例：仅查询当前 App 写入的心率平均值

```ts
const stats = await Health.queryStatistics("heartRate", {
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02"),
  statisticsOptions: ["discreteAverage"]
})

const source = HealthSource.forCurrentApp()
const averageHR = stats?.averageQuantity(HealthUnit.countPerMinute(), source)

console.log("当前 App 的心率平均值：", averageHR)
```

***

## 注意事项

- 如果未指定 `statisticsOptions`，某些字段（如总和、平均值等）可能为 `null`。
- 若需访问原始样本数据，请使用 `Health.queryQuantitySamples()` 方法。
- 可用的统计类型与数据类型相关，例如心率支持 `discreteAverage`，而步数支持 `cumulativeSum`。



---
url: /zh/guide/Device Capabilities/Health/Reading Activity Summaries.md
---

# 读取活动摘要（HealthActivitySummary）

Scripting 应用通过全局函数 `Health.queryActivitySummaries()` 提供对 Apple Health 每日活动摘要数据的访问。这些摘要包含 Apple Watch 追踪的 **移动（Move）**、**锻炼（Exercise）** 和 **站立（Stand）** 目标，以及完成情况和历史趋势。

此 API 非常适合在应用中展示每日活动环或分析长期健身趋势。

***

## 什么是活动摘要？

`HealthActivitySummary` 提供一天 Apple Watch 活动的概览：

- **移动（活跃能量消耗）**

  - `activeEnergyBurned(unit: HealthUnit): number`
  - `activeEnergyBurnedGoal(unit: HealthUnit): number`

- **锻炼（分钟）**

  - `appleExerciseTime(unit: HealthUnit): number`
  - `appleExerciseTimeGoal(unit: HealthUnit): number`

- **站立（小时）**

  - `appleStandHours(unit: HealthUnit): number`
  - `appleStandHoursGoal(unit: HealthUnit): number`

- **日期信息**

  - `dateComponents: DateComponents` —— 包含 `year`、`month`、`day` 的 `DateComponents` 对象

***

## API 概览

```ts
Health.queryActivitySummaries(
  options?: {
    start: DateComponents
    end: DateComponents
  }
): Promise<HealthActivitySummary[]>
```

***

## 参数

| 参数      | 类型               | 说明                       |
| ------- | ---------------- | ------------------------ |
| `start` | `DateComponents` | 查询范围的起始日期，仅返回在该日期或之后的摘要。 |
| `end`   | `DateComponents` | 查询范围的结束日期，仅返回在该日期或之前的摘要。 |

> 如果同时省略 `options`，则返回所有可用摘要（受系统限制）。
> 返回的摘要按日期升序排序。

***

## 示例：读取最近 7 天的活动摘要

```ts
async function fetchLastWeek() {
  // 构建日期范围
  const today = new Date()
  const sevenDaysAgo = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() - 6
  )

  const startComponents = DateComponents.fromDate(sevenDaysAgo)
  const endComponents = DateComponents.fromDate(today)

  // 查询活动摘要
  const summaries = await Health.queryActivitySummaries({
    start: startComponents,
    end: endComponents,
  })

  // 遍历并打印每天数据
  for (const summary of summaries) {
    const date = summary.dateComponents.date
    console.log(`日期: ${date?.toDateString()}`)

    const kcal = summary.activeEnergyBurned(HealthUnit.kilocalorie())
    const kcalGoal = summary.activeEnergyBurnedGoal(HealthUnit.kilocalorie())
    const exerciseMin = summary.appleExerciseTime(HealthUnit.minute())
    const standHrs = summary.appleStandHours(HealthUnit.count())

    console.log(` 移动:    ${kcal} / ${kcalGoal} kcal`)
    console.log(` 锻炼:    ${exerciseMin} 分钟`)
    console.log(` 站立:    ${standHrs} 小时`)
    console.log('---')
  }
}

fetchLastWeek()
```

***

## 注意事项

- `DateComponents` 至少需包含 `year`、`month`、`day`，其他字段（如小时、分钟）在日摘要中会被忽略。
- 各项指标方法均返回所指定单位下的原始 `number` 值。
- 使用 `HealthUnit` 工厂方法（如 `kilocalorie()`、`minute()`、`count()`）来指定单位。
- 如果某些日期没有数据（例如 Apple Watch 未佩戴或未同步），则该日期的摘要可能会被省略。

***

## 总结

1. 调用 `Health.queryActivitySummaries({ start, end })` 并传入 `DateComponents` 指定查询范围。
2. 获取按日期升序排列的 `HealthActivitySummary[]`。
3. 调用摘要实例的方法读取移动、锻炼和站立的实际值及目标值。
4. 在 UI 或分析中展示或统计这些数字。



---
url: /zh/guide/Device Capabilities/Health/Reading Category Samples.md
---

# 读取分类数据（HealthCategorySample）

Scripting 应用支持通过全局函数 `Health.queryCategorySamples()` 访问 HealthKit 中的**分类健康数据**。分类样本表示某一健康事件或状态的记录，通常包括起止时间和一个离散的状态值，例如：睡眠分析、冥想记录、经期流量、排卵测试结果等。

本文将介绍如何查询、解析并使用这些分类数据。

***

## 什么是 Category Sample？

**Category Sample（分类样本）** 包含以下信息：

- `type`：样本的分类类型（如 `"sleepAnalysis"`、`"mindfulSession"`）
- `startDate` / `endDate`：事件发生的起止时间
- `value`：表示事件状态的整数值，需使用对应的枚举进行解释
- `metadata`：可选的附加信息

常见示例：

- `"sleepAnalysis"` 对应的值可以是 `asleepCore`、`awake`、`inBed`
- `"menstrualFlow"` 对应的值可以是 `mild`、`moderate`、`severe`

***

## API 用法

```ts
Health.queryCategorySamples(
  categoryType: HealthCategoryType,
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "value"
      order?: "forward" | "reverse"
    }>
  }
): Promise<HealthCategorySample[]>
```

***

## 参数说明

| 参数名                                 | 描述                                            |
| ----------------------------------- | --------------------------------------------- |
| `categoryType`                      | 要查询的分类数据类型（如 `"sleepAnalysis"`）               |
| `startDate` / `endDate`             | 筛选结果的时间范围                                     |
| `limit`                             | 返回的最大样本数量                                     |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间                                    |
| `sortDescriptors`                   | 可选排序规则，例如按 `startDate`、`endDate` 或 `value` 排序 |

***

## 示例：读取睡眠分析数据

```ts
const results = await Health.queryCategorySamples("sleepAnalysis", {
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-05T00:00:00"),
  sortDescriptors: [{ key: "startDate", order: "forward" }]
})

for (const sample of results) {
  console.log("开始时间：", sample.startDate)
  console.log("结束时间：", sample.endDate)
  console.log("睡眠状态值：", sample.value) // 需要使用枚举解释该值
}
```

你可以使用对应的枚举来解释 `value` 值：

```ts
switch (sample.value) {
  case HealthCategoryValueSleepAnalysis.awake:
    console.log("清醒")
    break
  case HealthCategoryValueSleepAnalysis.asleepCore:
    console.log("核心睡眠")
    break
  case HealthCategoryValueSleepAnalysis.asleepDeep:
    console.log("深度睡眠")
    break
  case HealthCategoryValueSleepAnalysis.inBed:
    console.log("在床上")
    break
  // 可根据需要继续扩展其他状态
}
```

***

## 示例：读取冥想记录

```ts
const sessions = await Health.queryCategorySamples("mindfulSession", {
  startDate: new Date(Date.now() - 7 * 86400 * 1000) // 最近 7 天
})

console.log(`共找到 ${sessions.length} 条冥想记录`)
```

***

## 注意事项

- 所有返回结果都是 `HealthCategorySample` 实例
- `.value` 是一个整数，需要使用对应类型的枚举进行解释
- `.metadata` 字段为可选，可提供附加信息（如来源、标签等）
- 分类数据适用于建模事件型健康记录，例如睡眠、冥想、生理周期、症状等

***

## 小结

要读取分类样本数据：

1. 调用 `Health.queryCategorySamples(categoryType, options)`
2. 设置时间范围、数量限制、排序方式等参数
3. 使用 `.value` 配合相应枚举来解释数据含义

该 API 提供了对基于事件的健康数据的结构化访问方式，适用于日志展示、趋势分析等场景。



---
url: /zh/guide/Device Capabilities/Health/Reading Characteristic Data.md
---

# 读取特征数据

HealthKit 中的 **特征数据** 指的是用户个人的静态属性，如出生日期、生物性别、血型、皮肤类型、是否使用轮椅，以及活动移动模式等。这些信息通常由用户在“健康”App 中设置，属于只读数据。

Scripting 提供了一系列 **全局异步 API** 来读取这些数据。

***

## 支持读取的特征

| 特征名称              | API 调用方式                             | 返回类型                           |
| ----------------- | ------------------------------------ | ------------------------------ |
| 出生日期              | `await Health.dateOfBirth()`         | `DateComponents`               |
| 生物性别              | `await Health.biologicalSex()`       | `HealthBiologicalSex` 枚举       |
| 血型                | `await Health.bloodType()`           | `HealthBloodType` 枚举           |
| 皮肤类型（Fitzpatrick） | `await Health.fitzpatrickSkinType()` | `HealthFitzpatrickSkinType` 枚举 |
| 是否使用轮椅            | `await Health.wheelchairUse()`       | `HealthWheelchairUse` 枚举       |
| 活动移动模式            | `await Health.activityMoveMode()`    | `HealthActivityMoveMode` 枚举    |

***

## 1. 读取出生日期

```ts
const birthDate = await Health.dateOfBirth()
console.log(`出生日期：${birthDate.year}年${birthDate.month}月${birthDate.day}日`)
```

返回值为 `DateComponents` 对象，例如：

```ts
{
  year: 1989,
  month: 7,
  day: 4
}
```

***

## 2. 读取生物性别

```ts
const sex = await Health.biologicalSex()

switch (sex) {
  case HealthBiologicalSex.female:
    console.log("女性")
    break
  case HealthBiologicalSex.male:
    console.log("男性")
    break
  case HealthBiologicalSex.other:
    console.log("其他")
    break
  case HealthBiologicalSex.notSet:
    console.log("未设置")
    break
}
```

***

## 3. 读取血型

```ts
const blood = await Health.bloodType()

switch (blood) {
  case HealthBloodType.aPositive:
    console.log("A型阳性")
    break
  case HealthBloodType.oNegative:
    console.log("O型阴性")
    break
  // 可补充更多类型
  default:
    console.log("未设置")
}
```

***

## 4. 读取皮肤类型（Fitzpatrick）

```ts
const skinType = await Health.fitzpatrickSkinType()

switch (skinType) {
  case HealthFitzpatrickSkinType.I:
    console.log("类型 I：非常白")
    break
  case HealthFitzpatrickSkinType.VI:
    console.log("类型 VI：深褐色至黑色")
    break
  default:
    console.log("未设置")
}
```

***

## 5. 判断是否使用轮椅

```ts
const wheelchair = await Health.wheelchairUse()

if (wheelchair === HealthWheelchairUse.yes) {
  console.log("用户使用轮椅")
} else if (wheelchair === HealthWheelchairUse.no) {
  console.log("用户不使用轮椅")
} else {
  console.log("未设置")
}
```

***

## 6. 读取活动移动模式

```ts
const mode = await Health.activityMoveMode()

if (mode === HealthActivityMoveMode.activeEnergy) {
  console.log("通过活跃能量追踪活动")
} else if (mode === HealthActivityMoveMode.appleMoveTime) {
  console.log("通过 Apple Move Time 追踪活动")
}
```

***

## 错误处理

如果：

- 用户未设置该特征；
- 没有获取权限；
- 设备不支持 HealthKit；

调用 API 时可能抛出异常。建议使用 `try/catch` 进行捕获：

```ts
try {
  const sex = await Health.biologicalSex()
  console.log(sex)
} catch (err) {
  console.error("读取生物性别失败：", err)
}
```

***

## 总结

你可以通过以下全局 API 读取用户的静态健康特征：

```ts
await Health.dateOfBirth()
await Health.biologicalSex()
await Health.bloodType()
await Health.fitzpatrickSkinType()
await Health.wheelchairUse()
await Health.activityMoveMode()
```

这些值来源于用户在健康 App 中的个人设置，通常不会频繁变化。请注意处理未设置或读取失败的情况。



---
url: /zh/guide/Device Capabilities/Health/Reading Correlation Data.md
---

# 读取关联数据（HealthCorrelation）

Scripting 应用支持通过全局 API `Health.queryCorrelations()` 查询 HealthKit 中的**相关健康数据**。相关数据用于表示一组相互关联的健康样本，例如：

- 一次血压测量（包含收缩压和舒张压）
- 一次食物摄入记录（包含热量、蛋白质、碳水等）

本文将介绍如何读取相关数据并提取其中的样本信息。

***

## 什么是 Correlation（相关数据）？

Correlation 是将多个健康样本组合成单个事件的数据结构。支持的类型包括：

- `"bloodPressure"`：包含两个数量样本：`bloodPressureSystolic`（收缩压）和 `bloodPressureDiastolic`（舒张压）
- `"food"`：可包含多个营养类样本，如 `dietaryEnergyConsumed`（摄入热量）、`dietaryProtein`（蛋白质）、`dietaryCarbohydrates`（碳水化合物）等

每个 Correlation 包含以下信息：

- 类型（如 `"bloodPressure"`、`"food"`）
- 开始/结束时间
- 元数据（可选）
- 相关的多个样本（QuantitySample 或 CategorySample）

***

## API 用法

```ts
Health.queryCorrelations(
  correlationType: HealthCorrelationType,
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate"
      order?: "forward" | "reverse"
    }>
  }
): Promise<HealthCorrelation[]>
```

***

## 参数说明

| 参数名                                 | 描述                                     |
| ----------------------------------- | -------------------------------------- |
| `correlationType`                   | `"bloodPressure"` 或 `"food"`           |
| `startDate` / `endDate`             | 查询的时间范围                                |
| `limit`                             | 返回的最大条数                                |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间                             |
| `sortDescriptors`                   | 可选的排序规则，支持按 `startDate` 或 `endDate` 排序 |

***

## 示例：读取血压记录

```ts
const correlations = await Health.queryCorrelations("bloodPressure", {
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-02T00:00:00"),
  limit: 5,
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const correlation of correlations) {
  console.log("开始时间：", correlation.startDate)
  console.log("结束时间：", correlation.endDate)

  const systolic = correlation.quantitySamples.find(
    s => s.quantityType === "bloodPressureSystolic"
  )

  const diastolic = correlation.quantitySamples.find(
    s => s.quantityType === "bloodPressureDiastolic"
  )

  if (systolic && diastolic) {
    const sys = systolic.quantityValue(HealthUnit.millimeterOfMercury())
    const dia = diastolic.quantityValue(HealthUnit.millimeterOfMercury())
    console.log(`血压：${sys}/${dia} mmHg`)
  }
}
```

***

## 示例：读取食物摄入记录

```ts
const correlations = await Health.queryCorrelations("food", {
  startDate: new Date(Date.now() - 86400 * 1000), // 最近 24 小时
  limit: 10
})

for (const correlation of correlations) {
  console.log("记录时间：", correlation.startDate)

  for (const sample of correlation.quantitySamples) {
    const unit = sample.quantityType.includes("Energy")
      ? HealthUnit.kilocalorie()
      : HealthUnit.gram()

    const value = sample.quantityValue(unit)
    console.log(`${sample.quantityType}：${value}`)
  }
}
```

***

## 如何访问样本

每个 `HealthCorrelation` 实例中包含以下数组：

- `quantitySamples`：所有数量样本（可含 cumulative / discrete 类型）
- `cumulativeQuantitySamples`：仅累积样本
- `discreteQuantitySamples`：仅离散样本
- `categorySamples`：分类样本（某些类型支持）

你可以通过 `.quantityType` 和 `.quantityValue(unit)` 读取每个样本的具体数值。

***

## 错误处理

```ts
try {
  const results = await Health.queryCorrelations("bloodPressure")
  console.log("共返回", results.length, "条记录")
} catch (err) {
  console.error("查询失败：", err)
}
```

***

## 小结

读取 HealthKit 中的 Correlation 数据的步骤如下：

1. 使用 `Health.queryCorrelations(type, options)` 进行查询；
2. 遍历返回的 `HealthCorrelation` 列表；
3. 使用 `.quantitySamples` 访问每个相关样本；
4. 使用 `.quantityValue(unit)` 获取数值。

该方法适用于读取复合型健康数据（如血压或饮食记录），适合用于统计分析或健康日志记录。



---
url: /zh/guide/Device Capabilities/Health/Reading Heartbeat Series Samples.md
---

# 读取心跳序列数据（HealthHeartbeatSeriesSample）

Scripting 应用通过全局函数 `Health.queryHeartbeatSeriesSamples()` 提供对 Apple Health 中**心跳序列数据**的访问。该数据代表 Apple Watch 在锻炼或静息状态下记录的一系列连续心跳间隔（R-R 间隔），可用于分析心律稳定性与频率变化。

每条记录提供该心跳序列的**持续时间、心跳数量**及**元数据**，但**不包含原始的每次间隔时间值**。

***

## 什么是 Heartbeat Series Sample？

每个 `HealthHeartbeatSeriesSample` 对象包含以下字段：

- `uuid`：该样本的唯一标识符
- `sampleType`：样本类型（恒为 `"heartbeatSeries"`）
- `startDate` / `endDate`：记录该序列的时间范围
- `count`：该序列中记录的心跳次数
- `metadata`：可选的附加信息（如记录来源设备、应用等）

> 注意：此接口仅返回摘要信息，不包含每一次心跳的具体间隔值。

***

## API 用法

```ts
Health.queryHeartbeatSeriesSamples(
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate"
      order?: "forward" | "reverse"
    }>
    requestPermissions?: HealthQuantityType[]
  }
): Promise<HealthHeartbeatSeriesSample[]>
```

***

## 参数说明

| 参数名                                 | 描述                                                                     |
| ----------------------------------- | ---------------------------------------------------------------------- |
| `startDate` / `endDate`             | 可选时间范围，用于筛选样本                                                          |
| `limit`                             | 限制返回的最大样本数量                                                            |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间边界                                                           |
| `sortDescriptors`                   | 可选排序方式（如按 `startDate` 或 `endDate` 排序）                                  |
| `requestPermissions`                | 可选请求更多数据类型权限，默认只请求`heartRate`、`heartbeat` 和 `heartRateVariabilitySDNN` |

***

## 示例：读取最近的心跳序列记录

```ts
const results = await Health.queryHeartbeatSeriesSamples({
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-05T00:00:00"),
  limit: 10,
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const sample of results) {
  console.log("UUID:", sample.uuid)
  console.log("开始时间：", sample.startDate)
  console.log("结束时间：", sample.endDate)
  console.log("心跳次数：", sample.count)
  console.log("元数据：", sample.metadata)
  console.log("---")
}
```

***

## 数据说明与限制

- **无法获取每一次心跳的具体间隔时间**，仅可看到总次数和时间范围。

- 如需计算平均心率（BPM），可通过以下方式估算：

  ```ts
  const duration = (sample.endDate.getTime() - sample.startDate.getTime()) / 1000
  const avgBPM = (sample.count / duration) * 60
  ```

- 该 API 不包含间隔异常（如缺失数据、节律中断）信息。

***

## 小结

读取心跳序列数据的流程如下：

1. 使用 `Health.queryHeartbeatSeriesSamples()` 方法进行查询；
2. 可按时间范围、排序或限制数量进行过滤；
3. 遍历返回的 `HealthHeartbeatSeriesSample` 数组；
4. 每个对象包含 `startDate`、`endDate`、`count` 和 `metadata`；
5. 可通过持续时间与总次数计算平均心率。

此 API 适用于分析 Apple Watch 记录的心跳追踪频率，可结合锻炼或其他健康数据进行综合评估。



---
url: /zh/guide/Device Capabilities/Health/Reading Quantity Samples.md
---

# 读取数量型数据（HealthQuantitySample）

Scripting 应用支持通过全局 API `Health.queryQuantitySamples()` 查询 HealthKit 中的**数量型健康数据**，例如步数、心率、体重、卡路里、距离等。

本文将介绍如何使用该 API 查询数据样本并解析结果。

***

## 什么是 Quantity Sample？

**Quantity Sample（数量型样本）** 表示某一时间点或时间段内的数值型健康数据。常见类型包括：

- `stepCount`（步数）
- `heartRate`（心率）
- `bodyMass`（体重）
- `activeEnergyBurned`（活动能量消耗）
- `distanceWalkingRunning`（步行/跑步距离）

数据样本可能是：

- **离散数据**（单次测量）
- **累积数据**（时间段内累加值）

***

## API 简介

```ts
Health.queryQuantitySamples(
  quantityType: HealthQuantityType,
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "count"
      order?: "forward" | "reverse"
    }>
  }
): Promise<Array<HealthQuantitySample | HealthCumulativeQuantitySample | HealthDiscreteQuantitySample>>
```

***

## 参数说明

| 参数名                                 | 类型        | 描述                                            |
| ----------------------------------- | --------- | --------------------------------------------- |
| `quantityType`                      | `string`  | 要查询的数据类型，如 `"stepCount"`、`"heartRate"`        |
| `startDate` / `endDate`             | `Date`    | 查询的时间范围                                       |
| `limit`                             | `number`  | 限制返回的最大样本数量                                   |
| `strictStartDate` / `strictEndDate` | `boolean` | 是否严格匹配开始/结束时间                                 |
| `sortDescriptors`                   | `Array`   | 对结果进行排序，可按 `startDate`、`endDate` 或 `count` 排序 |

***

## 示例：读取步数数据

```ts
const results = await Health.queryQuantitySamples("stepCount", {
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-02T00:00:00"),
  limit: 10,
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const sample of results) {
  const value = sample.quantityValue(HealthUnit.count())
  console.log(`步数：${value} 时间：${sample.startDate} ~ ${sample.endDate}`)
}
```

***

## 示例：读取心率数据（单位为 bpm）

```ts
const results = await Health.queryQuantitySamples("heartRate", {
  startDate: new Date(Date.now() - 3600 * 1000) // 最近一小时
})

for (const sample of results) {
  const bpm = sample.quantityValue(
    HealthUnit.count().divided(HealthUnit.minute())
  )
  console.log(`心率：${bpm} bpm 时间：${sample.startDate}`)
}
```

***

## 判断样本类型

返回的样本可能属于以下三种之一：

- `HealthQuantitySample`（基础类）
- `HealthCumulativeQuantitySample`：可调用 `.sumQuantity(unit)`
- `HealthDiscreteQuantitySample`：可调用 `.averageQuantity(unit)`、`.maximumQuantity(unit)` 等

你可以使用 `in` 操作符判断：

```ts
if ("averageQuantity" in sample) {
  const avg = sample.averageQuantity(HealthUnit.count())
  console.log("平均值：", avg)
}
```

***

## 常见类型与推荐单位

| 数据类型                       | 推荐单位                                              |
| -------------------------- | ------------------------------------------------- |
| `"stepCount"`              | `HealthUnit.count()`                              |
| `"heartRate"`              | `HealthUnit.count().divided(HealthUnit.minute())` |
| `"bodyMass"`               | `HealthUnit.gram(HealthMetricPrefix.kilo)`        |
| `"activeEnergyBurned"`     | `HealthUnit.kilocalorie()`                        |
| `"distanceWalkingRunning"` | `HealthUnit.meter()`                              |

***

## 错误处理示例

```ts
try {
  const results = await Health.queryQuantitySamples("stepCount")
  console.log("共返回样本数量：", results.length)
} catch (err) {
  console.error("查询失败：", err)
}
```

***

## 小结

读取数量型样本的流程如下：

1. 调用 `Health.queryQuantitySamples(类型, 查询参数)`
2. 遍历返回结果
3. 使用 `.quantityValue(unit)` 或 `.sumQuantity(unit)` 等方法获取数值

该 API 提供了对时间序列健康数据的强大访问能力，适用于统计、图表和趋势分析等应用场景。



---
url: /zh/guide/Device Capabilities/Health/Reading Workout Samples.md
---

# 读取锻炼数据（HealthWorkout）

Scripting 应用支持通过全局函数 `Health.queryWorkouts()` 从 HealthKit 查询**锻炼记录**。Workout 表示一次完整的身体活动，如跑步、步行、游泳、骑行、力量训练等。

每条锻炼记录包含活动类型、起止时间、持续时间、相关事件以及详细的统计信息（如心率、步数、距离、能量消耗等）。

***

## 什么是 Workout？

每条 `HealthWorkout` 锻炼记录包含以下内容：

- `startDate` / `endDate`：锻炼的起止时间
- `duration`：持续时间（单位：秒）
- `workoutActivityType`：锻炼类型（枚举值，如跑步、步行、瑜伽等）
- `metadata`：可选的附加信息
- `workoutEvents`：可选的事件数组（如暂停、继续、圈数等）
- `allStatistics`：一个包含所有健康指标统计的字典，例如心率、距离、卡路里等

***

## API 用法

```ts
Health.queryWorkouts(
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "duration"
      order?: "forward" | "reverse"
    }>
    requestPermissions?: HealthQuantityType[]
  }
): Promise<HealthWorkout[]>
```

***

## 参数说明

| 参数名                                 | 描述                                          |
| ----------------------------------- | ------------------------------------------- |
| `startDate` / `endDate`             | 用于筛选锻炼记录的时间范围（可选）                           |
| `limit`                             | 最大返回条数（可选）                                  |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间                                  |
| `sortDescriptors`                   | 按 `startDate`、`endDate` 或 `duration` 排序（可选） |
| `requestPermissions`                | 申请更多数据类型的权限（可选）                             |

***

## 示例：读取最近的锻炼记录

```ts
const workouts = await Health.queryWorkouts({
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-05"),
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const workout of workouts) {
  console.log("锻炼类型：", workout.workoutActivityType)
  console.log("开始时间：", workout.startDate)
  console.log("结束时间：", workout.endDate)
  console.log("持续时间（分钟）：", workout.duration / 60)

  const heartRate = workout.allStatistics["heartRate"]
  const energy = workout.allStatistics["activeEnergyBurned"]

  if (heartRate) {
    const avgHR = heartRate.averageQuantity(HealthUnit.count().divided(HealthUnit.minute()))
    console.log("平均心率：", avgHR)
  }

  if (energy) {
    const kcal = energy.sumQuantity(HealthUnit.kilocalorie())
    console.log("消耗能量（千卡）：", kcal)
  }

  console.log("---")
}
```

***

## 如何读取统计指标

每条锻炼记录的 `allStatistics` 字典包含该锻炼过程中的各种指标统计，例如：

```ts
const stat = workout.allStatistics["heartRate"]
const avg = stat?.averageQuantity(HealthUnit.count().divided(HealthUnit.minute()))
const max = stat?.maximumQuantity(HealthUnit.count().divided(HealthUnit.minute()))
```

常见可用指标包括：

- `"heartRate"`：心率
- `"activeEnergyBurned"`：活跃能量消耗
- `"distanceWalkingRunning"`：步行/跑步距离
- `"stepCount"`：步数

***

## Workout Events（可选事件）

如果记录了事件（如暂停、继续、圈数等），可通过 `workout.workoutEvents` 获取：

```ts
for (const event of workout.workoutEvents || []) {
  console.log("事件类型：", event.type)
  console.log("从：", event.dateInterval.start)
  console.log("到：", event.dateInterval.end)
}
```

事件类型包括：暂停（pause）、继续（resume）、圈数（lap）、分段（segment）等。

***

## 注意事项

- 每条记录都是 `HealthWorkout` 实例
- `workoutActivityType` 是一个枚举，可转换为文本或图标
- 如果 `allStatistics` 中缺少某些指标，说明设备或应用在当时未记录该数据
- 可结合分类数据（如睡眠）或数量数据（如心率）进行完整的活动分析

***

## 小结

读取 Workout 数据的步骤如下：

1. 调用 `Health.queryWorkouts(options)` 获取锻炼记录数组；
2. 可通过时间范围、数量限制、排序方式进行筛选；
3. 通过属性获取锻炼类型、时长等基本信息；
4. 使用 `allStatistics` 获取详细的健康指标；
5. 可选读取 `workoutEvents` 获取锻炼过程中的事件记录。

该 API 非常适用于展示锻炼历史、生成健身日报或绘制活动趋势图等场景。



---
url: /zh/guide/Device Capabilities/Health/Writing Health Category Samples.md
---

# 写入分类数据（HealthCategorySample）

Scripting 应用支持将分类健康数据（如睡眠状态、冥想记录、月经流量、排卵测试结果等）写入 Apple HealthKit。你可以通过 `HealthCategorySample` 类创建分类数据样本，并使用 `Health.saveCategorySample()` 方法将其保存到健康数据库中。

***

## 使用前提

- 确保设备支持 HealthKit：

  ```ts
  if (!Health.isHealthDataAvailable) {
    throw new Error("此设备不支持健康数据。")
  }
  ```

- 确保脚本具备目标分类数据类型的写入权限。Scripting 会在首次保存时自动请求授权。

***

## 一、创建 `HealthCategorySample` 实例

使用 `HealthCategorySample.create()` 方法创建分类数据样本。

### 参数说明

| 参数          | 类型                        | 描述                                                                   |
| ----------- | ------------------------- | -------------------------------------------------------------------- |
| `type`      | `HealthCategoryType`      | 要写入的分类类型，例如 `"sleepAnalysis"`、`"mindfulSession"`、`"menstrualFlow"` 等 |
| `startDate` | `Date`                    | 分类事件的开始时间                                                            |
| `endDate`   | `Date`                    | 分类事件的结束时间                                                            |
| `value`     | 对应的枚举值                    | 表示该分类状态的枚举值，需根据具体类型使用相应枚举                                            |
| `metadata`  | `Record<string, any>`（可选） | 可选的元数据，用于标记数据来源或附加信息                                                 |

### 枚举值说明

- 不同类型的分类数据需要传入不同的枚举类型：

  - 对于 `"sleepAnalysis"`，应使用 `HealthCategoryValueSleepAnalysis` 枚举，如：

    - `HealthCategoryValueSleepAnalysis.asleepCore`
    - `HealthCategoryValueSleepAnalysis.awake`

  - 对于 `"menstrualFlow"`，应使用 `HealthCategoryValueSeverity` 枚举，如：

    - `HealthCategoryValueSeverity.mild`、`moderate`、`severe`

  请参考具体分类类型所支持的枚举列表。

***

### 示例代码

```ts
const sample = HealthCategorySample.create({
  type: "sleepAnalysis",
  startDate: new Date("2025-07-03T23:00:00"),
  endDate: new Date("2025-07-04T07:00:00"),
  value: HealthCategoryValueSleepAnalysis.asleepCore,
  metadata: {
    source: "ScriptingApp"
  }
})

if (!sample) {
  throw new Error("创建 HealthCategorySample 失败")
}
```

***

## 二、保存样本到 HealthKit

使用 `Health.saveCategorySample()` 方法将创建的样本写入 HealthKit：

```ts
await Health.saveCategorySample(sample)
```

如果保存失败（如权限不足），该方法将抛出错误。

***

## 完整示例

```ts
async function writeSleepData() {
  const sample = HealthCategorySample.create({
    type: "sleepAnalysis",
    startDate: new Date("2025-07-03T23:00:00"),
    endDate: new Date("2025-07-04T07:00:00"),
    value: HealthCategoryValueSleepAnalysis.asleepCore,
  })

  if (!sample) {
    console.error("创建样本失败")
    return
  }

  try {
    await Health.saveCategorySample(sample)
    console.log("睡眠数据写入成功")
  } catch (err) {
    console.error("保存失败：", err)
  }
}

writeSleepData()
```

***

## 注意事项

- `value` 参数必须是指定 `type` 类型对应的合法枚举值，否则创建将失败。
- `startDate` 与 `endDate` 应表示事件的发生时间段，例如一次睡眠或一次冥想。
- `metadata` 是可选的，适用于添加数据来源或标识用途。



---
url: /zh/guide/Device Capabilities/Health/Writing Health Correlation Data.md
---

# 写入关联数据（HealthCorrelation）

Scripting 应用允许你使用全局 API `HealthCorrelation.create()` 和 `Health.saveCorrelation()` 向 Apple HealthKit 写入**相关健康数据**。相关数据表示多个健康样本之间的逻辑关联，例如：

- 一次血压测量同时包含收缩压和舒张压；
- 一次进食记录同时包含卡路里、蛋白质、碳水等多种营养成分。

本文档将说明如何创建和保存相关样本。

***

## 什么是 Correlation（相关数据）？

Correlation 是一种将多个健康样本聚合为一个事件的机制，目前支持以下类型：

- `"bloodPressure"`：包含 `"bloodPressureSystolic"`（收缩压）和 `"bloodPressureDiastolic"`（舒张压）两个样本
- `"food"`：可以包含热量、蛋白质、脂肪、碳水化合物等营养成分的样本

***

## 一、创建关联的 QuantitySample

在创建相关数据前，需要先创建各个组成的 `HealthQuantitySample` 实例。

### 示例：血压测量数据

```ts
const systolic = HealthQuantitySample.create({
  type: "bloodPressureSystolic",
  startDate: new Date(),
  endDate: new Date(),
  value: 120,
  unit: HealthUnit.millimeterOfMercury()
})

const diastolic = HealthQuantitySample.create({
  type: "bloodPressureDiastolic",
  startDate: new Date(),
  endDate: new Date(),
  value: 80,
  unit: HealthUnit.millimeterOfMercury()
})
```

请确保创建成功（返回值不为 `null`）后再继续。

***

## 二、创建 Correlation 实例

使用 `HealthCorrelation.create()` 创建相关数据对象。

### 参数说明

| 参数          | 类型                                                      | 描述           |   |
| ----------- | ------------------------------------------------------- | ------------ | - |
| `type`      | `"bloodPressure"` 或 `"food"`                            | 相关类型         |   |
| `startDate` | `Date`                                                  | 事件开始时间       |   |
| `endDate`   | `Date`                                                  | 事件结束时间       |   |
| `objects`   | `(HealthQuantitySample      \| HealthCategorySample)[]` | 包含的健康样本数组    |   |
| `metadata`  | `Record<string, any>`（可选）                               | 附加元数据（如来源说明） |   |

### 示例

```ts
const correlation = HealthCorrelation.create({
  type: "bloodPressure",
  startDate: systolic.startDate,
  endDate: systolic.endDate,
  objects: [systolic, diastolic],
  metadata: {
    source: "ScriptingApp"
  }
})

if (!correlation) {
  throw new Error("创建 Correlation 失败")
}
```

***

## 三、保存到 HealthKit

使用 `Health.saveCorrelation()` 将创建的相关数据写入 HealthKit：

```ts
await Health.saveCorrelation(correlation)
```

***

## 完整示例：写入一次血压记录

```ts
async function writeBloodPressure() {
  const systolic = HealthQuantitySample.create({
    type: "bloodPressureSystolic",
    startDate: new Date(),
    endDate: new Date(),
    value: 120,
    unit: HealthUnit.millimeterOfMercury()
  })

  const diastolic = HealthQuantitySample.create({
    type: "bloodPressureDiastolic",
    startDate: new Date(),
    endDate: new Date(),
    value: 80,
    unit: HealthUnit.millimeterOfMercury()
  })

  if (!systolic || !diastolic) {
    console.error("样本创建失败")
    return
  }

  const correlation = HealthCorrelation.create({
    type: "bloodPressure",
    startDate: systolic.startDate,
    endDate: systolic.endDate,
    objects: [systolic, diastolic],
    metadata: {
      note: "手动记录"
    }
  })

  if (!correlation) {
    console.error("Correlation 创建失败")
    return
  }

  try {
    await Health.saveCorrelation(correlation)
    console.log("血压数据写入成功")
  } catch (err) {
    console.error("保存失败：", err)
  }
}

writeBloodPressure()
```

***

## 注意事项

- 所有样本的时间范围（startDate / endDate）应一致或合理重叠；
- `"bloodPressure"` 类型必须包含 **收缩压** 和 **舒张压** 两个样本；
- `"food"` 类型可包含多个营养成分样本，如：

  - `"dietaryEnergyConsumed"` → `HealthUnit.kilocalorie()`
  - `"dietaryProtein"` → `HealthUnit.gram()`
  - `"dietaryCarbohydrates"` → `HealthUnit.gram()`
- 如果传入的参数不合法或缺少必要样本，`HealthCorrelation.create()` 将返回 `null`。



---
url: /zh/guide/Device Capabilities/Health/Writing Health Quantity Samples.md
---

# 写入数量型数据（HealthQuantitySample）

Scripting 应用支持将数量型健康数据（例如步数、心率、体重、卡路里等）写入 Apple 的 HealthKit。你可以使用 `HealthQuantitySample` 类创建数据样本，并通过 `Health.saveQuantitySample()` 方法保存到健康数据库中。

## 使用前提

- 确保设备支持 HealthKit：

  ```ts
  if (!Health.isHealthDataAvailable) {
    throw new Error("此设备不支持健康数据。")
  }
  ```

- 脚本需要具备对目标数据类型的写入权限。当你调用保存 API 时，Scripting 会自动检查并请求所需权限。

***

## 一、创建 `HealthQuantitySample` 实例

使用 `HealthQuantitySample.create()` 方法创建一个数量型数据样本。

### 参数说明

| 参数          | 类型                       | 描述                                                                     |
| ----------- | ------------------------ | ---------------------------------------------------------------------- |
| `type`      | `HealthQuantityType`     | 要写入的数据类型，如 `"stepCount"`（步数）、`"heartRate"`（心率）、`"bodyMass"`（体重）等       |
| `startDate` | `Date`                   | 样本的开始时间                                                                |
| `endDate`   | `Date`                   | 样本的结束时间                                                                |
| `value`     | `number`                 | 健康数据的数值                                                                |
| `unit`      | `HealthUnit`             | 数据单位，如 `HealthUnit.count()`、`HealthUnit.gram(HealthMetrixPrefix.kilo)` |
| `metadata`  | `Record<string, any>` 可选 | 元数据，例如来源信息                                                             |

### 示例

```ts
const sample = HealthQuantitySample.create({
  type: "stepCount",
  startDate: new Date("2025-07-03T08:00:00"),
  endDate: new Date("2025-07-03T09:00:00"),
  value: 1200,
  unit: HealthUnit.count(),
  metadata: {
    source: "ScriptingApp"
  }
})

if (!sample) {
  throw new Error("创建 HealthQuantitySample 失败")
}
```

***

## 二、保存样本到 HealthKit

创建完样本后，调用 `Health.saveQuantitySample()` 将其写入健康数据：

```ts
await Health.saveQuantitySample(sample)
```

如果写入失败（例如权限不足），此方法将抛出错误。

***

## 完整示例

```ts
async function writeStepCount() {
  const sample = HealthQuantitySample.create({
    type: "stepCount",
    startDate: new Date("2025-07-03T08:00:00"),
    endDate: new Date("2025-07-03T09:00:00"),
    value: 1200,
    unit: HealthUnit.count(),
  })

  if (!sample) {
    console.error("创建样本失败")
    return
  }

  try {
    await Health.saveQuantitySample(sample)
    console.log("步数数据写入成功")
  } catch (err) {
    console.error("写入失败：", err)
  }
}

writeStepCount()
```

***

## 注意事项

- 请确保 `unit` 与 `type` 类型匹配，例如：

  - `"stepCount"` → `HealthUnit.count()`
  - `"bodyMass"` → `HealthUnit.gram(HealthMetrixPrefix.kilo)`
  - `"heartRate"` → `HealthUnit.count().divided(HealthUnit.minute())`
- 对于累计类数据（如步数、距离），`startDate` 和 `endDate` 应表示数据的记录时间段。



---
url: /zh/guide/Device Capabilities/Keychain.md
---

# 钥匙串

`Keychain` 提供对系统钥匙串（Keychain）的安全访问接口，用于在 **Scripting 脚本环境中安全、持久地存储敏感数据**，典型用途包括：

- 登录凭证
- Token
- 许可证信息
- 订阅状态
- 加密密钥
- 用户隐私数据

所有数据均使用系统级 Keychain 安全机制存储，具备高安全性与持久性。

***

## 一、Keychain 的脚本作用域隔离规则

在 Scripting 中，`Keychain` 采用 **按脚本隔离（Per-Script Sandbox）** 的安全模型：

### 1. 作用域规则

- **每一个脚本拥有独立的 Keychain 作用域**

- 每个脚本 **只能访问自己写入的 Keychain 数据**

- 不同脚本之间：

- 即使 Key 名相同

- 即使 `synchronizable: true`

- 也 **无法互相读取或覆盖数据**

- 脚本被视为独立安全单元

***

### 2. 该规则的安全意义

该设计确保：

- 不同脚本之间的数据完全隔离
- 防止第三方脚本窃取用户隐私数据
- 防止恶意脚本读取登录态、订阅状态、授权信息
- 提供比系统 Keychain 更细粒度的安全隔离层

***

### 3. 脚本卸载对 Keychain 的影响

- 当脚本被删除后：

  - 该脚本作用域下的 Keychain 数据将被系统回收
- 其他脚本的数据不会受到任何影响

***

## 二、API 命名空间

```ts
namespace Keychain
```

***

## 三、支持的数据类型

`Keychain` 支持以下三种数据类型：

| 类型    | 写入        | 读取        |
| ----- | --------- | --------- |
| 字符串   | `set`     | `get`     |
| 布尔值   | `setBool` | `getBool` |
| 二进制数据 | `setData` | `getData` |

***

## 四、KeychainAccessibility 可访问性策略

```ts
type KeychainAccessibility =
  | 'passcode'
  | 'unlocked'
  | 'unlocked_this_device'
  | 'first_unlock'
  | 'first_unlock_this_device'
```

| 值                          | 说明                  |
| -------------------------- | ------------------- |
| `passcode`                 | 仅在设备设置锁屏密码时可访问，不会迁移 |
| `unlocked`                 | 仅在设备解锁状态下可访问        |
| `unlocked_this_device`     | 仅限本设备访问，不会迁移        |
| `first_unlock`             | 重启后首次解锁即可访问         |
| `first_unlock_this_device` | 重启后首次解锁即可访问，不会迁移    |

默认值：

```ts
accessibility: "unlocked"
```

***

## 五、iCloud 同步（synchronizable）

```ts
synchronizable?: boolean
```

| 值       | 说明                 |
| ------- | ------------------ |
| `true`  | 在同一 Apple ID 设备间同步 |
| `false` | 仅存储在本设备            |

默认值：

```ts
synchronizable: false
```

***

## 六、写入数据

### 1. 写入字符串

```ts
Keychain.set(key: string, value: string, options?): boolean
```

```ts
Keychain.set("token", "abcdef")
```

```ts
Keychain.set("token", "abcdef", {
  accessibility: "first_unlock",
  synchronizable: true
})
```

***

### 2. 写入布尔值

```ts
Keychain.setBool(key: string, value: boolean, options?): boolean
```

```ts
Keychain.setBool("is_login", true)
```

***

### 3. 写入二进制数据

```ts
Keychain.setData(key: string, value: Data, options?): boolean
```

```ts
Keychain.setData("avatar", imageData)
```

***

### 4. 覆盖规则

- Key 已存在时会自动覆盖
- 成功返回 `true`
- 失败返回 `false`

***

## 七、读取数据

### 字符串

```ts
Keychain.get(key: string, options?): string | null
```

### 布尔值

```ts
Keychain.getBool(key: string, options?): boolean | null
```

### 二进制数据

```ts
Keychain.getData(key: string, options?): Data | null
```

***

## 八、删除数据

```ts
Keychain.remove(key: string, options?): boolean
```

- Key 存在：删除并返回 `true`
- Key 不存在：安全返回 `true`

***

## 九、是否存在

```ts
Keychain.contains(key: string, options?): boolean
```

***

## 十、获取所有 Key

```ts
Keychain.keys(options?): string[]
```

***

## 十一、清空 Keychain

```ts
Keychain.clear(options?): boolean
```

- 仅清空当前脚本作用域内的数据
- 不影响其他脚本
- 不影响 App 自身或其他 App 的系统 Keychain 数据

***

## 十二、synchronizable 的读写一致性规则

如果某 Key 使用：

```ts
synchronizable: true
```

则后续所有操作必须带相同参数：

```ts
Keychain.set("token", "abc", { synchronizable: true })

Keychain.get("token") // 读取不到
Keychain.get("token", { synchronizable: true }) // 可读取
```

***

## 十三、安全性与使用建议

### 适合存储的数据

- 登录 Token
- 订阅与授权状态
- 用户唯一标识
- 加密密钥

### 不建议存储

- 大体积文件
- 高频变化的缓存数据
- 可公开的普通配置

***

## 十四、典型使用示例

```ts
// 写入
Keychain.set("token", "abcdef")
Keychain.setBool("is_login", true)
Keychain.setData("avatar", avatarData)

// 读取
const token = Keychain.get("token")
const isLogin = Keychain.getBool("is_login")
const avatar = Keychain.getData("avatar")

// 删除
Keychain.remove("token")

// 判断是否存在
Keychain.contains("token")

// 获取所有 Key
Keychain.keys()

// 清空
Keychain.clear()
```



---
url: /zh/guide/Device Capabilities/LocalAuth.md
---

# 本地认证

`LocalAuth` API 是一个 iOS 本地认证框架的封装，用于在 Scripting 应用的脚本中启用生物识别或密码认证。本文档介绍了如何高效使用 `LocalAuth` API。

## 概览

`LocalAuth` 模块提供了检查认证可用性和执行用户认证的方法和属性。它支持的生物识别包括 Face ID、Touch ID 和 Optic ID，并提供密码作为备选方案。

***

## 属性

### `LocalAuth.isAvailable`

- **类型：** `boolean`
- **描述：** 表示是否可以使用任何可用的认证策略进行认证。
- **示例：**
  ```tsx
  if (LocalAuth.isAvailable) {
    console.log("认证功能可用。")
  } else {
    console.log("认证功能不可用。")
  }
  ```

### `LocalAuth.isBiometricsAvailable`

- **类型：** `boolean`
- **描述：** 表示是否可以使用生物识别认证。
- **示例：**
  ```tsx
  if (LocalAuth.isBiometricsAvailable) {
    console.log("生物识别认证可用。")
  } else {
    console.log("生物识别认证不可用。")
  }
  ```

### `LocalAuth.biometryType`

- **类型：** `LocalAuthBiometryType`
- **描述：** 指定设备支持的生物识别认证类型。可能的值包括：
  - `"faceID"`
  - `"touchID"`
  - `"opticID"`
  - `"none"`
  - `"unknown"`
- **示例：**
  ```tsx
  const biometry = LocalAuth.biometryType
  console.log(`生物识别类型：${biometry}`)
  ```

***

## 方法

### `LocalAuth.authenticate(reason: string, useBiometrics?: boolean): Promise<boolean>`

- **描述：** 使用可用的生物识别或备选方法（如密码）对用户进行认证。返回一个 Promise，当认证成功时解析为 `true`，认证失败时解析为 `false`。
- **参数：**
  - `reason`（string）：向用户提示认证时显示的消息。此消息不能为空。例如：`'请认证以访问 MyScript。'`
  - `useBiometrics`（boolean，可选）：默认值为 `true`。如果为 `true`，则方法使用生物识别认证；否则，允许使用生物识别或备选方法（如密码）。
- **示例：**
  ```tsx
  async function authenticateUser() {
    const reason = "请认证以访问 MyScript。"
    const result = await LocalAuth.authenticate(reason, true)
    if (result) {
      console.log("认证成功。")
    } else {
      console.log("认证失败。")
    }
  }

  authenticateUser()
  ```

***

## 使用示例

### 检查生物识别可用性

```tsx
if (LocalAuth.isBiometricsAvailable) {
  console.log("设备支持生物识别认证。")
  console.log(`生物识别类型：${LocalAuth.biometryType}`)
} else {
  console.log("设备不支持生物识别认证。")
}
```

### 使用生物识别认证

```tsx
async function accessSecureData() {
  const authenticated = await LocalAuth.authenticate(
    "请认证以访问安全数据。"
  )
  if (authenticated) {
    console.log("访问已授权。")
  } else {
    console.log("访问被拒绝。")
  }
}

accessSecureData()
```

### 回退到密码认证

```tsx
async function authenticateWithFallback() {
  const authenticated = await LocalAuth.authenticate(
    "请认证以继续。",
    false // 允许生物识别或密码认证
  )
  console.log(authenticated ? "认证成功" : "认证失败")
}

authenticateWithFallback()
```

***

## 注意事项

- 始终在 `reason` 参数中提供有意义的消息，帮助用户理解为什么需要认证。
- 在调用 `LocalAuth.authenticate` 之前，使用 `LocalAuth.isAvailable` 和 `LocalAuth.isBiometricsAvailable` 检查认证选项的可用性。
- 优雅地处理认证成功和失败的情况，为用户提供无缝体验。



---
url: /zh/guide/Device Capabilities/Location.md
---

# 定位

全局 `Location` API 提供对设备地理位置信息的访问能力，包括一次性定位、逆地理编码、用户手动选点、定位精度控制、以及用于小组件的权限检测等功能。

***

## 功能概览

你可以通过该 API 实现以下功能：

- 获取设备当前位置（支持缓存）
- 用户通过地图界面手动选择位置
- 将经纬度转换为可读的地址（逆地理编码）
- 设置定位精度（耗电量和等待时间可控）
- 检查小组件是否获得定位权限

> **注意：** 该 API 为全局 API，无需额外导入。

***

## 接口文档

### `Location.isAuthorizedForWidgetUpdates(): Promise<boolean>`

检查小组件是否拥有获取定位更新的权限。

```ts
const isAuthorized = await Location.isAuthorizedForWidgetUpdates()
if (!isAuthorized) {
  console.log("小组件没有获取定位的权限")
}
```

***

### `Location.setAccuracy(accuracy: LocationAccuracy): Promise<void>`

设置期望的定位精度。精度越高，耗电和等待时间也可能增加。

#### 可选值

| 精度值                 | 描述      |
| ------------------- | ------- |
| `"best"`            | 最高可用精度  |
| `"tenMeters"`       | 10 米以内  |
| `"hundredMeters"`   | 100 米以内 |
| `"kilometer"`       | 1 公里以内  |
| `"threeKilometers"` | 3 公里以内  |

```ts
await Location.setAccuracy("hundredMeters")
```

***

### `Location.requestCurrent(options?: { forceRequest?: boolean }): Promise<LocationInfo | null>`

请求一次设备当前的位置信息。

默认情况下，如果存在缓存位置（例如启动时从系统获取到的位置），将立即返回该缓存值。如果未缓存，则会触发新的定位请求。

你可以通过传入 `{ forceRequest: true }` 强制跳过缓存，始终发起新请求。

#### 参数

| 参数名            | 类型        | 是否必填 | 描述                          |
| -------------- | --------- | ---- | --------------------------- |
| `forceRequest` | `boolean` | 否    | 若为 `true`，将忽略缓存，始终发起新的定位请求。 |

```ts
const location = await Location.requestCurrent({ forceRequest: true })
if (location) {
  console.log("纬度:", location.latitude)
  console.log("经度:", location.longitude)
  console.log("时间戳:", location.timestamp)
}
```

***

### `Location.pickFromMap(): Promise<LocationInfo | null>`

打开内置地图界面，允许用户手动选择一个位置。

```ts
const selected = await Location.pickFromMap()
if (selected) {
  console.log("用户选择的位置:", selected.latitude, selected.longitude)
}
```

***

### `Location.reverseGeocode(options): Promise<LocationPlacemark[] | null>`

将经纬度转换为人类可读的地理信息（如街道、城市、国家等）。

#### 参数

| 字段          | 类型       | 是否必填 | 描述                             |
| ----------- | -------- | ---- | ------------------------------ |
| `latitude`  | `number` | 是    | 纬度（单位：度）                       |
| `longitude` | `number` | 是    | 经度（单位：度）                       |
| `locale`    | `string` | 否    | 可选语言区域（如 `"zh-CN"`），默认使用设备语言设置 |

```ts
const placemarks = await Location.reverseGeocode({
  latitude: 31.2304,
  longitude: 121.4737,
  locale: "zh-CN"
})

if (placemarks?.length) {
  const place = placemarks[0]
  console.log("城市:", place.locality)
  console.log("国家:", place.country)
}
```

***

## 类型定义

### `LocationAccuracy`

表示定位精度选项：

```ts
type LocationAccuracy =
  | "best"
  | "tenMeters"
  | "hundredMeters"
  | "kilometer"
  | "threeKilometers"
```

***

### `LocationInfo`

表示一个带有时间戳的地理坐标点：

```ts
type LocationInfo = {
  /**
   * 纬度，单位：度
   */
  latitude: number
  /**
   * 经度，单位：度
   */
  longitude: number
  /**
   * 获取该位置的时间戳（单位：毫秒）
   */
  timestamp: number
}
```

***

### `LocationPlacemark`

表示一个可读的地理位置，通常由逆地理编码返回，包含详细的地址结构信息：

```ts
type LocationPlacemark = {
  location?: LocationInfo
  region?: string
  timeZone?: string
  name?: string
  thoroughfare?: string
  subThoroughfare?: string
  locality?: string
  subLocality?: string
  administrativeArea?: string
  subAdministrativeArea?: string
  postalCode?: string
  isoCountryCode?: string
  country?: string
  inlandWater?: string
  ocean?: string
  areasOfInterest?: string[]
}
```

#### 字段说明

| 字段                      | 类型             | 描述                                |
| ----------------------- | -------------- | --------------------------------- |
| `location`              | `LocationInfo` | 坐标点信息（通常等于请求的经纬度）                 |
| `region`                | `string`       | 区域名，如省/州                          |
| `timeZone`              | `string`       | 时区标识（如 `"Asia/Shanghai"`）         |
| `name`                  | `string`       | 地点名称，如建筑物、地标等                     |
| `thoroughfare`          | `string`       | 街道名称，如 `"中关村大街"`                  |
| `subThoroughfare`       | `string`       | 详细地址，如门牌号                         |
| `locality`              | `string`       | 城市或镇                              |
| `subLocality`           | `string`       | 区、街道等子区域                          |
| `administrativeArea`    | `string`       | 省份、州或其他一级行政区域                     |
| `subAdministrativeArea` | `string`       | 县、区等次级行政区域                        |
| `postalCode`            | `string`       | 邮政编码                              |
| `isoCountryCode`        | `string`       | 国家代码（ISO 3166-1 alpha-2，如 `"CN"`） |
| `country`               | `string`       | 国家全名，如 `"中国"`                     |
| `inlandWater`           | `string`       | 附近的内陆水体名称，如湖泊、河流                  |
| `ocean`                 | `string`       | 附近的海洋名称                           |
| `areasOfInterest`       | `string[]`     | 附近的兴趣点/地标数组，如 `"东方明珠"`            |

***

## 示例用法

### 逆地理编码

```ts
const placemarks = await Location.reverseGeocode({
  latitude: 39.9042,
  longitude: 116.4074,
  locale: "zh-CN"
})

if (placemarks?.length) {
  const place = placemarks[0]
  console.log("国家:", place.country)
  console.log("城市:", place.locality)
  console.log("街道:", place.thoroughfare, place.subThoroughfare)
  console.log("地标名称:", place.name)
  console.log("邮编:", place.postalCode)
  console.log("兴趣点:", place.areasOfInterest?.join(", "))
}
```

***

### 地址格式化工具

```ts
function formatAddress(p: LocationPlacemark): string {
  return [
    p.country,
    p.administrativeArea,
    p.locality,
    p.subLocality,
    p.thoroughfare,
    p.subThoroughfare
  ].filter(Boolean).join(", ")
}
```

***

## 最佳实践与使用建议

- 使用 `areasOfInterest` 和 `name` 显示更友好的位置信息（如地标名）
- 使用 `postalCode`、`locality`、`administrativeArea` 自动填写表单或记录标签
- 使用 `timestamp` 判断位置数据是否新鲜
- 使用 `timeZone` 进行本地时间转换或事件提醒
- 在调用 `requestCurrent` 前使用 `setAccuracy` 控制精度
- 对小组件使用 `isAuthorizedForWidgetUpdates()` 检查权限

***

## 说明

- 逆地理编码可能返回多个结果，通常第一个最相关
- 若获取失败，API 将返回 `null`
- 若未强制刷新，系统会优先使用缓存位置，响应更快
- 小组件受限于系统权限机制，务必检测权限状态



---
url: /zh/guide/Device Capabilities/MediaComposer/MediaComposer Example.md
---

# MediaComposer 示例

本示例演示如何使用 `MediaComposer` 将 **视频 + 图片 + 音频** 组合成一个最终视频文件，并导出到脚本目录中。

示例流程包括：

1. 选择音频文件
2. 选择一张图片
3. 选择一个视频
4. 构建视频时间线（Video + Image）
5. 在指定时间点插入音频
6. 导出合成后的视频

***

## 示例代码

```tsx
import { Path, Script } from "scripting"

console.present().then(() => Script.exit())

async function run() {
  try {

    const audioPath = (await DocumentPicker.pickFiles({
      types: ["public.audio"]
    })).at(0)

    if (audioPath == null) {
      console.error("no audio")
      return
    }

    console.log("Audio Picked")

    const imageResult = (await Photos.pick({
      filter: PHPickerFilter.images()
    })).at(0)

    const imagePath = await imageResult?.itemProvider.loadFilePath("public.image")

    if (!imagePath) {
      console.log("No image")
      return
    }

    console.log("Image picked")

    const videoResult = (await Photos.pick({
      filter: PHPickerFilter.videos()
    })).at(0)

    const videoPath = await videoResult?.itemProvider.loadFilePath("public.movie")

    if (videoPath == null) {
      console.log("No video")
      return
    }

    console.log("Video Picked")

    console.log("Start composing...")

    const exportPath = Path.join(
      Script.directory,
      "dest.mp4"
    )

    const exportResult = await MediaComposer.composeAndExport({
      exportPath,
      timeline: {
        videoItems: [{
          videoPath: videoPath
        }, {
          imagePath: imagePath,
          duration: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }],
        audioClips: [{
          path: audioPath,
          at: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }]
      }
    })

    console.log(
      "Result:",
      exportResult.exportPath,
      "\n",
      exportResult.duration.getSeconds()
    )

  } catch (e) {
    console.error(e)
  }
}

run()
```

***

## 时间线解析

### 视频 / 图片时间线（videoItems）

```ts
videoItems: [
  { videoPath },
  {
    imagePath,
    duration: MediaTime.make({
      seconds: 5,
      preferredTimescale: 600
    })
  }
]
```

- 第一个 `VideoItem` 是完整视频
- 第二个 `VideoItem` 是一张图片，显示 5 秒
- 所有 `videoItems` **按顺序依次拼接**
- 最终视频总时长 = 视频时长 + 图片 5 秒

***

### 音频时间线（audioClips）

```ts
audioClips: [{
  path: audioPath,
  at: MediaTime.make({
    seconds: 5,
    preferredTimescale: 600
  })
}]
```

- 音频在最终视频的 **第 5 秒开始播放**
- 不指定 `at` 时，音频会顺序接在前一个外部音频之后
- 音频不会影响最终视频时长

***

## 导出结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- `exportPath`：导出文件的完整路径
- `duration`：最终视频时长（仅由 `videoItems` 决定）

***

## 常见错误与边界情况

### 1. ImageClip 未指定 duration

```ts
{
  imagePath: "...",
  //  缺少 duration
}
```

**问题：**

- ImageClip 没有天然时长
- 不指定 `duration` 会导致合成失败

**解决方案：**

- 必须显式提供 `MediaTime`

***

### 2. 使用浮点秒数而非 MediaTime

```ts
// 错误
at: 5
```

**正确做法：**

```ts
at: MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

MediaComposer 中 **所有时间必须使用 MediaTime**。

***

### 3. 混合不同 timescale 导致精度问题

**问题：**

- 不同音视频资源使用不同 timescale
- 在剪辑、拼接、淡入淡出时可能出现边界误差

**建议：**

- 在脚本中统一使用 `preferredTimescale: 600`
- 对外部时间先做 `convertScale`

***

### 4. 音频超出视频范围

**行为说明：**

- 音频即使超过视频末尾，也不会延长最终视频
- 超出部分会被自动截断

***

### 5. 同时存在视频原音与外部音频但音量异常

**原因：**

- 默认情况下，外部音频与视频原音会同时混合
- 未配置 ducking 时，可能出现人声被盖住的问题

***

## 音频 Ducking 行为说明

### 什么是 Ducking

Ducking 指的是：

> 当视频原音（如人声）存在时，自动降低外部音频（如背景音乐）的音量

***

### Ducking 配置

```ts
exportOptions: {
  ducking: {
    enabled: true,
    duckedVolume: 0.25,
    attackSeconds: 0.15,
    releaseSeconds: 0.25
  }
}
```

#### 参数说明

- **enabled**
  是否启用 ducking，默认 `true`

- **duckedVolume**
  被压低后的外部音频音量（0…1）

- **attackSeconds**
  在视频原音开始前，音量下降的过渡时间

- **releaseSeconds**
  在视频原音结束后，音量恢复的过渡时间

***

### Ducking 生效条件

Ducking 仅在以下条件同时满足时生效：

1. `VideoClip.keepOriginalAudio === true`
2. 存在外部 `audioClips`
3. `exportOptions.ducking.enabled !== false`

***

## 音频混音规则总结

1. **视频原音**

   - 只有在 `keepOriginalAudio: true` 时才参与混音

2. **外部音频**

   - 可指定时间点或顺序拼接
   - 可设置 `volume`、`fade`、`loopToFitVideoDuration`

3. **最终混音顺序**

   - 所有音频会被混合到单一音轨
   - 不会改变视频时长
   - Ducking 在混音阶段自动应用



---
url: /zh/guide/Device Capabilities/MediaComposer/MediaTime.md
---

# MediaTime

`MediaTime` 用于表示音视频处理中的**精确时间点或时间长度**，是 Scripting 中 MediaComposer 时间系统的基础类型。
它在语义上对应于底层媒体框架中的“带时间基准的时间值”（如 AVFoundation 的 `CMTime`），但对脚本侧提供了更安全、可读、可计算的抽象。

`MediaTime` 既可以表示**确定的数值时间**，也可以表示**无效、无限或不确定时间**，并支持严格的时间运算与比较。

***

## 核心特性

- 使用 **value + timescale** 或 **seconds + preferredTimescale** 精确构造时间
- 支持时间缩放（convertScale）及多种舍入策略
- 支持加减运算与大小比较
- 明确区分有效时间、无效时间、无限时间和不确定时间
- 适用于时间线计算、剪辑、对齐、放置（at）、淡入淡出等所有时间相关场景

***

## 时间精度模型

`MediaTime` 的底层模型基于以下概念：

- **value**：整数时间值
- **timescale**：每秒的时间单位数
  例如：

  - `value = 300`, `timescale = 600` 表示 0.5 秒
  - `value = 18000`, `timescale = 600` 表示 30 秒

通过 timescale，`MediaTime` 可以精确表达帧级或采样级时间，而不依赖浮点数。

***

## 只读属性

### secondes

```ts
readonly secondes: number
```

当前时间对应的秒数（浮点数形式）。
这是一个**派生值**，主要用于展示或调试，不建议用于时间计算。

***

### isValid

```ts
readonly isValid: boolean
```

表示该时间是否是一个有效、可用于计算的时间值。
当时间为 `invalid`、`indefinite` 或无穷大时，该值为 `false`。

***

### isPositiveInfinity / isNegativeInfinity

```ts
readonly isPositiveInfinity: boolean
readonly isNegativeInfinity: boolean
```

表示该时间是否为正无穷或负无穷。
常用于内部边界标记或时间线计算中的极值判断。

***

### isIndefinite

```ts
readonly isIndefinite: boolean
```

表示该时间是否为“不确定时间”。
通常用于尚未解析出真实时长的媒体资源。

***

### isNumeric

```ts
readonly isNumeric: boolean
```

表示该时间是否是一个可参与数值计算的时间。
只有在该值为 `true` 时，才应进行加减或比较操作。

***

### hasBeenRounded

```ts
readonly hasBeenRounded: boolean
```

表示该时间是否在构造或转换过程中发生过舍入。
对于帧精度或采样精度要求较高的场景，该属性可用于调试或验证。

***

## 时间转换

### convertScale

```ts
convertScale(newTimescale: number, method: MediaTimeRoundingMethod): MediaTime
```

将当前时间转换为新的 timescale，并使用指定的舍入策略。

**典型用途：**

- 对齐视频帧时间（如 600、90000）
- 对齐音频采样时间（如 44100、48000）
- 避免不同时间基准混用导致的误差

***

## 时间值获取

### getSeconds

```ts
getSeconds(): number
```

返回当前时间对应的秒数（浮点数）。
该方法等价于读取 `secondes`，但在语义上更明确。

***

## 时间运算

### plus / minus

```ts
plus(other: MediaItem): MediaItem
minus(other: MediaItem): MediaItem
```

执行时间加法或减法运算，返回新的 `MediaTime`。

- 运算双方必须为可计算时间
- 不会修改原对象
- 运算结果遵循内部时间基准规则

***

## 时间比较

```ts
lt(other: MediaItem): boolean
gt(other: MediaItem): boolean
lte(other: MediaItem): boolean
gte(other: MediaItem): boolean
eq(other: MediaItem): boolean
neq(other: MediaItem): boolean
```

用于比较两个时间的大小或相等性。

- 支持严格比较
- 对无效或非数值时间的比较结果是确定性的
- 推荐在进行时间线排序、裁剪判断、边界检测时使用

***

## 静态构造方法

### make

```ts
static make(options: {
  value: number
  timescale: number
} | {
  seconds: number
  preferredTimescale: number
}): MediaTime
```

用于创建一个 `MediaTime` 实例。

#### 使用 value + timescale

```ts
MediaTime.make({
  value: 300,
  timescale: 600
})
```

适用于需要精确控制时间单位的场景。

#### 使用 seconds + preferredTimescale

```ts
MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

适用于脚本层以“秒”为主的时间描述方式。

***

### zero

```ts
static zero(): MediaTime
```

返回一个表示 **0 秒** 的时间。

***

### invalid

```ts
static invalid(): MediaTime
```

返回一个无效时间。
用于显式表示错误、缺失或不可用的时间值。

***

### indefinite

```ts
static indefinite(): MediaTime
```

返回一个不确定时间。
通常用于媒体尚未加载完成、时长未知的状态。

***

### positiveInfinity / negativeInfinity

```ts
static positiveInfinity(): MediaTime
static negativeInfinity(): MediaTime
```

返回正无穷或负无穷时间。
主要用于内部时间线边界控制，不建议在普通脚本逻辑中使用。

***

## 使用建议与注意事项

- **避免直接使用浮点秒数进行时间计算**，应始终使用 `MediaTime`
- 不同媒体资源可能使用不同的 timescale，必要时显式调用 `convertScale`
- 在比较或运算前，建议检查 `isNumeric`
- 在构建时间线（如 `at`、`sourceTimeRange`）时，统一 timescale 可减少误差

***

## 在 MediaComposer 中的典型用途

- 指定音频或视频片段的放置时间（`AudioClip.at`）
- 定义剪辑的起点与时长（`TimeRange`）
- 计算最终导出视频的精确时长
- 控制淡入淡出、对齐、循环等时间行为



---
url: /zh/guide/Device Capabilities/MediaComposer/Quick Start.md
---

# 快速开始

`MediaComposer` 用于在 Scripting 中 **组合视频、图片与音频时间线并导出最终媒体文件**。
它封装了一套稳定的时间线模型，支持视频剪辑、图片片段、音频叠加、淡入淡出、音频 ducking、导出参数控制等高级能力。

该模块适用于：

- 视频与图片混合生成短片
- 给视频添加背景音乐、配音或音效
- 使用图片序列生成视频
- 自动化视频处理与内容生成脚本

***

## 设计概览

MediaComposer 的核心由三部分组成：

1. **时间模型**
   使用 `MediaTime` / `TimeRange` 精确描述时间点与时长

2. **时间线模型**

   - `VideoItem[]`：视频或图片片段（顺序拼接）
   - `AudioClip[]`：音频轨道（可指定时间点或自动顺序放置）

3. **导出系统**
   通过统一的 `composeAndExport` 接口完成渲染与导出

***

## 时间线结构

```ts
timeline: {
  videoItems: VideoItem[]
  audioClips: AudioClip[]
}
```

- **videoItems**
  定义视觉时间线，视频与图片会严格按数组顺序依次排列
- **audioClips**
  定义音频时间线，可自由指定放置时间（`at`），或顺序追加

最终导出的视频时长由 **videoItems 决定**。

***

## VideoItem

```ts
type VideoItem = XOR<VideoClip, ImageClip>
```

`VideoItem` 表示时间线中的一个“视觉片段”，可以是 **视频** 或 **图片**，但不能同时是两者。

***

## VideoClip（视频片段）

```ts
type VideoClip = {
  videoPath: string
  sourceTimeRange?: TimeRange | null
  keepOriginalAudio?: boolean
  fade?: FadeConfig | null
}
```

### videoPath

- 视频文件路径
- 支持本地视频文件

***

### sourceTimeRange

```ts
sourceTimeRange?: TimeRange | null
```

- 指定从源视频中使用的时间范围
- 不提供时，默认使用整个视频

**常见用途：**

- 裁剪视频片段
- 只取某一段作为素材

***

### keepOriginalAudio

```ts
keepOriginalAudio?: boolean
```

- 是否保留视频自带的音频
- 默认值：`false`

**说明：**

- 为 `true` 时，视频原音会参与混音
- 可与外部 `audioClips` 同时存在
- 是否对外部音频进行 ducking 由 `ExportOptions.ducking` 控制

***

### fade

```ts
fade?: FadeConfig | null
```

- 视频片段的淡入淡出配置
- 会覆盖全局视频淡入淡出设置（如果存在）

***

## ImageClip（图片片段）

```ts
type ImageClip = {
  imagePath: string
  duration: MediaTime
  contentMode?: "fit" | "crop"
  backgroundColor?: Color
  fade?: FadeConfig | null
}
```

`ImageClip` 用于将一张静态图片作为视频时间线中的一个片段。

***

### imagePath

- 图片文件路径
- 支持常见图片格式（JPEG / PNG / HEIC 等）

***

### duration

```ts
duration: MediaTime
```

- 图片片段在视频中的显示时长
- 必须显式指定

***

### contentMode

```ts
contentMode?: "fit" | "crop"
```

- 控制图片如何适配渲染尺寸
- 默认值：`fit`

说明：

- `fit`：完整显示图片，可能留黑边
- `crop`：填满画面，超出部分裁剪

***

### backgroundColor

```ts
backgroundColor?: Color
```

- 图片未覆盖区域的背景色
- 通常与 `fit` 模式搭配使用

***

### fade

```ts
fade?: FadeConfig | null
```

- 图片片段的淡入淡出配置
- 支持与视频片段统一使用

***

## AudioClip（音频片段）

```ts
type AudioClip = {
  path: string
  sourceTimeRange?: TimeRange | null
  at?: MediaTime
  volume?: number
  fade?: FadeConfig | null
  loopToFitVideoDuration?: boolean
}
```

音频片段用于在最终视频中添加背景音乐、配音或音效。

***

### path

- 音频文件路径

***

### sourceTimeRange

- 指定使用音频的某一时间段
- 默认使用整个音频文件

***

### at

```ts
at?: MediaTime
```

- 指定音频在最终时间线中的放置时间
- 不指定时：

  - 按顺序接在前一个外部音频片段之后

***

### volume

```ts
volume?: number
```

- 单个音频片段的音量（0…1）
- 默认值：1

***

### fade

- 音频淡入淡出配置
- 常用于背景音乐的自然过渡

***

### loopToFitVideoDuration

```ts
loopToFitVideoDuration?: boolean
```

- 是否循环音频以匹配视频总时长
- 常用于背景音乐

***

## FadeConfig（淡入淡出）

```ts
type FadeConfig = {
  fadeInSeconds?: number
  fadeOutSeconds?: number
}
```

- 单位：秒
- 可用于视频、图片、音频
- 未指定时默认为 0

***

## ExportOptions（导出配置）

```ts
type ExportOptions = {
  renderSize?: Size
  frameRate?: number
  scaleMode?: VideoScaleMode
  globalVideoFade?: FadeConfig | null
  externalAudioBaseVolume?: number
  ducking?: DuckingConfig
  presetName?: ExportPreset
  outputFileType?: ExportFileType
}
```

### 常用说明

- **renderSize**
  最终视频分辨率，默认 1080×1920

- **frameRate**
  渲染帧率，默认 30

- **globalVideoFade**
  全局视频淡入淡出（可被单个 clip 覆盖）

- **ducking**
  当视频存在原音时，自动降低外部音频音量

- **presetName / outputFileType**
  控制编码质量与文件格式

***

## composeAndExport

```ts
function composeAndExport(options: {
  exportPath: string
  timeline: {
    videoItems: VideoItem[]
    audioClips: AudioClip[]
  }
  exportOptions?: ExportOptions
  overwrite?: boolean
}): Promise<{
  exportPath: string
  duration: MediaTime
}>
```

### 参数说明

- **exportPath**
  导出文件路径

- **timeline.videoItems**
  视频 / 图片时间线（顺序执行）

- **timeline.audioClips**
  音频时间线（可自由放置）

- **exportOptions**
  导出配置，可选

- **overwrite**
  是否覆盖已有文件，默认 `true`

***

### 返回结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- **exportPath**：最终导出路径
- **duration**：最终视频时长（由 videoItems 决定）

***

## 使用建议与最佳实践

- 始终使用 `MediaTime` 描述时间，避免直接使用浮点秒数
- 图片片段必须显式指定 `duration`
- 音频与视频的时间线是 **独立但最终混合** 的
- 对复杂项目，建议统一 timescale（如 600）
- 背景音乐推荐使用 `loopToFitVideoDuration`

***

## 典型使用场景

- 图片 + 视频混合短片
- 自动生成带背景音乐的视频
- 视频剪辑与配音合成
- 内容创作与自动化视频生成



---
url: /zh/guide/Device Capabilities/MediaPlayer.md
---

# 媒体播放器

`MediaPlayer` API 允许与 **Now Playing Center** 交互，管理 **Now Playing Info**，并响应远程控制事件。以下是使用指南、最佳实践及示例。

***

## 入门指南

`MediaPlayer` API 提供对媒体播放信息的控制及远程命令处理。入门步骤如下：

1. 设置 `nowPlayingInfo`，用于显示当前媒体信息。
2. 使用 `setAvailableCommands()` 配置可用的命令。
3. 注册 `commandHandler`，以响应远程事件。

```typescript
MediaPlayer.nowPlayingInfo = {
  title: "歌曲标题",
  artist: "艺术家",
  playbackRate: 1.0,
  elapsedPlaybackTime: 30,
  playbackDuration: 240
}

MediaPlayer.setAvailableCommands(["play", "pause", "nextTrack", "previousTrack"])

MediaPlayer.commandHandler = (command, event) => {
  console.log(`收到命令: ${command}`)
}
```

***

## API 参考

### `nowPlayingInfo`

`nowPlayingInfo` 对象显示当前播放媒体的元数据。将其设置为 `null` 可清除 Now Playing Info Center。

**属性：**

- **`title`**: `string` （必需）\
  媒体标题。
- **`artist`**: `string` （可选）\
  媒体艺术家或表演者。
- **`albumTitle`**: `string` （可选）\
  专辑标题。
- **`artwork`**: `UIImage` （可选）\
  媒体封面图片。
- **`mediaType`**: `MediaType` （可选）\
  默认值为 `audio`。
- **`playbackRate`**: `number` （可选）\
  当前播放速度，默认为 `0`。
- **`elapsedPlaybackTime`**: `DurationInSeconds` （可选）\
  当前播放时间，默认为 `0`。
- **`playbackDuration`**: `DurationInSeconds` （可选）\
  媒体总时长，默认为 `0`。

***

### 播放状态

`playbackState` 属性指示应用的当前播放状态：

- **`unknown`**: 默认状态，播放状态未定义。
- **`playing`**: 正在播放。
- **`paused`**: 播放已暂停。
- **`stopped`**: 播放已停止。
- **`interrupted`**: 播放被外部事件中断。

```typescript
if (MediaPlayer.playbackState === MediaPlayerPlaybackState.playing) {
    console.log("媒体正在播放")
}
```

***

### 命令与事件处理

#### `setAvailableCommands(commands: MediaPlayerRemoteCommand[])`

指定用户可交互的远程命令。

**示例：**

```typescript
MediaPlayer.setAvailableCommands(["play", "pause", "stop", "nextTrack"])
```

#### `commandHandler`

回调函数，用于处理远程命令。注册此函数以处理命令（如 `play`、`pause` 或 `seekBackward`）。

**示例：**

```typescript
MediaPlayer.commandHandler = (command, event) => {
  switch (command) {
    case "play":
      console.log("收到播放命令")
      break
    case "pause":
      console.log("收到暂停命令")
      break
    default:
      console.log(`未处理的命令: ${command}`)
  }
}
```

**支持的命令：**

- `play`、`pause`、`stop`、`nextTrack`、`previousTrack`
- `seekBackward`、`seekForward`、`skipBackward`、`skipForward`
- `rating`、`like`、`dislike`、`bookmark`
- `changeRepeatMode`、`changeShuffleMode`
- `enableLanguageOption`、`disableLanguageOption`

***

## 常见用例

### 显示 Now Playing 信息

```typescript
MediaPlayer.nowPlayingInfo = {
  title: "播客集数",
  artist: "主持人",
  elapsedPlaybackTime: 120,
  playbackDuration: 1800,
  playbackRate: 1.0
}
```

### 响应播放命令

```typescript
MediaPlayer.setAvailableCommands(["play", "pause", "stop"])

MediaPlayer.commandHandler = (command, event) => {
  if (command === "play") {
    console.log("开始播放")
  } else if (command === "pause") {
    console.log("暂停播放")
  }
}
```

### 处理自定义事件

```typescript
MediaPlayer.commandHandler = (command, event) => {
  if (command === "seekForward") {
    const seekEvent = event as MediaPlayerSeekCommandEvent
    console.log(`Seek 事件类型: ${seekEvent.type}`)
  }
}
```

***

## 最佳实践

1. **保持元数据最新**：在播放状态变化时更新 `nowPlayingInfo`。
2. **处理所有相关命令**：确保支持用户交互（如跳转或快进）。
3. **资源管理**：播放停止时清除 `nowPlayingInfo`，避免显示过期信息。
4. **使用外部设备测试**：通过耳机或车载系统验证命令处理。
5. **提供用户反馈**：在命令响应中提示成功或失败。

***

## 完整示例

以下是 `MediaPlayer` 的完整实现：

```typescript
// 设置 Now Playing 信息
MediaPlayer.nowPlayingInfo = {
  title: "歌曲标题",
  artist: "艺术家",
  albumTitle: "专辑名称",
  playbackRate: 1.0,
  elapsedPlaybackTime: 0,
  playbackDuration: 300
}

// 启用命令
MediaPlayer.setAvailableCommands(["play", "pause", "nextTrack", "previousTrack", "seekForward", "seekBackward"])

// 处理命令
MediaPlayer.commandHandler = (command, event) => {
  switch (command) {
    case "play":
      console.log("开始播放")
      break
    case "pause":
      console.log("暂停播放")
      break
    case "nextTrack":
      console.log("跳到下一曲")
      break
    case "seekForward":
      const seekEvent = event as MediaPlayerSeekCommandEvent
      console.log(`Seek 事件: ${seekEvent.type}`)
      break
    default:
      console.log(`未处理的命令: ${command}`)
  }
}
```



---
url: /zh/guide/Device Capabilities/Notification/index.md
---

# 通知

Scripting App 中的 `Notification` 模块用于安排、管理和展示本地通知，支持多种触发方式、交互操作按钮和富交互界面（自定义 UI）。

***

## 目录

1. [安排通知](#安排通知)
2. [通知触发器](#通知触发器)

   - [TimeIntervalNotificationTrigger](#timeintervalnotificationtrigger)
   - [CalendarNotificationTrigger](#calendarnotificationtrigger)
   - [LocationNotificationTrigger](#locationnotificationtrigger)
3. [通知操作按钮](#通知操作按钮)
4. [富通知（自定义 UI）](#富通知自定义-ui)
5. [通知管理](#通知管理)
6. [通知信息与请求结构](#通知信息与请求结构)
7. [完整示例](#完整示例)

***

## 安排通知

使用 `Notification.schedule` 来安排本地通知。它支持标题、触发器、点击行为、操作按钮、自定义 UI 和其他投递选项：

```ts
await Notification.schedule({
  title: "提醒事项",
  body: "该起身活动了！",
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 1800,
    repeats: true
  }),
  actions: [
    {
      title: "我知道了",
      icon: "checkmark",
      url: Script.createRunURLScheme("确认脚本", { acknowledged: true })
    }
  ],
  tapAction: {
    type: "runScript",
    scriptName: "确认脚本"
  },
  customUI: false
})
```

### 参数说明

| 参数名                 | 类型                                                                                                            | 说明                                          |
| ------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| `title`             | `string`                                                                                                      | 必填，通知标题。                                    |
| `subtitle`          | `string?`                                                                                                     | 可选，副标题内容。                                   |
| `body`              | `string?`                                                                                                     | 可选，正文内容。                                    |
| `iconImageData`     | `Data` \| `SystemImageIcon` \| `null`                                                                         | 可选，自定义通知图标图片的二进制数据或系统图标名称。                  |
| `badge`             | `number?`                                                                                                     | 可选，应用图标角标数字。                                |
| `silent`            | `boolean?`                                                                                                    | 可选，默认为 `false`。设为 `true` 则不播放声音静默送达。        |
| `interruptionLevel` | `"active"` \| `"passive"` \| `"timeSensitive"`                                                                | 可选，通知的重要级别和投递优先级。                           |
| `userInfo`          | `Record<string, any>?`                                                                                        | 可选，附加的自定义数据。                                |
| `threadIdentifier`  | `string?`                                                                                                     | 可选，用于通知分组的标识符。                              |
| `trigger`           | `TimeIntervalNotificationTrigger` \| `CalendarNotificationTrigger` \| `LocationNotificationTrigger` \| `null` | 可选，定义何时发送通知。                                |
| `actions`           | `NotificationAction[]?`                                                                                       | 可选，通知展开后展示的操作按钮。                            |
| `customUI`          | `boolean?`                                                                                                    | 可选，设为 `true` 可使用 `notification.tsx` 自定义 UI。 |
| `tapAction`         | `"none"` \| `{ type: "runScript", scriptName: string }` \| `{ type: "openURL", url: string }`                 | 可选，定义用户点击通知时执行的操作。                          |

#### SystemImageIcon

```ts
type SystemImageIcon = {
  systemImage: string
  color: Color
}
```

用于定义通知图标的系统图标名称和颜色。

- `systemImage`: 系统图标（SFSymbol）名称
- `color`: 图标颜色

***

### 通知操作按钮（`actions`）

通过 `actions` 参数，你可以为通知添加操作按钮。操作按钮会在通知展开后出现，用户可以点击进行操作。

#### 通知操作按钮类型（`NotificationAction`）

```ts
type NotificationAction = {
    title: string;
    icon?: string;
    url: string;
    destructive?: boolean;
}
```

- `title`: 按钮标题
- `icon`: 按钮图标
- `url`: 点击后打开的 URL
- `destructive`: 是否为破坏性操作

***

### 点击行为（`tapAction`）

通过 `tapAction` 参数，你可以完全控制用户**点击通知**时的行为：

- `"none"`：点击后无任何响应
- `{ type: "runScript", scriptName: string }`：运行指定脚本
- `{ type: "openURL", url: string }`：打开指定 URL，可为 deeplink 或 https 链接

如果不设置 `tapAction`，默认行为是运行**当前脚本**，你可以通过 `Notification.current` 获取通知内容。

***

## 通知触发器

### TimeIntervalNotificationTrigger

在指定秒数后触发通知：

```ts
new TimeIntervalNotificationTrigger({
  timeInterval: 3600,
  repeats: true
})
```

- `timeInterval`: 延迟秒数
- `repeats`: 是否重复触发
- `nextTriggerDate()`: 返回下次预期触发的时间

***

### CalendarNotificationTrigger

根据特定日期和时间触发通知：

```ts
const components = new DateComponents({ hour: 8, minute: 0 })
new CalendarNotificationTrigger({
  dateMatching: components,
  repeats: true
})
```

- 支持设置 `year`、`month`、`day`、`hour` 等
- 适用于每日、每周或特定时间提醒

***

### LocationNotificationTrigger

当进入或离开某个地理区域时触发：

```ts
new LocationNotificationTrigger({
  region: {
    identifier: "公司",
    center: { latitude: 37.7749, longitude: -122.4194 },
    radius: 100,
    notifyOnEntry: true,
    notifyOnExit: false
  },
  repeats: false
})
```

- 支持进入/离开圆形区域的触发

***

## 通知操作按钮

通过 `actions` 参数添加通知操作按钮：

```ts
actions: [
  {
    title: "查看详情",
    url: Script.createRunURLScheme("详情脚本", { fromNotification: true })
  },
  {
    title: "忽略",
    url: Script.createRunURLScheme("忽略脚本", { dismissed: true }),
    destructive: true
  }
]
```

- 使用 `Script.createRunURLScheme(...)` 创建 URL
- 按钮在长按或下拉通知时显示

***

## 富通知（自定义 UI）

你可以使用 TSX 文件定义通知的展开视图：

1. 安排通知时设置 `customUI: true`
2. 在脚本中添加 `notification.tsx` 文件
3. 使用 `Notification.present(<JSX>)` 渲染 UI

### `Notification.present(element: JSX.Element): void`

在 `notification.tsx` 中调用，用于渲染富通知界面。

***

### 示例 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function NotificationView() {
  return (
    <VStack>
      <Text>需要完成你的任务吗？</Text>
      <Button title="已完成" action={() => console.log("任务完成")} />
      <Button title="稍后提醒" action={() => console.log("稍后提醒")} />
    </VStack>
  )
}

Notification.present(<NotificationView />)
```

***

## 通知管理

| 方法名                                    | 说明              |
| -------------------------------------- | --------------- |
| `getAllDelivereds()`                   | 获取所有已送达的通知      |
| `getAllPendings()`                     | 获取所有已安排但尚未送达的通知 |
| `removeAllDelivereds()`                | 移除所有已送达的通知      |
| `removeAllPendings()`                  | 取消所有待发送通知       |
| `removeDelivereds(ids)`                | 移除指定 ID 的已送达通知  |
| `removePendings(ids)`                  | 取消指定 ID 的已安排通知  |
| `getAllDeliveredsOfCurrentScript()`    | 获取当前脚本发送的已送达通知  |
| `getAllPendingsOfCurrentScript()`      | 获取当前脚本安排的待发送通知  |
| `removeAllDeliveredsOfCurrentScript()` | 清除当前脚本的所有已送达通知  |
| `removeAllPendingsOfCurrentScript()`   | 清除当前脚本的所有待发送通知  |
| `setBadgeCount(count)`                 | 设置应用图标的角标数值     |

***

## 通知信息与请求结构

当脚本是通过点击通知启动时，可以通过 `Notification.current` 获取上下文信息：

```ts
if (Notification.current) {
  const { title, userInfo } = Notification.current.request.content
  console.log(`从通知启动：${title}`, userInfo)
}
```

### `NotificationRequest` 字段

| 字段名                        | 说明              |
| -------------------------- | --------------- |
| `identifier`               | 通知请求的唯一标识符      |
| `content.title`            | 通知标题            |
| `content.subtitle`         | 通知副标题           |
| `content.body`             | 通知正文            |
| `content.userInfo`         | 附加信息            |
| `content.threadIdentifier` | 分组标识            |
| `trigger`                  | 触发器对象，控制通知的投递逻辑 |

***

## 完整示例

以下示例展示了通知的完整用法：自定义 UI、交互按钮、点击行为、重复触发等。

### 第一步：安排通知

```ts
await Notification.schedule({
  title: "喝水提醒",
  body: "别忘了喝水哦！",
  interruptionLevel: "timeSensitive",
  iconImageData: UIImage
    .fromSFSymbol("waterbottle")!
    .withTintColor("systemBlue")!
    .toPNGData(),
  customUI: true,
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 3600,
    repeats: true
  }),
  tapAction: {
    type: "runScript",
    scriptName: "喝水记录"
  },
  actions: [
    {
      title: "已喝水",
      url: Script.createRunURLScheme("喝水记录", { drank: true }),
    },
    {
      title: "忽略",
      url: Script.createRunURLScheme("喝水记录", { drank: false }),
      destructive: true
    }
  ]
})
```

### 第二步：创建 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function HydrationUI() {
  return (
    <VStack>
      <Text>你刚刚喝水了吗？</Text>
      <Button title="是的" action={() => console.log("已确认喝水")} />
      <Button title="还没" action={() => console.log("忽略提醒")} />
    </VStack>
  )
}

Notification.present(<HydrationUI />)
```

***

## 总结

Scripting 中的 `Notification` API 提供了强大的本地通知功能：

- 支持时间、日历、位置触发器
- 支持操作按钮及跳转脚本
- 通过 `tapAction` 自定义点击通知的行为
- 使用 `notification.tsx` 创建富交互通知界面
- 提供全面的通知生命周期管理



---
url: /zh/guide/Device Capabilities/Notification/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Notification, Script, Section, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Notification"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
      >
        <Button
          title={"Schedule a Notification with actions"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down",
              actions: [
                {
                  title: "Widget",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "Widget",
                  })
                },
                {
                  title: "LiveActivity",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "LiveActivity",
                  })
                }
              ]
            })
          }}
        />
      </Section>

      <Section
      >
        <Button
          title={"Schedule a Notification with Rich Content"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down to show rich content.",
              customUI: true,
              userInfo: {
                title: "AudioRecorder",
                subtitle: "The interface allows you to record audio data to a file. It provides functionalities to start, stop, pause, and manage audio recordings, with configurable settings for audio quality, sample rate, format, and more.",
              }
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/PDF.md
---

# PDF

Scripting app 提供了 `PDFDocument` 和 `PDFPage` 两个类，封装了 PDFKit 功能，支持加载、修改、提取、保存 PDF 文件，并支持同步或异步的操作方式。

***

## `PDFPage` 类

表示 PDF 文档中的单个页面。提供访问页面文本、数据和相关信息的能力。

### 静态方法

#### `PDFPage.fromImage(image: UIImage): PDFPage | null`

从图像创建一个新的 PDF 页面。

- **参数**：

  - `image`：要转换为 PDF 页的图像。
- **返回**：`PDFPage` 实例，若失败返回 `null`。

***

### 属性

#### `document: PDFDocument | null`

所属的 PDF 文档实例。若该页面尚未添加至文档，则为 `null`。

#### `label: string | null`

页面的标签（如页码、用户可定义标题等）。

#### `numberOfCharacters: number`

页面中提取到的字符数量。

***

### 异步属性（getter）

#### `string: Promise<string | null>`

异步获取页面的文本内容。

- 如果页面是图像或不可解析为文本，则返回 `null`。

#### `data: Promise<Data | null>`

异步获取页面的原始二进制数据。

***

## `PDFDocument` 类

表示完整的 PDF 文档。可读取、修改页面，提取元信息，并进行保存（支持异步和同步写入）。

***

### 静态方法

#### `PDFDocument.fromData(data: Data): PDFDocument | null`

从二进制数据创建文档实例。

- **参数**：

  - `data`：有效的 PDF 数据。
- **返回**：`PDFDocument` 实例，若无效则为 `null`。

#### `PDFDocument.fromFilePath(filePath: string): PDFDocument | null`

从文件路径加载 PDF 文件。

- **参数**：

  - `filePath`：PDF 文件的本地路径。
- **返回**：成功返回 `PDFDocument`，否则为 `null`。

***

### 只读属性

#### `pageCount: number`

文档总页数。

#### `filePath: string | null`

文档源文件路径。若是通过内存创建则为 `null`。

#### `isLocked: boolean`

文档是否被加锁（需要密码解锁）。

#### `isEncrypted: boolean`

文档是否加密。

#### `documentAttributes: object | null`

PDF 的元数据（如作者、标题、创建时间等）。

```ts
{
  author?: string | null
  creationDate?: Date | null
  creator?: string | null
  keywords?: any | null
  modificationDate?: Date | null
  producer?: string | null
  subject?: string | null
  title?: string | null
}
```

##### 示例

```ts
const doc = PDFDocument.fromFilePath("path/to/example.pdf")
const attrs = doc.documentAttributes
console.log(attrs?.title) // 输出："项目报告"
```

***

### 异步属性（getter）

#### `data: Promise<Data | null>`

异步获取整个文档的二进制数据。

#### `string: Promise<string | null>`

异步获取整个文档的文本内容。若为图片型 PDF，可能返回 `null`。

***

### 方法

#### `pageAt(index: number): PDFPage | null`

获取指定索引的页面。

- **参数**：

  - `index`：页面索引（从 0 开始）。
- **返回**：`PDFPage` 实例，索引无效时返回 `null`。

#### `indexOf(page: PDFPage): number`

获取指定页面在文档中的索引。

- **参数**：

  - `page`：页面实例。
- **返回**：索引值，若找不到则为 `-1`。

#### `removePageAt(index: number): void`

移除指定索引的页面。

#### `insertPageAt(page: PDFPage, atIndex: number): void`

在指定索引插入一个页面。

##### 示例

```ts
const doc = PDFDocument.fromFilePath("path/to/document.pdf")
const imagePage = PDFPage.fromImage(image)
doc.insertPageAt(imagePage, 1)
```

#### `exchangePage(atIndex: number, withPageIndex: number): void`

交换两个页面的位置。

***

### 保存方法

#### `writeSync(toFilePath: string, options?): boolean`

将 PDF 同步写入指定路径，支持设置密码和其他选项。

- **参数**：

  - `toFilePath`：输出文件路径。
  - `options`（可选）：

    ```ts
    {
      ownerPassword?: string
      userPassword?: string
      burnInAnnotations?: boolean
      saveTextFromOCR?: boolean
      saveImagesAsJPEG?: boolean
    }
    ```
- **返回**：保存成功返回 `true`，否则为 `false`。

##### 示例

```ts
const doc = PDFDocument.fromFilePath("path/to/input.pdf")
const success = doc.writeSync("path/to/output.pdf", {
  ownerPassword: "admin",
  userPassword: "1234"
})
```

#### `write(toFilePath: string, options?): Promise<boolean>`

异步方式写入 PDF 文件。

- 参数与 `writeSync` 相同。
- **返回值**：`Promise<boolean>` 表示保存是否成功。

***

### 解锁文档

#### `unlock(password: string): boolean`

尝试使用密码解锁文档。

- **参数**：

  - `password`：密码字符串。
- **返回**：若解锁成功，返回 `true`，否则返回 `false`。

***

## 示例代码

```ts
const doc = PDFDocument.fromFilePath("path/to/book.pdf")
if (doc && !doc.isLocked) {
  const firstPage = doc.pageAt(0)
  const text = await firstPage?.string
  console.log("第一页文本：", text)
  
  const success = await doc.write("path/to/book-copy.pdf")
  console.log(success ? "保存成功" : "保存失败")
}
```



---
url: /zh/guide/Device Capabilities/Pasteboard.md
---

# 剪贴板

`Pasteboard` 命名空间提供在 **Scripting app** 中读取、设置与监听系统粘贴板内容变化的完整接口。
相比旧版 `Clipboard`，`Pasteboard` 提供了更强的功能支持，包括：

- 支持多类型数据（文本、图片、URL、二进制数据等）
- 监听粘贴板变化事件
- 设置隐私属性（如过期时间、本地可见性）

> **注意**
> 如果希望能够从其他 App 粘贴内容，请前往：
> **设置 > Scripting > 从其他 App 粘贴 > 允许**

***

## 命名空间：`Pasteboard`

### 类型定义

#### `Item`

表示一个粘贴板项目。
每个项目是一个 `Record<UTType, string | UIImage | Data>` 映射表，其中键为数据类型（`UTType`），值可以是字符串、图片或二进制数据。

常见类型：

- `public.plain-text` → 文本字符串
- `public.url` → URL 字符串
- `public.jpeg` / `public.png` → 图片对象（`UIImage`）
- `public.data` → 二进制数据（`Data`）

**示例**

```ts
const item: Pasteboard.Item = {
  "public.plain-text": "Hello, world!",
  "public.url": "https://example.com"
}
```

***

## 属性（Properties）

### `hasStrings: Promise<boolean>`

判断粘贴板中是否包含文本内容。

**示例**

```ts
if (await Pasteboard.hasStrings) {
  console.log("粘贴板中包含文本")
}
```

***

### `hasImages: Promise<boolean>`

判断粘贴板中是否包含图片。

**示例**

```ts
if (await Pasteboard.hasImages) {
  console.log("粘贴板中包含图片")
}
```

***

### `hasURLs: Promise<boolean>`

判断粘贴板中是否包含 URL。

**示例**

```ts
if (await Pasteboard.hasURLs) {
  console.log("粘贴板中包含 URL 链接")
}
```

***

### `numberOfItems: Promise<number>`

获取当前粘贴板中项目的数量。

**示例**

```ts
const count = await Pasteboard.numberOfItems
console.log(`共有 ${count} 个粘贴板项目`)
```

***

### `changeCount: Promise<number>`

获取自系统启动以来粘贴板内容变化的次数。
每当粘贴板内容发生变化（新增、修改或清空），该计数都会增加。
可用于检测粘贴板是否有更新。

**示例**

```ts
const changeCount = await Pasteboard.changeCount
console.log("粘贴板变化次数：", changeCount)
```

***

## 文本操作

### `getString(): Promise<string | null>`

获取粘贴板中第一个项目的文本字符串。

**示例**

```ts
const text = await Pasteboard.getString()
if (text) console.log("读取到文本：", text)
```

***

### `setString(string: string | null): Promise<void>`

设置粘贴板中第一个项目的文本字符串。

**示例**

```ts
await Pasteboard.setString("Scripting is powerful!")
```

***

### `getStrings(): Promise<string[] | null>`

获取粘贴板中所有项目的文本数组。

**示例**

```ts
const texts = await Pasteboard.getStrings()
console.log(texts)
```

***

### `setStrings(strings: string[] | null): Promise<void>`

设置多个文本字符串到粘贴板。

**示例**

```ts
await Pasteboard.setStrings(["Apple", "Banana", "Cherry"])
```

***

## URL 操作

### `getURL(): Promise<string | null>`

获取粘贴板中第一个 URL 字符串。

**示例**

```ts
const url = await Pasteboard.getURL()
if (url) console.log("链接内容：", url)
```

***

### `setURL(url: string | null): Promise<void>`

设置粘贴板中第一个 URL 字符串。

**示例**

```ts
await Pasteboard.setURL("https://example.com")
```

***

### `getURLs(): Promise<string[] | null>`

获取粘贴板中所有 URL 项目。

**示例**

```ts
const urls = await Pasteboard.getURLs()
console.log(urls)
```

***

### `setURLs(urls: string[] | null): Promise<void>`

设置多个 URL 项目到粘贴板。

**示例**

```ts
await Pasteboard.setURLs([
  "https://apple.com",
  "https://openai.com"
])
```

***

## 图片操作

### `getImage(): Promise<UIImage | null>`

获取粘贴板中第一个图片对象。

**示例**

```ts
const img = await Pasteboard.getImage()
if (img) console.log("读取到图片")
```

***

### `setImage(image: UIImage | null): Promise<void>`

设置粘贴板中第一个图片对象。

**示例**

```ts
await Pasteboard.setImage(myImage)
```

***

### `getImages(): Promise<UIImage[] | null>`

获取粘贴板中所有图片对象。

**示例**

```ts
const images = await Pasteboard.getImages()
console.log(`共读取到 ${images?.length ?? 0} 张图片`)
```

***

### `setImages(images: UIImage[] | null): Promise<void>`

设置多个图片对象到粘贴板。

**示例**

```ts
await Pasteboard.setImages([img1, img2])
```

***

## 粘贴板项目操作

### `addItems(items: Item[]): Promise<void>`

向当前粘贴板追加新项目（不会清除已有内容）。

**示例**

```ts
await Pasteboard.addItems([
  { "public.plain-text": "First" },
  { "public.url": "https://example.com" }
])
```

***

### `setItems(items: Item[], options?: { localOnly?: boolean, expirationDate?: Date }): Promise<void>`

设置粘贴板内容为指定项目，并支持隐私控制选项。

**参数**

- `items`：粘贴板项目数组。
- `options.localOnly`：若为 `true`，不会通过 Handoff 同步到其他设备。
- `options.expirationDate`：设置过期时间，系统会在该时间后自动清除内容。

**示例**

```ts
await Pasteboard.setItems(
  [
    { "public.plain-text": "Sensitive Info" }
  ],
  {
    localOnly: true,
    expirationDate: new Date(Date.now() + 60 * 1000) // 1分钟后过期
  }
)
```

***

### `getItems(): Promise<Item[] | null>`

获取粘贴板中所有项目，每个项目为一个 `Pasteboard.Item` 对象。

**示例**

```ts
const items = await Pasteboard.getItems()
console.log(items)
```

***

## 事件回调（Callbacks）

### `onChanged: ((addedKeys: string[]) => void) | null | undefined`

当粘贴板内容发生变化时触发。
参数 `addedKeys` 为一个字符串数组，包含本次**新增的表示类型**（`UTType`）。

**示例**

```ts
Pasteboard.onChanged = addedKeys => {
  console.log("粘贴板新增内容类型：", addedKeys)
}
```

***

### `onRemoved: ((removedKeys: string[]) => void) | null | undefined`

当粘贴板内容被移除时触发。
参数 `removedKeys` 为一个字符串数组，包含被移除的表示类型（`UTType`）。

**示例**

```ts
Pasteboard.onRemoved = removedKeys => {
  console.log("粘贴板移除的类型：", removedKeys)
}
```

***

## 与旧版 Clipboard API 的区别

旧的 `Clipboard` 命名空间现已**弃用**，仅保留最基本的兼容接口：

- `Clipboard.copyText(text: string)` → 请改用 `Pasteboard.setString()`
- `Clipboard.getText()` → 请改用 `Pasteboard.getString()`



---
url: /zh/guide/Device Capabilities/Photos/index.md
---

# 照片

`Photos` 模块为 Scripting 提供了对系统相册与相机能力的统一访问接口，用于：

- 使用系统相机拍照或录制视频
- 从系统照片库中选择图片、视频或 Live Photo
- 获取最近拍摄的照片
- 将图片或视频保存到系统 Photos 应用

所有 API 均基于 iOS 原生框架（Photos、PHPicker、UIImagePicker 等）封装，并遵循以下设计原则：

- 系统级权限管理
- Promise 异步接口
- 系统 UI 托管，不可自定义
- 媒体数据访问安全、受控

***

## CaptureInfo

```ts
type CaptureInfo = {
  cropRect: {
    x: number
    y: number
    width: number
    height: number
  } | null
  originalImage: UIImage | null
  editedImage: UIImage | null
  imagePath: string | null
  mediaMetadata: Record<string, any> | null
  mediaPath: string | null
  mediaType: string | null
}
```

`CaptureInfo` 描述了一次拍摄操作（照片或视频）的完整返回信息。

### 字段说明

- `cropRect`
  用户在编辑阶段应用的裁剪区域
  若未裁剪则为 `null`

- `originalImage`
  拍摄得到的原始图片（未编辑）

- `editedImage`
  用户编辑后的图片
  仅在 `allowsEditing` 启用且实际编辑后存在

- `imagePath`
  图片在磁盘中的文件路径

- `mediaMetadata`
  媒体的元数据，如 EXIF、方向信息等

- `mediaPath`
  视频文件在磁盘中的路径

- `mediaType`
  媒体的 UTType 字符串标识

***

## availableMediaTypes()

```ts
function availableMediaTypes(): string[] | null
```

返回当前设备相机支持的媒体类型（UTType 字符串数组）。

常用于：

- 判断设备是否支持视频拍摄
- 根据设备能力动态配置拍摄参数

当信息不可获取时返回 `null`。

***

## capture(options)

```ts
function capture(options: {
  mode: "photo" | "video"
  mediaTypes: UTType[]
  allowsEditing?: boolean
  cameraDevice?: "rear" | "front"
  cameraFlashMode?: "auto" | "on" | "off"
  videoMaximumDuration?: DurationInSeconds
  videoQuality?: 
    | "low"
    | "medium"
    | "high"
    | "640x480"
    | "iFrame960x540"
    | "iFrame1280x720"
}): Promise<CaptureInfo | null>
```

展示系统相机界面以进行拍照或视频录制。

### 参数说明

- `mode`
  拍摄模式

  - `"photo"`：拍照
  - `"video"`：录制视频

- `mediaTypes`
  允许拍摄的媒体类型（UTType 数组）

- `allowsEditing`
  是否允许用户在完成拍摄后编辑媒体

- `cameraDevice`
  使用的摄像头
  默认为 `"rear"`

- `cameraFlashMode`
  闪光灯模式
  默认为 `"auto"`

- `videoMaximumDuration`
  视频最长录制时长（秒）

- `videoQuality`
  视频分辨率与编码质量设置

### 行为说明

- 拍摄界面完全由系统管理
- Promise 在用户完成或取消操作后返回
- 权限请求由系统自动处理

***

## pick(options)

```ts
function pick(options?: {
  mode?: "default" | "compact"
  filter?: PHPickerFilter
  limit?: number
}): Promise<PHPickerResult[]>
```

展示系统照片选择器，用于从相册中选择媒体资源。

### 参数说明

- `mode`
  选择器布局模式

  - `default`：网格布局
  - `compact`：线性紧凑布局

- `filter`
  用于限制可选择资源类型的 `PHPickerFilter`

- `limit`
  最大选择数量
  默认为 `1`

### 返回值

返回 `PHPickerResult` 数组。
每个结果必须显式调用对应方法解析为具体资源。

***

## PHPickerFilter

`PHPickerFilter` 用于描述 **Photos.pick** 可选择的资源类型。
它是一个不可实例化的类，仅通过静态方法构建。

### 基础过滤器

- `PHPickerFilter.images()`
  仅允许选择普通图片

- `PHPickerFilter.videos()`
  仅允许选择视频

- `PHPickerFilter.livePhotos()`
  仅允许选择 Live Photo

- `PHPickerFilter.bursts()`
  连拍照片

- `PHPickerFilter.panoramas()`
  全景照片

- `PHPickerFilter.screenshots()`
  屏幕截图

- `PHPickerFilter.screenRecordings()`
  屏幕录制视频

- `PHPickerFilter.depthEffectPhotos()`
  含景深效果的照片（人像）

- `PHPickerFilter.cinematicVideos()`
  电影效果视频

- `PHPickerFilter.slomoVideos()`
  慢动作视频

- `PHPickerFilter.timelapseVideos()`
  延时摄影视频

***

### 组合过滤器

- `PHPickerFilter.all(filters)`
  同时满足所有过滤条件
  相当于逻辑 AND

- `PHPickerFilter.any(filters)`
  满足任意一个过滤条件
  相当于逻辑 OR

- `PHPickerFilter.not(filter)`
  排除指定过滤条件
  相当于逻辑 NOT

### 示例说明

```ts
// 仅允许选择 Live Photo 或普通图片
const filter = PHPickerFilter.any([
  PHPickerFilter.livePhotos(),
  PHPickerFilter.images()
])

await Photos.pick({ filter })
```

***

## PHPickerResult

表示照片选择器返回的单个选择结果。

### itemProvider: ItemProvider

获取结果的 `ItemProvider`对象，是一个Swift 的 `NSItemProvider` 对象的包装。

### livePhoto()

```ts
livePhoto(): Promise<LivePhoto | null>
```

尝试将结果解析为 Live Photo。
若资源不支持 Live Photo，则返回 `null`。

***

### uiImage()

```ts
uiImage(): Promise<UIImage | null>
```

尝试将结果解析为 `UIImage`。
若资源不是图片，则返回 `null`。

***

### imagePath()

```ts
imagePath(): Promise<string | null>
```

尝试将结果解析为图片。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回图片路径。
你应该在使用完成后删除该文件。

#### 示例

```ts
const filePath = await result.imagePath()
```

***

### videoPath()

```ts
videoPath(): Promise<string | null>
```

尝试将结果解析为视频。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回视频路径。
你应该在使用完成后删除该文件。

***

## getLatestPhotos(count)

```ts
function getLatestPhotos(count: number): Promise<UIImage[] | null>
```

获取相册中最新的若干张照片。

### 行为说明

- 仅返回图片
- 顺序为从最新到最旧
- 无权限时返回 `null`

***

## pickPhotos(count)

```ts
function pickPhotos(count: number): Promise<UIImage[]>
```

旧版便捷 API，用于快速选择固定数量的照片。

直接返回 `UIImage` 数组，不包含路径或元数据。

***

## takePhoto()

```ts
function takePhoto(): Promise<UIImage | null>
```

快速拍照接口。

- 不支持高级配置
- 用户取消时返回 `null`

***

## savePhoto(path, options)

```ts
function savePhoto(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将磁盘中的图片文件保存到系统 Photos 应用。

***

## savePhoto(image, options)

```ts
function savePhoto(
  image: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将图片二进制数据直接写入系统相册，避免创建临时文件。

***

## saveVideo(path, options)

```ts
function saveVideo(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频文件保存到系统 Photos 应用。

***

## saveVideo(video, options)

```ts
function saveVideo(
  video: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频二进制数据直接写入系统相册。

***

## 设计说明

- 所有 API 均为异步 Promise 接口
- 所有 UI 均由系统托管
- Picker 返回的结果为惰性对象，需显式解析
- 保存接口仅返回成功状态，不暴露系统资源标识



---
url: /zh/guide/Device Capabilities/Photos/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Photos"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Get the latest specified number of photos from the Photos app.</Text>
        }
      >
        <Button
          title={"Photos.getLatestPhotos"}
          action={async () => {
            const images = await Photos.getLatestPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Present a photo picker dialog and pick limited number of photos.</Text>
        }
      >

        <Button
          title={"Photos.pickPhotos"}
          action={async () => {
            const images = await Photos.pickPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Take a photo and return a UIImage instance.</Text>
        }
      >
        <Button
          title={"Photos.takePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Save an image to the Photos app. Returns a boolean value indicates that whether the operation is successful.</Text>
        }
      >
        <Button
          title={"Photos.savePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              const success = await Photos.savePhoto(Data.fromJPEG(image, 0.5)!)
              Dialog.alert({
                message: "The photo has been saved: " + success
              })
            } else {
              Dialog.alert({
                message: "Canceled"
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/Play Video/AVPlayerView.md
---

# 视频播放组件(AVPlayerView)

`AVPlayerView` 是 Scripting 提供的视频播放组件，基于系统原生 `AVPlayerViewController` 封装。
与 `VideoPlayer` 不同，`AVPlayerView` **完整支持系统级 Picture in Picture（画中画，PiP）**，并允许脚本层监听 PiP 的生命周期变化。

该组件适用于对**原生播放行为、后台播放、PiP、锁屏与控制中心联动**有明确需求的媒体类场景。

***

## 一、何时使用 AVPlayerView

当你的场景满足以下任意条件时，应使用 `AVPlayerView`：

- 需要视频进入系统 PiP 模式
- 需要原生播放控制 UI
- 需要在后台持续播放视频
- 需要与系统 Now Playing / 锁屏 / 控制中心联动
- 需要精确感知 PiP 的开始与结束

如果仅做简单的视频展示且不需要 PiP，`VideoPlayer` 仍然是更轻量的选择。

***

## 二、核心属性详解

### 1. `player`

```ts
player: AVPlayer
```

- 实际执行播放的核心对象
- 由开发者自行创建和管理
- 支持网络视频、本地文件、HLS 等格式

`AVPlayerView` **不会管理播放器的生命周期**，播放器在 PiP 期间必须保持存活。

***

### 2. `pipStatus`

```ts
pipStatus: Observable<PIPStatus>
```

用于监听系统 PiP 的生命周期状态变化。

可能的取值如下：

| 状态                 | 含义            |
| ------------------ | ------------- |
| `willStart`        | PiP 即将开始      |
| `didStart`         | PiP 已开始       |
| `willStop`         | PiP 即将结束      |
| `didStop`          | PiP 已结束       |
| `undefined / null` | 尚未进入 PiP 生命周期 |

该状态完全由系统控制，**只能监听，不应手动修改**。

***

## 三、PiP 相关配置项

### 1. `allowsPictureInPicturePlayback`

```ts
allowsPictureInPicturePlayback?: boolean
```

- 是否允许视频进入 PiP
- 默认值：`true`

若设为 `false`：

- 系统 PiP 按钮不会显示
- 视频无法进入画中画模式

***

### 2. `canStartPictureInPictureAutomaticallyFromInline`

```ts
canStartPictureInPictureAutomaticallyFromInline?: boolean
```

- 当应用从前台切换到后台时，是否自动进入 PiP
- 默认值：`false`

适合以下场景：

- 用户按下 Home 键离开应用
- 希望播放不中断并自动进入 PiP

***

### 3. `updatesNowPlayingInfoCenter`

```ts
updatesNowPlayingInfoCenter?: boolean
```

- 是否自动更新系统 Now Playing 信息
- 默认值：`true`

开启后，视频信息会显示在：

- 锁屏界面
- 控制中心
- 外接播放设备

***

## 四、全屏播放行为

### 1. `entersFullScreenWhenPlaybackBegins`

```ts
entersFullScreenWhenPlaybackBegins?: boolean
```

- 播放开始时是否自动进入全屏
- 默认值：`false`

***

### 2. `exitsFullScreenWhenPlaybackEnds`

```ts
exitsFullScreenWhenPlaybackEnds?: boolean
```

- 播放结束时是否自动退出全屏
- 默认值：`false`

***

## 五、视频显示方式（videoGravity）

```ts
videoGravity?: AVLayerVideoGravity
```

| 值                  | 行为说明           |
| ------------------ | -------------- |
| `resize`           | 拉伸填满，不保持比例     |
| `resizeAspect`     | 保持比例，完整显示（默认）  |
| `resizeAspectFill` | 保持比例，填满区域，可能裁剪 |

***

## 六、完整 DEMO 示例

以下示例演示了：

- 创建并配置 `AVPlayer`
- 正确配置音频会话
- 监听 PiP 生命周期
- 控制播放 / 暂停
- 正确释放资源

```tsx
function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(
    TimeControlStatus.paused
  )
  const pipstatus = useObservable<PIPStatus>()

  console.log(pipstatus.value)

  const player = useMemo(() => {
    const player = new AVPlayer()

    player.setSource(
      "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
    )

    player.onTimeControlStatusChanged = status => {
      setStatus(status)
    }

    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      "playback",
      ["defaultToSpeaker"]
    )

    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="VideoPlayer"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        cancellationAction: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <AVPlayerView
        player={player}
        pipStatus={pipstatus}
        canStartPictureInPictureAutomaticallyFromInline
        updatesNowPlayingInfoCenter
        entersFullScreenWhenPlaybackBegins
      />

      <Button
        title={
          status === TimeControlStatus.paused
            ? "Play"
            : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 七、PiP 生命周期说明

PiP 状态通常按以下顺序变化：

1. `willStart`
2. `didStart`
3. PiP 运行中
4. `willStop`
5. `didStop`

在异常或系统打断情况下，部分状态可能被跳过，因此应以 `didStart` 和 `didStop` 作为最终判断依据。

***

## 八、重要注意事项

### 1. AVPlayerView 使用的是系统级视频 PiP

- 基于系统原生视频 PiP
- 与 Scripting 的自定义 PiP View Modifiers **完全不同**
- 两种 PiP 机制不可混用

***

### 2. PiP 依赖正确的音频会话配置

要保证 PiP 正常工作，必须：

- 激活音频会话
- 使用 `playback` 类别
- 正确配置后台音频能力

否则可能出现 PiP 无法启动或静默失败的情况。

***

### 3. PiP 期间不要销毁 AVPlayer

- PiP 运行中销毁或替换 `AVPlayer`
- 会导致 PiP 异常退出
- 甚至触发系统错误

应在 `pipStatus` 变为 `didStop` 后再释放播放器资源。

***

## 九、推荐实践总结

- 视频 PiP 场景始终使用 `AVPlayerView`
- 将 `pipStatus` 视为只读状态
- PiP 期间保持 `AVPlayer` 生命周期稳定
- 显式配置音频会话
- 避免频繁创建或替换播放器
- 在 PiP 完全结束后再释放资源



---
url: /zh/guide/Device Capabilities/Play Video/VideoPlayer/index.md
---

# 视频播放器

该视图使用强大的 `AVPlayer` 作为后端，配合简单且可定制的前端 UI，用于播放视频和音频内容。通过这种方式，你可以轻松加载媒体、控制播放、处理事件，甚至添加自定义的覆盖（overlay）界面。

***

## 概述

`VideoPlayer` 依赖一个 `AVPlayer` 实例，你需要预先将媒体加载到 `AVPlayer`，然后就能通过它来控制播放（播放、暂停、停止）并响应各种事件，例如视频准备就绪或播放结束。`overlay` 属性允许你在视频内容之上添加交互式 UI 元素（但位于系统自带的播放控制按钮下方）。

**要点概述**：

- 通过传入的 `AVPlayer` 实例来控制播放。
- 使用 `overlay` 在视频上方添加自定义 UI 元素。
- 监听 `onReadyToPlay`、`onEnded`、`onError` 等事件来响应媒体播放过程中的各种状态。

***

## 基本用法

首先，创建并配置一个 `AVPlayer` 实例：

```tsx
const player = new AVPlayer()

// 设置媒体源：可以是本地文件路径或远程 URL
player.setSource("https://example.com/video.mp4")

// 当媒体准备就绪时开始播放
player.onReadyToPlay = () => {
  console.log("媒体已就绪，开始播放。")
  player.play()
}

// 处理播放状态的变化
player.onTimeControlStatusChanged = (status) => {
  console.log("播放状态改变:", status)
}

// 当播放结束时
player.onEnded = () => {
  console.log("播放结束。")
}

// 处理错误
player.onError = (message) => {
  console.error("播放错误:", message)
}

// 配置播放属性
player.volume = 1.0          // 音量全开
player.rate = 1.0            // 正常播放速度
player.numberOfLoops = 0     // 不循环
```

然后，在你的 UI 中使用 `VideoPlayer` 视图：

```tsx
<VideoPlayer
  player={player}
  overlay={
    <HStack padding>
      <Button title="暂停" action={() => player.pause()} />
      <Button title="播放" action={() => player.play()} />
    </HStack>
  }
/>
```

这样就会在视频上展示你自定义的按钮控件，默认显示在底部左侧。

***

## 使用场景示例

假设你想要一个带有自定义控件并能自动重播的视频：

```tsx
function VideoPlayerView() {
  const player = useMemo(() => new AVPlayer(), [])

  useEffect(() => {
    player.setSource(
      Path.join(
        Script.directory,
        "localvideo.mp4"
      )
    )
    player.onReadyToPlay = () => player.play()
    player.onEnded = () => player.play() // 视频结束后自动重播

    // 设置 shared audio session.
    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      'playback',
      ['mixWithOthers']
    )

    return () => {
      // 当该视图要被销毁时，释放 AVPlayer 实例
      player.dispose()
    }
  }, [])

  return <VideoPlayer
    player={player}
    overlay={
      <HStack padding>
        <Button title="暂停" action={() => player.pause()} />
        <Button title="继续" action={() => player.play()} />
      </HStack>
    }
    frame={{
      height: 300
    }}
  />
}
```

该示例：

- 在视频准备就绪时立即加载并播放本地文件。
- 视频播放结束后自动重播。
- 在视频底部右侧提供自定义的暂停/继续按钮作为叠加控件（overlay）。

***

## 总结

`VideoPlayer` 组件在 `AVPlayer` 实例的支持下，为你的应用带来细致入微的视频播放控制。无论是调整音量、播放速度、处理缓冲状态或错误，亦或是在视频之上叠加自定义 UI 控件，`VideoPlayer` 组件和 `AVPlayer` 类都能为你提供丰富且交互性强的多媒体体验。



---
url: /zh/guide/Device Capabilities/Play Video/VideoPlayer/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, useEffect, useMemo, useState, VideoPlayer, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(TimeControlStatus.paused)

  const player = useMemo(() => {
    const player = new AVPlayer()
    player.setSource("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4")
    player.onTimeControlStatusChanged = (status) => {
      setStatus(status)
    }
    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      'playback',
      ['mixWithOthers']
    )
    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle={"VideoPlayer"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <VideoPlayer
        player={player}
        frame={{
          height: 300
        }}
      />
      <Button
        title={status === TimeControlStatus.paused
          ? "Play"
          : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack >
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/QRCode.md
---

# 二维码

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text } from "scripting"

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"QRCode"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        footer={
          <Text>Open the QRCode scan page and scan.</Text>
        }
      >
        <Button
          title={"QRCode.scan"}
          action={async () => {
            const result = await QRCode.scan()
            if (result) {
              Dialog.alert({
                message: "Result: " + result
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Parse QRCode file to a string.</Text>
        }
      >
        <Button
          title={"QRCode.parse"}
          action={async () => {
            const result = await DocumentPicker.pickFiles({
              allowsMultipleSelection: false
            })
            if (result.length) {
              const code = await QRCode.parse(result[0])
              Dialog.alert({
                message: "Parse reuslt: " + code
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/QuickLook.md
---

# 快速查看

在 Scripting 应用中，**QuickLook API** 提供了一种简单的方法，用于在脚本中预览文本、图片或文件。这是对 iOS QuickLook 功能的封装，允许您快速显示多种内容类型的预览。

每个方法都会返回一个 Promise，该 Promise 会在 QuickLook 视图被关闭时解析，从而使您可以轻松地链式调用操作或处理预览后的逻辑。

***

## **API 参考**

### `QuickLook.previewText(text: string): Promise<void>`

显示文本字符串的预览。

#### **参数**

- `text` (string)：要在预览中显示的文本内容。
- `fullscreen` (boolean?): 是否以全屏模式预览。默认为false.

#### **返回值**

- `Promise<void>`：在预览关闭后解析。

#### **示例**

```tsx
await QuickLook.previewText("你好，世界！这是一个 QuickLook 预览示例。")
console.log("文本预览已关闭")
```

***

### `QuickLook.previewImage(image: UIImage): Promise<void>`

显示图片的预览。

#### **参数**

- `image` (UIImage)：要在预览中显示的图片。
- `fullscreen` (boolean?): 是否以全屏模式预览。默认为false.

#### **返回值**

- `Promise<void>`：在预览关闭后解析。

#### **示例**

```tsx
// 假设 `myImage` 是一个 UIImage 实例
await QuickLook.previewImage(myImage, true)
console.log("图片预览已关闭")
```

***

### `QuickLook.previewURLs(urls: string[]): Promise<void>`

显示一个或多个文件（位于指定的文件 URL 路径）的预览。

#### **参数**

- `urls` (string\[])：文件 URL 字符串数组。每个字符串应指向一个有效的文件路径或可以通过 QuickLook 预览的远程文件。
- `fullscreen` (boolean?): 是否以全屏模式预览。默认为false.

#### **返回值**

- `Promise<void>`：在预览关闭后解析。

#### **示例**

```tsx
const fileURLs = [
  "/path/to/file1.pdf",
  "/path/to/file2.jpg",
]

await QuickLook.previewURLs(fileURLs)
console.log("文件预览已关闭")
```

***

## **使用说明**

- **UI 阻塞**：这些方法会显示一个模态 QuickLook 视图。在用户关闭预览之前，后续代码（`await` 之后的部分）将暂停执行。
- **错误处理**：使用 `try...catch` 来处理错误，例如无效的文件路径或不支持的内容类型。
- **支持的文件类型**：支持的文件类型取决于 iOS 的 QuickLook 功能，包括常见的文件类型，例如 PDF、图片、文本文件等。

***

## **示例使用场景**

### 按顺序预览文本、图片和文件

```tsx
// 预览文本
await QuickLook.previewText("QuickLook 预览示例")

// 预览图片
const myImage = UIImage.fromFile("/path/to/image.png")
await QuickLook.previewImage(myImage)

// 预览文件
const fileURLs = [
  "/path/to/file1.pdf",
  "/path/to/file2.jpg",
]
await QuickLook.previewURLs(fileURLs)

console.log("所有预览已完成")
```

通过这个 API，您可以将 QuickLook 预览无缝集成到脚本中，以最小的努力提升用户体验。

***



---
url: /zh/guide/Device Capabilities/Recurrence.md
---

# 重复规则

这些与重复相关的类型和类（`RecurrenceFrequency`、`RecurrenceDayOfWeek`、`RecurrenceWeekday`、`RecurrenceEnd` 以及 `RecurrenceRule`）允许你在 Scripting 中为事件和提醒定义并管理重复模式。通过这些类型和类，你可以设置重复间隔、指定重复的特定日期或月份，以及定义结束条件。

## 重复类型和类

### 1. `RecurrenceFrequency`

`RecurrenceFrequency` 用于定义事件或提醒的重复频率。可选值如下：

- `daily`: 每天重复。
- `weekly`: 每周重复。
- `monthly`: 每月重复。
- `yearly`: 每年重复。

此类型通常作为 `RecurrenceRule` 类中的一个属性，用来指定重复发生的频率。

**使用示例：**

```ts
const frequency: RecurrenceFrequency = "weekly"
```

### 2. `RecurrenceWeekday`

`RecurrenceWeekday` 是一个枚举类型，表示一周中的某一天。它可以让你在周重复模式下指定事件重复的具体星期几。可用值包括：

- `"sunday"`, `"monday"`, `"tuesday"`, `"wednesday"`, `"thursday"`, `"friday"`, `"saturday"`

**使用示例：**

```ts
const weekday: RecurrenceWeekday = "monday"
```

### 3. `RecurrenceDayOfWeek`

`RecurrenceDayOfWeek` 允许你指定某个特定的工作日（weekday），并可选地配合 `weekNumber` 一起使用。\
在更复杂的周重复模式中，如果你想指定某个月的某个特定星期几（例如，每月的第二个星期二），就可以用到这个类型。

`RecurrenceDayOfWeek` 可以是以下两种形式之一：

- 一个简单的 `RecurrenceWeekday`（例如 `"monday"`），或
- 一个对象，包含：
  - `weekday`: 一个 `RecurrenceWeekday`（如 `"monday"`）
  - `weekNumber`: 一个数字，用来表示该星期几在当月或当年出现的次序（正数代表从头数，负数代表从尾数）。例如，`1` 表示第一个出现的星期几，`-1` 表示最后一个出现的星期几。

**使用示例：**

```ts
const dayOfWeek: RecurrenceDayOfWeek = { weekday: "tuesday", weekNumber: 2 }
```

### 4. `RecurrenceEnd`

`RecurrenceEnd` 用于定义重复规则何时结束。它提供了两种结束重复的方式：

- `fromCount(count: number)`: 在重复了指定次数后结束。
- `fromDate(date: Date)`: 在某个特定日期结束。

这在需要限制事件或提醒的重复次数或日期时非常有用。

#### RecurrenceEnd 方法

- **fromCount(count)**: 基于重复次数创建结束条件。
  ```ts
  const endByCount = RecurrenceEnd.fromCount(10)
  ```

- **fromDate(date)**: 基于具体日期创建结束条件。
  ```ts
  const endByDate = RecurrenceEnd.fromDate(new Date("2024-12-31"))
  ```

### 5. `RecurrenceRule`

`RecurrenceRule` 用来定义事件或提醒的完整重复模式，包括重复频率、间隔、指定的日期、月份，以及可选的结束条件等。

#### RecurrenceRule 属性

- **identifier**: `string` – 该重复规则的唯一标识符。
- **frequency**: `RecurrenceFrequency` – 重复的频率（`daily`, `weekly`, `monthly`, `yearly`）。
- **interval**: `number` – 重复间的间隔（例如，每 2 周一次），必须大于 0。
- **recurrenceEnd**: `RecurrenceEnd (可选)` – 指定重复何时结束。
- **firstDayOfTheWeek**: `number` – 用来表示一周的起始日。
- **daysOfTheWeek**: `RecurrenceDayOfWeek[] (可选)` – 指定一周中的哪些天需要重复。
- **daysOfTheMonth**: `number[] (可选)` – 指定一个月中哪些日期需要重复（1 到 31 或 -1 到 -31）。
- **daysOfTheYear**: `number[] (可选)` – 指定一年中的哪些天需要重复。
- **weeksOfTheYear**: `number[] (可选)` – 指定一年中的哪些周需要重复。
- **monthsOfTheYear**: `number[] (可选)` – 指定一年中的哪些月份需要重复。
- **setPositions**: `number[] (可选)` – 用于在频率周期内筛选特定序号位置的重复。

#### RecurrenceRule 方法

- **create(options)**: 使用指定的选项创建一个 `RecurrenceRule` 实例。
  - **Options**:
    - **frequency**: 重复的频率（如 `daily`、`weekly`）。
    - **interval**: 重复的间隔（如每 2 天）。
    - **daysOfTheWeek**: `RecurrenceDayOfWeek` 数组。
    - **daysOfTheMonth**: 月中某些特定日期的数组。
    - **monthsOfTheYear**: 一年中某些特定月份的数组。
    - **weeksOfTheYear**: 一年中某些特定周的数组。
    - **daysOfTheYear**: 一年中某些特定天的数组。
    - **setPositions**: 指定用于筛选重复位置的序号数组。
    - **end**: 指定何时结束重复的规则。

**示例：**

```ts
const rule = RecurrenceRule.create({
  frequency: "monthly",
  interval: 1,
  daysOfTheWeek: [{ weekday: "monday", weekNumber: 1 }],
  end: RecurrenceEnd.fromCount(10)
})
```

## 综合运用

要使用这些类型来创建带有重复模式的事件或提醒，可以按照以下步骤：

1. **定义重复频率**：设置 `RecurrenceFrequency` 来指定事件或提醒的重复频率。
2. **指定日期或月份**：使用 `RecurrenceWeekday`、`RecurrenceDayOfWeek`、`daysOfTheMonth` 等来确定具体的重复日期。
3. **设置间隔**：通过 `interval` 控制基于频率的重复间隔。
4. **定义结束条件**（可选）：使用 `RecurrenceEnd` 指定重复何时终止。
5. **创建规则**：通过 `RecurrenceRule.create()` 并传入相关配置选项，生成最终的重复规则。

### 示例：每月的第二个星期二开会，持续 6 个月

```ts
const recurrenceRule = RecurrenceRule.create({
  frequency: "monthly",
  interval: 1,
  daysOfTheWeek: [{ weekday: "tuesday", weekNumber: 2 }],
  end: RecurrenceEnd.fromCount(6)
})

// 将 recurrenceRule 添加到你的事件或提醒中
event.addRecurrenceRule(recurrenceRule)
await event.save()
```

此示例中，`RecurrenceRule` 定义了每个月的第二个星期二重复一次的会议，共重复六次后停止。



---
url: /zh/guide/Device Capabilities/Reminder.md
---

`Reminder` API 用于在 iOS 日历系统中创建、编辑和管理提醒事项。
它支持通过 `DateComponents` 设置截止日期、管理完成状态、设置优先级、添加备注、配置重复规则，以及使用提醒的各种相关属性，例如闹钟（EventAlarm）、参与者信息、状态检测属性等。

***

## 类：`Reminder`

`Reminder` 类用于操作单个提醒事项，包括读取与修改其属性、管理重复规则与闹钟，以及执行保存或删除操作。

***

# 一、属性说明

### identifier: string

唯一标识符，由系统分配（只读）。

### calendar: Calendar

提醒所属的日历。必须为有效的日历对象。

### title: string

提醒的标题或摘要。

### notes: string | null

备注信息，用于补充提醒内容。

***

## 完成状态相关属性

### isCompleted: boolean

记录提醒是否已完成。

- 设置为 `true` 时，会自动将 `completionDate` 设为当前时间。
- 设置为 `false` 时，会将 `completionDate` 设为 `null`。

说明：如果在其他设备完成了提醒，系统可能出现 `isCompleted = true` 但 `completionDate = null` 的情况。

### completionDate: Date | null

提醒被完成的时间。

- 设置为某个日期时，会自动令 `isCompleted = true`。
- 设置为 `null` 会将提醒标记为未完成。

***

## 截止时间相关属性

### dueDateComponents: DateComponents | null

表示提醒的截止时间，使用 `DateComponents` 可只设置日期部分或同时包含时间部分。

可使用 `DateComponents.isValidDate` 检查是否为有效日期组合。

### dueDate: Date | null

（已被替代的旧字段）

请使用 `dueDateComponents?.date` 获取实际日期。

### dueDateIncludesTime: boolean

（遗留字段）

可通过以下判断是否包含时间字段：
`dueDateComponents?.hour != null && dueDateComponents?.minute != null`

***

## 优先级

### priority: number

提醒的优先级，数值越大表示越重要或紧急。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

重复规则数组。

### hasRecurrenceRules: boolean

是否存在重复规则（只读）。

***

## 闹钟（Alarm）相关

### alarms: EventAlarm\[] | null

提醒绑定的提醒闹钟列表。

支持：

- 绝对时间闹钟
- 相对截止时间的闹钟（基于事件开始时间时使用）
- 地理围栏位置提醒

### hasAlarm: boolean

是否包含闹钟。

***

## 参与者相关

### attendees: EventParticipant\[] | null

提醒可包含参与者对象（只读）。

说明：并非所有来源的提醒都支持参与者。

### hasAttendees: boolean

指示是否存在参与者。

***

## 状态标识属性

### hasNotes: boolean

是否包含备注信息。

### hasChanges: boolean

当前实例或其内部对象是否含有尚未保存的更改。

***

# 二、实例方法

### addAlarm(alarm: EventAlarm): void

为提醒添加一个闹钟。

### removAlarm(alarm: EventAlarm): void

移除提醒中的某个闹钟。
（方法名称为 `removAlarm`）

***

### addRecurrenceRule(rule: RecurrenceRule): void

向提醒添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除指定的重复规则。

***

### `save(): Promise<void>`

保存提醒的修改。若为新建提醒，将自动添加到所属日历。

### `remove(): Promise<void>`

从日历中删除该提醒事项。

***

# 三、静态方法

### `Reminder.getAll(calendars?: Calendar[]): Promise<Reminder[]>`

获取所有提醒，可选指定日历列表。

***

### `Reminder.getIncompletes(options?): Promise<Reminder[]>`

获取未完成的提醒事项，可按截止时间与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含截止时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含截止时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

说明：
该方法不会展开重复提醒实例，仅返回基础提醒条目。

***

### `Reminder.getCompleteds(options?): Promise<Reminder[]>`

获取已完成的提醒事项，可按完成日期范围与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含完成时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含完成时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

***

# 四、示例

## 使用 DateComponents 设置提醒

```ts
const reminder = new Reminder()
reminder.title = "准备会议资料"
reminder.notes = "周一会议前完成"

reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
  hour: 9,
  minute: 30,
})

reminder.priority = 2
await reminder.save()
```

***

## 创建仅包含日期的提醒（无时间）

```ts
reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
})
```

***

## 从 Date 创建 DateComponents

```ts
const now = new Date()
reminder.dueDateComponents = DateComponents.fromDate(now)
```

***

## 获取提醒事项

```ts
const reminders = await Reminder.getAll()
for (const r of reminders) {
  console.log(`提醒：${r.title}`)
}
```

***

## 获取未完成的提醒

```ts
const incompletes = await Reminder.getIncompletes({
  startDate: new Date("2025-01-01"),
  endDate: new Date("2025-01-31"),
})
```

***

## 标记提醒完成

```ts
reminder.isCompleted = true
await reminder.save()
```

***

## 删除提醒

```ts
await reminder.remove()
```

***

# 五、补充说明

### 日期管理

建议使用 `dueDateComponents` 统一处理截止时间相关逻辑。
支持：

- 仅日期
- 完整日期与时间
- 部分字段指定（如只指定小时与分钟）

可使用 `.isValidDate` 判断组件组合是否有效。

***

### 重复提醒

查询方法不展开重复实例，而是返回提醒对象本身。
可通过 `addRecurrenceRule` 与 `removeRecurrenceRule` 管理重复模式。

***

### 闹钟（EventAlarm）

Reminder 与 CalendarEvent 均可使用 `EventAlarm`。
闹钟可基于绝对时间、相对时间或地理位置触发。

***

### 参与者字段

部分提醒来源不一定支持参与者，因此 `attendees` 可能为 `null`。



---
url: /zh/guide/Device Capabilities/Safari/index.md
---

# Safari

`Safari` 模块提供用于打开和展示网页的函数，可通过系统默认浏览器外部打开，或在 Scripting 应用内通过内嵌 Safari 视图打开网页，实现沉浸式或外部浏览的无缝切换。

***

## 模块：`Safari`

该模块包含两个函数：

***

### ▸ `Safari.openURL(url: string): Promise<boolean>`

使用系统默认方式打开指定的 URL。根据 URL 的 scheme 类型，可能会启动 Safari、其他浏览器或对应的第三方应用。

#### 参数

- **`url`** (`string`): 要打开的 URL。支持以 `http://`、`https://` 开头的网址，也支持如 `mailto:`、`tel:`、`appname://` 等自定义 URL scheme。

#### 返回值

- 返回一个 `Promise<boolean>`，当 URL 成功打开时为 `true`，如果打开失败（例如无效的 scheme 或未安装支持的应用）则为 `false`。

#### 示例

```ts
const success = await Safari.openURL('mailto:hello@example.com')
if (!success) {
  console.error('打开 URL 失败')
}
```

***

### ▸ `Safari.present(url: string, fullscreen?: boolean): Promise<void>`

在 Scripting 应用内使用内嵌 Safari 视图展示网页。该网页以模态窗口方式呈现。返回的 Promise 会在用户关闭该视图后才完成。

#### 参数

- **`url`** (`string`): 要展示的网页地址。
- **`fullscreen`** (`boolean`, 可选): 是否以全屏方式展示，默认为 `true`。

#### 返回值

- 一个 `Promise<void>`，在用户关闭网页视图后完成。

#### 示例

默认全屏展示网站：

```ts
await Safari.present('https://developer.apple.com')

// 视图关闭后执行
console.log('网页视图已关闭。')
```

非全屏展示（例如嵌入界面中的子页面）：

```ts
await Safari.present('https://news.ycombinator.com', false)

// 视图关闭后执行
console.log('网页视图已关闭。')
```

***

## 使用场景

- 跳转到外部链接，例如帮助文档、认证页面或 App Store。
- 在应用内展示在线内容，如博客文章、数据面板等。
- 通过自定义 URL scheme 启动第三方应用。

***

## 注意事项

- 请确保传入的是完整有效的 URL。
- 若希望用户停留在应用中，请使用 `present()`。
- 若需跳转到外部浏览器或打开其他 app，请使用 `openURL()`。



---
url: /zh/guide/Device Capabilities/Safari/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, } from "scripting"

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Safari"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Button
        title={"Open URL in system default browser"}
        action={() => {
          Safari.openURL("https://github.com")
        }}
      />

      <Button
        title={"Open URL in-app browser"}
        action={async () => {
          await Safari.present("https://github.com", false)
          console.log("Dismissed")
        }}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/Send Mail.md
---

# 发送邮件

`MailUI` 模块允许你的脚本调用系统的邮件撰写视图，预填收件人、主题、正文和附件，并由用户发送邮件。它还提供一个属性用于检测设备是否支持发送邮件。

原 `Mail` API 已废弃。

***

## `MailUI.isAvailable: boolean`

如果当前设备已配置邮箱账户，并支持通过系统的 Mail 应用发送邮件，返回 `true`。

```ts
if (!MailUI.isAvailable) {
  console.log("当前设备不支持发送邮件。")
}
```

***

## `MailUI.present(options): Promise<"cancelled" | "sent" | "failed" | "saved">`

展示系统级的邮件撰写界面，预填内容并等待用户操作。用户可编辑内容后选择发送、取消或保存草稿。

### 参数说明

| 参数名                            | 类型             | 是否必填 | 说明                         |
| ------------------------------ | -------------- | ---- | -------------------------- |
| `toRecipients`                 | `string[]`     | 是    | 邮件主收件人列表，填写在“收件人”字段        |
| `ccRecipients`                 | `string[]`     | 否    | 抄送收件人列表，填写在“抄送”字段          |
| `bccRecipients`                | `string[]`     | 否    | 密送收件人列表，填写在“密送”字段          |
| `preferredSendingEmailAddress` | `string`       | 否    | 指定用于发送邮件的发件邮箱（如果配置了多个邮箱账户） |
| `subject`                      | `string`       | 否    | 邮件主题内容                     |
| `body`                         | `string`       | 否    | 邮件正文内容                     |
| `attachments`                  | `Attachment[]` | 否    | 附件数组，添加文件至邮件中              |

### 附件对象结构

每个附件应包含以下字段：

| 字段名        | 类型       | 是否必填 | 说明                                               |
| ---------- | -------- | ---- | ------------------------------------------------ |
| `data`     | `Data`   | 是    | 要附加的二进制数据内容                                      |
| `mimeType` | `string` | 是    | 附件的 MIME 类型，例如 `"image/png"`、`"application/pdf"` |
| `fileName` | `string` | 是    | 附件在邮件中显示的文件名                                     |

***

### 返回值

此方法返回一个 `Promise`，其结果为下列字符串之一：

- `"sent"`：邮件已成功发送；
- `"cancelled"`：用户取消了发送操作；
- `"failed"`：发送失败（如无邮箱账户配置或发送错误）；
- `"saved"`：邮件已保存为草稿。

***

### 抛出异常

当满足以下条件时，此方法会抛出异常：

- 当前设备不支持发送邮件（`MailUI.isAvailable` 为 `false`）；
- 参数格式错误或缺少必填项；

***

## 示例：发送简单邮件

```ts
if (MailUI.isAvailable) {
  const result = await MailUI.present({
    toRecipients: ["user@example.com"],
    subject: "来自脚本的问候",
    body: "这封邮件由 Scripting 脚本发送。"
  })

  console.log("发送结果：", result) // 可能为 sent、cancelled、failed 或 saved
}
```

***

## 示例：发送带附件的邮件

```ts
const fileData = Data.fromString("这是附件的内容。")

if (MailUI.isAvailable) {
  const result = await MailUI.present({
    toRecipients: ["user@example.com"],
    subject: "附加文件",
    body: "请查收附件。",
    attachments: [
      {
        data: fileData,
        mimeType: "text/plain",
        fileName: "说明.txt"
      }
    ]
  })

  if (result === "sent") {
    console.log("邮件已成功发送。")
  } else {
    console.log("邮件未发送，状态：", result)
  }
}
```

***

## 注意事项

- 邮件撰写界面必须在具有用户交互的上下文中调用，不能在后台脚本中使用；
- 邮件发送行为由用户最终确认；
- 此 API 需要设备上已正确配置 Mail 应用的邮箱账户。



---
url: /zh/guide/Device Capabilities/Send Message.md
---

# 发送信息

`MessageUI` 命名空间提供了一组 API，用于检测设备的短信发送能力，并展示系统级的短信撰写界面。你可以通过脚本向一个或多个联系人发送短信或彩信，还可以添加主题和附件（如果设备支持）。

## 可用性属性

### `MessageUI.isAvailable: boolean`

如果设备支持发送纯文本短信，返回 `true`。

```ts
if (!MessageUI.isAvailable) {
  console.log("此设备无法发送短信")
}
```

### `MessageUI.canSendSubject: boolean`

如果设备支持添加“主题”字段，返回 `true`。

### `MessageUI.canSendAttachments: boolean`

如果设备支持在短信中添加“附件”，返回 `true`。

***

## `MessageUI.present(options): Promise<"cancelled" | "sent" | "failed">`

展示系统的短信撰写界面，并在用户操作完成后返回结果。

### 参数

| 参数名           | 类型             | 是否必填 | 说明                                           |
| ------------- | -------------- | ---- | -------------------------------------------- |
| `recipients`  | `string[]`     | 是    | 收件人电话号码数组                                    |
| `body`        | `string`       | 是    | 短信正文内容                                       |
| `subject`     | `string`       | 否    | 可选的主题内容，仅在 `canSendSubject` 为 `true` 时有效     |
| `attachments` | `Attachment[]` | 否    | 可选的附件列表，仅在 `canSendAttachments` 为 `true` 时有效 |

### 附件对象结构

| 字段名        | 类型       | 是否必填 | 说明                                               |
| ---------- | -------- | ---- | ------------------------------------------------ |
| `data`     | `Data`   | 是    | 要附加的二进制数据                                        |
| `type`     | `UTType` | 是    | 附件的统一类型标识符，例如 `"public.image"`、`"public.text"` 等 |
| `fileName` | `string` | 是    | 附件在消息中显示的文件名                                     |

***

### 返回值

返回一个 `Promise`，其结果为以下字符串之一：

- `"sent"`：用户已成功发送短信；
- `"cancelled"`：用户取消了发送；
- `"failed"`：系统发送失败（如网络或权限问题）。

***

## 示例：发送普通短信

```ts
if (MessageUI.isAvailable) {
  const result = await MessageUI.present({
    recipients: ["1234567890"],
    body: "你好，这是一条脚本发送的短信！"
  })

  console.log("发送结果：", result) // 可能为 sent、cancelled 或 failed
}
```

***

## 示例：发送带主题和附件的短信

```ts
const fileData = Data.fromString("这是文档的内容")

if (MessageUI.isAvailable && MessageUI.canSendAttachments) {
  const result = await MessageUI.present({
    recipients: ["1234567890"],
    body: "请查收附件文件。",
    subject: "你请求的文件",
    attachments: [
      {
        data: fileData,
        type: "public.text",
        fileName: "说明.txt"
      }
    ]
  })

  if (result === "sent") {
    console.log("短信发送成功")
  } else {
    console.log("短信未发送，原因：", result)
  }
}
```

***

## 注意事项

- 如果设备不支持主题或附件功能，相关选项会被自动忽略。
- 撰写界面由系统提供，用户必须手动发送或取消。
- 该 API 只能在前台交互式脚本中使用，不能在后台任务中调用。



---
url: /zh/guide/Device Capabilities/ShareSheet.md
---

# 分享内容

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"ShareSheet"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        footer={
          <Text>Present a ShareSheet UI.</Text>
        }
      >
        <Button
          title={"ShareSheet.present"}
          action={async () => {
            // const image = await Photos.getLatestPhotos(1)
            // await ShareSheet.present([image])
            if (await ShareSheet.present(["Hello Scripting!"])) {
              Dialog.alert({
                message: "Share successfully."
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/SharedAudioSession.md
---

# SharedAudioSession

通过 `SharedAudioSession`，你可以在脚本中方便地管理和操作共享音频会话（audio session）。音频会话充当脚本、Scripting 应用、操作系统和底层音频硬件之间的中介，允许你有效地配置和控制音频的行为。

***

## 功能简介

- 获取和设置音频会话的类别（category）、模式（mode）和选项（options）。
- 配置音频输入和输出的首选采样率（sample rate）。
- 处理音频中断事件。
- 查询设备所支持的类别和模式。
- 根据具体的应用场景（如视频录制、语音聊天、后台播放等）来定制音频行为。

***

## 方法和属性

### 1. **会话类别与选项**

#### `category`

获取当前音频会话的类别（Category）。

```typescript
const category = await SharedAudioSession.category
console.log(category) // 示例输出：'playback'
```

#### `categoryOptions`

获取当前音频会话类别的选项（Options）。

```typescript
const options = await SharedAudioSession.categoryOptions
console.log(options) // 示例输出：['mixWithOthers', 'allowAirPlay']
```

#### `setCategory(category: AudioSessionCategory, options: AudioSessionCategoryOptions[])`

设置音频会话的类别并指定其选项。

```typescript
await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
```

***

### 2. **会话模式**

#### `mode`

获取当前音频会话模式（Mode）。

```typescript
const mode = await SharedAudioSession.mode
console.log(mode) // 示例输出：'videoChat'
```

#### `setMode(mode: AudioSessionMode)`

设置音频会话模式。

```typescript
await SharedAudioSession.setMode('voiceChat')
```

***

### 3. **采样率 (Sample Rate)**

#### `preferredSampleRate`

获取当前首选采样率（单位为 Hz）。

```typescript
const sampleRate = await SharedAudioSession.preferredSampleRate
console.log(sampleRate) // 示例输出：44100
```

#### `setPreferredSampleRate(sampleRate: number)`

设置音频输入和输出的首选采样率。

```typescript
await SharedAudioSession.setPreferredSampleRate(48000)
```

***

### 4. **音频中断处理**

#### `addInterruptionListener(listener: AudioSessionInterruptionListener)`

监听音频中断事件。

```typescript
SharedAudioSession.addInterruptionListener((type) => {
  if (type === 'began') {
    console.log('音频中断开始')
  } else if (type === 'ended') {
    console.log('音频中断结束')
  }
})
```

#### `removeInterruptionListener(listener: AudioSessionInterruptionListener)`

移除音频中断监听器。

```typescript
SharedAudioSession.removeInterruptionListener(myListener)
```

***

### 5. **设备功能查询**

#### `availableCategories`

获取设备上可用的音频会话类别列表。

```typescript
const categories = await SharedAudioSession.availableCategories
console.log(categories) // 示例输出：['playback', 'record', 'soloAmbient']
```

#### `availableModes`

获取设备上可用的音频会话模式列表。

```typescript
const modes = await SharedAudioSession.availableModes
console.log(modes) // 示例输出：['default', 'videoChat', 'voiceChat']
```

***

### 6. **其他属性**

#### `isOtherAudioPlaying`

检查设备上是否有其他音频正在播放。

```typescript
const isPlaying = await SharedAudioSession.isOtherAudioPlaying
console.log(isPlaying) // 示例输出：true
```

#### `secondaryAudioShouldBeSilencedHint`

检查次要音频是否应该被静音。

```typescript
const shouldSilence = await SharedAudioSession.secondaryAudioShouldBeSilencedHint
console.log(shouldSilence) // 示例输出：false
```

#### `allowHapticsAndSystemSoundsDuringRecording`

检查录音期间是否允许触觉反馈和系统声音。

```typescript
const allowHaptics = await SharedAudioSession.allowHapticsAndSystemSoundsDuringRecording
console.log(allowHaptics) // 示例输出：true
```

#### `prefersNoInterruptionsFromSystemAlerts`

检查音频会话是否偏好不被系统警报打断。

```typescript
const prefersNoInterruptions = await SharedAudioSession.prefersNoInterruptionsFromSystemAlerts
console.log(prefersNoInterruptions) // 示例输出：false
```

***

### 7. **会话激活**

#### `setActive(active: boolean, options?: AudioSessionSetActiveOptions[])`

激活或停用共享音频会话，可指定激活选项。

```typescript
await SharedAudioSession.setActive(
  true,
  ['notifyOthersOnDeactivation']
)
```

***

### 8. **系统设置**

#### `setAllowHapticsAndSystemSoundsDuringRecording(value: boolean)`

启用或禁用在录音期间允许触觉反馈和系统声音。

```typescript
await SharedAudioSession.setAllowHapticsAndSystemSoundsDuringRecording(true)
```

#### `setPrefersNoInterruptionsFromSystemAlerts(value: boolean)`

设置是否偏好不被系统警报打断。

```typescript
await SharedAudioSession.setPrefersNoInterruptionsFromSystemAlerts(true)
```

***

### 9. **系统输出音量**

#### `outputVolume: number`

获取当前系统输出音量（范围为 0 到 1）。

#### outputVolume 监听事件

类型类型

```ts
type AudioSessionOutputVolumeListener = (newValue: number, oldValue: number) => void
```

##### `addOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

添加系统输出音量监听器。

##### `removeOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

移除系统输出音量监听器。

***

## 枚举（Enumerations）

### **AudioSessionSetActiveOptions**

定义激活选项：

- `'notifyOthersOnDeactivation'`

### **AudioSessionCategory**

定义音频会话的类别：

- `'ambient'`
- `'multiRoute'`
- `'playAndRecord'`
- `'playback'`
- `'record'`
- `'soloAmbient'`

### **AudioSessionCategoryOptions**

定义类别的可选行为：

- `'mixWithOthers'`
- `'duckOthers'`
- `'interruptSpokenAudioAndMixWithOthers'`
- `'allowBluetooth'`
- `'allowBluetoothA2DP'`
- `'allowAirPlay'`
- `'defaultToSpeaker'`
- `'overrideMutedMicrophoneInterruption'`

### **AudioSessionMode**

指定会话模式：

- `'default'`
- `'gameChat'`
- `'measurement'`
- `'moviePlayback'`
- `'spokenAudio'`
- `'videoChat'`
- `'videoRecording'`
- `'voiceChat'`
- `'voicePrompt'`

### **AudioSessionInterruptionType**

指定中断类型：

- `'began'`
- `'ended'`
- `'unknown'`

***

通过此接口，你可以在 Scripting 应用中对音频会话进行深度管理，非常适合构建对音频依赖较高的脚本，如音乐播放器和视频会议工具等。



---
url: /zh/guide/Device Capabilities/Speech/index.md
---

# 语音合成

该接口为文本转语音（TTS）功能提供了高级 API，方便进行语音合成、播放控制以及语音合成相关设置的管理。下面详细介绍 `Speech` API 的方法、属性以及用法示例。

***

## 功能概述

- **文本转语音**：将文本转换为语音，可自定义语速、音调和音量等选项。
- **语音管理**：根据语言或语音标识符来选择系统中的可用语音。
- **Markdown 支持**：将文本作为 Markdown 解析以进行基本格式化。
- **音频会话管理**：与其他音频源无缝衔接，控制音频会话。
- **事件监听器**：对语音合成过程中的生命周期事件做出响应。

***

## 类型定义

### `SpeechBoundary`

指定何时暂停或停止语音：

- `'immediate'`: 立即暂停或停止。
- `'word'`: 在完成当前单词后暂停或停止。

***

### `SpeechSynthesisVoice`

表示语音合成使用的语音：

- `identifier`: 语音的唯一标识符。
- `name`: 语音的显示名称。
- `language`: BCP 47 格式的语言和区域代码。
- `quality`: 语音品质（`'default'`、`'premium'`、`'enhanced'`）。
- `gender`: 语音性别（`'male'`、`'female'`、`'unspecified'`）。

***

### `SpeechProgressDetails`

语音合成过程中有关进度的详细信息：

- `text`: 正在朗读的完整文本。
- `start`: 当前单词在文本中的起始索引。
- `end`: 当前单词在文本中的结束索引。
- `word`: 当前正在朗读的单词。

***

### `SpeechSynthesisOptions`

自定义语音合成的选项：

- `isMarkdown`（可选）: 将文本视为 Markdown 解析。
- `pitch`, `rate`, `volume`: 用于覆盖全局 `Speech` 设置中的音调、语速和音量。
- `preUtteranceDelay`, `postUtteranceDelay`: 控制每句开始前与结束后的延迟。
- `voiceIdentifier`, `voiceLanguage`: 用于覆盖全局语音设置。

***

## 静态属性

### 全局语音设置

- `pitch`: 默认音调（范围：`0.5`～`2.0`；默认值：`1.0`）。
- `rate`: 语速（范围：`Speech.minSpeechRate` ～ `Speech.maxSpeechRate`；默认值：`Speech.defaultSpeechRate`）。
- `volume`: 默认音量（范围：`0.0`～`1.0`；默认值：`1.0`）。
- `preUtteranceDelay`, `postUtteranceDelay`: 全局的发音前后延迟。

### 语音和语言

- `speechVoices`: 获取所有可用语音。
- `currentLanguageCode`: 设备的当前语言代码。

### 音频会话

- `usesApplicationAudioSession`: 指定是否由应用来管理音频会话。

***

## 方法

### 语音播放与合成

- **`speak(text: string, options?: SpeechSynthesisOptions): Promise<void>`**\
  将文本添加到语音队列进行合成和朗读。

- **`synthesizeToFile(text: string, filePath: string, options?: SpeechSynthesisOptions): Promise<void>`**\
  将文本合成为音频文件并保存在文档目录下的指定文件路径。

### 播放控制

- **`pause(at?: SpeechBoundary): Promise<boolean>`**\
  在指定的边界点暂停语音。默认在 `'immediate'` 处暂停。

- **`resume(): Promise<boolean>`**\
  从暂停状态恢复朗读。

- **`stop(at?: SpeechBoundary): Promise<boolean>`**\
  在指定边界点停止朗读。默认在 `'immediate'` 处停止。

### 状态管理

- **`isSpeaking`**: 检查当前合成器是否正在朗读或处于暂停状态。
- **`isPaused`**: 检查当前合成器是否处于暂停状态。

### 语音管理

- **`setVoiceByIdentifier(identifier: string): Promise<boolean>`**\
  根据语音标识符来设置语音。

- **`setVoiceByLanguage(language: string): Promise<boolean>`**\
  根据语言代码来设置语音。

***

## 事件监听器

### 支持的事件

- **`start`**: 语音合成开始。
- **`pause`**: 语音暂停。
- **`continue`**: 语音从暂停状态继续。
- **`finish`**: 语音朗读完成。
- **`cancel`**: 语音合成被取消。
- **`progress`**: 提供合成进度的详细信息（`SpeechProgressDetails`）。

### 监听器管理

- **`addListener(event: string, listener: Function): void`**\
  添加事件监听器。

- **`removeListener(event: string, listener: Function): void`**\
  移除事件监听器。

***

## 示例

### 配置 `SharedAudioSession`

```ts
await SharedAudioSession.setActive(true)
await SharedAudioSession.setCategory(
  "playback",
  ["mixWithOthers"]
)
```

### 播放文本

```ts
await Speech.speak("Hello, world!")
```

### 使用自定义选项朗读文本

```ts
await Speech.speak("Welcome to **Scripting**", {
  isMarkdown: true,
  pitch: 1.5,
  rate: 0.8,
  voiceLanguage: "en-US",
})
```

### 将文本合成为文件

```ts
import { Path } from "scripting"

const filePath = Path.join(FileManager.documentDirectory, "output.caf")
await Speech.synthesizeToFile("Saving to file.", filePath, { rate: 1.0 })
```

### 控制播放

```ts
await Speech.speak("Pausing example...")
await Speech.pause("word")
await Speech.resume()
await Speech.stop() // 默认在 "immediate" 处停止。
```

### 添加进度监听器

```ts
Speech.addListener("progress", (details) => {
  console.log(`正在朗读: ${details.word}`)
});
await Speech.speak("Event listening example.")
Speech.removeListener("progress", listener)
```

通过这些 API，你可以在脚本中实现功能强大的语音合成操作，包括基础的文本转语音、播放控制以及事件回调，为开发者提供灵活且丰富的 TTS 功能。



---
url: /zh/guide/Device Capabilities/Speech/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Path, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Speech Example"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Activate the SharedAudioSeesion, and speak a text.</Text>
        }
      >
        <Button
          title={"Speak a text"}
          action={async () => {
            console.present()
            if (await Speech.isSpeaking) {
              await Speech.stop('immediate')
              console.log("Stopped.")
              return
            }

            await SharedAudioSession.setActive(true)
            await SharedAudioSession.setCategory('playback', ['mixWithOthers'])

            const listener = () => {
              console.log("Speak completed!")
              Speech.removeListener('finish', listener)
            }

            Speech.addListener('finish', listener)

            await Speech.speak('Hi there, welcome to Scripting! I wish this app is helpful to you.', {
              voiceLanguage: 'en-US',
            })

            console.log("Started, tap the run button to stop.")
          }}
        />
      </Section>
      <Section
        footer={
          <Text>Synthesize text to the file stored in local documents directory.</Text>
        }
      >
        <Button
          title={"synthesize to File"}
          action={async () => {
            console.present()
            const filePath = Path.join(FileManager.documentsDirectory, 'greeting.caf')
            const listener = () => {
              if (FileManager.existsSync(filePath)) {
                console.log("Audio file is saved to " + filePath + ". Start to play it.")

                let player = new AVPlayer()
                player.setSource(filePath)
                player.onReadyToPlay = () => {
                  player.play()
                }
                player.onEnded = () => {
                  player.dispose()
                }
              } else {
                console.log("Failed to save audio file.")
              }
              Speech.removeListener('finish', listener)
            }

            Speech.addListener('finish', listener)

            await Speech.synthesizeToFile(
              'Hi there, welcome to Scripting! I wish this app is helpful to you.',
              filePath, {
              voiceLanguage: 'en-US',
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/SpeechRecognition/index.md
---

# 语音识别

该接口可用于执行语音识别，包括实时语音识别和音频文件的识别，能适应多种使用场景的需求。

***

## 功能概览

- **实时识别**：从麦克风捕获实时音频并转录为文本。
- **文件识别**：分析和转录已录制的音频文件。
- **多语言支持**：指定识别的语言区域，用于识别不同语言。
- **中间结果**：获取渐进式的转录结果，包括部分结果和最终结果。
- **自定义回调**：通过事件监听器处理转录结果和音量变化等。

***

## 类型定义

### `RecognitionTaskHint`

用于指定语音识别任务的类型提示：

- `'confirmation'`：适合诸如“yes”，“no”或“maybe”之类的指令。
- `'dictation'`：类似键盘输入的语音听写。
- `'search'`：识别搜索关键词。
- `'unspecified'`：通用的语音识别。

***

### `SpeechRecognitionResult`

表示语音识别的结果：

- `isFinal`: 表示该转录结果是否完整且最终。
- `text`: 转录内容，为置信度最高的可展示文本。

***

## 静态属性

### 支持的语言区域

- `supportedLocales`: 返回该语音识别器支持的语言区域列表，如 `"en-US"`、`"fr-FR"` 或 `"zh-CN"` 等。

### 识别状态

- `isRecognizing`: 指示当前是否有识别请求在进行中。

***

## 方法

### 开始实时识别

**`start(options: object): Promise<boolean>`**\
从设备麦克风开始进行语音识别。

#### Options 参数

- `locale`: 识别所用的语言区域字符串（可选）。
- `partialResults`: 是否返回中间结果（默认为 `true`）。
- `addsPunctuation`: 是否自动添加标点符号（默认为 `false`）。
- `requestOnDeviceRecognition`: 是否将音频数据留在本地进行识别（默认为 `false`）。
- `taskHint`: 指定识别任务类型（`'confirmation'`, `'dictation'`, `'search'`, `'unspecified'`）。
- `useDefaultAudioSessionSettings`: 是否使用默认的音频会话设置（默认为 `true`）。
- `onResult`: 用于处理识别结果的回调函数（参数类型为 `SpeechRecognitionResult`）。
- `onSoundLevelChanged`: 音量变化时触发的回调函数（可选）。

#### 使用示例

```ts
await SpeechRecognition.start({
  locale: "en-US",
  partialResults: true,
  addsPunctuation: true,
  onResult: (result) => {
    console.log("Transcription:", result.text)
  },
  onSoundLevelChanged: (level) => {
    console.log("Sound Level:", level)
  }
})
```

***

### 识别音频文件

**`recognizeFile(options: object): Promise<boolean>`**\
对已录制的音频文件进行识别。

#### Options 参数

- `filePath`: 音频文件的路径。
- `locale`: 识别所用的语言区域字符串（可选）。
- `partialResults`: 是否返回中间结果（默认为 `false`）。
- `addsPunctuation`: 是否自动添加标点符号（默认为 `false`）。
- `requestOnDeviceRecognition`: 是否将音频数据留在本地进行识别（默认为 `false`）。
- `taskHint`: 指定识别任务类型（`'confirmation'`, `'dictation'`, `'search'`, `'unspecified'`）。
- `onResult`: 用于处理识别结果的回调函数（参数类型为 `SpeechRecognitionResult`）。

#### 使用示例

```ts
await SpeechRecognition.recognizeFile({
  filePath: FileManager.join(FileManager.documentDirectory, "example.wav"),
  locale: "en-US",
  addsPunctuation: true,
  onResult: (result) => {
    console.log("File Transcription:", result.text)
  }
})
```

***

### 停止识别

**`stop(): Promise<void>`**\
停止当前正在进行的语音识别。

#### 使用示例

```ts
await SpeechRecognition.stop()
```

***

## 示例

### 实时识别并查看进度

```ts
await SpeechRecognition.start({
  locale: "en-US",
  onResult: (result) => {
    console.log(result.isFinal ? "Final Result:" : "Partial Result:", result.text)
  },
  onSoundLevelChanged: (level) => {
    console.log("Sound Level:", level)
  }
})
```

### 识别音频文件

```ts
await SpeechRecognition.recognizeFile({
  filePath: FileManager.join(FileManager.documentDirectory, "audio.m4a"),
  partialResults: false,
  onResult: (result) => {
    console.log("File recognition completed. Transcription:", result.text)
  }
})
```

### 停止正在进行的识别

```ts
if (await SpeechRecognition.start({
  // ...
})) {
  // 10 秒后停止识别
  setTimeout(() => {
    await SpeechRecognition.stop()
  }, 10 * 1000)
}
```

***

## 注意事项

- 在使用该 API 前，请先确保已获取必要的麦克风或文件访问权限。
- 可以使用 `supportedLocales` 来确定可用于识别的语言。
- 为了获得最佳效果，请使用 iOS 支持的音频格式（例如 `.wav`, `.m4a`）作为输入。



---
url: /zh/guide/Device Capabilities/SpeechRecognition/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"SpeechRecognition"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Returns the list of locales that are supported by the speech recognizer.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.supportedLocales"}
          action={() => {
            console.clear()
            console.present()
            console.log(JSON.stringify(SpeechRecognition.supportedLocales, null, 2))
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Returns a boolean that indicates whether the recognizer is running.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.isRecognizing"}
          action={() => {
            console.clear()
            console.present()
            console.log(
              "SpeechRecognition.isRecognizing",
              SpeechRecognition.isRecognizing
            )
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Start a speech audio buffer recognition request. Return a boolean value that indicates whether the operation was successfully.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.start"}
          action={async () => {
            console.clear()
            console.present()
            console.log("Speech recognizing is started, it will stop after 5s.")

            if (await SpeechRecognition.start({
              locale: "en-US",
              partialResults: false,
              onResult: result => {
                console.log("Result: " + result.text)
              }
            })) {
              setTimeout(async () => {
                await SpeechRecognition.stop()
                console.log("Stoped")
              }, 5000)
            } else {
              console.error("Failed to start recognizing")
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Start a request to recognize speech in a recorded audio file.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.recognizeFile"}
          action={async () => {
            console.clear()
            console.present()
            console.log("SpeechRecognition is started, it will stop after 5s.")

            let audioFilePathToRecognize = await DocumentPicker.pickFiles({
              types: ["public.audio"]
            })

            if (audioFilePathToRecognize.length === 0) {
              console.log("Please pick a audio file.")
              return
            }

            if (await SpeechRecognition.recognizeFile({
              filePath: audioFilePathToRecognize[0],
              partialResults: true,
              onResult: (result) => {
                console.log("Recognized result: " + result.text)
              }
            })) {
              console.log("Started recognizing file...")
            } else {
              console.error("Failed to start recognizing",)
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Stop speech recognition request. Return a boolean value that indicates whether the operation was successfully.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.stop"}
          action={async () => {
            if (SpeechRecognition.isRecognizing) {
              await SpeechRecognition.stop()
              Dialog.alert({
                message: "SpeechRecognition is stopped."
              })
            } else {
              Dialog.alert({
                message: "No progressing recognition."
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}


async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Device Capabilities/Translation.md
---

# 翻译

`Translation` API 提供了将文本在不同语言之间翻译的能力，支持单条文本和批量文本的翻译，适用于 **iOS 18.0 及以上系统**。

## 概览

此 API 通过 `Translation` 类提供，包含以下功能：

- 共享的全局翻译实例 `Translation.shared`
- 翻译单条文本
- 翻译多条文本（批量翻译）
- 支持自动检测源语言并根据设备偏好选择目标语言

***

## 类：`Translation`

### `Translation.shared: Translation`

提供一个共享的 `Translation` 实例，适用于无界面脚本或需要复用统一翻译主机的场景。

#### 示例

```ts
const translated = await Translation.shared.translate({
  text: "Hello, world!",
  source: "en",
  target: "es"
})

console.log(translated) // 输出: "¡Hola, mundo!"
```

***

### 方法：`translate(options): Promise<string>`

将一段文本从源语言翻译为目标语言。

#### 参数

- `options.text: string`
  要翻译的文本内容。

- `options.source?: string`
  源语言代码，例如 `"en"` 表示英语。如果省略或为 `null`，系统将自动尝试识别源语言，并在不确定时提示用户选择。

- `options.target?: string`
  目标语言代码，例如 `"es"` 表示西班牙语。如果省略或为 `null`，系统将根据设备的 `Device.preferredLanguages` 和源语言自动选择目标语言。

#### 返回值

- `Promise<string>` — 返回一个 Promise，解析为翻译后的文本字符串。

#### 异常

- 翻译失败时会抛出错误（例如网络问题、不支持的语言等）。

#### 示例

```ts
const translated = await Translation.shared.translate({
  text: "Good morning",
  target: "fr"
})

console.log(translated) // 输出: "Bonjour"
```

***

### 方法：`translateBatch(options): Promise<string[]>`

将多个文本条目从源语言翻译为目标语言，支持批量处理。

#### 参数

- `options.texts: string[]`
  要翻译的文本数组。返回的翻译结果与输入顺序一一对应。

- `options.source?: string`
  源语言代码，作用同 `translate` 方法。

- `options.target?: string`
  目标语言代码，作用同 `translate` 方法。

#### 返回值

- `Promise<string[]>` — 返回一个 Promise，解析为翻译后的文本数组。

#### 异常

- 如果翻译过程中出现任何错误，会抛出异常。

#### 示例

```ts
const results = await Translation.shared.translateBatch({
  texts: ["Hello", "Good night", "Thank you"],
  source: "en",
  target: "ja"
})

console.log(results)
// 输出: ["こんにちは", "おやすみなさい", "ありがとう"]
```

***

## 注意事项

- 语言代码应使用 [ISO 639-1](https://zh.wikipedia.org/wiki/ISO_639-1) 标准（如 `"en"` 表示英语，`"zh"` 表示中文，`"de"` 表示德语）。

- API 使用系统级翻译服务，部分情况下可能弹出语言选择提示。

- 在以下场景中应使用 `translationHost` 视图修饰符：
  - **在用户界面中进行翻译操作**
    当你的脚本包含用户界面（例如使用 `<VStack>`、`<List>` 等）并使用自定义的 `Translation` 实例（例如通过 `new Translation()` 创建）执行翻译时，**必须**将 `translationHost` 应用于根视图，以便系统能够弹出权限请求、语言下载提示或源语言选择对话框。

  - **未指定源语言（`source` 为 `null`）**
    如果在翻译请求中省略了 `source` 字段，依赖系统自动检测语言，当检测失败时，`translationHost` 可确保系统能够提示用户手动选择源语言。

  - **可能需要下载语言包**
    如果设备未安装所需的源语言或目标语言，`translationHost` 允许系统向用户弹出下载提示，从而完成翻译任务。

- 如果你使用的是预设绑定的 `Translation.shared` 实例，并且脚本不涉及任何界面（如后台运行的脚本），则**不需要**设置 `translationHost`。



---
url: /zh/guide/Device Capabilities/VideoRecorder.md
---

# 视频录制（VideoRecorder）

`VideoRecorder` 用于在 Scripting 中创建和控制一个可编程的视频录制会话，完整封装了相机选择、音视频采集、编码、暂停/恢复、缩放、对焦、补光灯控制以及最终文件写入流程。

该 API 适用于自定义相机界面、视频采集工具、自动化录制脚本等场景。

***

## 核心能力概览

- 支持前置与后置摄像头
- 支持指定摄像头类型（广角、超广角、长焦等）
- 支持多种帧率（24 / 30 / 60 / 120）
- 支持音频录制的启用与禁用
- 支持多种系统 Session Preset
- 支持多种视频编码格式（HEVC / H.264 / ProRes 等）
- 支持录制过程中的暂停与恢复
- 支持对焦点、曝光点独立控制
- 支持变焦与平滑变焦（ramp）
- 支持补光灯（Torch）控制
- 明确的状态机与状态回调
- 明确的生命周期管理（prepare / reset / dispose）

***

## 类型定义

### CameraPosition

```ts
type CameraPosition = "front" | "back"
```

表示使用的摄像头朝向。

***

### CameraType

```ts
type CameraType =
  | "wide"
  | "ultraWide"
  | "telephoto"
  | "trueDepth"
  | "dual"
  | "dualWide"
  | "triple"
```

表示摄像头的物理类型。
是否支持某一类型取决于设备硬件能力。

***

### VideoRecorderState

```ts
type VideoRecorderState =
  | "idle"
  | "preparing"
  | "ready"
  | "recording"
  | "paused"
  | "finishing"
  | "finished"
  | "failed"
```

#### 状态说明

| 状态          | 含义             |
| ----------- | -------------- |
| `idle`      | 初始状态，尚未配置资源    |
| `preparing` | 正在配置相机会话与音视频管线 |
| `ready`     | 已准备完成，可以开始录制   |
| `recording` | 正在录制           |
| `paused`    | 录制已暂停          |
| `finishing` | 正在结束录制并写入文件    |
| `finished`  | 录制完成           |
| `failed`    | 发生错误，录制失败      |

***

### VideoCaptureSessionPreset

```ts
type VideoCaptureSessionPreset =
  | "high"
  | "medium"
  | "low"
  | "cif352x288"
  | "vga640x480"
  | "iFrame960x540"
  | "iFrame1280x720"
  | "hd1280x720"
  | "hd1920x1080"
  | "hd4K3840x2160"
```

表示捕捉会话的分辨率预设。

***

### VideoCodec

```ts
type VideoCodec =
  | "hevc"
  | "h264"
  | "jpeg"
  | "JPEGXL"
  | "proRes4444"
  | "appleProRes4444XQ"
  | "proRes422"
  | "proRes422HQ"
  | "proRes422LT"
  | "proRes422Proxy"
  | "proResRAW"
  | "proResRAWHQ"
  | "hevcWithAlpha"
```

表示视频编码格式。
具体是否可用取决于设备与系统支持情况。

***

### VideoOrientation

```ts
type VideoOrientation =
  | "portrait"
  | "landscapeLeft"
  | "landscapeRight"
```

表示输出视频的方向。

***

## 构造函数

```ts
new VideoRecorder(settings?)
```

### settings 参数

```ts
{
  camera?: {
    position: CameraPosition
    preferredTypes?: CameraType[]
  }
  frameRate?: number
  audioEnabled?: boolean
  sessionPreset?: VideoCaptureSessionPreset
  videoCodec?: VideoCodec
  videoBitRate?: number
  orientation?: VideoOrientation
  mirrorFrontCamera?: boolean
}
```

#### 参数说明

- **camera**

  - `position`
    使用的摄像头位置，默认 `"back"`
  - `preferredTypes`
    偏好的摄像头类型列表
    如果未提供，内部将根据摄像头位置自动选择合适的类型

- **frameRate**
  目标帧率，支持 24 / 30 / 60 / 120，默认 30
  实际帧率受设备与分辨率限制

- **audioEnabled**
  是否录制音频，默认 `true`

- **sessionPreset**
  捕捉会话分辨率预设，默认 `"high"`

- **videoCodec**
  视频编码格式，默认 `"hevc"`

- **videoBitRate**
  视频平均码率（bit/s），未指定时由系统自动选择

- **orientation**
  输出视频方向，默认 `"portrait"`

- **mirrorFrontCamera**
  前置摄像头是否镜像，默认 `true`
  仅在使用前置摄像头时生效

***

## 只读属性

### minZoomFactor

```ts
readonly minZoomFactor: number
```

当前设备支持的最小变焦倍率。

***

### maxZoomFactor

```ts
readonly maxZoomFactor: number
```

当前设备支持的最大变焦倍率。

***

### currentZoomFactor

```ts
readonly currentZoomFactor: number
```

当前变焦倍率。

***

### displayZoomFactor

```ts
readonly displayZoomFactor: number
```

用户可读的变焦倍率。

***

### hasTorch

```ts
readonly hasTorch: boolean
```

当前摄像头是否支持补光灯。

***

### torchMode

```ts
readonly torchMode: "auto" | "on" | "off"
```

当前补光灯模式。

***

## 状态与回调

### state

```ts
state: VideoRecorderState
```

表示当前录制器所处的状态。

***

### onStateChanged

```ts
onStateChanged?: (
  state: VideoRecorderState,
  details?: string
) => void
```

状态变化回调。

- 当 `state === "failed"`
  `details` 为错误信息描述

- 当 `state === "finished"`
  `details` 为最终视频文件的完整保存路径

***

## 方法说明

### prepare()

```ts
prepare(): Promise<void>
```

准备录制器资源，包括相机会话、输入输出与音视频管线配置。

#### 使用约束

- 必须在 `startRecording` 之前调用
- 成功后状态变为 `ready`
- 失败会进入 `failed` 状态

***

### startRecording(toPath)

```ts
startRecording(toPath: string): void
```

开始录制视频。

#### 参数

- **toPath**
  视频文件保存路径（完整路径）

#### 使用约束

- 仅允许在 `ready` 状态下调用
- 调用后状态变为 `recording`

***

### pauseRecording()

```ts
pauseRecording(): void
```

暂停当前录制。

#### 使用约束

- 仅允许在 `recording` 状态下调用
- 调用后状态变为 `paused`
- 时间线会被正确压缩，不产生空白帧

***

### resumeRecording()

```ts
resumeRecording(): void
```

恢复已暂停的录制。

#### 使用约束

- 仅允许在 `paused` 状态下调用
- 调用后状态回到 `recording`

***

### stopRecording()

```ts
stopRecording(): Promise<void>
```

停止录制并生成最终视频文件。

#### 行为说明

- 状态先进入 `finishing`
- 文件写入完成后进入 `finished`
- 最终文件路径通过 `onStateChanged` 回调返回

***

### reset()

```ts
reset(): Promise<void>
```

重置录制器状态，用于开始新一轮录制。

#### 使用场景

- 已完成一次录制
- 或录制失败后希望复用同一实例

#### 行为说明

- 成功后状态回到 `idle`
- 可再次调用 `prepare`

***

### setTorchMode()

```ts
setTorchMode(mode: "auto" | "off" | "on"): void
```

设置补光灯模式。

***

### setFocusPoint()

```ts
setFocusPoint(point: { x: number; y: number }): void
```

设置对焦点。

- 坐标为归一化值，范围 `0.0 ~ 1.0`
- `(0,0)` 表示画面左上角，`(1,1)` 表示右下角

***

### setExposurePoint()

```ts
setExposurePoint(point: { x: number; y: number }): void
```

设置曝光点，坐标规则与对焦点一致。

***

### resetFocus()

```ts
resetFocus(): void
```

恢复自动对焦模式。

***

### resetExposure()

```ts
resetExposure(): void
```

恢复自动曝光模式。

***

### setZoomFactor()

```ts
setZoomFactor(factor: number): void
```

立即设置变焦倍率。

- 值应位于 `minZoomFactor` 与 `maxZoomFactor` 之间

***

### rampZoomFactor()

```ts
rampZoomFactor(toFactor: number, rate: number): void
```

以平滑方式调整变焦倍率。

- `toFactor` 为目标倍率
- `rate` 为变化速率，单位为每秒的 2 次幂变化

***

### resetZoom()

```ts
resetZoom(): void
```

将变焦倍率恢复为默认值（通常为 1.0）。

***

### dispose()

```ts
dispose(): Promise<void>
```

释放并销毁录制器。

#### 使用约束

- 调用后实例不可再使用
- 会释放相机、音频与底层系统资源
- 建议在页面或脚本生命周期结束时调用

***

## 典型使用流程

```ts
const recorder = new VideoRecorder({
  camera: { position: "back" },
  frameRate: 60,
  videoCodec: "hevc"
})

recorder.onStateChanged = (state, details) => {
  if (state === "finished") {
    console.log("Video saved at:", details)
  }
}

await recorder.prepare()
recorder.startRecording("/path/to/tmp/demo.mov")
```

***

## 使用建议

- 始终监听 `onStateChanged` 以掌握完整状态变化
- 不要在未调用 `prepare` 的情况下开始录制
- 每次完成录制后，如需复用实例，应先调用 `reset`
- 生命周期结束时务必调用 `dispose` 释放资源



---
url: /zh/guide/Device Capabilities/Vision.md
---

# 视觉

`Vision` 模块提供了用于**文本识别**的 API。\
支持从静态图片中识别文本，或者通过相机扫描文档并提取文本内容。

***

## 类型

### `RecognizedText`

表示单个识别到的文本块。

- `content: string`\
  识别到的文本内容。

- `confidence: number`\
  置信度（0.0 到 1.0 之间），1.0 表示最高置信度。

- `boundingBox: { x: number, y: number, width: number, height: number }`\
  文本所在的矩形区域，使用归一化坐标表示。

***

### `RecognizeTextOptions`

文本识别的配置选项。

- `recognitionLevel?: "accurate" | "fast"`\
  识别模式：
  - `"accurate"`（默认）：优先保证准确度。
  - `"fast"`：优先保证速度。

- `recognitionLanguages?: string[]`\
  识别时优先使用的语言数组（ISO 语言编码）。

- `usesLanguageCorrection?: boolean`\
  是否在识别过程中应用语言自动纠错。

- `minimumTextHeight?: number`\
  最小识别文本高度，相对于图片高度（默认 `0.03125`）。

- `customWords?: string[]`\
  补充词汇表（只在启用语言纠错时生效）。

***

## 函数

### `recognizeText(image: UIImage, options?: RecognizeTextOptions): Promise<{ text: string, candidates: RecognizedText[] }>`

对指定图片进行文本识别。

- **参数**：
  - `image`：要识别的 `UIImage` 对象。
  - `options` _(可选)_：文本识别配置。

- **返回**：\
  返回 Promise，包含：
  - `text`：识别出的完整文本。
  - `candidates`：识别出的文本块数组及详细信息。

***

### `scanDocument(options?: RecognizeTextOptions): Promise<string[]>`

使用相机扫描文档并识别文本。

- **参数**：
  - `options` _(可选)_：文本识别配置。

- **返回**：\
  返回 Promise，包含识别到的文档文本数组。\
  如果用户取消，Promise 将抛出错误。

***

## 使用示例

### 识别图片文件中的文本

```tsx
const image = UIImage.fromFile('/路径/图片.png')
if (image) {
  const result = await Vision.recognizeText(image, {
    recognitionLevel: 'accurate',
    recognitionLanguages: ['zh-Hans', 'en'],
    usesLanguageCorrection: true
  })
  console.log('识别到的完整文本：', result.text)

  for (const block of result.candidates) {
    console.log(`文本：${block.content}，置信度：${block.confidence}`)
  }
}
```

***

### 使用相机扫描文档

```tsx
try {
  const documents = await Vision.scanDocument({
    recognitionLevel: 'fast',
    recognitionLanguages: ['zh-Hans']
  })
  console.log('扫描到的文档内容：', documents)
} catch (error) {
  console.error('扫描取消或失败：', error)
}
```



---
url: /zh/guide/Device Capabilities/Weather/index.md
---

# 天气

Scripting 的天气 API 提供对实时天气和天气预报数据的访问，包括当前天气状况、每小时预报和每日预报。用户可以获取指定位置的温度、风速、湿度和降水等天气信息。

## 类型定义

### `UnitType`

表示带有数值、符号和格式化字符串的测量单位。

```ts
type UnitType = {
  value: number
  symbol: string
  formatted: string
}
```

### `UnitTemperature`, `UnitSpeed`, `UnitLength`, `UnitAngle`, `UnitPressure`

这些类型基于 `UnitType`，分别表示温度、速度、长度、角度和气压。

## `WeatherCondition`

字符串枚举，描述各种天气状况，包括：

- `clear`（晴朗）
- `rain`（雨）
- `snow`（雪）
- `thunderstorms`（雷暴）
- `cloudy`（多云）
- `windy`（有风）
- ...

## API 方法

### `Weather.requestCurrent(location: LocationInfo): Promise<CurrentWeather>`

获取指定位置的当前天气状况。

#### 参数

- `location: LocationInfo` – 需要查询天气的位置。

#### 返回值

返回一个 `Promise`，解析为 `CurrentWeather` 对象。

#### 示例

```ts
const location = { latitude: 37.7749, longitude: -122.4194 }
const weather = await Weather.requestCurrent(location)
console.log(`当前温度：${weather.temperature.formatted}`)
```

### `Weather.requestDailyForecast(location: LocationInfo, options?: { startDate: Date, endDate: Date }): Promise<WeatherDailyForecast>`

获取指定位置每日天气预报。你可以选择传入开始日期和结束日期以自定义查询范围。

#### 参数

- `location: LocationInfo` – 查询的位置。
- `options.startDate` – 预报开始日期。
- `options.endDate` – 预报结束日期。

#### 返回值

返回一个 `Promise`，解析为 `WeatherDailyForecast` 对象。

#### 示例

```ts
const forecast = await Weather.requestDailyForecast(location, {
  startDate: new Date(),
  endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000)
})
console.log(`明天天气：${forecast.forecast[1].condition}`)
```

### `Weather.requestHourlyForecast(location: LocationInfo, options?: { startDate: Date, endDate: Date }): Promise<WeatherHourlyForecast>`

获取指定位置每小时的天气预报。你可以选择传入开始日期和结束日期以自定义查询范围。

#### 参数

- `location: LocationInfo` – 查询的位置。
- `options.startDate` – 预报开始时间。
- `options.endDate` – 预报结束时间。

#### 返回值

返回一个 `Promise`，解析为 `WeatherHourlyForecast` 对象。

#### 示例

```ts
const hourlyForecast = await Weather.requestHourlyForecast(location, {
  startDate: new Date(),
  endDate: new Date(Date.now() + 3 * 60 * 60 * 1000)
})
console.log(`下一小时温度：${hourlyForecast.forecast[0].temperature.formatted}`)
```

## `CurrentWeather`

表示当前天气状况。

```ts
type CurrentWeather = {
  temperature: UnitTemperature
  apparentTemperature: UnitTemperature
  humidity: number
  wind: WeatherWind
  condition: WeatherCondition
  date: number
  symbolName: string
}
```

## `WeatherDailyForecast`

表示每日天气预报。

```ts
type WeatherDailyForecast = {
  metadata: WeatherMetadata
  forecast: DayWeather[]
}
```

## `WeatherHourlyForecast`

表示每小时天气预报。

```ts
type WeatherHourlyForecast = {
  metadata: WeatherMetadata
  forecast: HourWeather[]
}
```

## `DayWeather`

表示每日天气详情。

```ts
type DayWeather = {
  highTemperature: UnitTemperature
  lowTemperature: UnitTemperature
  wind: WeatherWind
  condition: WeatherCondition
  date: number
  symbolName: string
}
```

## `HourWeather`

表示每小时天气详情。

```ts
type HourWeather = {
  temperature: UnitTemperature
  humidity: number
  wind: WeatherWind
  condition: WeatherCondition
  date: number
  symbolName: string
}
```

## 使用示例

### 获取并显示当前天气

```ts
async function displayCurrentWeather() {
  const location = { latitude: 37.7749, longitude: -122.4194 }
  const weather = await Weather.requestCurrent(location)
  console.log(`温度：${weather.temperature.formatted}，天气：${weather.condition}`)
}

displayCurrentWeather()
```

### 获取并显示每日天气预报

```ts
async function displayDailyForecast() {
  const location = { latitude: 37.7749, longitude: -122.4194 }
  const forecast = await Weather.requestDailyForecast(location, {
    startDate: new Date(),
    endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  })
  forecast.forecast.forEach(day => {
    console.log(`日期：${new Date(day.date).toDateString()}，天气：${day.condition}`)
  })
}

displayDailyForecast()
```

### 获取并显示每小时天气预报

```ts
async function displayHourlyForecast() {
  const location = { latitude: 37.7749, longitude: -122.4194 }
  const hourlyForecast = await Weather.requestHourlyForecast(location, {
    startDate: new Date(),
    endDate: new Date(Date.now() + 5 * 60 * 60 * 1000)
  })
  hourlyForecast.forecast.forEach(hour => {
    console.log(`时间：${new Date(hour.date).toLocaleTimeString()}，温度：${hour.temperature.formatted}`)
  })
}

displayHourlyForecast()
```



---
url: /zh/guide/Device Capabilities/Weather/index_example.md
---

# 示例

```tsx
import { Script } from "scripting"

console.present().then(() => {
  Script.exit()
})

console.log("Requesting Current Weather...")

async function displayCurrentWeather() {
  let location: LocationInfo | null = null
  try {
    console.log("Requesting location... Please move your device to trigger a location update.")
    location = await Location.requestCurrent()

    if (location) {
      const placemarks = await Location.reverseGeocode(location)
      if (placemarks && placemarks.length) {
        console.log(`Your current location: ${JSON.stringify(placemarks[0], null, 2)}`)
      }
    }
  } catch (e) {
    console.log("Failed to request location", e)
  }

  if (!location) {
    console.error("Please approval the location permission request")
    return
  }

  // Use the WeatherKit
  const weather = await Weather.requestCurrent(
    location
  )

  console.log(
    `The temperature is ${weather.temperature.formatted
    } with ${weather.condition}`
  )
}

displayCurrentWeather()
```



---
url: /zh/guide/Device Capabilities/WebViewController.md
---

# WebView 控制器

`WebViewController` 是一个用于显示和交互网页内容的控制器。它允许你在脚本中加载 HTML、展示 Web 页面、执行 JavaScript 脚本，并与页面中的 JavaScript 进行消息通信。你可以将它作为浏览器使用，也可以嵌入应用功能页面。

***

## 类：`WebViewController`

```ts
const webView = new WebViewController()
```

***

## 属性

### `shouldAllowRequest?: (request) => Promise<boolean>`

一个可选回调，用于决定是否允许或拦截 WebView 发起的请求。每次加载资源之前都会调用此函数，例如导航到新页面或提交表单时。

适用于拦截跳转行为、自定义安全策略或过滤广告等不需要的请求。

#### 参数

回调函数接收一个 `request` 对象，包含以下字段：

- `url: string`
  请求的完整 URL。

- `method: string`
  HTTP 方法，如 `GET`、`POST`。

- `body?: Data | null`
  可选，请求体数据（通常用于 `POST` 请求）。

- `headers: Record<string, string>`
  请求头信息。

- `timeoutInterval: number`
  请求的超时时间（单位为秒）。

- `navigationType: "linkActivated" | "reload" | "backForward" | "formResubmitted" | "formSubmitted" | "other"`
  触发导航的上下文。

#### 返回值

一个 `Promise<boolean>`，用于指示是否允许该请求：

- `true`：允许请求继续
- `false`：阻止该请求

#### 示例

```ts
const webView = new WebViewController()

webView.shouldAllowRequest = async (request) => {
  console.log('拦截到请求：', request.url)

  // 拦截所有访问 example.com 的请求
  if (request.url.includes('example.com')) {
    return false
  }

  return true
}

await webView.loadURL('https://www.wikipedia.org')
await webView.present({ navigationTitle: '已过滤的网页视图' })
```

***

## 方法

### `loadURL(url: string): Promise<boolean>`

加载指定 URL 的网页内容。

- **参数**：

  - `url`：要加载的网页完整地址。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadFile(path: string, allowingReadAccessTo?: string): Promise<boolean>`

加载文件内容作为网页。

- **参数**:

  - `path`：要加载的文件路径。
  - `allowingReadAccessTo`（可选）：允许读取文件的路径，默认为 `path`。
- **返回**：`Promise<boolean>`

### `loadHTML(html: string, baseURL?: string): Promise<boolean>`

加载原始 HTML 字符串内容。

- **参数**：

  - `html`：要渲染的 HTML 字符串。
  - `baseURL`（可选）：用于解析相对路径的基础 URL。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadData(data: Data, mimeType: string, encoding: string, baseURL: string): Promise<boolean>`

加载原始数据作为网页内容。

- **参数**：

  - `data`：要加载的二进制内容。
  - `mimeType`：内容的 MIME 类型，例如 `"text/html"`。
  - `encoding`：字符编码，例如 `"utf-8"`。
  - `baseURL`：用于解析相对路径的基础地址。
- **返回**：`Promise<boolean>`

***

### `waitForLoad(): Promise<boolean>`

等待 WebView 加载完成。

- **返回**：`Promise<boolean>`

***

### `getHTML(): Promise<string | null>`

获取当前页面的 HTML 内容。

- **返回**：`Promise<string | null>`

***

### `evaluateJavaScript<T = any>(javascript: string): Promise<T>`

在 WebView 中执行指定的 JavaScript 代码。

- **参数**：

  - `javascript`：要执行的 JavaScript 代码字符串。若希望返回值，必须在代码中使用 `return`。
- **返回**：`Promise<T>` — JavaScript 执行结果将作为 Promise 的值返回。

#### 示例

```ts
const webView = new WebViewController()
await webView.loadURL("https://example.com")
const title = await webView.evaluateJavaScript("return document.title")
console.log(title) // "Example Domain"
webView.dispose()
```

或：

```ts
const webView = new WebViewController()
await webView.loadHTML(`
  <html>
    <body>
      <script>
        window.myValue = 42
      </script>
    </body>
  </html>
`)

await webView.waitForLoad()

const result = await webView.evaluateJavaScript('return window.myValue')
console.log(result) // 42
```

***

### `addScriptMessageHandler<P = any, R = any>(name: string, handler: (params?: P) => R): Promise<void>`

添加一个脚本消息处理器，可在网页中通过 JavaScript 调用，并接收原生代码返回的结果。

- **参数**：

  - `name`：消息处理器名称，必须唯一且非空。
  - `handler`：处理函数，接收来自网页的参数并返回一个值，作为 Promise 的结果回传给网页。
- **返回**：`Promise<void>` — 添加成功后完成。

#### 示例

```ts
let webView = new WebViewController()

await webView.addScriptMessageHandler("sayHi", (greeting: string) => {
  console.log("收到消息", greeting)
  return "你好！"
})

await webView.loadHTML(`
  <html>
    <body>
      <script>
        (async () => {
          const response = await window.webkit.messageHandlers.sayHi.postMessage("Hi!")
          alert(response) // 弹出 "你好！"
        })()
      </script>
    </body>
  </html>
`)
```

***

### `present(options?: { fullscreen?: boolean, navigationTitle?: string }): Promise<void>`

以模态窗口形式展示 WebView。

- **选项**：

  - `fullscreen`：是否以全屏模式展示。
  - `navigationTitle`：导航栏标题（可选）。
- **返回**：`Promise<void>`

***

### `canGoBack(): Promise<boolean>`

判断 WebView 是否可以后退。

***

### `canGoForward(): Promise<boolean>`

判断 WebView 是否可以前进。

***

### `goBack(): Promise<boolean>`

返回上一页。

***

### `goForward(): Promise<boolean>`

前进到下一页。

***

### `reload(): Promise<void>`

重新加载当前网页。

***

### `dismiss(): void`

关闭 WebView 页面（若当前正在展示）。

***

### `dispose(): void`

释放 WebView 实例并清理资源。

- 如果 WebView 正在展示，将先自动关闭。
- **重要**：请务必调用此方法以避免内存泄漏。

***

## 完整示例

```ts
const webView = new WebViewController()

await webView.addScriptMessageHandler('greet', (name) => {
  return `你好，${name}`
})

await webView.loadHTML(`
  <html>
    <body>
      <h1>自定义网页视图</h1>
      <button onclick="sendMessage()">打招呼</button>
      <script>
        async function sendMessage() {
          const response = await window.webkit.messageHandlers.greet.postMessage("Alice")
          alert(response)
        }
      </script>
    </body>
  </html>
`)

await webView.present({ navigationTitle: '网页视图示例' })
webView.dispose()
```



---
url: /zh/guide/Intent/Intent.continueInForeground.md
---

`Intent.continueInForeground` 用于在脚本从 Shortcuts 中后台执行时，**请求系统将流程转移到 Scripting App 的前台继续运行**。
此过程需要用户明确确认。

适用场景包括：

- 需要展示完整 UI（如表单、列表、导航页面）
- 需要用户在 App 内进行交互操作
- 后续步骤无法在后台执行

调用此方法后，系统会弹出确认对话框：

- 用户 **允许** → Scripting App 打开到前台，脚本继续执行
- 用户 **取消** → 当前脚本立即终止
- 此行为完全由系统管理，开发者无需手动处理跳转流程

由于该能力基于 iOS 26 引入的 AppIntents 行为：

**该 API 只能在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function continueInForeground(
  dialog?: Dialog | null,
  options?: {
    alwaysConfirm?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## dialog?: Dialog | null

用于提示用户为什么需要切换到前台继续执行。

`Dialog` 的类型格式支持三种形式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否前往应用继续执行？";
```

或带辅助说明：

```ts
{
  full: "需要在应用中继续执行下一步操作",
  supporting: "接下来的步骤需要完整的 UI 交互。",
  systemImageName: "app"
}
```

若传入 `null`，系统可能不显示提示，仅直接触发系统确认（不推荐）。

***

## `options?: { alwaysConfirm?: boolean }`

用于控制系统是否每次都显示确认提示。

- `alwaysConfirm: false`（默认）
  系统一般会根据上下文自动判断是否需要确认。

- `alwaysConfirm: true`
  每次调用都会提示用户明确确认。

示例：

```ts
{
  alwaysConfirm: true;
}
```

***

# 执行流程

执行 `await Intent.continueInForeground(...)` 时：

1. 快捷指令执行暂停

2. 系统弹出确认对话框

3. 用户选择：

   - **确认** → 打开 Scripting App → 脚本继续
   - **取消** → 脚本立即终止

4. 后续脚本在 Scripting App 前台环境中继续执行

**注意：脚本不会在后台继续运行，必须等待用户操作。**

***

# 典型应用场景

推荐在以下场景调用：

- 需要展示完整的导航界面或交互表单（如示例中的 TextField）
- 需要使用 `Navigation.present` 呈现 UI
- 需要 App 内操作如：

  - 预览文件
  - 编辑长文本
  - 选择复杂数据
  - 多步骤流程

不推荐在以下情况使用：

- 单纯的数据处理，不需要 UI
- 简单操作已经可通过 SnippetIntent 完成

***

# 完整示例代码

以下示例展示如何从 Shortcuts 通过 `continueInForeground` 切换到 Scripting App 前台，然后展示 UI 让用户输入文本，输入结束后再返回 Shortcuts。

```tsx
// intent.tsx
import {
  Button,
  Intent,
  List,
  Navigation,
  NavigationStack,
  Script,
  Section,
  TextField,
  useState,
} from "scripting";

function View() {
  const dismiss = Navigation.useDismiss();
  const [text, setText] = useState("");

  return (
    <NavigationStack>
      <List navigationTitle="Intent Demo">
        <TextField title="Enter a text" value={text} onChanged={setText} />

        <Section>
          <Button
            title="Return Text"
            action={() => {
              dismiss(text);
            }}
            disabled={!/\S+/.test(text)}
          />
        </Section>
      </List>
    </NavigationStack>
  );
}

async function runIntent() {
  // 请求系统将执行流程切换到 Scripting App 前台
  await Intent.continueInForeground("Do you want to open the app and continue?");

  // 在前台呈现交互式 UI，用户填写文本
  const text = await Navigation.present<string | null>(<View />);

  // 可选：返回到快捷指令界面
  Safari.openURL("shortcuts://");

  // 返回结果给 Shortcuts
  Script.exit(Intent.text(text ?? "No text return"));
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**，否则会抛出异常或行为不可用。
- 若脚本依赖用户输入、复杂 UI 或操作，请使用该 API 触发前台模式。
- 对话内容应清晰说明需要用户切换前台的原因，提升用户信任度。
- 若用户拒绝，脚本将终止，开发者无需自行处理取消逻辑。
- 可以与 SnippetIntent 结合，构建完整的后台 UI + 前台 UI 混合流程。



---
url: /zh/guide/Intent/Intent.requestConfirmation.md
---

`Intent.requestConfirmation` 用于在脚本执行过程中，**向用户请求确认某项操作**。
调用后，系统会暂停脚本执行，并展示一个基于 **SnippetIntent 的 UI** 作为确认界面，同时可显示提示对话内容。

确认流程行为：

- 用户 **确认** → Promise resolve，脚本继续执行
- 用户 **取消** → 当前脚本终止执行
- 确认界面通过传入的 **SnippetIntent** 的 UI 定义
- 系统自动管理此流程，无需开发者处理 UI 呈现逻辑

**该 API 仅可在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function requestConfirmation(
  actionName: ConfirmationActionName,
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## actionName: ConfirmationActionName

用于告诉系统“要确认的行为语义是什么”，系统会根据该值生成自然语言文案。例如：

- `"set"` → “确定要设置…？”
- `"buy"` → “确定要购买…？”
- `"toggle"` → “是否切换…？”

可选值如下（与苹果 AppIntents 框架一致）：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" |
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

选择合适的语义有助于提高确认界面的自然体验。

***

## snippetIntent: SnippetIntent

必须是一个 **注册为 SnippetIntent 类型的 AppIntent**：

```ts
AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>;
```

用户在确认界面中看到的内容就是该 SnippetIntent 的 `perform()` 返回的 UI，例如选项列表、内容预览等。

***

## `options?: { dialog?: Dialog; showDialogAsPrompt?: boolean }`

### dialog?: Dialog

用于在确认 UI 上方或系统对话框中显示提示文本。
支持四种格式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否继续？";
```

更复杂的：

```ts
{
  full: "确定要设置此颜色吗？",
  supporting: "此操作将更新应用的主题颜色。",
  systemImageName: "paintpalette"
}
```

用途：

- 解释确认动作含义
- 提醒用户可能产生的影响
- 提供更友好的交互上下文

***

### showDialogAsPrompt?: boolean

默认值：`true`
决定系统是否以「提示弹窗」方式显示对话文本。

设为 `false` 时，文本可能以更沉浸的方式显示在 Snippet 卡片内部。

***

# 执行流程

调用 `await Intent.requestConfirmation(...)` 时脚本执行顺序如下：

1. 脚本暂停执行

2. 系统展示确认界面（SnippetIntent UI + 可选 dialog 文案）

3. 用户进行交互：

   - **确认** → Promise resolve，脚本继续
   - **取消** → 脚本终止执行

4. 不需要开发者手动关闭 UI

此流程完全由系统管理。

***

# 使用场景

以下场景推荐使用 `requestConfirmation`：

- 修改重要设置（如主题颜色、隐私设置）
- 对数据执行有副作用的操作（如删除、更新、重置）
- 流程中一步需用户明确授权
- 启动某个需要用户选择的 UI 子流程（如颜色选择器、账号切换器）

不适用场景：

- 简单数据处理，不需要用户确认
- 可以在后台无 UI 完成的操作

***

# 完整示例代码

以下示例展示如何使用 `requestConfirmation` 请求用户确认一次颜色选择，并在确认后继续执行脚本。

假设你已有两个 SnippetIntent：

- `PickColorIntent`：颜色选择 UI
- `ShowResultIntent`：结果展示 UI

## intent.tsx 示例

```tsx
import { Intent, Script } from "scripting";
import { PickColorIntent, ShowResultIntent } from "./app_intents";

async function runIntent() {
  // 第一步：请求用户确认颜色选择
  await Intent.requestConfirmation("set", PickColorIntent(), {
    dialog: {
      full: "确定要设置此颜色吗？",
      supporting: "此操作将更新应用的主题颜色。",
      systemImageName: "paintpalette",
    },
  });

  // 第二步：读取来自 Shortcuts 的输入（如果有）
  const text =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts";

  // 第三步：呈现最终 SnippetIntent
  const snippet = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: text }),
  });

  Script.exit(snippet);
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**
  提前检查系统版本或优雅降级。

- **总是提供清晰的 dialog 文案**
  确认行为应让用户理解，不应仅依赖 Snippet UI 本身。

- **用于重要或可逆性较差的操作**
  如修改设置、启动后台任务、提交数据等。

- **与 SnippetIntent 配合使用效果最佳**
  因为确认 UI 直接展示 SnippetIntent 的视图。

- **用户取消时脚本会被系统直接终止**
  不要在后续代码中假设脚本一定会继续执行。



---
url: /zh/guide/Intent/Quick Start.md
---

# 快速开始

Scripting 支持通过 `intent.tsx` 文件创建 iOS Intents，实现脚本与系统分享扩展（Share Sheet）和快捷指令（Shortcuts）的深度集成。你可以接收来自用户的文本、图片、文件和 URL 等输入，并返回结果供调用方使用。通过 UI 展示、数据处理与结果返回，可构建灵活且强大的自动化流程。

***

## 一、创建和配置 Intent

### 1. 创建 Intent 脚本

1. 在 Scripting 中新建一个脚本项目。
2. 添加名为 `intent.tsx` 的文件，并编写处理逻辑和可选的 UI 组件。

### 2. 配置支持的输入类型

点击编辑器顶部标题栏中的项目名称，打开 **Intent 设置页面**，选择该脚本支持的输入类型，如：

- 文本（Text）
- 图片（Image）
- 文件路径（File URL）
- URL

配置后，该脚本就能在分享扩展或 Shortcuts 中处理相应类型的数据。

***

## 二、处理输入数据

在 `intent.tsx` 中，可通过以下 API 访问用户传入的数据：

| 属性名                        | 说明                                       |
| -------------------------- | ---------------------------------------- |
| `Intent.shortcutParameter` | Shortcuts 中传入的单个参数，包含 `.type` 和 `.value` |
| `Intent.textsParameter`    | 文本字符串数组                                  |
| `Intent.urlsParameter`     | URL 字符串数组                                |
| `Intent.imagesParameter`   | 图片数组（UIImage 实例）                         |
| `Intent.fileURLsParameter` | 文件路径数组（本地 URL）                           |

示例：

```ts
if (Intent.shortcutParameter) {
  if (Intent.shortcutParameter.type === "text") {
    console.log(Intent.shortcutParameter.value)
  }
}
```

***

## 三、返回结果

使用 `Script.exit(result)` 结束脚本执行并返回结果给调用方，例如 Shortcuts 或另一个脚本。支持的返回类型包括：

- 文本：`Intent.text(value)`
- 富文本：`Intent.attributedText(value)`
- URL：`Intent.url(value)`
- JSON 数据：`Intent.json(value)`
- 文件路径：`Intent.file(value)` 或 `Intent.fileURL(value)`

示例：

```ts
import { Script, Intent } from "scripting"

Script.exit(Intent.text("处理完成"))
```

***

## 四、展示交互式 UI

你可以使用 `Navigation.present()` 呈现一个自定义界面，展示输入信息或收集用户反馈。在 UI 交互结束后调用 `Script.exit()` 返回结果。

示例：

```ts
import { Intent, Script, Navigation, VStack, Text } from "scripting"

function MyIntentView() {
  return (
    <VStack>
      <Text>{Intent.textsParameter?.[0]}</Text>
    </VStack>
  )
}

async function run() {
  await Navigation.present(<MyIntentView />)
  Script.exit()
}

run()
```

***

## 五、在分享扩展中使用

当脚本项目启用了对应类型的输入支持，Scripting 会自动集成到系统分享菜单：

1. 用户选中内容（如 Safari 中的文字或图片），点击分享按钮。
2. 分享列表中选择 **Scripting**。
3. 显示支持当前输入类型的脚本列表，供用户执行。

***

## 六、与 Shortcuts 集成

你可以在 Shortcuts 应用中调用 Scripting 脚本：

- **运行脚本（Run Script）**：后台执行，无 UI。
- **在 App 中运行脚本（Run Script in App）**：前台执行，支持 UI 展示。

操作步骤：

1. 在 Shortcuts 中添加 “Run Script” 或 “Run Script in App” 操作。
2. 选择目标脚本。
3. 配置参数，执行脚本。

***

## 七、Intent API 参考

### `Intent` 类属性

| 属性                  | 类型                  | 说明                                    |
| ------------------- | ------------------- | ------------------------------------- |
| `shortcutParameter` | `ShortcutParameter` | Shortcuts 传入的参数对象，包含 `type` 和 `value` |
| `textsParameter`    | `string[]`          | 文本输入数组                                |
| `urlsParameter`     | `string[]`          | URL 字符串数组                             |
| `imagesParameter`   | `UIImage[]`         | 图片数组（路径或图片对象）                         |
| `fileURLsParameter` | `string[]`          | 文件路径数组（本地 URL）                        |

### `Intent` 类方法

| 方法                             | 返回类型                        | 示例                                    |
| ------------------------------ | --------------------------- | ------------------------------------- |
| `Intent.text(value)`           | `IntentTextValue`           | `Intent.text("内容")`                   |
| `Intent.attributedText(value)` | `IntentAttributedTextValue` | `Intent.attributedText("富文本")`        |
| `Intent.url(value)`            | `IntentURLValue`            | `Intent.url("https://example.com")`   |
| `Intent.json(value)`           | `IntentJsonValue`           | `Intent.json({ key: "value" })`       |
| `Intent.file(filePath)`        | `IntentFileValue`           | `Intent.file("/path/to/file.txt")`    |
| `Intent.fileURL(filePath)`     | `IntentFileURLValue`        | `Intent.fileURL("/path/to/file.pdf")` |
| `Intent.image(UIImage)`        | `IntentImageValue`          | `Intent.image(uiImage)`               |

***

## 八、最佳实践与注意事项

- 所有脚本应显式调用 `Script.exit()` 以确保内存安全。
- 推荐在 UI 脚本中使用 `await Navigation.present()` 之后再调用 `Script.exit()`。
- 对于大文件或图像，建议使用 “Run Script in App” 模式，以避免系统内存限制导致的崩溃。
- 如果脚本需要共享数据，可通过 URL Scheme 或 `queryParameters` 实现。



---
url: /zh/guide/Intent/SnippetIntent.md
---

SnippetIntent 是一种特殊类型的 AppIntent，可在 Shortcuts 中生成原生的 Snippet UI 卡片。它适用于：

- 多步骤表单式交互
- 从 Shortcuts 中获取用户输入
- 键值选择、确认、展示结果等轻量级交互
- 在 Shortcuts 工作流中内嵌 UI 组件

SnippetIntent 特点如下：

1. 在 Scripting 中必须通过 `AppIntentManager.register` 注册
2. `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
3. `perform()` 必须返回一个 `VirtualNode`（TSX UI）
4. 在脚本中必须以 `Intent.snippetIntent()` 封装后返回
5. Shortcuts 必须使用「Show Snippet Intent」动作才能显示 Snippet UI

***

# 系统要求

**SnippetIntent 只能在 iOS 26 及以上系统运行。**

在 iOS 26 以下环境：

- 无法调用 `Intent.snippetIntent`
- 无法使用 `Intent.requestConfirmation`
- Shortcuts 中不存在「Show Snippet Intent」动作
- SnippetIntent 类型的 AppIntent 不会被 Shortcuts 正常识别

***

# 注册 SnippetIntent（app\_intents.tsx）

在 `app_intents.tsx` 中声明 SnippetIntent：

```tsx
export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})
```

再例如：

```tsx
export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    return <ResultView content={content} />
  }
})
```

要求：

- `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
- `perform()` 必须返回 `VirtualNode`
- 与普通 AppIntent 区别在于返回的是 UI，而非数据

***

# SnippetIntent 返回值封装：Intent.snippetIntent

SnippetIntent 不能直接作为 JS 返回值，必须通过 `Intent.snippetIntent()` 包装成 `IntentSnippetIntentValue`。

```tsx
const snippetValue = Intent.snippetIntent({
  value: Intent.text("Some value returning for Shortcuts"),
  snippetIntent: ShowResultIntent({
    content: "Example Text"
  })
})

Script.exit(snippetValue)
```

### 类型定义

```ts
type SnippetIntentValue = {
  value?: IntentAttributedTextValue | IntentFileURLValue | IntentJsonValue | IntentTextValue | IntentURLValue | IntentFileValue | null
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>
}

declare class IntentSnippetIntentValue extends IntentValue<
  'SnippetIntent',
  SnippetIntentValue
> {
  value: SnippetIntentValue
  type: 'SnippetIntent'
}
```

封装的返回值可被 Shortcuts 的「Show Snippet Intent」动作识别并展示 UI。

***

# Snippet 确认界面：Intent.requestConfirmation

SnippetIntent 支持在执行逻辑中先请求用户确认某个操作。此能力同样基于 iOS 26。

```ts
Intent.requestConfirmation(
  actionName: ConfirmationActionName,
  intent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>
```

### ConfirmationActionName

这些名称会影响 Shortcuts UI 中呈现的文案，例如 “Set …”、“Add …”、“Toggle …” 等。

示例值：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" | 
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

### 示例

```tsx
await Intent.requestConfirmation(
  "set",
  PickColorIntent()
)
```

效果：

- Shortcuts 弹出 PickColorIntent 对应的 Snippet UI
- 用户点击确认后 Promise resolve
- 用户取消时脚本执行终止

***

# Shortcuts 的「Show Snippet Intent」动作（iOS 26+）

Shortcuts 在 iOS 26 新增动作：

**Show Snippet Intent**

用于展示 SnippetIntent 返回的 Snippet UI。

### 与其他动作对比

| Shortcuts 动作                 | 显示界面                 | 支持 SnippetIntent | 场景               |
| ---------------------------- | -------------------- | ---------------- | ---------------- |
| Run Script                   | 无 UI                 | 否                | 纯数据处理            |
| Run Script in App            | Scripting App UI（前台） | 否                | 大型 UI、文件选择等      |
| Show Snippet Intent（iOS 26+） | Snippet 卡片 UI        | 是                | SnippetIntent 场景 |

使用方式：

1. 在 Shortcuts 中添加「Show Snippet Intent」
2. 选择脚本项目（需包含 intent.tsx）
3. 脚本返回 `Intent.snippetIntent(...)`
4. Shortcuts 显示 Snippet UI

***

# IntentMemoryStorage — 跨 AppIntent 状态共享

## 1. 为什么需要 IntentMemoryStorage

由于系统行为，每次 Intent 执行后：

- AppIntent 的 `perform()` 执行完毕后立即销毁上下文
- `intent.tsx` 执行完并调用 `Script.exit()` 后脚本上下文也会完全释放

因此无法依赖 JS 变量在多个 Intent 之间保持状态。

例如：

- PickColorIntent（选择颜色）
- SetColorIntent（设置颜色）
- ShowResultIntent（展示颜色结果）

在这些 Intent 之间共享状态必须依赖持久化存储。

## 2. IntentMemoryStorage 提供轻量级、跨 Intent 的共享存储

API 定义：

```ts
namespace IntentMemoryStorage {
  function get<T>(key: string): T | null
  function set(key: string, value: any): void
  function remove(key: string): void
  function contains(key: string): boolean
  function clear(): void
  function keys(): string[]
}
```

用途：

- 存储小量状态，例如当前颜色、当前步骤、临时选项
- 在多个 AppIntent 之间共享数据
- 生命周期跨 Intent 调用，但随脚本生命周期管理

### 示例：存储用户颜色选择

```ts
IntentMemoryStorage.set("color", "systemBlue")

const color = IntentMemoryStorage.get<Color>("color")
```

### 建议

- 不要存储大型数据（如大图像、长文本）
- 大型数据请使用：

  - `Storage`（持久键值存储）
  - `FileManager` 写入 appGroupDocumentsDirectory

IntentMemoryStorage 适合作为临时状态共享，不适合当作数据库使用。

***

# 完整示例（iOS 26+）

## app\_intents.tsx

```tsx
export const SetColorIntent = AppIntentManager.register({
  name: "SetColorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async (color: Color) => {
    IntentMemoryStorage.set("color", color)
  }
})

export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})

export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    const color = IntentMemoryStorage.get<Color>("color") ?? "systemBlue"
    return <ResultView content={content} color={color} />
  }
})
```

## intent.tsx

```tsx
async function runIntent() {

  // 1. 通过 Snippet 请求用户确认颜色
  await Intent.requestConfirmation(
    "set",
    PickColorIntent()
  )

  // 2. 从 Shortcuts 输入中读取文本
  const textContent =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts"

  // 3. 创建 SnippetIntent 返回结果
  const snippetIntentValue = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: textContent })
  })

  Script.exit(snippetIntentValue)
}

runIntent()
```



---
url: /zh/guide/Interactive Widget and LiveActivity.md
---

# 可互动的小组件和灵动岛

**Scripting** 应用支持在 **小组件** 和 **LiveActivity（灵动岛）** 中添加互动的功能，使您可以通过 `Button` 和 `Toggle` 组件创建动态、交互式的 UI。这些控件可以执行 **AppIntent** 来触发操作，从而增强小组件和 LiveActivity 的功能。

***

## 1. AppIntent 简介

### 什么是 AppIntent？

**AppIntent** 定义了一个由控件（如 `Button` 或 `Toggle`）触发的特定操作，用于小组件或 LiveActivity UI。AppIntent 将 UI 组件与可执行逻辑连接起来，实现无缝交互。

### 支持的协议

AppIntent 可以实现以下协议：

- **`AppIntent`**：通用意图，用于触发自定义操作。
- **`AudioPlaybackIntent`**：处理音频播放（如播放、暂停或切换音频状态）。
- **`AudioRecordingIntent`**：管理音频录制状态（需要 iOS 18+，并且在录制期间保持 LiveActivity 活跃）。
- **`LiveActivityIntent`**：修改或管理 LiveActivity 状态。

***

## 2. 注册 AppIntent

在使用 **AppIntent** 之前，必须通过 `AppIntentManager.register` 方法在 `app_intents.tsx` 文件中注册。

### 示例：注册 AppIntent

```typescript
// app_intents.tsx

import { AppIntentManager, AppIntentProtocol } from "scripting"

// 注册不带参数的 AppIntent
const IntentWithoutParams = AppIntentManager.register({
  name: "IntentWithoutParams",
  protocol: AppIntentProtocol.AppIntent,
  perform: async (params: undefined) => {
    // 执行自定义操作
    console.log("Intent 被触发")
    // 可选：刷新小组件
    Widget.reloadAll()
  }
})

// 注册带参数的 AppIntent
const ToggleIntentWithParams = AppIntentManager.register({
  name: "ToggleIntentWithParams",
  protocol: AppIntentProtocol.AudioPlaybackIntent,
  perform: async (audioName: string) => {
    // 根据参数执行操作
    console.log(`切换音频播放状态：${audioName}`)
    Widget.reloadAll()
  }
})
```

***

## 3. 在小组件或 LiveActivity UI 中使用 AppIntent

注册完 AppIntent 后，可以在 `widget.tsx` 或 LiveActivity UI 文件中的 `Button` 和 `Toggle` 等交互组件中链接这些 AppIntent。

### 示例：在小组件中使用 AppIntent

```typescript
// widget.tsx

import { VStack, Button, Toggle } from "scripting"
import { IntentWithoutParams, ToggleIntentWithParams } from "./app_intents"
import { model } from "./model"

function WidgetView() {
  return (
    <VStack>
      <Button
        title="点击我"
        intent={IntentWithoutParams(undefined)} // 触发无参数的 AppIntent
      />
      <Toggle
        title="播放或暂停"
        value={model.checked}
        intent={ToggleIntentWithParams("audio_name")} // 触发带参数的 AppIntent
      />
    </VStack>
  )
}

// 展示小组件
Widget.present(<WidgetView />)
```

***

## 4. API 参考

### `AppIntentManager.register`

注册一个可在小组件或 LiveActivity UI 中使用的 AppIntent。

#### 参数：

- `name` (string)：意图的唯一名称。
- `protocol` (`AppIntentProtocol`)：指定意图类型（如 `AppIntent`、`AudioPlaybackIntent`）。
- `perform` (function)：当触发意图时执行的函数。

#### 返回：

- 一个 `AppIntentFactory` 函数，可用于创建已注册意图的实例。

***

### `Button` 组件

可点击的按钮，用于触发 AppIntent。

#### 属性：

- `title` (string)：按钮的标签。
- `intent` (`AppIntent<any>`)：按钮被点击时执行的 AppIntent。
- `systemImage` (可选)：按钮上显示的 SF Symbol 图标。

***

### `Toggle` 组件

切换开关，切换值时触发 AppIntent。

#### 属性：

- `value` (boolean)：切换状态（开/关）。
- `intent` (`AppIntent<any>`)：切换时执行的 AppIntent。
- `title` (string)：切换的标签。
- `systemImage` (可选)：切换上显示的 SF Symbol 图标。

***

## 5. 注意事项和最佳实践

- 在 `perform` 函数中使用 `Widget.reloadAll()` 可在执行意图后动态更新小组件。
- 将所有 AppIntent 定义在 `app_intents.tsx` 文件中，方便组织和重用。
- 根据意图的功能选择合适的协议（如 `AudioPlaybackIntent`）。



---
url: /zh/guide/LiveActivity.md
---

`LiveActivity` API 允许你的脚本在 iOS 的锁屏界面以及支持的设备上的动态岛中展示实时数据。通过该 API，你可以创建、更新并结束 Live Activity，同时监听其生命周期状态和系统支持情况。

本文件详细介绍 Scripting app 中的 **LiveActivity API**，包括：

- Live Activity 的生命周期与核心概念
- 如何注册 Live Activity UI
- 如何在脚本中启动、更新、结束 Live Activity
- 如何构建 Live Activity UI（包括 Dynamic Island 多种布局）
- 所有类型参数说明
- 完整示例代码与最佳实践

本 API 基于 Apple ActivityKit 能力，并以 TypeScript/TSX 的方式封装，允许开发者使用 React 风格构建 Lock Screen 与 Dynamic Island 界面。

***

# 1. Live Activity 概念理解

Live Activity 展示在以下区域：

- **锁屏界面**
- **iPhone 14 Pro+ 的 Dynamic Island**
- **其他设备的悬浮样式（Banner）**

它能随着应用或脚本运行实时更新内容，如：

- 计时器
- 外卖进度
- 健身、运动状态
- 倒计时、打卡、提醒

**在 Scripting app 中，一个 Live Activity 由两部分组成：**

1. **内容状态（contentState）**
   一个 JSON 可序列化的对象，会随时间改变。
2. **UI Builder**
   通过 TSX 描述不同区域的展示方式。

***

# 2. Live Activity 状态类型

```ts
type LiveActivityState = "active" | "dismissed" | "ended" | "stale";
```

| 状态        | 描述                              |
| --------- | ------------------------------- |
| active    | 正在显示，可以更新内容                     |
| stale     | 已过期，需要更新 staleDate 后才能恢复 active |
| ended     | 活动已结束但仍在锁屏显示（最长 4 小时或自定时间）      |
| dismissed | 已被系统或用户移除，不再可见                  |

***

# 3. LiveActivityDetail 类型

```ts
type LiveActivityDetail = {
  id: string;
  state: LiveActivityState;
};
```

用于描述当前正在运行的所有 Live Activity 信息。

***

# 4. LiveActivity UI 构建类型

## 4.1 LiveActivityUIProps

```ts
type LiveActivityUIProps = {
  content: VirtualNode;
  compactLeading: VirtualNode;
  compactTrailing: VirtualNode;
  minimal: VirtualNode;
  children: VirtualNode | VirtualNode[];
};
```

这些字段对应 Dynamic Island：

- **content**：锁屏和普通设备顶部 Banner 显示
- **compactLeading / compactTrailing**：Dynamic Island 收缩状态左右区域
- **minimal**：最小化的单点显示
- **children**：展开后的多个区域（使用 `LiveActivityUIExpanded*` 包裹）

***

# 5. 注册 Live Activity UI

Live Activity 必须放在单独的文件中，例如 `live_activity.tsx`：

```tsx
import { LiveActivity, LiveActivityUI, LiveActivityUIBuilder } from "scripting";

export type State = {
  mins: number;
};

function ContentView(state: State) {
  return (
    <HStack activityBackgroundTint={{ light: "clear", dark: "clear" }}>
      <Image systemName="waterbottle" foregroundStyle="systemBlue" />
      <Text>{state.mins}分钟后补水</Text>
    </HStack>
  );
}

const builder: LiveActivityUIBuilder<State> = (state) => {
  return (
    <LiveActivityUI
      content={<ContentView {...state} />}
      compactLeading={
        <HStack>
          <Image systemName="clock" />
          <Text>{state.mins}m</Text>
        </HStack>
      }
      compactTrailing={<Image systemName="waterbottle" foregroundStyle="systemBlue" />}
      minimal={<Image systemName="clock" />}>
      <LiveActivityUIExpandedCenter>
        <ContentView {...state} />
      </LiveActivityUIExpandedCenter>
    </LiveActivityUI>
  );
};

export const MyLiveActivity = LiveActivity.register("MyLiveActivity", builder);
```

***

# 6. 在脚本中使用 Live Activity

下面展示如何启动、更新、监听状态并结束 Live Activity。

```tsx
import {
  Button,
  Text,
  VStack,
  Navigation,
  NavigationStack,
  useMemo,
  useState,
  LiveActivityState,
  BackgroundKeeper,
} from "scripting";
import { MyLiveActivity } from "./live_activity";

function Example() {
  const dismiss = Navigation.useDismiss();
  const [state, setState] = useState<LiveActivityState>();

  const activity = useMemo(() => {
    const instance = MyLiveActivity();

    instance.addUpdateListener((s) => {
      setState(s);
      if (s === "dismissed") {
        BackgroundKeeper.stop();
      }
    });

    return instance;
  }, []);

  return (
    <NavigationStack>
      <VStack
        navigationTitle="LiveActivity 示例"
        navigationBarTitleDisplayMode="inline"
        toolbar={{
          cancellationAction: <Button title="完成" action={dismiss} />,
        }}>
        <Text>当前状态：{state ?? "-"}</Text>

        <Button
          title="启动 Live Activity"
          disabled={state != null}
          action={() => {
            let count = 5;
            BackgroundKeeper.keepAlive();

            activity.start({ mins: count });

            function tick() {
              setTimeout(() => {
                count -= 1;

                if (count === 0) {
                  activity.end({ mins: 0 });
                  BackgroundKeeper.stop();
                } else {
                  activity.update({ mins: count });
                  tick();
                }
              }, 60000);
            }
            tick();
          }}
        />
      </VStack>
    </NavigationStack>
  );
}

async function run() {
  await Navigation.present(<Example />);
  Script.exit();
}

run();
```

***

# 7. LiveActivity 类 API 说明

## 7.1 start(contentState, options?)

```ts
start(contentState: T, options?: LiveActivityOptions): Promise<boolean>
```

- 请求系统启动 Live Activity
- contentState 必须可以 JSON 序列化

### LiveActivityOptions

```ts
type LiveActivityOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
};
```

- staleDate：到期变为 stale 的时间戳（ms） 或 Date 对象
- relevanceScore：控制 Dynamic Island 的优先级

***

## 7.2 update(contentState, options?)

```ts
update(contentState: T, options?: LiveActivityUpdateOptions)
```

### LiveActivityUpdateOptions

```ts
type LiveActivityUpdateOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  alert?: {
    title: string;
    body: string;
  };
};
```

可带 Apple Watch 的更新提示。

***

## 7.3 end(contentState, options?)

```ts
end(contentState: T, options?: LiveActivityEndOptions)
```

### LiveActivityEndOptions

```ts
type LiveActivityEndOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  dismissTimeInterval?: number;
};
```

dismissTimeInterval（单位秒）:

- 未提供：系统默认最长保留 4 小时
- \<= 0：立即移除
- \> 0：指定多久后移除

***

## 7.4 获取活动状态

```ts
getActivityState(): Promise<LiveActivityState | null>
```

***

## 7.5 监听状态更新

```ts
addUpdateListener(listener);
removeUpdateListener(listener);
```

当 Live Activity 状态变更时回调，例如：

- active → stale
- active → ended
- ended → dismissed

***

## 7.6 静态方法

```ts
static areActivitiesEnabled(): Promise<boolean>
static getAllActivities(): Promise<LiveActivityDetail[]>
static getAllActivitiesIds(): Promise<string[]>
static getActivityState(activityId: string)
static from(activityId, name)
static endAllActivities(options?)
```

***

# 8. Live Activity UI 组件

| 组件                             | 描述         |
| ------------------------------ | ---------- |
| LiveActivityUI                 | 注册 UI 的根结构 |
| LiveActivityUIExpandedCenter   | 展开状态的中间区域  |
| LiveActivityUIExpandedLeading  | 左侧区域       |
| LiveActivityUIExpandedTrailing | 右侧区域       |
| LiveActivityUIExpandedBottom   | 底部区域       |

用于构建 Dynamic Island 展开布局。

***

# 9. 注意事项与最佳实践

## 9.1 必须 JSON 可序列化

contentState 中不能包含：

- 函数
- Date 对象（需转 timestamp）
- class 实例
- 非可序列化对象

## 9.2 Live Activity 必须放在独立文件

例如：

```
live_activity.tsx
```

这与系统对 UI 构建的要求有关。

## 9.3 Scripting 的 Live Activity 与脚本生命周期隔离

即使脚本结束，Live Activity 会继续保持。

若你希望脚本保持运行，可使用：

```ts
BackgroundKeeper.keepAlive();
```

***

# 10. 完整示例（简化版）

```tsx
const activity = MyLiveActivity();

await activity.start({ mins: 10 });

await activity.update({ mins: 5 });

await activity.end({ mins: 0 }, { dismissTimeInterval: 0 });
```

# 11. 注意事项

- Live Activity 的启动是异步的，需要等到 `start` 返回 `true` 时才能调用 `update` 和 `end`
- Live Activity 不能访问 Documents 和 iCloud 目录，只能访问 app group 目录，如果你想要访问文件或者渲染图片，必须把文件或图片保存到 `FileManager.appGroupDocumentsDirectory` 目录中。 比如渲染图片，你保存到 `FileManager.appGroupDocumentsDirectory` 中， 再通过 `<Image filePath={Path.join(FileManager.appGroupDocumentsDirectory, 'example.png')} />` 渲染
- Live Activity 可以访问与 App 共享的 Storage 数据



---
url: /zh/guide/Quick Start.md
---

# 快速开始

欢迎使用 **Scripting**！这是一款可让你使用 **TypeScript** 编写 **React 类似的 TSX 语法**来创建 UI 组件和自定义小组件、灵动岛和使用发通知提醒等能力的应用。通过 Scripting，你可以使用包装过的 SwiftUI 视图来获得在 iOS 上流畅且原生的使用体验，并通过熟悉的编码结构来创建和呈现各种 iOS 工具型 UI 页面。本指南将带你完成项目设置、组件创建以及结合 Hooks 构建动态界面的流程。

### 目录

1. **快速开始**
2. **创建脚本项目**
3. **导入组件**
4. **创建自定义组件**
5. **呈现 UI 视图**
6. **使用 Hooks**
7. **构建复杂的 UI**

***

### 1. 快速开始

在 Scripting 中，你可以通过定义函数式组件的方式来创建简单的 UI 元素。你需要的所有组件和 API 都可以从 `scripting` 包里导入。

### 2. 创建脚本项目

在开始编写代码之前，你需要**创建一个脚本项目**。项目创建完成后，你可以在 `index.tsx` 文件中编写代码。这个文件是定义 UI 组件和逻辑的主要入口。

`index.tsx` 的示例：

```tsx
import { VStack, Text } from "scripting"

// 定义一个自定义视图组件
function View() {
  return (
    <VStack>
      <Text>Hello, Scripting!</Text>
    </VStack>
  )
}
```

***

### 3. 导入视图

SwiftUI 中的所有视图以及部分 API 都进行了包装，并通过 `scripting` 包提供给你使用。以下是部分可用视图的列表：

- **布局视图**: `VStack`, `HStack`, `ZStack`, `Grid`
- **控件**: `Button`, `Picker`, `Toggle`, `Slider`, `ColorPicker`
- **集合**: `List`, `Section`
- **日期和时间**: `DatePicker`
- **文本和标签**: `Text`, `Label`, `TextField`

你可以像这样在项目中导入它们：

```tsx
import { VStack, Text, Button, Picker } from "scripting"
```

***

### 4. 创建自定义组件

在 Scripting 中，函数式组件的工作原理与 React 基本相同，可以使用类似 JSX 的语法来构建可复用组件。

示例：

```tsx
import { VStack, HStack, Text, Button } from "scripting"

function Greeting({
   name
}: {
   name: string 
}) {
  return (
    <HStack>
      <Text>Hello, {name}!</Text>
    </HStack>
  )
}

function MainView() {
  return (
    <VStack>
      <Greeting name="Scripting User" />
      <Button 
        title="Click Me" 
        action={() => console.log("Button Clicked!")}
      />
    </VStack>
  )
}
```

***

### 5. 呈现 UI 视图

若要呈现 UI 视图，可以使用 `Navigation.present` 方法。它能够以模态视图的形式显示自定义组件，并处理该视图的关闭。`Navigation.present` 方法会返回一个在视图被关闭后才会完成的 Promise。为了避免内存泄漏，一定要在视图关闭后调用 `Script.exit()`。

示例：

```tsx
import { VStack, Text, Navigation, Script } from "scripting"

function View() {
  return (
    <VStack>
      <Text>Hello, Scripting!</Text>
    </VStack>
  )
}

// 显示该视图
Navigation.present({ 
  element: <View />
}).then(() => {
  // 视图关闭后清理资源，避免内存泄漏
  Script.exit()
})
```

在上述示例中，`Navigation.present({ element: <View /> })` 会呈现 `View` 组件；当用户关闭此视图后，`Script.exit()` 确保释放相关资源。

***

### 6. 使用 Hooks

Scripting 支持一系列与 React 类似的 Hooks，用于管理组件中的状态、副作用、Memo 化以及上下文。以下是每种 Hook 的使用指南及示例：

***

#### `useState`

`useState` Hook 能够让你在函数式组件中添加本地状态。

```tsx
import { useState, VStack, Text, Button } from "scripting"

function Counter() {
  const [count, setCount] = useState(0)

  return (
    <VStack>
      <Text>Count: {count}</Text>
      <Button
        title="Increment"
        action={() => setCount(count + 1)}
      />
    </VStack>
  )
}
```

在这个示例中，每次点击按钮都会更新 `count` 变量，并触发组件的自动重新渲染。

***

#### `useEffect`

`useEffect` Hook 可以让你在组件中执行副作用操作，比如获取数据或者设置订阅。

```tsx
import { useState, useEffect, VStack, Text } from "scripting"

function TimeDisplay() {
  const [time, setTime] = useState(
    new Date().toLocaleTimeString()
  )

  useEffect(() => {
    let timerId: number

    const startTimer = () => {
      timerId = setTimeout(() => {
        setTime(new Date().toLocaleTimeString())
      }, 1000)
    }

    startTimer()
    
    return () => clearTimeout(timerId) // 组件卸载时清理定时器
  }, [])

  return <Text>Current Time: {time}</Text>
}
```

在此示例中，`useEffect` Hook 会设置一个间隔操作，每秒更新一次 `time` 变量，并在组件卸载时清除该间隔以避免潜在的问题。

***

#### `useReducer`

当你需要在组件中管理更复杂的状态逻辑时，`useReducer` Hook 非常有用。

```tsx
import { useReducer, VStack, Text, Button } from "scripting"

type Action = { 
  type: "increment"
} | {
  type: "decrement"
}
const reducer = (state: number, action: Action) => {
  switch (action.type) {
    case "increment":
      return state + 1
    case "decrement":
      return state - 1
    default:
      return state
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0)

  return (
    <VStack>
      <Text>Count: {count}</Text>
      <Button 
        title="Increment"
        action={() => dispatch({ type: "increment" })}
      />
      <Button
        title="Decrement"
        action={() => dispatch({ type: "decrement" })}
      />
    </VStack>
  )
}
```

`useReducer` Hook 可以通过一个 reducer 函数来帮助你更好地处理复杂的状态变更。

***

#### `useCallback`

`useCallback` Hook 可以让你对函数进行 Memo 化，以避免在每次渲染时都重新创建函数，从而提升性能。

```tsx
import { useState, useCallback, VStack, Text, Button } from "scripting"

function Counter() {
  const [count, setCount] = useState(0)

  const increment = useCallback(() => {
    setCount((prev) => prev + 1)
  }, [])

  return (
    <VStack>
      <Text>Count: {count}</Text>
      <Button 
        title="Increment"
        action={increment}
      />
    </VStack>
  )
}
```

使用 `useCallback`，只有在依赖项改变时才会重新创建 `increment` 函数，从而在大型或频繁更新的组件中提升性能。

***

#### `useMemo`

`useMemo` Hook 允许你对某些值进行 Memo 化，以缓存代价高的计算结果，从而提高性能。

```tsx
import { useState, useMemo, VStack, Text, Button } from "scripting"

function FactorialCounter() {
  const [count, setCount] = useState(1)

  const factorial = useMemo(() => {
    let result = 1
    for (let i = 1; i <= count; i++) result *= i
    return result
  }, [count])

  return (
    <VStack>
      <Text>Factorial of {count} is {factorial}</Text>
      <Button 
        title="Increase"
        action={() => setCount(count + 1)}
      />
    </VStack>
  )
}
```

`useMemo` Hook 仅在 `count` 改变时才重新计算阶乘，从而避免不必要的性能消耗。

***

#### `useContext`

`useContext` Hook 允许你在应用的各组件之间共享状态，而无需进行层层的 props 传递（即“向下传递”）。

```tsx
import { createContext, useContext, VStack, Text, Button } from "scripting"

const CountContext = createContext<number>()

function Display() {
  const count = useContext(CountContext)
  return <Text>Shared Count: {count}</Text>
}

function App() {
  return (
    <CountContext.Provider value={42}>
      <VStack>
        <Display />
      </VStack>
    </CountContext.Provider>
  )
}
```

在此示例中，`useContext` 可以访问 `CountContext`，从而在应用中共享计数值。

***

### 7. 构建复杂的 UI

通过结合已提供的视图、Hooks 和自定义组件，你可以构建出功能完善、结构复杂的 UI。

示例：

```tsx
import { useState, VStack, Text, TextField, List, Section, NavigationStack, Script } from "scripting"

function ToDoApp() {
  const [tasks, setTasks] = useState(["Task 1", "Task 2", "Task 3"])
  const [content, setContent] = useState("")

  return (
    <NavigationStack>
        <List
          navigationTitle="My Tasks"
        >
          <Section>
            {tasks.map((task, index) => (
              <Text key={index}>{task}</Text>
            ))}
          </Section>
          
          <TextField
            title="New Task"
            value={content}
            onSubmit={() => {
              if (content.length === 0) {
                return
              }
              setTasks([...tasks, content])
              setContent("")
            }}
          />
        </List>
    </NavigationStack>
  )
}

async function run() {
  await Navigation.present({
    element: <ToDoApp />
  })

  Script.exit()
}
```

***

如需了解更多详细信息，请查阅完整的 API 文档，该文档包含关于 `scripting` 包的更多示例和使用场景。



---
url: /zh/guide/Script.md
---

# Script

`Script` 模块为 Scripting App 中的脚本执行提供上下文和实用函数。它允许你访问运行时元数据、通过结果终止脚本、以编程方式运行其他脚本，并构造 URL Scheme 启动或打开脚本。

***

## 属性（Properties）

### `name: string`

当前正在运行的脚本名称。

```ts
console.log(Script.name) // 示例: "MyScript"
```

***

### `directory: string`

当前脚本所在的目录路径。

```ts
console.log(Script.directory) // 示例: "/private/var/mobile/Containers/..."
```

***

### `env: string`

表示当前脚本运行的环境类型，用于根据上下文动态调整脚本行为，例如判断是否处于主应用、组件、通知或扩展中。

### 可选值说明：

| 值                  | 说明                                                                                          |
| ------------------ | ------------------------------------------------------------------------------------------- |
| `"index"`          | 主应用环境中运行，入口文件为 `index.tsx`。用于普通应用逻辑和界面展示。                                                   |
| `"widget"`         | 小组件中运行，入口文件为 `widget.tsx`。用于生成主屏幕组件内容。                                                      |
| `"control_widget"` | 控制中心小组件中运行，入口文件为 `control_widget_button.tsx`或`control_widget_toggle.tsx`。用于控制中心小组件的按钮或开关控件。 |
| `"notification"`   | 富通知扩展中运行，入口文件为 `notification.tsx`。用于自定义通知界面。                                                |
| `"intent"`         | 通过快捷指令或分享面板触发的脚本，入口文件为 `intent.tsx`。                                                        |
| `"app_intents"`    | App Intents 扩展中运行，入口文件为 `app_intents.tsx`。用于原生快捷指令集成。                                       |
| `"assistant_tool"` | Assistant Tool 工具模式中运行，入口文件为 `assistant_tool.tsx`。                                          |
| `"keyboard"`       | 自定义键盘扩展中运行，入口文件为 `keyboard.tsx`。用于实现个性化键盘逻辑。                                                |
| `"live_activity"`  | LiveActivity 扩展中运行，入口文件为 `live_activity.tsx`。用于实现实时活动逻辑。                                    |

### 示例：

```ts
if (Script.env === "widget") {
  Widget.present(<MyWidget />)
} else if (Script.env === "index") {
  Navigation.present({ element: <MainPage /> })
}
```

***

### `widgetParameter: string`

从小组件启动脚本时传入的参数。

```ts
if (Script.widgetParameter) {
  console.log("Widget input:", Script.widgetParameter)
}
```

***

### `queryParameters: Record<string, string>`

通过 `run` URL Scheme 传入的键值对参数。

```ts
// URL: scripting://run/MyScript?user=John&id=123
console.log(Script.queryParameters.user) // "John"
console.log(Script.queryParameters.id)   // "123"
```

***

### `metadata: { ... }`

当前脚本的元数据信息。

- `icon`: 脚本图标，可以是系统图标(SFSymbol)名称
- `color`: 脚本颜色，可以是十六进制颜色字符串（如 `#FF0000`）或 CSS 颜色名称（如 `"red"`）
- `localizedName`: 当前系统语言下的脚本本地化名称
- `localizedNames`: 不同语言下的本地化名称，键为语言代码，值为对应的名称
- `description`: 脚本的英文描述
- `localizedDescription`: 当前系统语言下的本地化描述
- `localizedDescriptions`: 不同语言下的本地化描述，键为语言代码，值为对应描述
- `version`: 脚本的版本字符串
- `author`: 作者信息对象：

  - `name`: 作者姓名
  - `email`: 作者电子邮箱
  - `homepage`: 作者个人主页（可选）
- `contributors`: 贡献者信息数组，每项结构同 `author`
- `remoteResource`: 远程资源信息：

  - `url`: 远程资源地址（可以是 zip 文件或 Git 仓库）
  - `autoUpdateInterval`: 自动更新间隔时间（单位：秒），若未设置则不自动更新

```ts
console.log(Script.metadata.localizedName) // 示例: "天气助手"
console.log(Script.metadata.version)       // 示例: "1.2.0"
```

***

## 方法（Methods）

### `Script.exit(result?): void`

终止当前脚本，并可选地返回一个结果。**必须调用该方法来正确释放资源。**

- `result?: any | IntentValue`: 要返回的值，可以是任意类型，也可以是 `IntentValue` 对象（例如返回给快捷指令或其他脚本）

```ts
Script.exit("Done")

// 或返回结构化数据
Script.exit(Intent.json({ status: "ok" }))
```

***

### `Script.run<T>(options): Promise<T | null>`

以编程方式运行另一个脚本，并等待其结果。

- `options.name`: 要运行的脚本名称
- `options.queryParameters`: 可选参数，作为 URL 参数传递
- `options.singleMode`: 若为 `true`，确保同一脚本只能同时运行一个实例

返回目标脚本中 `Script.exit(result)` 返回的值。

```ts
const result = await Script.run({
  name: "ProcessData",
  queryParameters: { input: "abc" }
})

console.log(result)
```

***

### `Script.createRunURLScheme(scriptName, queryParameters?): string`

生成一个 `scripting://run` URL，可用于启动并执行脚本。

```ts
const url = Script.createRunURLScheme("MyScript", { user: "Alice" })
// "scripting://run/MyScript?user=Alice"
```

***

### `Script.createRunSingleURLScheme(scriptName, queryParameters?): string`

生成一个 `scripting://run_single` URL，确保脚本不会并行运行多个实例。

```ts
const url = Script.createRunSingleURLScheme("MyScript", { id: "1" })
// "scripting://run_single/MyScript?id=1"
```

***

### `Script.createOpenURLScheme(scriptName): string`

生成一个 `scripting://open` URL，用于在编辑器中打开脚本。

```ts
const url = Script.createOpenURLScheme("MyScript")
// "scripting://open/MyScript"
```

***

### `Script.createDocumentationURLScheme(title?): string`

生成用于打开 Scripting App 内文档页面的 URL。

- `title`: （可选）若传入标题，将直接打开该文档主题页面。

```ts
const url = Script.createDocumentationURLScheme("Widgets")
// "scripting://doc?title=Widgets"
```

***

### `createImportScriptsURLScheme(urls): string`

根据提供的 URL 数组生成导入脚本的 URL Scheme。

- `urls: string[]`: 要导入的脚本资源 URL 列表（支持 zip 或单文件）

```ts
const urlScheme = Script.createImportScriptsURLScheme([
  "https://github.com/schl3ck/scripting-app-lib",
  "https://example.com/my-script.zip",
])
// "scripting://import_scripts?urls=..."
```

***

### `hasFullAccess(): boolean`

判断用户是否具有完整的 Scripting PRO 访问权限。

返回:`true` 如果用户具有完整的 Scripting PRO 访问权限，否则返回 `false`。

```ts
if (Script.hasFullAccess()) {
  // 有完整的 Scripting PRO 访问权限
  Assistant.requestStructedData(...)
}
```

***

## 注意事项（Notes）

- 请务必调用 `Script.exit()` 正确终止脚本并释放内存资源
- 使用 `Script.run()` 可以实现脚本的模块化和调用链，获取结构化返回值
- URL Scheme 可用于从外部应用（如快捷指令）触发脚本执行
- 对于需要避免并发执行的脚本，建议使用 `singleMode` 或 `run_single` URL Scheme



---
url: /zh/guide/Types/Alignment.md
---

# 对齐

通过 `Alignment`，你可以指定内容在视图框架（frame）中的位置，与 SwiftUI 内置对齐方式的行为相对应。当组件有额外空间或需要在布局中按特定方式对齐时，可使用 `Alignment` 来控制元素在容器中的位置。

***

## 概述

当你使用像 `VStack`、`HStack`、`ZStack` 等需要堆叠、分层或定位多个视图的容器时，`Alignment` 非常有用。\
选择一个对齐方式就意味着告诉布局系统如何将这些视图相互对齐或在其容器中对齐。

举例来说，如果一个 `ZStack` 的对齐方式为 `topLeading`，它会把内容放置在容器的左上方；若对齐方式为 `bottomTrailing`，则会把内容放置在容器的右下方。

***

## 可用的对齐方式

- **基础对齐 (Basic Alignments)**:
  - **`top`**：沿视图顶部对齐。
  - **`center`**：在水平和垂直方向上同时居中。
  - **`bottom`**：沿视图底部对齐。
  - **`leading`**：沿主阅读方向的起始边对齐（在从左到右语言环境下为左侧）。
  - **`trailing`**：沿主阅读方向的末尾边对齐（在从左到右语言环境下为右侧）。

- **复合对齐 (Compound Alignments)**:
  - **`topLeading`**：同时沿顶部和起始边对齐。
  - **`topTrailing`**：同时沿顶部和末尾边对齐。
  - **`bottomLeading`**：同时沿底部和起始边对齐。
  - **`bottomTrailing`**：同时沿底部和末尾边对齐。

- **文本基线对齐 (Text Baseline Alignments)**:
  当视图包含文本时，可以用基线对齐保证文本在同一基线上对齐。以下值可用于使文本在特定基线上对齐：
  - **`centerFirstTextBaseline`**
  - **`centerLastTextBaseline`**
  - **`leadingFirstTextBaseline`**
  - **`leadingLastTextBaseline`**
  - **`trailingFirstTextBaseline`**
  - **`trailingLastTextBaseline`**

***

## 使用示例

### **居中对齐 (Center Alignment)**

```tsx
<ZStack alignment="center">
  <Rectangle fill="gray" frame={{width: 100, height: 100}} />
  <Text font="title">Centered Text</Text>
</ZStack>
```

在此示例中，`Text` 会在 `Rectangle` 中居中显示。

***

### **顶部靠左对齐 (Top Leading Alignment)**

```tsx
<ZStack alignment="topLeading">
  <Rectangle fill="gray" frame={{width: 200, height: 200}} />
  <Text>I'm at the top-left!</Text>
</ZStack>
```

在这里，`Text` 会出现在灰色矩形的左上角。

***

### **基线对齐 (Baseline Alignment)**

```tsx
<HStack alignment="leadingFirstTextBaseline">
  <Text font="largeTitle">Big Title</Text>
  <Text font="title">Smaller Subtitle</Text>
</HStack>
```

此示例中，两个文本的首行基线对齐，即使它们的字号不同，也能让第一行文字在视觉上保持整齐。

***

## 小结

`Alignment` 让你能够细粒度地控制内容在容器内部的定位方式。无论是使用基础的边缘对齐，还是更为高级的文本基线对齐，都能确保你的 UI 元素在视觉上呈现一致且直观的效果。



---
url: /zh/guide/Types/Color.md
---

# 颜色

`Color` API 支持多种颜色格式，包括 HEX 字符串、RGBA 字符串和预定义颜色关键字。它与 SwiftUI 的颜色系统无缝集成，提供鲜艳且可自适应的颜色，用于设计出色的 UI。

***

## `Color` 类型

`Color` 类型可以采用以下三种格式来表示颜色：

1. **HEX 字符串**：标准的十六进制颜色代码。
2. **RGBA 字符串**：类似 CSS 的字符串格式，包含红色、绿色、蓝色以及透明度通道。
3. **关键字颜色**：一组预定义的系统和语义化颜色。

***

### 支持的格式

#### 1. HEX 字符串 (`ColorStringHex`)

- **格式**: `#RRGGBB` 或者 `#RGB`
- **示例**:
  ```tsx
  const primaryColor: Color = "#FF5733"
  const secondaryColor: Color = "#333"
  ```

***

#### 2. RGBA 字符串 (`ColorStringRGBA`)

- **格式**: `rgba(R, G, B, A)`
  - `R`: 红色, 取值范围 0–255
  - `G`: 绿色, 取值范围 0–255
  - `B`: 蓝色, 取值范围 0–255
  - `A`: 透明度, 取值范围 0–1
- **示例**:
  ```tsx
  const transparentBlack: Color = "rgba(0, 0, 0, 0.5)"
  const semiTransparentRed: Color = "rgba(255, 0, 0, 0.8)"
  ```

***

#### 3. 关键字颜色 (`KeywordsColor`)

系统中预定义的颜色，根据当前系统外观（浅色/深色模式）和辅助功能设置进行自适应。这些颜色可以与原生 iOS 应用保持一致的视觉效果。

- **示例**:
  ```tsx
  const systemAccent: Color = "accentColor"
  const systemBackground: Color = "systemBackground"
  const linkColor: Color = "link"
  const customGray: Color = "systemGray4"
  ```

***

### 关键字颜色列表

#### 系统颜色

- `accentColor`
- `systemRed`, `systemGreen`, `systemBlue`, `systemOrange`, `systemYellow`, `systemPink`, `systemPurple`, `systemTeal`, `systemIndigo`, `systemBrown`, `systemMint`, `systemCyan`

#### 语义化颜色

- **标签类 (Labels)**: `label`, `secondaryLabel`, `tertiaryLabel`, `quaternaryLabel`
- **填充颜色 (Fill Colors)**: `systemFill`, `secondarySystemFill`, `tertiarySystemFill`, `quaternarySystemFill`
- **背景色 (Backgrounds)**:
  - `systemBackground`, `secondarySystemBackground`, `tertiarySystemBackground`
  - `systemGroupedBackground`, `secondarySystemGroupedBackground`, `tertiarySystemGroupedBackground`
- **分割线 (Separators)**: `separator`, `opaqueSeparator`

#### 传统颜色 (Legacy Colors)

- `black`, `darkGray`, `lightGray`, `white`, `gray`, `red`, `green`, `blue`, `cyan`, `yellow`, `magenta`, `orange`, `purple`, `brown`, `clear`

***

### 在 TSX 组件中的使用

```tsx
import { View, Text, VStack } from 'scripting'

function MyView() {
  return (
    <VStack background="systemBackground">
      <Text foregroundStyle="accentColor">
        Welcome to the Scripting App!
      </Text>
    </VStack>
  )
}
```

在这个组件中，使用了自适应的系统颜色，以与 iOS 的外观设置保持一致。

***

### 注意事项

- **性能**: 当使用关键字颜色时，应用会根据系统设置（如深色模式）自动更新颜色。
- **校验**: 若颜色字符串不符合预期格式，运行时可能抛出错误。请确保所使用的颜色字符串是有效的。



---
url: /zh/guide/Types/DynamicShapeStyle.md
---

# DynamicShapeStyle

`DynamicShapeStyle` 类型允许为一个形状定义两种不同的样式——一种用于浅色模式，另一种用于深色模式。系统会根据用户设备的当前配色方案（浅色或深色）自动应用适合的样式。

## 概述

动态样式是创建自适应且视觉吸引力用户界面的关键之一。通过使用 `DynamicShapeStyle`，可以确保您的形状与用户首选的配色方案完美融合，为浅色模式和深色模式分别定义样式。

**关键点：**

- 使用 `light` 属性定义 **浅色模式** 的样式。
- 使用 `dark` 属性定义 **深色模式** 的样式。
- 系统会根据用户当前的设置自动应用适当的样式。

## 声明

```tsx
type DynamicShapeStyle = {
    light: ShapeStyle;
    dark: ShapeStyle;
};
```

- **`light: ShapeStyle`**\
  当系统处于浅色模式时应用的样式。

- **`dark: ShapeStyle`**\
  当系统处于深色模式时应用的样式。

### 支持的 `ShapeStyle`

`ShapeStyle` 可以是颜色、渐变或材质，例如：

- **颜色**：如 `"red"`、十六进制值 `"#FF0000"` 或类似 CSS 的 RGBA 字符串 `"rgba(255, 0, 0, 1)"`。
- **渐变**：线性渐变或径向渐变。
- **材质**：系统材质，如 `"regularMaterial"`、`"thickMaterial"`。

## 使用示例

### 使用动态颜色

```tsx
const dynamicStyle: DynamicShapeStyle = {
  light: "blue",
  dark: "gray"
}

<Text
  foregroundStyle={dynamicStyle}
/>
```

在此示例中，形状在浅色模式下显示为 **蓝色**，在深色模式下显示为 **灰色**。

### 使用动态渐变

```tsx
const dynamicStyle: DynamicShapeStyle = {
  light: {
    gradient: [
      { color: "lightblue", location: 0 },
      { color: "white", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  },
  dark: {
    gradient: [
      { color: "darkblue", location: 0 },
      { color: "black", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  }
}

<Circle
  fill={dynamicStyle}
/>
```

在此示例中，形状在浅色模式下使用 **浅蓝到白色渐变**，在深色模式下使用 **深蓝到黑色渐变**。

### 使用材质

```tsx
const dynamicStyle: DynamicShapeStyle = {
  light: "regularMaterial",
  dark: "ultraThickMaterial"
}

<HStack
  background={dynamicStyle}
></HStack>
```

此配置在浅色模式下应用 **普通材质**，在深色模式下应用 **超厚材质**。

## 为什么使用 `DynamicShapeStyle`？

动态样式通过以下方式提升用户体验：

1. **视觉和谐**：形状自适应用户的配色方案，保持美观一致。
2. **可访问性**：针对深色模式调整样式，提升在低光环境中的可读性和易用性。
3. **一致性**：与系统整体的偏好设置保持一致，使应用看起来更加集成。

## 总结

通过使用 `DynamicShapeStyle`，您可以为形状创建灵活且自适应的样式，根据用户的配色方案无缝切换。为浅色和深色模式分别定义样式，确保应用在任何环境下都能提供一致且用户友好的体验。



---
url: /zh/guide/Types/Shape.md
---

# 形状

`Shape` 类型用于定义视图的裁剪形状或背景形状，常用于 `clipShape`、`background`、`border` 等修饰符中，对应 SwiftUI 中的 `Shape` 协议。支持内建关键字形状，也支持自定义圆角矩形（包括统一圆角、椭圆角或每个角独立控制）。

***

## 内建形状

### `'rect'`（矩形）

标准矩形，默认无圆角。如需圆角请使用对象形式配置。

```tsx
clipShape="rect"
```

***

### `'circle'`（圆形）

在视图框架中居中显示的圆形，半径等于视图框架最短边的一半。

```tsx
clipShape="circle"
```

***

### `'capsule'`（胶囊）

填充整个宽度或高度的椭圆形。等效于圆角半径为短边一半的矩形。

```tsx
clipShape="capsule"
```

***

### `'ellipse'`（椭圆）

在视图框架中对齐并填满的椭圆。

```tsx
clipShape="ellipse"
```

***

### `'buttonBorder'`（按钮边框）

一个系统定义的按钮边框形状，具体外观由平台和上下文决定。

```tsx
clipShape="buttonBorder"
```

***

### `'containerRelative'`（继承容器）

继承父级容器定义的形状作为自身形状。如果未定义容器形状，则默认为矩形。

```tsx
clipShape="containerRelative"
```

***

## 自定义矩形形状（圆角矩形）

当你需要更精细地控制圆角半径或不同角的圆角时，可以使用以下三种对象形式：

***

### 统一圆角矩形

```ts
{
  type: 'rect',
  cornerRadius: number,
  style?: RoundedCornerStyle
}
```

- `cornerRadius`: 所有角的统一圆角半径。
- `style`（可选）: 圆角风格，可选 `'circular'` 或 `'continuous'`。

#### 示例：

```tsx
clipShape={{
  type: 'rect',
  cornerRadius: 12,
  style: 'continuous'
}}
```

***

### 椭圆角尺寸（宽高不同）

```ts
{
  type: 'rect',
  cornerSize: {
    width: number
    height: number
  },
  style?: RoundedCornerStyle
}
```

- 使用不同的 `width` 和 `height` 来生成椭圆形圆角。

#### 示例：

```tsx
clipShape={{
  type: 'rect',
  cornerSize: { width: 10, height: 20 }
}}
```

***

### 每个角分别设置圆角半径

```ts
{
  type: 'rect',
  cornerRadii: {
    topLeading: number,
    topTrailing: number,
    bottomLeading: number,
    bottomTrailing: number
  },
  style?: RoundedCornerStyle
}
```

- 分别指定四个角的圆角半径。

#### 示例：

```tsx
clipShape={{
  type: 'rect',
  cornerRadii: {
    topLeading: 10,
    topTrailing: 20,
    bottomLeading: 0,
    bottomTrailing: 30
  }
}}
```

***

## `RoundedCornerStyle`（圆角风格）

可选参数，用于定义圆角的表现风格：

- `"circular"`: 传统的圆形圆角，适合经典 UI。
- `"continuous"`（默认）: 连续平滑的圆角曲线，适用于现代设计风格。

***

## 总结表

| 形状类型                  | 描述说明                                        |
| --------------------- | ------------------------------------------- |
| `'rect'`              | 普通矩形                                        |
| `'circle'`            | 基于最短边生成的居中圆形                                |
| `'capsule'`           | 胶囊形状，适应整个宽或高                                |
| `'ellipse'`           | 填满框架的椭圆                                     |
| `'buttonBorder'`      | 系统决定的按钮边框形状                                 |
| `'containerRelative'` | 继承容器的形状或使用矩形作为默认                            |
| 自定义 `'rect'`          | 通过 cornerRadius、cornerSize 或 cornerRadii 配置 |



---
url: /zh/guide/Types/ShapeStyle.md
---

# 形状样式

`ShapeStyle` 类型定义了如何将颜色、渐变和材质应用于视图的前景或背景，反映了 SwiftUI 中的样式能力。它涵盖了广泛的样式选项，包括纯色、系统材质和复杂的渐变。

## 概览

在使用 `foregroundStyle` 或 `background` 等修饰符时，你可以传入一个 `ShapeStyle` 来确定视觉外观。例如，可以使用纯红色背景、系统模糊材质或线性渐变，这些都可以通过 `ShapeStyle` 表达。

**SwiftUI 示例（仅供参考）：**

```swift
Text("Hello")
    .foregroundStyle(.red)
    .background(
        LinearGradient(
            colors: [.green, .blue],
            startPoint: .top,
            endPoint: .bottom
        )
    )
```

**脚本语言示例（TypeScript/TSX）：**

```tsx
<Text
  foregroundStyle="red"
  background={{
    gradient: [
      { color: 'green', location: 0 },
      { color: 'blue', location: 1 }
    ],
    startPoint: { x: 0.5, y: 0 },
    endPoint: { x: 0.5, y: 1 }
  }}
>
  Hello
</Text>
```

## ShapeStyle 的类型变体

`ShapeStyle` 可以是以下几种之一：

1. **Material（材质）**：系统定义的材质，用于创建层叠效果，通常包含模糊或半透明。
2. **Color（颜色）**：一个纯色，可通过关键字、十六进制或 RGBA 字符串定义。
3. **Gradient（渐变）**：颜色或渐变停点集合，生成平滑的颜色过渡效果。
4. **LinearGradient（线性渐变）**：沿直线方向的颜色渐变。
5. **RadialGradient（径向渐变）**：从中心向外辐射的渐变。
6. **AngularGradient（角向渐变）**：又称“圆锥渐变”，以角度为依据沿中心点展开。
7. **MeshGradient（网格渐变）**：由二维颜色网格定义的复杂渐变。
8. **ColorWithGradientOrOpacity**：带有标准渐变或不透明度调节的基础颜色。

### 材质（Materials）

**Material** 指的是系统模糊效果，如 `regularMaterial`、`thinMaterial` 等，常用于营造 iOS 应用中的“毛玻璃”外观。

**示例：**

```tsx
<HStack background="regularMaterial">
  {/* 内容 */}
</HStack>
```

### 颜色（Colors）

颜色可以通过三种方式定义：

- **关键字颜色**：系统或命名颜色（如 `"systemBlue"`、`"red"`、`"label"`）。
- **十六进制字符串**：类似 CSS 的格式（如 `"#FF0000"` 或 `"#F00"` 表示红色）。
- **RGBA 字符串**：CSS 格式的 rgba（如 `"rgba(255,0,0,1)"` 表示不透明红）。

**示例：**

```tsx
<Text foregroundStyle="blue">蓝色文字</Text>
<HStack background="#00FF00">绿色背景</HStack>
<HStack background="rgba(255,255,255,0.5)">半透明白色背景</HStack>
```

### 渐变（Gradients）

渐变可以是颜色数组或 `GradientStop` 数组，每个 `GradientStop` 包含一个颜色和一个从 0 到 1 的位置值，用于定义过渡位置。

**示例：**

```tsx
<HStack
  background={
    gradient([
      { color: 'red', location: 0 },
      { color: 'orange', location: 0.5 },
      { color: 'yellow', location: 1 }
    ])
  }
>
  {/* 内容 */}
</HStack>
```

### 线性渐变（LinearGradient）

线性渐变沿两点之间的直线进行颜色过渡。你可以指定颜色或渐变停点，以及起点和终点（可使用关键字如 `'top'`、`'bottom'`，或 `{x, y}` 格式的坐标）。

**示例：**

```tsx
<HStack
  background={
    gradient("linear", {
      colors: ['green', 'blue'],
      startPoint: 'top',
      endPoint: 'bottom'
    })
  }
>
  {/* 内容 */}
</HStack>
```

或使用渐变停点与自定义坐标：

```tsx
<HStack
  background={
    gradient("linear", {
      stops: [
        { color: 'green', location: 0 },
        { color: 'blue', location: 1 }
      ],
      startPoint: { x: 0.5, y: 0 },
      endPoint: { x: 0.5, y: 1 }
    })
  }
>
  {/* 内容 */}
</HStack>
```

### 径向渐变（RadialGradient）

径向渐变从一个中心点向外扩展，指定起始和结束半径。

**示例：**

```tsx
<HStack
  background={
    gradient("radial", {
      colors: ['red', 'yellow'],
      center: { x: 0.5, y: 0.5 },
      startRadius: 0,
      endRadius: 100
    })
  }
>
  {/* 内容 */}
</HStack>
```

### 角向渐变（AngularGradient）

角向渐变围绕中心点以角度变化生成颜色过渡，适合用于圆形进度条等效果。

#### 定义方式

```ts
type AngularGradient =
  | { stops: GradientStop[], center: KeywordPoint | Point, startAngle: Angle, endAngle: Angle }
  | { colors: Color[], center: KeywordPoint | Point, startAngle: Angle, endAngle: Angle }
  | { gradient: Gradient, center: KeywordPoint | Point, startAngle: Angle, endAngle: Angle }
  | { stops: GradientStop[], center: KeywordPoint | Point, angle: Angle }
  | { colors: Color[], center: KeywordPoint | Point, angle: Angle }
  | { gradient: Gradient, center: KeywordPoint | Point, angle: Angle }
```

#### 参数说明

- **`colors` 或 `stops`**：定义渐变的颜色或颜色停点。
- **`center`**：以哪个点为中心展开渐变，可用关键字或自定义点。
- **`startAngle` 与 `endAngle`**：渐变覆盖的角度范围。
- **`angle`**：用于简化表示完整角度变化。

#### 示例

```tsx
<Circle
  fill={gradient("angular", {
    colors: ["blue", "purple", "pink"],
    center: "center",
    startAngle: 0,
    endAngle: 360
  })}
/>
```

此示例为圆形应用一个从蓝到粉的角向渐变。

### 网格渐变（MeshGradient）（iOS 18.0+）

`MeshGradient` 是由控制点网格组成的二维渐变，能实现复杂细腻的动态颜色过渡。

#### 定义

```ts
type MeshGradient = {
  width: number
  height: number
  points: Point[]
  colors: Color[]
  background?: Color
  smoothsColors?: boolean
}
```

#### 参数说明

- **`width` 与 `height`**：控制点网格的宽度和高度。
- **`points`**：每个控制点的位置，数量需与 `width × height` 一致。
- **`colors`**：每个点的颜色，数量也需一致。
- **`background`**（可选）：网格外部的背景颜色，默认是透明。
- **`smoothsColors`**（可选）：是否启用平滑颜色插值，默认为 `true`。

> 注：仅支持 **iOS 18.0 及以上版本**

#### 示例

```tsx
<Rectangle
  fill={gradient("mesh", {
    width: 2,
    height: 2,
    points: [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: 1, y: 1 }
    ],
    colors: ["red", "yellow", "blue", "green"]
  })}
/>
```

这个示例定义了一个 2×2 网格，在四个控制点之间进行颜色过渡。

### `gradient()` 工具函数

`gradient()` 是一个辅助函数，用于使代码更具可读性和表达力，支持所有渐变类型。

#### 函数签名

```ts
function gradient(gradient: Gradient): Gradient
function gradient(type: "linear", gradient: LinearGradient): LinearGradient
function gradient(type: "radial", gradient: RadialGradient): RadialGradient
function gradient(type: "angular", gradient: AngularGradient): AngularGradient
function gradient(type: "mesh", gradient: MeshGradient): MeshGradient
```

#### 描述

- 单参数使用：`gradient(Gradient)` 返回原始渐变对象。
- 双参数使用：第一个参数为渐变类型，第二个为其配置项。

#### 示例

```tsx
<Text
  foregroundStyle={
    gradient("linear", {
      colors: ["red", "orange"],
      startPoint: "leading",
      endPoint: "trailing"
    })
  }
>
  Hello World!
</Text>
```

### ColorWithGradientOrOpacity

该类型以基础颜色为起点，可设置 `gradient: true` 来自动应用标准渐变，或通过 `opacity` 设置透明度。

**示例：**

```tsx
<HStack
  background={{
    color: 'blue',
    gradient: true,
    opacity: 0.8
  }}
>
  {/* 内容 */}
</HStack>
```

这将生成一个蓝色的标准渐变，并应用 80% 的不透明度。

## 总结

- 使用 **Material** 实现系统模糊效果。
- 使用 **Color** 进行纯色填充。
- 使用 **各种 Gradient 类型** 实现多色渐变过渡。
- 使用 **ColorWithGradientOrOpacity** 实现颜色透明度调整或标准渐变。

通过选择合适的 `ShapeStyle` 类型，可以轻松地为 UI 元素实现所需的视觉样式，无论是简单的纯色、动态的渐变，还是精致的材质效果。



---
url: /zh/guide/Utilities/App Events.md
---

# App事件

Scripting 提供的 `AppEvents` 模块允许你监听应用程序级别的状态变化事件，例如生命周期（scene phase）变更以及系统外观（light/dark 模式）切换。这些功能非常适合用于构建对运行时环境具有感知能力的响应式脚本或组件。

***

## 场景生命周期

### `ScenePhase`

```ts
type ScenePhase = 'active' | 'inactive' | 'background'
```

表示 App 当前的生命周期状态：

- **`active`**：应用处于前台，正在交互。
- **`inactive`**：应用处于过渡状态，暂时不活跃（如切换页面、弹窗等）。
- **`background`**：应用已进入后台，不再显示在屏幕上。

***

## 颜色外观（Color Scheme）

### `ColorScheme`

```ts
type ColorScheme = 'light' | 'dark'
```

表示当前系统主题外观模式：

- **`light`**：浅色模式。
- **`dark`**：深色模式。

***

## `AppEventListenerManager<T>`

```ts
class AppEventListenerManager<T> {
  addListener(listener: (data: T) => void): void
  removeListener(listener: (data: T) => void): void
}
```

通用事件监听器管理类，用于注册和移除监听器。`scenePhase` 和 `colorScheme` 都基于该类实现。

***

## `AppEvents` 类

```ts
class AppEvents {
  static scenePhase: AppEventListenerManager<ScenePhase>
  static colorScheme: AppEventListenerManager<ColorScheme>
}
```

### `AppEvents.scenePhase`

监听应用生命周期状态的变化，例如进入后台或前台。

#### 示例：

```ts
AppEvents.scenePhase.addListener((phase) => {
  if (phase === 'active') {
    console.log("App 已激活")
  } else if (phase === 'background') {
    console.log("App 已进入后台")
  }
})
```

***

### `AppEvents.colorScheme`

监听系统外观模式的切换事件（浅色 / 深色）。

#### 示例：

```ts
AppEvents.colorScheme.addListener((scheme) => {
  console.log(`当前外观：${scheme}`)
})
```

***

## `useColorScheme()` 钩子函数

```ts
declare function useColorScheme(): ColorScheme
```

### 说明：

`useColorScheme()` 是一个响应式 Hook，用于在组件中实时获取当前的 `ColorScheme`（`'light'` 或 `'dark'`）。当用户更改系统主题时，返回值会自动更新。

### 示例：

```tsx
function ThemedView() {
  const colorScheme = useColorScheme()

  return <Text>
    {colorScheme === 'dark' ? '当前为深色模式' : '当前为浅色模式'}
  </Text>
}
```

***

## 使用说明

- 使用 `AppEvents.scenePhase` 和 `AppEvents.colorScheme` 可观察全局状态变化，适用于数据暂停/恢复、UI调整等。
- 使用 `useColorScheme()` 是在组件中获取并响应系统外观切换的推荐方式。
- 所有通过 `addListener` 注册的事件都应在不再需要时调用 `removeListener` 以避免内存泄漏。



---
url: /zh/guide/Utilities/Archive.md
---

# Archive（归档）

`Archive` 类用于读取、创建与修改压缩归档文件（如 ZIP 格式）。
它支持以同步或异步的方式向归档中添加文件、目录或从归档中提取文件内容。

***

## 概述

`Archive` 提供了灵活的接口来管理压缩包内容，包括：

- 打开已有归档或创建新归档；
- 添加文件、目录或自定义数据；
- 支持异步与同步两种操作模式；
- 提取文件内容到内存或磁盘；
- 删除归档中的条目；
- 支持自定义压缩算法（如 `deflate`）；
- 可通过 `entries()` 获取归档中的所有条目信息。

***

## 静态方法

### `static openForMode(path: string, accessMode: "update" | "read", options?: { pathEncoding?: Encoding }): Archive`

打开一个归档文件。

**参数：**

| 参数名                    | 类型                   | 说明                                               |
| ---------------------- | -------------------- | ------------------------------------------------ |
| `path`                 | `string`             | 要打开的归档文件路径。                                      |
| `accessMode`           | `"update" \| "read"` | 访问模式： - `"read"`：以只读方式打开； - `"update"`：以可修改方式打开。 |
| `options.pathEncoding` | `Encoding`           | 可选，指定归档中文件路径的编码方式，默认为 `"utf-8"`。                 |

**返回值：**
返回一个 `Archive` 对象。

**示例：**

```ts
const archive = Archive.openForMode("/tmp/example.zip", "update")
```

***

## 属性

### `path: string`

归档文件的路径。

**示例：**

```ts
console.log(archive.path)
```

***

### `data: Data | null`

归档的二进制数据内容（如果以内存方式打开）。

***

## 实例方法

### `entries(pathEncoding?: Encoding): ArchiveEntry[]`

获取归档中所有条目的信息。

**参数：**
`pathEncoding` 可选，指定路径的编码方式，默认为 `"utf-8"`。

**返回值：**
返回一个 `ArchiveEntry` 对象的数组，包含所有条目的信息。

***

### `getEntryPaths(encoding?: Encoding): string[]`

获取归档中所有条目的路径。

**参数：**
`encoding` 可选，指定路径的编码方式，默认为 `"utf-8"`。

**返回值：**
返回一个字符串数组，包含所有条目的路径。

***

### `getEntry(path: string): ArchiveEntry | null`

获取归档中指定路径的条目。

**参数：**
`path` 要获取的条目的路径。

**返回值：**
返回一个 `ArchiveEntry` 对象，或 `null` 如果条目不存在。

***

### `contains(path: string): boolean`

判断归档中是否包含指定路径的条目。

**参数：**

`path` 要判断的条目的路径。

**返回值：**
`true` 表示存在，`false` 表示不存在。

**示例：**

```ts
if (archive.contains("README.md")) {
  console.log("Archive contains README.md")
}
```

***

### `addEntry(path: string, toPath: string, options?: { compressionMethod?: "deflate" | "none"; bufferSize?: number }): Promise<void>`

向归档中添加一个现有文件（异步）。

**参数：**

| 参数名                         | 类型          | 说明                      |                    |
| --------------------------- | ----------- | ----------------------- | ------------------ |
| `path`                      | `string`    | 源文件路径。                  |                    |
| `toPath`                    | `string`    | 添加到归档中的目标路径。            |                    |
| `options.compressionMethod` | `"deflate"` | `"none"`                | 压缩方式，默认为 `"none"`。 |
| `options.bufferSize`        | `number`    | 缓冲区大小，默认为 `16*1024` 字节。 |                    |

**示例：**

```ts
await archive.addEntry("/tmp/input.txt", "docs/input.txt", {
  compressionMethod: "deflate"
})
```

***

### `addEntrySync(path: string, toPath: string, options?)`

同步版本，与 `addEntry()` 功能相同。
若添加失败会抛出异常。

***

### `addFileEntry(path: string, uncompressedSize: number, provider: (offset: number, length: number) => Data, options?): Promise<void>`

通过数据提供函数添加文件到归档（异步）。

**参数：**

| 参数名                         | 类型                                         | 说明                           |                    |
| --------------------------- | ------------------------------------------ | ---------------------------- | ------------------ |
| `path`                      | `string`                                   | 要添加的归档路径（文件名）。               |                    |
| `uncompressedSize`          | `number`                                   | 文件未压缩时的大小。                   |                    |
| `provider`                  | `(offset: number, length: number) => Data` | 用于提供文件数据的函数，会被多次调用直到读取完所有数据。 |                    |
| `options.modificationDate`  | `Date`                                     | 修改时间（可选）。                    |                    |
| `options.compressionMethod` | `"deflate"`                                | `"none"`                     | 压缩方式（默认 `"none"`）。 |
| `options.bufferSize`        | `number`                                   | 缓冲区大小，默认 `16*1024` 字节。       |                    |

**示例：**

```ts
const data = Data.fromRawString("abcdefg".repeat(100))
await archive.addFileEntry("fromMemory.txt", data.count, (offset, length) => {
  return data.slice(offset, offset + length)
})
```

***

### `addFileEntrySync(...)`

同步版本，与上方异步方法功能一致。

***

### `addDirectoryEntry(path: string, options?): Promise<void>`

向归档中添加一个目录。

**参数：**

| 参数名                         | 类型          | 说明                   |                    |
| --------------------------- | ----------- | -------------------- | ------------------ |
| `path`                      | `string`    | 要添加的目录路径。            |                    |
| `options.modificationDate`  | `Date`      | 修改日期（可选）。            |                    |
| `options.compressionMethod` | `"deflate"` | `"none"`             | 压缩方式（默认 `"none"`）。 |
| `options.bufferSize`        | `number`    | 缓冲区大小（默认 `16*1024`）。 |                    |

**示例：**

```ts
await archive.addDirectoryEntry("images/")
```

***

### `addDirectoryEntrySync(...)`

同步版本，与 `addDirectoryEntry()` 功能相同。

***

### `removeEntry(path: string, options?): Promise<void>`

从归档中删除指定路径的条目（异步）。

**参数：**

| 参数名                  | 类型       | 说明                   |
| -------------------- | -------- | -------------------- |
| `path`               | `string` | 要删除的条目路径。            |
| `options.bufferSize` | `number` | 缓冲区大小（默认 `16*1024`）。 |

**示例：**

```ts
await archive.removeEntry("old/file.txt")
```

***

### `removeEntrySync(...)`

同步版本，与 `removeEntry()` 功能相同。

***

### `extract(path: string, consumer: (data: Data) => void, options?): Promise<void>`

从归档中提取指定文件，并将其数据通过回调函数分块返回（异步）。

**参数：**

| 参数名                  | 类型                     | 说明                   |
| -------------------- | ---------------------- | -------------------- |
| `path`               | `string`               | 要提取的文件路径。            |
| `consumer`           | `(data: Data) => void` | 数据消费函数，用于处理提取的数据块。   |
| `options.bufferSize` | `number`               | 缓冲区大小（默认 `16*1024`）。 |

**示例：**

```ts
await archive.extract("docs/manual.txt", (chunk) => {
  console.log("Received chunk:", chunk.count)
})
```

***

### `extractSync(...)`

同步版本，与 `extract()` 功能一致。

***

### `extractTo(path: string, to: string, options?): Promise<void>`

将归档中的文件或目录提取到指定磁盘路径（异步）。

**参数：**

| 参数名                                | 类型        | 说明                               |
| ---------------------------------- | --------- | -------------------------------- |
| `path`                             | `string`  | 归档内路径。                           |
| `to`                               | `string`  | 提取到的目标路径。                        |
| `options.bufferSize`               | `number`  | 缓冲区大小（默认 `16*1024`）。             |
| `options.allowUncontainedSymlinks` | `boolean` | 是否允许解压出不在目标目录内的符号链接（默认 `false`）。 |

**示例：**

```ts
await archive.extractTo("docs/", "/tmp/extracted/")
```

***

### `extractToSync(...)`

同步版本，与 `extractTo()` 功能一致。

***

## ArchiveEntry 类型

`ArchiveEntry` 表示归档中的一个条目（文件、目录或符号链接）。

| 属性                 | 类型                                                       | 说明                  |             |       |
| ------------------ | -------------------------------------------------------- | ------------------- | ----------- | ----- |
| `path`             | `string`                                                 | 条目的路径。              |             |       |
| `type`             | `"file"`                                                 | `"directory"`       | `"symlink"` | 条目类型。 |
| `isCompressed`     | `boolean`                                                | 是否为压缩状态。            |             |       |
| `compressedSize`   | `number`                                                 | 压缩后的大小（字节）。         |             |       |
| `uncompressedSize` | `number`                                                 | 原始未压缩大小（字节）。        |             |       |
| `fileAttributes`   | `{ posixPermissions?: number; modificationDate?: Date }` | 文件属性信息（时间戳、类型、大小等）。 |             |       |

**示例：**

```ts
for (const entry of archive.entries()) {
  console.log(`[${entry.type}] ${entry.path} (${entry.uncompressedSize} bytes)`)
}
```

***

## 综合示例

### 创建新压缩包并添加文件

```ts
const archive = Archive.openForMode("/tmp/example.zip", "update")

await archive.addEntry(
  "/tmp/hello.txt",
  "docs/hello.txt",
  { compressionMethod: "deflate" }
)

await archive.addDirectoryEntry("images/")
await archive.addEntry("/tmp/logo.png", "images/logo.png")

console.log("Archive entries:", archive.entries().length)
```

### 提取文件到本地目录

```ts
const archive = Archive.openForMode("/tmp/example.zip", "read")
await archive.extractTo("docs/hello.txt", "/tmp/unpacked/hello.txt")
```



---
url: /zh/guide/Utilities/Crypto.md
---

# 加密

`Crypto` 模块提供了一组加密工具函数，用于数据哈希、HMAC 认证、对称密钥生成，以及 AES-GCM 加解密。该模块支持标准的加密算法，配合 `Data` 类型使用，适用于各种安全处理场景。

***

## 模块概览

`Crypto` 模块支持：

- 使用 MD5、SHA-1、SHA-2 系列算法进行哈希
- 基于密钥的 HMAC 消息认证
- 生成对称密钥（用于加密和 HMAC）
- 使用 AES-GCM 算法进行加密与解密

所有函数的输入与输出均为 `Data` 类型，代表二进制数据。

***

## 函数说明

### `Crypto.generateSymmetricKey(size?: number): Data`

生成一个随机对称密钥。

- **参数：**

  - `size`（可选）：密钥位数，默认是 256 位（即 32 字节）

- **返回值：** 返回一个 `Data` 实例，包含生成的密钥

- **示例：**

  ```ts
  const key = Crypto.generateSymmetricKey() // 默认生成 256 位密钥
  ```

***

## 哈希函数（Hash Functions）

以下函数用于对输入数据进行不可逆哈希，常用于签名或内容校验。

### `Crypto.md5(data: Data): Data`

使用 MD5 算法生成摘要（128 位）。

- **返回值：** 包含 MD5 哈希值的 `Data` 实例

- **示例：**

  ```ts
  const data = Data.fromString("Hello")
  const hash = Crypto.md5(data).toHexString()
  ```

***

### `Crypto.sha1(data: Data): Data`

使用 SHA-1 算法生成摘要（160 位）。

***

### `Crypto.sha256(data: Data): Data`

使用 SHA-256 算法生成摘要（256 位）。

- **示例：**

  ```ts
  const hash = Crypto.sha256(Data.fromString("test")).toHexString()
  ```

***

### `Crypto.sha384(data: Data): Data`

使用 SHA-384 算法生成摘要（384 位）。

***

### `Crypto.sha512(data: Data): Data`

使用 SHA-512 算法生成摘要（512 位）。

***

## HMAC 函数（带密钥的哈希）

以下函数使用密钥对消息进行哈希认证（HMAC），常用于消息完整性校验与身份验证。

- **参数：**

  - `data`: 要加密的消息（`Data`）
  - `key`: 对称密钥（`Data`）

- **返回值：** HMAC 结果为 `Data` 类型

***

### `Crypto.hmacMD5(data: Data, key: Data): Data`

使用 MD5 生成 HMAC。

```ts
const key = Crypto.generateSymmetricKey()
const hmac = Crypto.hmacMD5(Data.fromString("msg"), key).toHexString()
```

***

### `Crypto.hmacSHA1(data: Data, key: Data): Data`

使用 SHA-1 生成 HMAC。

***

### `Crypto.hmacSHA224(data: Data, key: Data): Data`

使用 SHA-224 生成 HMAC。

***

### `Crypto.hmacSHA256(data: Data, key: Data): Data`

使用 SHA-256 生成 HMAC。

***

### `Crypto.hmacSHA384(data: Data, key: Data): Data`

使用 SHA-384 生成 HMAC。

***

### `Crypto.hmacSHA512(data: Data, key: Data): Data`

使用 SHA-512 生成 HMAC。

***

## AES-GCM 加密与解密

### `Crypto.encryptAESGCM(data: Data, key: Data, options?: { iv?: Data, aad?: Data }): Data | null`

使用 AES-GCM 算法对数据进行加密。

- **参数：**

  - `data`: 明文数据（`Data`）
  - `key`: 对称密钥（`Data`）
  - `options`（可选）：

    - `iv`: 初始化向量（`Data`）。如果不指定，将自动生成随机 IV。
    - `aad`: 附加认证数据，不参与加密，但会影响认证标签（可选）

- **返回值：** 加密后的 `Data`，失败时返回 `null`

- **示例：**

  ```ts
  const key = Crypto.generateSymmetricKey()
  const plaintext = Data.fromString("secret message")
  const encrypted = Crypto.encryptAESGCM(plaintext, key)
  ```

***

### `Crypto.decryptAESGCM(data: Data, key: Data, aad?: Data): Data | null`

使用 AES-GCM 解密密文数据。

- **参数：**

  - `data`: 密文数据（`Data`）
  - `key`: 加密时使用的对称密钥（`Data`）
  - `aad`: 加密时使用的附加认证数据（若有）

- **返回值：** 解密后的明文 `Data`，如果解密失败（如认证标签不匹配、密钥错误），返回 `null`

- **示例：**

  ```ts
  const decrypted = Crypto.decryptAESGCM(encrypted, key)
  console.log(decrypted?.toRawString())
  ```

***

## 常见算法摘要

| 函数        | 输出长度  | 用途说明      |
| --------- | ----- | --------- |
| `md5`     | 128 位 | 旧版校验      |
| `sha1`    | 160 位 | 兼容场景      |
| `sha256`  | 256 位 | 推荐的通用加密哈希 |
| `sha384`  | 384 位 | 更强的哈希     |
| `sha512`  | 512 位 | 高安全性需求    |
| `hmacXXX` | 同哈希   | 消息认证      |
| `AES-GCM` | 可变    | 加密+认证     |

***

## 完整示例：加密与解密一段字符串

```ts
const key = Crypto.generateSymmetricKey()
const message = Data.fromString("Encrypt me")
const encrypted = Crypto.encryptAESGCM(message, key)
const decrypted = encrypted ? Crypto.decryptAESGCM(encrypted, key) : null

if (decrypted) {
  console.log("解密结果:", decrypted.toRawString())
}
```

***

## 说明与注意事项

- 所有函数都要求输入为 `Data` 类型
- AES-GCM 支持自动生成随机 IV，也支持传入自定义 IV 和 AAD
- 返回的加密结果包含密文和认证标签，必要时还应保存 IV



---
url: /zh/guide/Utilities/Data.md
---

# 二进制数据（Data）

`Data` 类用于表示二进制数据，提供多种方法用于数据的创建、转换、压缩、解压、拼接、读取等操作。可用于处理图像、文件、音频、编码数据等各种原始字节数据。

***

## CompressionAlgorithm（压缩算法枚举）

该枚举用于指定 `Data` 的压缩或解压算法：

| 枚举值     | 描述                    |
| ------- | --------------------- |
| `lzfse` | LZFSE 压缩算法，快速且高效。     |
| `lz4`   | LZ4 压缩算法，压缩和解压速度极快。   |
| `lzma`  | LZMA 算法，压缩率高，压缩速度较慢。  |
| `zlib`  | Zlib 算法，通用且广泛支持的压缩格式。 |

***

## 实例属性与方法

### `size: number`

当前数据的字节长度（只读属性）。

***

### `resetBytes(startIndex: number, endIndex: number): void`

将数据中指定范围内的字节清零。

- `startIndex`：起始索引（包含）
- `endIndex`：结束索引（不包含）

若索引超出范围将抛出异常。

***

### `advanced(amount: number): Data`

返回一个新的 `Data` 实例，去除前 `amount` 个字节。

***

### `replaceSubrange(startIndex, endIndex, data): void`

将当前数据中指定范围的字节替换为另一个 `Data` 实例的数据。

***

### `compressed(algorithm: CompressionAlgorithm): Data`

使用指定的压缩算法压缩当前数据，返回压缩后的新 `Data` 实例。

如果数据为空或无法压缩将抛出异常。

***

### `decompressed(algorithm: CompressionAlgorithm): Data`

使用指定的算法对当前数据进行解压，返回解压后的 `Data` 实例。

压缩与解压时使用的算法必须一致。

***

### `slice(start?: number, end?: number): Data`

返回数据的子集片段，形成新的 `Data` 实例。

- `start`：起始索引（默认 0）
- `end`：结束索引（默认到末尾）

***

### `append(other: Data): void`

将另一个 `Data` 实例的数据追加到当前数据末尾。

***

### `getBytes(): Uint8Array | null`（已废弃）

请改用 `toUint8Array()`。

***

### `toUint8Array(): Uint8Array | null`

将数据转换为 `Uint8Array`。

***

### `toArrayBuffer(): ArrayBuffer`

将数据转换为 `ArrayBuffer`。

***

### `toBase64String(): string`

将数据编码为 Base64 字符串。

***

### `toHexString(): string`

将数据编码为十六进制字符串。

***

### `toRawString(encoding?: string): string | null`

将数据转换为字符串，支持指定编码（默认 `"utf-8"`），严格解码，无法解码的字符将返回 `null`。

***

### `toDecodedString(encoding?: "utf8" | "ascii"): string`

将数据转换为字符串，支持指定编码（默认 `"utf-8"`）, 宽松解码，会将无法解码的字符替换为 `?`。

***

### `toIntArray(): number[]`

将数据转换为由整数表示的字节数组。

***

## 静态方法

### `Data.fromIntArray(array: number[]): Data`

从整数数组创建 `Data` 实例。

***

### `Data.fromString(str: string, encoding?: string): Data | null`（已废弃）

请使用 `Data.fromRawString()` 代替。

***

### `Data.fromRawString(str: string, encoding?: string): Data | null`

从字符串创建 `Data` 实例，支持指定编码（默认 `"utf-8"`）。

***

### `Data.fromFile(filePath: string): Data | null`

从本地文件路径读取数据，返回 `Data` 实例。

***

### `Data.fromArrayBuffer(buffer: ArrayBuffer): Data | null`

从 `ArrayBuffer` 创建 `Data` 实例。

***

### `Data.fromUint8Array(bytes: Uint8Array): Data | null`

从 `Uint8Array` 创建 `Data` 实例。

***

### `Data.fromBase64String(base64: string): Data | null`

从 Base64 编码字符串创建 `Data` 实例。

***

### `Data.fromHexString(hex: string): Data | null`

从十六进制字符串创建 `Data` 实例。

***

### `Data.fromJPEG(image: UIImage, compressionQuality?: number): Data | null`

将图像转为 JPEG 格式的 `Data` 实例。

- `compressionQuality`：JPEG 压缩质量，范围 0.0 \~ 1.0，默认值为 1.0（最高质量）

***

### `Data.fromPNG(image: UIImage): Data | null`

将图像转为 PNG 格式的 `Data` 实例。

***

### `Data.combine(dataList: Data[]): Data`

将多个 `Data` 实例合并为一个新实例。

如果列表为空或所有数据为空，则返回空数据。



---
url: /zh/guide/Utilities/DateComponents.md
---

# 日期组件

`DateComponents` 类提供了一种灵活的方式，用于表示和操作日期与时间的各个组成部分，例如年、月、日、小时、分钟、秒等。该类基于 Swift 的 `DateComponents` 实现，并与系统当前日历协同工作。

***

## 构造函数

```ts
new DateComponents(options?)
```

### 参数

构造函数可接收一个可选的 `options` 对象，用于初始化各个日期字段：

```ts
const components = new DateComponents({
  year: 2025,
  month: 6,
  day: 24,
  hour: 9,
  minute: 30
})
```

***

## 静态方法

### `DateComponents.fromDate(date: Date): DateComponents`

从给定的 `Date` 对象中提取所有可用的日期组成部分（年、月、日、小时、分钟、秒、纳秒），返回一个新的 `DateComponents` 实例。

#### 参数

- `date` (`Date`)：需要提取信息的日期对象。

#### 返回

- 包含该日期对应的组成部分的 `DateComponents` 实例。

#### 示例

```ts
const now = new Date()
const components = DateComponents.fromDate(now)
console.log(components.year, components.month)
```

***

### `DateComponents.forHourly(date: Date): DateComponents`

为“每小时重复”的需求创建一个日期组件，仅设置 `minute` 字段。

- 设置字段：`minute`

#### 示例

```ts
const components = DateComponents.forHourly(new Date())
// 每小时的指定分钟触发
```

***

### `DateComponents.forDaily(date: Date): DateComponents`

为“每天重复”的需求创建一个日期组件，设置 `hour` 和 `minute` 字段。

- 设置字段：`hour`, `minute`

#### 示例

```ts
const components = DateComponents.forDaily(new Date())
// 每天的同一时间触发
```

***

### `DateComponents.forWeekly(date: Date): DateComponents`

为“每周重复”的需求创建一个日期组件，设置 `weekday`、`hour`、`minute` 字段。

- 设置字段：`weekday`, `hour`, `minute`

#### 示例

```ts
const components = DateComponents.forWeekly(new Date())
// 每周的相同星期几和时间触发
```

***

### `DateComponents.forMonthly(date: Date): DateComponents`

为“每月重复”的需求创建一个日期组件，设置 `day`、`hour`、`minute` 字段。

- 设置字段：`day`, `hour`, `minute`

#### 示例

```ts
const components = DateComponents.forMonthly(new Date())
// 每月的相同日期和时间触发
```

***

## 属性说明

### 只读属性

- **`date?: Date | null`**
  使用当前组件通过系统日历计算得出的 `Date` 对象。如果无效则为 `null`。

- **`isValidDate: boolean`**
  当前组件组合是否构成一个有效日期。

***

### 可设置的字段

以下所有字段均为可选，可设为 `number` 或 `null`：

- `era`：纪元

- `year`：年份

- `yearForWeekOfYear`：与周数关联的年份

- `quarter`：季度（1 到 4）

- `month`：月份（1 到 12）

- `isLeapMonth`：是否为闰月（布尔值）

- `weekOfMonth`：当前月份中的第几周

- `weekOfYear`：当前年份中的第几周

- `weekday`：星期几（1 = 星期日，2 = 星期一，…，7 = 星期六）

- `weekdayOrdinal`：某星期几在当前月中第几次出现

  #### 示例

  ```ts
  const c = new DateComponents()
  c.weekday = 2           // 星期一
  c.weekdayOrdinal = 1    // 本月的第一个星期一
  ```

- `day`：每月中的某一天

- `hour`：小时（0 到 23）

- `minute`：分钟（0 到 59）

- `second`：秒（0 到 59）

- `nanosecond`：纳秒（0 到 999,999,999）

- `dayOfYear`：一年中的第几天（1 到 366）

***

## 使用示例

```ts
const components = new DateComponents({
  year: 2025,
  month: 12,
  day: 25,
  hour: 10,
  minute: 0
})

if (components.isValidDate) {
  console.log("有效日期:", components.date)
}
```

```ts
const daily = DateComponents.forDaily(new Date())
const weekly = DateComponents.forWeekly(new Date())
```

***

## 注意事项

- `date` 和 `isValidDate` 的计算依赖系统当前的日历设置。
- 若未设置足够字段，可能无法构成一个有效日期。
- 推荐使用 `forHourly`、`forDaily`、`forWeekly`、`forMonthly` 方法快速创建周期性日期组件，适用于通知调度、事件提醒等场景。



---
url: /zh/guide/Utilities/DateFormatter.md
---

`DateFormatter` 类用于将 `Date` 类型格式化为字符串，或将字符串解析为 `Date`。
该类封装了 iOS 的 `DateFormatter` 能力，适用于格式化日期、时间、本地化展示、农历日期展示（通过切换日历）、相对日期显示等场景。

***

# 枚举与类型定义

## DateFormatterStyle

用于指定日期或时间的格式化级别。

| 枚举值      | 含义                                |
| -------- | --------------------------------- |
| `none`   | 不显示日期或时间                          |
| `short`  | 短格式，例如 `12/1/25`、`3:20 PM`        |
| `medium` | 中等格式，例如 `Dec 1, 2025`             |
| `long`   | 长格式，例如 `December 1, 2025`         |
| `full`   | 全格式，例如 `Monday, December 1, 2025` |

***

## DateFormatterBehavior

指定格式化器的行为模式。

| 枚举值            | 含义                 |
| -------------- | ------------------ |
| `default`      | 系统默认行为             |
| `behavior10_4` | 兼容旧系统格式化行为（通常无需使用） |

***

## CalendarIdentifier

指定 `DateFormatter` 使用的历法类型。可用于格式化如：

- 公历（gregorian）
- 农历（chinese）
- 佛历（buddhist）
- 日本历（japanese）
- 伊斯兰历（islamic）
  等。

可选值示例：

```
"current" | "gregorian" | "chinese" | "japanese" | "islamic" | "iso8601" | ...
```

其中：

- `"current"` 代表当前系统日历
- `"autoupdatingCurrent"` 表示系统日历变更后自动更新

***

## TimeZoneIdentifier

指定时区。

可选值：

```
"current" | "autoupdatingCurrent" | "gmt" | string
```

当传入普通字符串时，可以使用任意合法时区 ID，例如：

- `"Asia/Shanghai"`
- `"America/Los_Angeles"`
- `"UTC"`

***

# 类：DateFormatter

## 初始化

### `new(): DateFormatter`

创建一个新的日期格式器实例。

***

# 静态方法

## `DateFormatter.localizedString(date, options)`

根据指定的日期格式与时间格式返回本地化后的字符串。

```ts
DateFormatter.localizedString(date: Date, options: {
  dateStyle: DateFormatterStyle
  timeStyle: DateFormatterStyle
}): string
```

适用于快速格式化，无需手动设置 formatter 属性。

***

## `DateFormatter.dateFormat(template, locale?)`

根据日期模板生成本地化后的格式化字符串。

```
static dateFormat(template: string, locale?: string): string | null
```

示例模板：`"yyyyMMdd"`, `"MMM d"`, `"HH:mm"`

如果传入 locale，则按指定语言区域生成；否则使用系统 locale。

***

# 实例方法

## `string(date: Date): string`

将 Date 转换为格式化字符串。

注意：如果设置了 `dateFormat`，则优先使用自定义格式；
否则根据 `dateStyle` 和 `timeStyle` 自动格式化。

***

## `date(string: string): Date | null`

将字符串解析为 Date。
解析能力依赖于当前 dateFormat、locale、calendar 等属性。

***

## `setLocalizedDateFormatFromTemplate(template: string): void`

根据模板生成本地化格式，并自动设置到 `dateFormat` 属性中。

***

# 属性说明

以下为所有可配置属性的功能说明。

## 日期与时间格式属性

### `calendar: CalendarIdentifier`

选择日期格式化使用的历法，如公历、农历、佛历等。

***

### `timeZone: TimeZoneIdentifier`

设置时区，例如 `"Asia/Shanghai"`。

***

### `locale: string`

指定区域语言，例如：

- `"zh_CN"`
- `"en_US"`
- `"ja_JP"`

***

### `dateFormat: string`

手动指定格式化模板。例如：

```
"yyyy-MM-dd HH:mm"
"MMM d, yyyy"
"EEEE"
```

如果设置该属性，则忽略 `dateStyle` 和 `timeStyle`。

***

### `dateStyle/timeStyle: DateFormatterStyle`

分别控制日期和时间格式级别。

***

## 行为属性

### `generatesCalendarDates: boolean`

是否生成历法日期，一般保持默认即可。

***

### `formatterBehavior: DateFormatterBehavior`

控制格式器行为，通常使用默认值。

***

### `isLenient: boolean`

是否宽松解析输入，例如解析模糊格式字符串。
一般保持 `false`，避免误解析。

***

### `twoDigitStartDate: Date | null`

设置双位数年份的起始范围。用于解析如 `"20"` 这样的年份值。

***

### `defaultDate: Date | null`

解析字符串无法获得时间时，使用的默认日期。

***

## 本地化符号与文案属性

以下属性用于自定义本地化符号，如月份名称、星期名称等。
这些属性通常无需手动设置，除非需要覆盖本地化字符串。

举例属性：

- `eraSymbols`
- `monthSymbols`
- `shortMonthSymbols`
- `weekdaySymbols`
- `shortWeekdaySymbols`
- `standaloneMonthSymbols`
- `amSymbol`
- `pmSymbol`
- `quarterSymbols`
- `standaloneQuarterSymbols`
- `veryShortWeekdaySymbols`
- `gregorianStartDate`

这些属性主要作用于需要深度定制本地化展示的场景。

***

## `doesRelativeDateFormatting: boolean`

启用相对日期格式化，例如：

- Today
- Yesterday
- Tomorrow

在中文环境中可显示为：

- 今天
- 昨天
- 明天

通常与 `dateStyle = .medium` 等组合使用。

***

# 示例代码

以下示例展示如何使用 `DateFormatter` 进行多种日期格式化场景。

***

## 示例一：使用 dateStyle 和 timeStyle 进行本地化格式化

```tsx
import { DateFormatter } from "scripting"

const df = new DateFormatter()
df.locale = "zh_CN"
df.dateStyle = DateFormatterStyle.full
df.timeStyle = DateFormatterStyle.short

const result = df.string(new Date())
// 输出示例： "2025年12月12日 星期五 下午3:20"
```

***

## 示例二：自定义日期格式模板

```tsx
const df = new DateFormatter()
df.locale = "en_US"
df.dateFormat = "yyyy-MM-dd HH:mm"

df.timeZone = "Asia/Shanghai"

const str = df.string(new Date())
// 输出示例： "2025-12-12 15:20"
```

***

## 示例三：使用农历格式化（chinese calendar）

```tsx
const df = new DateFormatter()

df.calendar = "chinese"
df.locale = "zh_CN"
df.dateFormat = "yyyy年MM月dd日 EEEE"

const lunar = df.string(new Date())
// 输出示例： "四十三年十月廿二日 星期五"
```

***

## 示例四：解析字符串为日期

```tsx
const df = new DateFormatter()
df.dateFormat = "yyyy/MM/dd HH:mm"

const date = df.date("2025/12/12 08:00")
```

***

## 示例五：使用模板生成本地化格式

```tsx
const df = new DateFormatter()
df.locale = "zh_CN"

// 自动设置为符合中文习惯的格式，例如 "12月12日"
df.setLocalizedDateFormatFromTemplate("MMdd")

const str = df.string(new Date())
```

***

## 示例六：使用静态快速格式化

```tsx
const str = DateFormatter.localizedString(new Date(), {
  dateStyle: DateFormatterStyle.medium,
  timeStyle: DateFormatterStyle.short
})
```



---
url: /zh/guide/Utilities/Encoding.md
---

# 编码

`Encoding` 类型定义了可用于文本与二进制数据之间转换的字符编码集。
常用于以下方法：

- `Data.fromRawString(str, encoding)` — 使用指定编码将字符串转换为二进制数据。
- `Data.toRawString(encoding)` — 使用指定编码将二进制数据解码为字符串。

通过这些编码类型，可以在不同系统、语言和文件格式之间正确地读写文本内容。

***

## 可用编码列表

| 编码名称                    | 说明                                                                       |
| ----------------------- | ------------------------------------------------------------------------ |
| **"utf-8" / "utf8"**    | UTF-8（8位 Unicode 转换格式）。目前最常用的文本编码方式，与 ASCII 兼容，几乎支持所有语言字符。               |
| **"utf-16" / "utf16"**  | UTF-16（16位 Unicode 转换格式），广泛用于 Windows 和 Apple 系统，每个字符通常占 2 个字节。          |
| **"utf-32" / "utf32"**  | UTF-32（32位 Unicode 转换格式），每个字符固定使用 4 个字节，适合直接处理 Unicode 码点。               |
| **"ascii"**             | 美国信息交换标准码（ASCII），仅包含英文字母、数字及基础符号（0–127），为最早的文本编码标准。                      |
| **"iso2022JP"**         | ISO-2022-JP，日本语编码格式，常用于电子邮件或旧系统中，支持 JIS X 0201/0208 字符集。                 |
| **"isoLatin1"**         | ISO-8859-1（Latin-1），覆盖西欧语言，如英语、法语、德语、西班牙语等。                              |
| **"japaneseEUC"**       | EUC-JP（扩展 Unix 编码），另一种日本语编码方式，主要用于 Unix 系统。                              |
| **"macOSRoman"**        | MacRoman 编码，早期 Mac OS 系统使用的本地编码格式，现已较少使用。                                |
| **"nextstep"**          | NeXTSTEP 系统使用的旧编码格式，属于历史遗留类型。                                            |
| **"nonLossyASCII"**     | 无损 ASCII 编码。通过转义序列将任意 Unicode 字符安全地表示为 ASCII，并可无损还原。                     |
| **"shiftJIS"**          | Shift-JIS，日本语编码格式，Windows 日本系统中广泛使用。                                     |
| **"symbol"**            | Symbol 字体编码，用于符号类字体（如数学符号、特殊字符）。                                         |
| **"unicode"**           | Unicode 编码的通用别名（通常等同于 UTF-16）。                                           |
| **"utf16BigEndian"**    | UTF-16 大端序编码（高位字节在前）。                                                    |
| **"utf16LittleEndian"** | UTF-16 小端序编码（低位字节在前）。                                                    |
| **"utf32BigEndian"**    | UTF-32 大端序编码。                                                            |
| **"utf32LittleEndian"** | UTF-32 小端序编码。                                                            |
| **"windowsCP1250"**     | Windows 代码页 1250，用于中欧和东欧语言（如波兰语、捷克语、匈牙利语）。                               |
| **"windowsCP1251"**     | Windows 代码页 1251，用于西里尔文字（如俄语、保加利亚语、塞尔维亚语）。                               |
| **"windowsCP1252"**     | Windows 代码页 1252，用于西欧语言，与 Latin-1 相似，但包含更多符号。                            |
| **"windowsCP1253"**     | Windows 代码页 1253，用于希腊语。                                                  |
| **"windowsCP1254"**     | Windows 代码页 1254，用于土耳其语。                                                 |
| **"gbk"**               | GBK（国家标准扩展码），是简体中文常用的字符编码，向下兼容 GB2312，并扩展了繁体字和日文假名，主要用于中国大陆的 Windows 系统。 |
| **"gb18030"**           | GB18030 是中国国家标准编码，兼容 GBK 和 GB2312，支持完整 Unicode 字符集，是目前中国大陆的强制性编码标准。      |

***

## 示例

### 示例一：UTF-8 编码与解码

```ts
import { Data } from 'scripting'

// 使用 UTF-8 将字符串转换为二进制数据
const text = "こんにちは世界" // 日语“你好，世界”
const utf8Data = Data.fromRawString(text, "utf-8")

// 使用 UTF-8 解码回字符串
const decoded = utf8Data.toRawString("utf-8")

console.log(decoded) // 输出: こんにちは世界
```

***

### 示例二：使用 Shift-JIS 编码

```ts
// 使用 Shift-JIS 编码（日本常用编码）
const sjisData = Data.fromRawString("テスト", "shiftJIS")

// 解码回字符串
const decodedSJIS = sjisData.toRawString("shiftJIS")
console.log(decodedSJIS) // 输出: テスト
```

***

### 示例三：Windows 代码页示例

```ts
// 使用中欧字符示例
const text = "Příliš žluťoučký kůň úpěl ďábelské ódy"
const data = Data.fromRawString(text, "windowsCP1250")
const result = data.toRawString("windowsCP1250")
console.log(result)
```

***

## 注意事项

- 若使用了错误的编码进行解码，字符串中可能出现乱码或替代符号（如 “�”）。
- 推荐默认使用 `"utf-8"`，它是最通用、最兼容的编码格式。
- 旧式编码（如 `"shiftJIS"`、`"iso2022JP"`、`"windowsCP125x"`）主要用于与旧文件或系统兼容的场景。
- 在处理网络数据或文件存储时，确保读写双方使用相同的编码格式，避免出现文字乱码。



---
url: /zh/guide/Utilities/FileEntity.md
---

# FileEntity

`FileEntity` 类提供了文件级的读写操作接口，用于在 `HttpServer` 或其他脚本环境中直接读取、写入、定位和关闭文件。
它支持以多种模式（只读、只写、读写、追加等）打开文件，并能配合 `HttpResponse` 直接返回文件内容给客户端。

***

## 概述

`FileEntity` 允许你在脚本中对文件执行以下操作：

- 打开文件进行读取、写入或读写；
- 按偏移量定位文件读取位置；
- 从文件中读取或写入指定大小的数据；
- 在使用完成后关闭文件；
- 支持以二进制流方式处理文件内容；
- 可直接作为 `HttpResponse.raw()` 的响应体返回。

***

## 实例属性

### `path: string`

文件路径（只读属性），表示该 `FileEntity` 对应的本地文件路径。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/file.txt")
console.log(file.path)
// 输出: "/path/to/file.txt"
```

***

## 实例方法

### `seek(offset: number): boolean`

移动文件指针到指定的偏移位置。
偏移量以字节为单位，返回值表示是否定位成功。

**参数：**

| 参数名      | 类型       | 说明          |
| -------- | -------- | ----------- |
| `offset` | `number` | 要移动到的字节偏移量。 |

**返回值：**

- `true`：定位成功；
- `false`：定位失败。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/data.bin")
file.seek(128)
```

***

### `read(size: number): Data`

从当前文件指针位置开始读取指定字节数的数据。
读取到的内容以 `Data` 对象返回。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `size` | `number` | 要读取的字节数量。 |

**返回值：**

- `Data`：包含所读取的文件数据。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/text.txt")
const data = file.read(100)
console.log(data.toRawString("utf-8"))
file.close()
```

***

### `write(data: Data): void`

将指定的 `Data` 写入到文件的当前位置。

**参数：**

| 参数名    | 类型     | 说明          |
| ------ | ------ | ----------- |
| `data` | `Data` | 要写入文件的数据对象。 |

**异常：**
如果文件未以写模式打开或写入失败，将抛出异常。

**示例：**

```ts
const data = Data.fromRawString("Hello, Scripting!", "utf-8")
const file = FileEntity.openNewForWriting("/tmp/test.txt")
file.write(data)
file.close()
```

***

### `close(): void`

关闭文件并释放资源。
关闭后不应再调用 `read()` 或 `write()`。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/file.txt")
// ...进行读取操作...
file.close()
```

***

## 静态方法

### `static openForReading(path: string): FileEntity`

以只读模式打开文件。
如果文件不存在或无法读取，将抛出异常。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `path` | `string` | 要打开的文件路径。 |

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/image.png")
```

***

### `static openNewForWriting(path: string): FileEntity`

以写入模式打开文件，若文件已存在会被覆盖。
适合用于创建新文件或清空原文件内容。

**示例：**

```ts
const file = FileEntity.openNewForWriting("/tmp/output.txt")
file.write(Data.fromRawString("New file created"))
file.close()
```

***

### `static openForMode(path: string, mode: string): FileEntity`

以指定模式打开文件。
支持的模式遵循标准 POSIX 文件模式，但建议使用带有二进制标志的形式（例如 `"rb"`, `"r+b"`），以确保跨平台兼容性，因为该接口底层以二进制方式读写文件。

**参数：**

| 模式               | 说明                                          |
| ---------------- | ------------------------------------------- |
| `"r"` / `"rb"`   | 以只读方式打开文件（文件必须存在）。推荐使用 `"rb"`，兼容性更好。        |
| `"w"` / `"wb"`   | 以只写方式打开文件（文件存在则清空，不存在则创建）。推荐使用 `"wb"`。      |
| `"a"` / `"ab"`   | 以追加写入模式打开文件（写入内容将添加到末尾，不存在则创建）。推荐使用 `"ab"`。 |
| `"r+"` / `"r+b"` | 以读写模式打开文件（文件必须存在）。推荐使用 `"r+b"`，支持二进制读写。     |
| `"w+"` / `"w+b"` | 以读写模式打开文件（文件存在则清空，不存在则创建）。推荐使用 `"w+b"`。     |
| `"a+"` / `"a+b"` | 以读写追加模式打开文件（文件不存在则创建）。推荐使用 `"a+b"`。         |

> 💡 **建议：**
> 优先使用带 `b` 后缀的模式（如 `"rb"`, `"r+b"` 等），因为 `FileEntity` 的底层接口以二进制流方式处理数据，这样可避免在不同平台上出现编码或换行符差异问题。

**示例：**

```ts
// 以二进制读写模式打开文件（推荐）
const file = FileEntity.openForMode("/tmp/log.bin", "r+b")

// 写入二进制内容
file.write(Data.fromRawString("append log\n"))

// 定位到文件开头并读取数据
file.seek(0)
const content = file.read(20).toRawString("utf-8")
console.log(content)

file.close()
```

***

## 在 HttpResponse 中使用文件

`FileEntity` 可直接作为 `HttpResponse.raw()` 的响应体，实现文件下载或静态内容响应。

**示例：**

```ts
server.registerHandler("/download", (req) => {
  const file = FileEntity.openForReading(Path.join(Script.directory, "manual.pdf"))
  return HttpResponse.raw(200, "OK", {
    headers: { "Content-Type": "application/pdf" },
    body: file
  })
})
```

客户端访问 `/download` 时将直接下载该文件。

***

## 总结

| 方法                           | 功能            | 使用场景       |
| ---------------------------- | ------------- | ---------- |
| `seek()`                     | 定位文件读取/写入位置   | 分段读取或随机访问  |
| `read()`                     | 从文件中读取数据      | 读取文本或二进制内容 |
| `write()`                    | 写入数据到文件       | 保存日志、导出文件  |
| `close()`                    | 关闭文件          | 释放资源       |
| `openForReading()`           | 以只读方式打开文件     | 读取静态资源     |
| `openNewForWriting()`        | 以写入模式打开文件（覆盖） | 创建新文件      |
| `openForWritingAndReading()` | 以读写模式打开文件     | 文件编辑或流式传输  |
| `openForMode()`              | 以自定义模式打开文件    | 兼容多种操作方式   |



---
url: /zh/guide/Utilities/FileManager.md
---

# 文件管理器

FileManager 模块提供对文件系统的统一访问接口，是脚本与本地文件及 iCloud 文件交互的主要方式。它支持对目录与文件进行读取、写入、拷贝、移动、删除、压缩、解压、符号链接操作，以及 iCloud 文件管理等功能。

***

## 基本属性

### `FileManager.scriptsDirectory: string`

存放脚本文件的目录路径。开发者编写的脚本会存储在该目录中。

### `FileManager.isiCloudEnabled: boolean`

用于判断 iCloud 是否可用。若当前设备未登录 iCloud，或未授权 Scripting 使用 iCloud，该属性返回 `false`。

### `FileManager.iCloudDocumentsDirectory: string`

返回 iCloud 的 `Documents` 目录路径。若 iCloud 未启用，调用该属性会抛出错误。使用前应检查 `FileManager.isiCloudEnabled`。

### `FileManager.appGroupDocumentsDirectory: string`

返回 App Group 的共享 Documents 目录路径。存储于该目录的文件不会显示在系统的“文件”应用中，但 Widget 中运行的脚本可访问这些文件。

### `FileManager.documentsDirectory: string`

返回本地的 `Documents` 目录路径。存储于该目录的文件可在“文件”应用中查看，但 Widget 不可访问。

### `FileManager.temporaryDirectory: string`

返回临时目录路径，用于创建临时文件。系统可能在适当时机自动清除该目录内容。

***

## iCloud 文件管理

### `FileManager.isFileStoredIniCloud(filePath: string): boolean`

判断指定文件是否为存储于 iCloud 的文件。

| 参数       | 类型     | 说明   |
| -------- | ------ | ---- |
| filePath | string | 文件路径 |

### `FileManager.isiCloudFileDownloaded(filePath: string): boolean`

判断指定的 iCloud 文件是否已从云端下载到本地。

### `FileManager.downloadFileFromiCloud(filePath: string): Promise<boolean>`

下载指定的 iCloud 文件。

| 返回值               | 说明     |
| ----------------- | ------ |
| Promise\<boolean> | 下载是否成功 |

示例：

```ts
if (FileManager.isiCloudEnabled) {
  const file = FileManager.iCloudDocumentsDirectory + "/data.json";
  const ok = await FileManager.downloadFileFromiCloud(file);
}
```

### `FileManager.getShareUrlOfiCloudFile(path: string, expiration?: number): string`

生成 iCloud 文件的可分享下载链接。文件必须存在于 iCloud 且已上传。

| 参数         | 类型        | 说明                                                  |
| ---------- | --------- | --------------------------------------------------- |
| path       | string    | 必须以 `FileManager.iCloudDocumentsDirectory` 为前缀的文件路径 |
| expiration | number 可选 | 链接过期时间戳                                             |

使用时需配合 `try-catch` 捕获异常。

***

## 目录与文件操作

支持异步（Promise）与同步（Sync）两种版本。同步方法会阻塞执行线程，在性能敏感场景应优先使用异步版本。

### 创建目录

#### `createDirectory(path: string, recursive?: boolean): Promise<void>`

#### `createDirectorySync(path: string, recursive?: boolean): void`

| 参数        | 类型         | 说明                   |
| --------- | ---------- | -------------------- |
| path      | string     | 目录路径                 |
| recursive | boolean 可选 | 若为 true，则自动创建不存在的父目录 |

### 创建符号链接

#### `createLink(path: string, target: string): Promise<void>`

#### `createLinkSync(path: string, target: string): void`

在 `path` 创建指向 `target` 的符号链接。

### 拷贝文件

#### `copyFile(path: string, newPath: string): Promise<void>`

#### `copyFileSync(path: string, newPath: string): void`

### 读取目录

#### `readDirectory(path: string, recursive?: boolean): Promise<string[]>`

#### `readDirectorySync(path: string, recursive?: boolean): string[]`

列出指定目录下所有内容，可递归。

### 判断文件存在性

#### `exists(path: string): Promise<boolean>`

#### `existsSync(path: string): boolean`

### 文件书签管理

文件书签用于持久访问用户授权的外部文件。

| 方法                      | 说明                    |
| ----------------------- | --------------------- |
| `bookmarkExists(name)`  | 判断书签是否存在              |
| `getAllFileBookmarks()` | 获取所有书签名称与路径           |
| `bookmarkedPath(name)`  | 返回书签对应的路径，不存在时返回 null |

### 判断文件类型

| 方法                                | 返回      | 说明       |
| --------------------------------- | ------- | -------- |
| `isFile / isFileSync`             | boolean | 是否为文件    |
| `isDirectory / isDirectorySync`   | boolean | 是否为目录    |
| `isLink / isLinkSync`             | boolean | 是否为符号链接  |
| `isBinaryFile / isBinaryFileSync` | boolean | 是否为二进制文件 |

***

## 文件读写

支持三种读写格式：字符串、字节数组、Data。

### 读取文件

| 方法                  | 返回类型       | 说明          |
| ------------------- | ---------- | ----------- |
| readAsString / Sync | string     | 指定编码读取文本内容  |
| readAsBytes / Sync  | Uint8Array | 读取为字节数组     |
| readAsData / Sync   | Data       | 读取为 Data 对象 |

### 写入文件

| 方法                   | 数据格式       |
| -------------------- | ---------- |
| writeAsString / Sync | string     |
| writeAsBytes / Sync  | Uint8Array |
| writeAsData / Sync   | Data       |

自动覆盖已有文件。

### 追加内容

| 方法                | 数据格式   |
| ----------------- | ------ |
| appendText / Sync | string |
| appendData / Sync | Data   |

若文件或目录不存在将自动创建。

***

## 文件信息与操作

### `stat(path: string): Promise<FileStat>`

### `statSync(path: string): FileStat`

获取文件信息。若 path 为符号链接，会返回真实文件的状态。

### `rename / renameSync`

移动或重命名文件或目录。

### `remove / removeSync`

删除文件或目录（目录会递归删除）。

***

## 压缩与解压

### `zip(srcPath: string, destPath: string, shouldKeepParent?: boolean): Promise<void>`

### `zipSync(srcPath: string, destPath: string, shouldKeepParent?: boolean): void`

压缩文件或目录为 zip。

### `unzip(srcPath: string, destPath: string): Promise<void>`

### `unzipSync(srcPath: string, destPath: string): void`

解压 zip 文件。

示例：

```ts
const docs = FileManager.documentsDirectory;
await FileManager.zip(docs + "/MyScript", docs + "/MyScript.zip");
await FileManager.unzip(docs + "/MyScript.zip", docs + "/Output");
```

***

## 其他工具方法

### `mimeType(path: string): string`

返回文件的 MIME 类型。

### `destinationOfSymbolicLink(path: string): string`

返回符号链接指向的目标路径。

***

## 类型定义

### `FileStat`

```ts
type FileStat = {
  creationDate: number;
  modificationDate: number;
  type: string; // "file" | "directory" | "link" | "unixDomainSock" | "pipe" | "notFound"
  size: number;
};
```



---
url: /zh/guide/Utilities/HttpServer/HttpRequest.md
---

# HttpRequest（HTTP 请求）

`HttpRequest` 类表示一个由客户端发往服务器的 HTTP 请求对象。它封装了请求的路径、方法、头部、请求体、来源地址以及解析后的参数信息，可在服务器的路由处理函数中使用。

***

## 概述

`HttpRequest` 通常作为参数传入由 `HttpServer.registerHandler()` 注册的处理函数中，用于：

- 读取请求路径、方法、头部与请求体；
- 访问 URL 参数与查询参数；
- 解析表单数据（包括 `application/x-www-form-urlencoded` 与 `multipart/form-data`）；
- 校验身份令牌或自定义 header。

***

## 属性

### `path: string`

请求的路径部分，不包含查询参数。

**示例：**

```ts
console.log(request.path) 
// 输出: "/api/user"
```

***

### `method: string`

请求的 HTTP 方法，例如 `"GET"`, `"POST"`, `"PUT"`, `"DELETE"` 等。

**示例：**

```ts
console.log(request.method)
// 输出: "POST"
```

***

### `headers: Record<string, string>`

包含请求头部的键值对对象。

**示例：**

```ts
console.log(request.headers["content-type"])
// 输出: "application/json"
```

***

### `body: Data`

请求体内容，封装为 `Data` 对象。
可通过 `Data.toRawString("utf-8")` 等方法将其转换为文本。

**示例：**

```ts
const text = request.body.toRawString("utf-8")
console.log("请求体内容:", text)
```

***

### `address: string | null`

请求来源的客户端 IP 地址。
若无法识别来源，则为 `null`。

**示例：**

```ts
console.log("来自地址:", request.address)
```

***

### `params: Record<string, string>`

路径参数对象，用于访问定义在路由路径中的占位符。

**示例：**

```ts
// 路由注册时定义
server.registerHandler("/user/:id", (req) => {
  const userId = req.params["id"]
  return HttpResponse.ok(HttpResponseBody.text(`User ID: ${userId}`))
})
```

访问 `/user/123` 时输出：

```
User ID: 123
```

***

### `queryParams: Array<{ key: string; value: string }>`

URL 查询参数数组，每项包含 `key` 与 `value`。
可用于读取 `?key=value` 形式的参数。

**示例：**

```ts
// 请求 URL: /search?keyword=apple&page=2
for (const param of request.queryParams) {
  console.log(param.key, "=", param.value)
}
// 输出：
// keyword = apple
// page = 2
```

***

## 方法

### `hasTokenForHeader(headerName: string, token: string): boolean`

检查指定请求头中是否包含给定的令牌（通常用于 `Authorization` 或自定义安全验证）。

**参数：**

| 参数名          | 类型       | 说明                 |
| ------------ | -------- | ------------------ |
| `headerName` | `string` | 要检查的请求头名称（不区分大小写）。 |
| `token`      | `string` | 期望匹配的令牌字符串。        |

**返回值：**

- `true`：请求头中包含该令牌；
- `false`：不包含。

**示例：**

```ts
if (!request.hasTokenForHeader("Authorization", "Bearer my-secret-token")) {
  return HttpResponse.unauthorized()
}
```

***

### `parseUrlencodedForm(): Array<{ key: string; value: string }>`

解析 `application/x-www-form-urlencoded` 格式的表单请求体。
通常用于处理 HTML 表单的 POST 请求。

**返回值：**
返回一个数组，每个元素包含 `key` 与 `value`。

**示例：**

```ts
const form = request.parseUrlencodedForm()
for (const field of form) {
  console.log(field.key, "=", field.value)
}
```

假设请求体为：

```
username=thom&password=1234
```

则输出：

```
username = thom
password = 1234
```

***

### `parseMultiPartFormData(): Array<{ name: string | null; filename: string | null; headers: Record<string, string>; data: Data }>`

解析 `multipart/form-data` 格式的表单请求（通常用于文件上传）。

**返回值：**
返回一个数组，每个元素代表一个表单字段或文件项，包含以下属性：

| 属性         | 类型                       | 说明                         |
| ---------- | ------------------------ | -------------------------- |
| `name`     | `string \| null`         | 表单字段名称。                    |
| `filename` | `string \| null`         | 如果是文件上传项，则为文件名；否则为 `null`。 |
| `headers`  | `Record<string, string>` | 文件或字段的头部信息。                |
| `data`     | `Data`                   | 字段或文件内容数据。                 |

**示例：**

```ts
const parts = request.parseMultiPartFormData()
for (const part of parts) {
  if (part.filename) {
    console.log("上传文件:", part.filename)
    FileManager.writeAsDataSync(Path.join(Script.directory, part.filename), part.data)
  } else {
    console.log("字段:", part.name, "=", part.data.toRawString("utf-8"))
  }
}
```

***

## 综合示例

以下示例展示了如何读取请求信息并返回响应：

```ts
server.registerHandler("/upload", (req) => {
  if (req.method === "POST") {
    const parts = req.parseMultiPartFormData()
    for (const part of parts) {
      if (part.filename) {
        console.log("Received file:", part.filename)
      } else {
        console.log("Field:", part.name)
      }
    }
    return HttpResponse.ok(HttpResponseBody.text("Upload successful"))
  } else {
    return HttpResponse.badRequest(HttpResponseBody.text("POST required"))
  }
})
```



---
url: /zh/guide/Utilities/HttpServer/HttpResponse.md
---

# HttpResponse（HTTP 响应）

`HttpResponse` 类表示服务器对客户端请求的响应对象。
它定义了 HTTP 响应的状态码、响应体及头部信息，并提供多种便捷方法生成常见的标准响应（如 `ok`、`notFound`、`internalServerError` 等）。

此类通常与 `HttpResponseBody` 搭配使用，用于在服务器端返回文本、HTML、二进制数据或文件内容。

***

## 概述

`HttpResponse` 的主要功能包括：

- 构造标准 HTTP 响应（200、404、500 等）；
- 返回自定义状态码与原因短语；
- 返回文本、数据、HTML 或文件；
- 设置自定义响应头；
- 支持从 `FileEntity` 或 `Data` 对象直接构建响应体。

***

## 属性

### `statusCode: number`

HTTP 响应状态码。

**示例：**

```ts
const res = HttpResponse.ok(HttpResponseBody.text("OK"))
console.log(res.statusCode)
// 输出: 200
```

***

### `reasonPhrase: string`

状态码对应的原因短语（例如 `"OK"`, `"Not Found"`, `"Internal Server Error"` 等）。

**示例：**

```ts
console.log(res.reasonPhrase)
// 输出: "OK"
```

***

## 方法

### `headers(): Record<string, string>`

返回响应头的键值对对象。

**示例：**

```ts
const res = HttpResponse.ok(HttpResponseBody.text("hello"))
console.log(res.headers())
```

***

### `static ok(body: HttpResponseBody): HttpResponse`

创建一个状态码为 `200 OK` 的响应。

**参数：**

| 参数名    | 类型                 | 说明                                                        |
| ------ | ------------------ | --------------------------------------------------------- |
| `body` | `HttpResponseBody` | 响应体对象，可通过 `HttpResponseBody.text()`、`data()`、`html()` 创建。 |

**示例：**

```ts
return HttpResponse.ok(HttpResponseBody.text("Hello, world!"))
```

***

### `static created(): HttpResponse`

返回 `201 Created` 响应，表示资源已成功创建。

**示例：**

```ts
return HttpResponse.created()
```

***

### `static accepted(): HttpResponse`

返回 `202 Accepted` 响应，表示请求已被接受但尚未处理完成。

**示例：**

```ts
return HttpResponse.accepted()
```

***

### `static movedPermanently(url: string): HttpResponse`

返回 `301 Moved Permanently` 响应，用于永久重定向。

**参数：**

| 参数名   | 类型       | 说明         |
| ----- | -------- | ---------- |
| `url` | `string` | 重定向目标 URL。 |

**示例：**

```ts
return HttpResponse.movedPermanently("https://example.com/new-page")
```

***

### `static movedTemporarily(url: string): HttpResponse`

返回 `302 Moved Temporarily` 响应，用于临时重定向。

**参数：**

| 参数名   | 类型       | 说明         |
| ----- | -------- | ---------- |
| `url` | `string` | 重定向目标 URL。 |

**示例：**

```ts
return HttpResponse.movedTemporarily("https://example.com/login")
```

***

### `static badRequest(body?: HttpResponseBody | null): HttpResponse`

返回 `400 Bad Request` 响应，表示请求格式错误或参数无效。

**参数：**

| 参数名    | 类型                  | 说明         |
| ------ | ------------------- | ---------- |
| `body` | `HttpResponseBody?` | 可选的错误消息内容。 |

**示例：**

```ts
return HttpResponse.badRequest(HttpResponseBody.text("Invalid parameters"))
```

***

### `static unauthorized(): HttpResponse`

返回 `401 Unauthorized` 响应，表示需要身份验证。

**示例：**

```ts
return HttpResponse.unauthorized()
```

***

### `static forbidden(): HttpResponse`

返回 `403 Forbidden` 响应，表示禁止访问。

**示例：**

```ts
return HttpResponse.forbidden()
```

***

### `static notFound(): HttpResponse`

返回 `404 Not Found` 响应，表示请求的资源不存在。

**示例：**

```ts
return HttpResponse.notFound()
```

***

### `static notAcceptable(): HttpResponse`

返回 `406 Not Acceptable` 响应，表示请求的内容类型不被支持。

**示例：**

```ts
return HttpResponse.notAcceptable()
```

***

### `static tooManyRequests(): HttpResponse`

返回 `429 Too Many Requests` 响应，表示请求过于频繁。

**示例：**

```ts
return HttpResponse.tooManyRequests()
```

***

### `static internalServerError(): HttpResponse`

返回 `500 Internal Server Error` 响应，表示服务器内部错误。

**示例：**

```ts
return HttpResponse.internalServerError()
```

***

### `static raw(statusCode: number, phrase: string, options?: { headers?: Record<string, string>; body?: Data | FileEntity } | null): HttpResponse`

创建一个自定义状态码与内容的原始响应。

**参数：**

| 参数名               | 类型                       | 说明                 |
| ----------------- | ------------------------ | ------------------ |
| `statusCode`      | `number`                 | HTTP 状态码。          |
| `phrase`          | `string`                 | 原因短语。              |
| `options.headers` | `Record<string, string>` | 自定义响应头。            |
| `options.body`    | `Data \| FileEntity`     | 响应体，可以是二进制数据或文件对象。 |

**示例：**

```ts
const file = FileEntity.openForReading(Path.join(Script.directory, "image.png"))
return HttpResponse.raw(200, "OK", {
  headers: { "Content-Type": "image/png" },
  body: file
})
```

***

## 与 HttpResponseBody 搭配使用

### `HttpResponseBody.text(text: string)`

返回文本响应体。

```ts
HttpResponse.ok(HttpResponseBody.text("Hello, world"))
```

### `HttpResponseBody.html(html: string)`

返回 HTML 响应体。

```ts
HttpResponse.ok(HttpResponseBody.html("<h1>Welcome</h1>"))
```

### `HttpResponseBody.data(data: Data)`

返回二进制响应体。

```ts
const data = Data.fromRawString("Binary content", "utf-8")
HttpResponse.ok(HttpResponseBody.data(data))
```

***

## 综合示例

### 1. 返回 JSON 响应

```ts
server.registerHandler("/user", (req) => {
  const json = JSON.stringify({ name: "Alice", age: 25 })
  const data = Data.fromRawString(json, "utf-8")
  return HttpResponse.ok(HttpResponseBody.data(data))
})
```

### 2. 返回文件下载

```ts
server.registerHandler("/download", (req) => {
  const file = FileEntity.openForReading(Path.join(Script.directory, "example.zip"))
  return HttpResponse.raw(200, "OK", {
    headers: { "Content-Type": "application/zip" },
    body: file
  })
})
```

### 3. 处理错误响应

```ts
server.registerHandler("/api", (req) => {
  if (req.method !== "POST") {
    return HttpResponse.badRequest(HttpResponseBody.text("POST method required"))
  }
  return HttpResponse.ok(HttpResponseBody.text("Success"))
})
```



---
url: /zh/guide/Utilities/HttpServer/HttpResponseBody.md
---

# HttpResponseBody（HTTP 响应体）

`HttpResponseBody` 类用于构造 HTTP 响应的主体内容。
它可以表示文本内容、HTML 页面、二进制数据或任意自定义数据类型，并与 `HttpResponse` 一起使用，用于向客户端返回响应内容。

***

## 概述

在使用 `HttpServer` 创建自定义 HTTP 服务时，响应主体 (`HttpResponseBody`) 决定了客户端实际接收到的数据内容。
该类提供多种静态工厂方法用于快速生成不同类型的响应内容：

- 文本（`text`）
- HTML（`html`、`htmlBody`）
- 二进制数据（`data`）

***

## 常见用途

- 返回纯文本响应（例如 API 消息）
- 返回 HTML 页面（例如浏览器展示）
- 返回文件或二进制流（例如图片、视频、压缩包）

***

## 静态方法

### `static text(text: string): HttpResponseBody`

创建一个文本类型的响应体。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `text` | `string` | 要返回的文本内容。 |

**示例：**

```ts
const body = HttpResponseBody.text("Hello, world")
return HttpResponse.ok(body)
```

返回结果：

```
HTTP/1.1 200 OK
Content-Type: text/plain

Hello, world
```

***

### `static data(data: Data): HttpResponseBody`

创建一个包含二进制数据的响应体。

**参数：**

| 参数名    | 类型     | 说明           |
| ------ | ------ | ------------ |
| `data` | `Data` | 要返回的二进制数据对象。 |

**示例：**

```ts
const content = Data.fromRawString("Binary content", "utf-8")
return HttpResponse.ok(HttpResponseBody.data(content))
```

此方法常用于返回文件下载、图片或 JSON 数据。

***

### `static html(html: string): HttpResponseBody`

创建一个 HTML 响应体（标准 HTML 文档）。

**参数：**

| 参数名    | 类型       | 说明         |
| ------ | -------- | ---------- |
| `html` | `string` | HTML 文本内容。 |

**示例：**

```ts
const html = `
<html>
  <head><title>Hello</title></head>
  <body><h1>Welcome to Scripting Server</h1></body>
</html>
`
return HttpResponse.ok(HttpResponseBody.html(html))
```

浏览器访问时将直接渲染为网页内容。

***

### `static htmlBody(html: string): HttpResponseBody`

创建一个仅包含 HTML “主体内容”的响应体。
与 `html()` 类似，但在部分实现中可能省略标准 HTML 文档结构（`<html>`、`<body>` 等标签）。
常用于模板渲染或嵌入式 HTML 内容返回。

**参数：**

| 参数名    | 类型       | 说明            |
| ------ | -------- | ------------- |
| `html` | `string` | HTML 片段或主体内容。 |

**示例：**

```ts
return HttpResponse.ok(HttpResponseBody.htmlBody("<h1>Inline HTML Body</h1>"))
```

***

## 使用场景示例

### 1. 返回纯文本响应

```ts
server.registerHandler("/hello", (req) => {
  return HttpResponse.ok(HttpResponseBody.text("Hello from server"))
})
```

### 2. 返回 HTML 页面

```ts
server.registerHandler("/", (req) => {
  const html = `
  <html>
    <head><title>Home</title></head>
    <body>
      <h1>Welcome</h1>
      <p>This is a simple Scripting HTTP server.</p>
    </body>
  </html>`
  return HttpResponse.ok(HttpResponseBody.html(html))
})
```

### 3. 返回二进制文件（如图片）

```ts
server.registerHandler("/image", (req) => {
  const fileData = FileManager.readAsData(Path.join(Script.directory, "logo.png"))
  return HttpResponse.ok(HttpResponseBody.data(fileData))
})
```

### 4. 返回局部 HTML 内容（用于嵌入）

```ts
server.registerHandler("/partial", (req) => {
  return HttpResponse.ok(HttpResponseBody.htmlBody("<div>Partial Content</div>"))
})
```

***

## 总结

| 方法           | 说明           | 典型用途         |
| ------------ | ------------ | ------------ |
| `text()`     | 返回纯文本内容      | API 响应、日志输出  |
| `data()`     | 返回二进制数据      | 文件下载、JSON、图片 |
| `html()`     | 返回完整 HTML 页面 | 网页展示         |
| `htmlBody()` | 返回 HTML 片段   | 模板渲染或局部更新    |



---
url: /zh/guide/Utilities/HttpServer/HttpServer.md
---

# HttpServer（HTTP 服务器）

`HttpServer` 类提供了在本地或局域网中启动一个轻量级 HTTP 服务器的能力，可用于处理 HTTP 请求、静态文件服务、WebSocket 通信等场景。该类在脚本中常用于本地 Web 调试、远程控制、设备通信等。

***

## 概述

`HttpServer` 支持以下功能：

- 处理自定义路径的 HTTP 请求。
- 提供静态文件或目录的访问。
- 注册 WebSocket 服务端，实现实时通信。
- 支持 IPv4 与 IPv6 地址。
- 可选择端口号（支持随机端口）。
- 支持服务器状态查询。

***

## 属性

### `state: HttpServerState`

服务器当前状态。
可能值包括：

| 状态           | 说明       |
| ------------ | -------- |
| `"starting"` | 正在启动服务器。 |
| `"running"`  | 服务器运行中。  |
| `"stopping"` | 正在停止服务器。 |
| `"stopped"`  | 服务器已停止。  |

***

### `port: number | null`

服务器监听的端口号。
如果服务器未运行，则为 `null`。

***

### `isIPv4: boolean`

指示服务器是否在 IPv4 地址上监听。若为 `false`，则可能监听 IPv6 地址。

***

### `listenAddressIPv4: string | null`

IPv4 监听地址，仅当 `forceIPv4` 为 `true` 时使用。

***

### `listenAddressIPv6: string | null`

IPv6 监听地址，仅当 `forceIPv6` 为 `true` 时使用。

***

## 方法

### `registerHandler(path: string, handler: (request: HttpRequest) => HttpResponse): void`

为指定路径注册一个 HTTP 请求处理器。

**参数：**

| 参数        | 类型                                       | 说明                           |
| --------- | ---------------------------------------- | ---------------------------- |
| `path`    | `string`                                 | 请求路径（支持动态参数，例如 `/user/:id`）。 |
| `handler` | `(request: HttpRequest) => HttpResponse` | 处理函数，接收请求对象并返回响应对象。          |

**示例：**

```ts
const server = new HttpServer()

server.registerHandler("/hello", (req) => {
  return HttpResponse.ok(HttpResponseBody.text("Hello, world!"))
})
```

***

### `registerFile(path: string, filePath: string): void`

为指定路径注册一个静态文件响应。

**参数：**

| 参数         | 类型       | 说明        |
| ---------- | -------- | --------- |
| `path`     | `string` | 请求路径。     |
| `filePath` | `string` | 要响应的文件路径。 |

**示例：**

```ts
server.registerFile("/readme", Path.join(Script.directory, "README.md"))
```

当访问 `/readme` 时，服务器将返回该文件的内容。

***

### `registerFilesFromDirectory(path: string, directory: string, options?: { defaults?: string[] }): void`

注册指定目录下的所有文件，使其可通过 HTTP 访问。

**参数：**

| 参数                 | 类型         | 说明                                                             |
| ------------------ | ---------- | -------------------------------------------------------------- |
| `path`             | `string`   | 路径模板，例如 `/static/:file`。                                       |
| `directory`        | `string`   | 目录路径。                                                          |
| `options.defaults` | `string[]` | 默认文件名，若未指定文件则尝试加载此列表中的文件（默认：`["index.html", "default.html"]`）。 |

**示例：**

```ts
server.registerFilesFromDirectory("/static/:file", Path.join(Script.directory, "html"), {
  defaults: ["index.html", "index.htm"]
})
```

当访问 `/static/` 时，会返回该目录下的默认首页文件。

***

### `registerWebsocket(path: string, handlers: WebSocketHandlers): void`

注册 WebSocket 服务端处理程序，用于实时通信。

**参数：**

| 参数         | 类型                  | 说明                |
| ---------- | ------------------- | ----------------- |
| `path`     | `string`            | WebSocket 路径。     |
| `handlers` | `WebSocketHandlers` | WebSocket 事件处理函数。 |

**WebSocketHandlers 类型定义：**

```ts
interface WebSocketHandlers {
  onPong?: (session: WebSocketSession) => void
  onConnected?: (session: WebSocketSession) => void
  onDisconnected?: (session: WebSocketSession) => void
  handleText?: (session: WebSocketSession, text: string) => void
  handleBinary?: (session: WebSocketSession, data: Data) => void
}
```

**示例：**

```ts
const connectedSessions: WebSocketSession[] = []

server.registerWebsocket("/ws", {
  onConnected: (session) => {
    connectedSessions.push(session)
  },
  onDisconnected: (session) => {
    connectedSessions.splice(connectedSessions.indexOf(session), 1)
  },
  handleText: (session, text) => {
    session.writeText("Echo: " + text)
  }
})
```

***

### `start(options?: { port?: number; forceIPv4?: boolean }): string | null`

启动服务器。

**参数：**

| 参数                  | 类型        | 说明                                    |
| ------------------- | --------- | ------------------------------------- |
| `options.port`      | `number`  | 指定监听端口，默认为 `8080`。如果设为 `0`，则自动选择可用端口。 |
| `options.forceIPv4` | `boolean` | 是否强制使用 IPv4 地址，默认 `false`。            |

**返回值：**

- 若启动失败，返回错误消息字符串。
- 若成功，返回 `null`。

**示例：**

```ts
const error = server.start({ port: 8080 })
if (error) {
  console.error("启动失败:", error)
} else {
  console.log("服务器运行在端口:", server.port)
}
```

***

### `stop(): void`

停止服务器并释放资源。

**示例：**

```ts
server.stop()
console.log("服务器已停止")
```

***

## 类型定义

### `HttpServerState`

```ts
type HttpServerState = "starting" | "running" | "stopping" | "stopped"
```

### `WebSocketSession`

表示一个 WebSocket 连接。

**常用方法：**

| 方法                        | 说明       |
| ------------------------- | -------- |
| `writeText(text: string)` | 发送文本消息。  |
| `writeData(data: Data)`   | 发送二进制消息。 |
| `close()`                 | 关闭连接。    |

***

## 综合示例

以下示例展示了一个完整的 HTTP 与 WebSocket 服务器：

```ts
const server = new HttpServer()

// 注册简单的 HTTP 处理
server.registerHandler("/api/hello", (req) => {
  return HttpResponse.ok(HttpResponseBody.text("Hello from Scripting Server"))
})

// 注册静态目录
server.registerFilesFromDirectory("/public/:file", Path.join(Script.directory, "html"))

// 注册 WebSocket 服务
server.registerWebsocket("/chat", {
  onConnected: (session) => {
    console.log("新连接")
    session.writeText("欢迎加入聊天")
  },
  handleText: (session, text) => {
    console.log("收到:", text)
    session.writeText("你说: " + text)
  }
})

// 启动服务器
const error = server.start({ port: 8080 })
if (error) {
  console.error("启动失败:", error)
} else {
  console.log("HTTP服务器已启动，端口:", server.port)
}
```



---
url: /zh/guide/Utilities/HttpServer/WebSocketSession.md
---

# WebSocketSession（WebSocket 会话）

`WebSocketSession` 类表示一个已建立的 WebSocket 连接会话。
它由服务器端的 `HttpServer.registerWebsocket()` 注册的处理函数自动创建，用于与客户端进行双向实时通信。

***

## 概述

通过 `WebSocketSession`，你可以：

- 接收客户端发送的文本或二进制数据；
- 向客户端发送消息（文本或二进制）；
- 处理连接的建立与断开事件；
- 关闭连接会话。

`WebSocketSession` 通常由 WebSocket 事件回调函数接收，如 `onConnected`、`handleText`、`handleBinary` 等。

***

## 使用场景

- 构建实时聊天、协作或通知系统；
- 实现实时状态同步或设备控制；
- 处理自定义协议的二进制数据通信；
- 构建本地 WebSocket 服务，与其他设备或网页通信。

***

## 方法

### `writeText(text: string): void`

向客户端发送一条文本消息。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `text` | `string` | 要发送的文本内容。 |

**示例：**

```ts
server.registerWebsocket("/chat", {
  onConnected: (session) => {
    session.writeText("Welcome to the chat room!")
  },
  handleText: (session, text) => {
    console.log("Client says:", text)
    session.writeText("You said: " + text)
  }
})
```

***

### `writeData(data: Data): void`

向客户端发送一条二进制消息。

**参数：**

| 参数名    | 类型     | 说明           |
| ------ | ------ | ------------ |
| `data` | `Data` | 要发送的二进制数据对象。 |

**示例：**

```ts
server.registerWebsocket("/binary", {
  onConnected: (session) => {
    const msg = Data.fromRawString("Binary hello", "utf-8")
    session.writeData(msg)
  }
})
```

***

### `close(): void`

关闭当前 WebSocket 会话连接。

调用后，连接会断开，且不再触发任何接收事件。

**示例：**

```ts
server.registerWebsocket("/ws", {
  handleText: (session, text) => {
    if (text === "bye") {
      session.writeText("Goodbye!")
      session.close()
    }
  }
})
```

***

## 与 HttpServer.registerWebsocket() 的配合使用

`WebSocketSession` 实例通过 `registerWebsocket()` 注册的事件回调函数获得。

### 注册示例

```ts
const connectedSessions: WebSocketSession[] = []

server.registerWebsocket("/ws", {
  onConnected: (session) => {
    connectedSessions.push(session)
    console.log("Client connected")
    session.writeText("Connection established!")
  },
  handleText: (session, text) => {
    console.log("Received:", text)
    // 广播消息给所有连接的客户端
    for (const s of connectedSessions) {
      s.writeText("Broadcast: " + text)
    }
  },
  handleBinary: (session, data) => {
    console.log("Received binary data:", data.length)
  },
  onDisconnected: (session) => {
    const index = connectedSessions.indexOf(session)
    if (index !== -1) connectedSessions.splice(index, 1)
    console.log("Client disconnected")
  }
})
```

***

## 常用事件回调（由 HttpServer 提供）

| 回调函数             | 触发时机                | 参数                                          | 说明          |
| ---------------- | ------------------- | ------------------------------------------- | ----------- |
| `onConnected`    | 客户端成功建立连接时          | `(session: WebSocketSession)`               | 创建新的会话对象。   |
| `onDisconnected` | 客户端断开连接时            | `(session: WebSocketSession)`               | 会话结束。       |
| `onPong`         | 收到客户端 Ping/Pong 响应时 | `(session: WebSocketSession)`               | 用于检测连接健康状态。 |
| `handleText`     | 收到文本消息时             | `(session: WebSocketSession, text: string)` | 处理文本通信。     |
| `handleBinary`   | 收到二进制数据时            | `(session: WebSocketSession, data: Data)`   | 处理二进制通信。    |

***

## 示例：构建简单的实时聊天室

```ts
const sessions: WebSocketSession[] = []

server.registerWebsocket("/chat", {
  onConnected: (session) => {
    sessions.push(session)
    session.writeText("Welcome! There are " + sessions.length + " users online.")
  },
  handleText: (session, text) => {
    for (const s of sessions) {
      s.writeText(text) // 广播消息
    }
  },
  onDisconnected: (session) => {
    const index = sessions.indexOf(session)
    if (index !== -1) sessions.splice(index, 1)
  }
})
```

客户端通过 JavaScript 连接：

```js
const ws = new WebSocket("ws://localhost:8080/chat")
ws.onmessage = e => console.log("Server:", e.data)
ws.send("Hello everyone!")
```

***

## 类型定义

```ts
class WebSocketSession {
  writeText(text: string): void
  writeData(data: Data): void
  close(): void
}
```

***

## 总结

| 方法            | 说明         | 使用场景          |
| ------------- | ---------- | ------------- |
| `writeText()` | 向客户端发送文本消息 | 聊天、通知、状态同步    |
| `writeData()` | 发送二进制数据    | 文件传输、实时流、设备数据 |
| `close()`     | 关闭连接       | 主动断开连接或清理资源   |



---
url: /zh/guide/Utilities/ItemProvider.md
---

# ItemProvider

`ItemProvider` 用于表示一个**可按需加载的数据提供者**，常见于拖放、文件导入、Photos 选择等场景。
它并不直接包含数据本身，而是描述**可以如何、安全地获取数据**。

`ItemProvider` 支持加载对象、文本、URL、原始数据以及文件路径，并对文件访问施加了明确的安全访问边界。

***

## 核心概念

- `ItemProvider` 描述的是能力，而不是数据
- 所有加载行为都必须遵循系统的安全作用域规则
- 文件类资源只能在受控的回调作用域内访问
- 是否支持原地访问（in-place）由底层系统决定

***

## 属性

### registeredTypes

```ts
readonly registeredTypes: UTType[]
```

表示该 `ItemProvider` 在语义上可以提供的所有类型。

- 包含直接类型以及可推导的父类型
- 用于判断内容大类或调试用途
- 不保证一定存在对应的底层文件表示

***

### registeredInPlaceTypes

```ts
readonly registeredInPlaceTypes: UTType[]
```

表示该 `ItemProvider` 支持原地访问（open-in-place）的类型集合。

- 常见于视频、音频、文档等大文件
- 是否真正原地访问需以加载结果为准

***

## 能力判断方法

### hasItemConforming

```ts
hasItemConforming(type: UTType): boolean
```

判断内容在语义上是否符合指定类型。

- 判断宽松
- 会考虑 UTType 的继承关系
- 适合用于业务分支判断

***

### hasRepresentationConforming

```ts
hasRepresentationConforming(type: UTType): boolean
```

判断是否存在一个真实的、可加载的底层表示符合指定类型。

- 判断严格
- 适合用于文件处理或精确格式要求的场景

***

### hasInPlaceRepresentationConforming

```ts
hasInPlaceRepresentationConforming(type: UTType): boolean
```

判断是否存在支持原地访问的底层表示。

- 常用于大文件加载策略选择

***

## 对象加载能力判断

### canLoadUIImage

```ts
canLoadUIImage(): boolean
```

判断是否可以加载为 `UIImage` 对象。

- 适合 UI 展示
- 不保证原始文件格式或元数据

***

### canLoadLivePhoto

```ts
canLoadLivePhoto(): boolean
```

判断是否可以加载为 `LivePhoto` 对象。

- 用于区分静态图片与 Live Photo
- 返回 `true` 时可调用 `loadLivePhoto`

***

## 加载方法

### loadUIImage

```ts
loadUIImage(): Promise<UIImage | null>
```

加载一个 `UIImage` 对象。

- 适合轻量展示
- 不适合用于文件级处理或资源保真

***

### loadLivePhoto

```ts
loadLivePhoto(): Promise<LivePhoto | null>
```

加载一个 `LivePhoto` 对象。

- 包含图片与配对视频
- 适合展示、保存或进一步处理

***

### loadURL

```ts
loadURL(): Promise<string | null>
```

加载一个 URL 字符串。

- 可能是网页 URL
- 也可能是文件 URL

***

### loadText

```ts
loadText(): Promise<string | null>
```

加载纯文本内容。

- 支持 plain text
- 富文本会被降级为纯文本

***

### loadData

```ts
loadData(type: UTType): Promise<Data | null>
```

加载指定类型的原始二进制数据。

- 数据会整体加载进内存
- 适合 JSON、配置文件、小体积资源
- 不适合视频、音频等大文件

***

## 文件路径加载（安全作用域）

文件路径的加载需要遵循系统的安全限制，所有文件访问都必须在指定的回调作用域内完成。

***

### loadFilePath

```ts
loadFilePath(type: UTType): Promise<string | null>
```

加载指定类型的文件路径，如果文件不存在或无法加载，返回 `null`。如果可以加载，文件会被复制到应用组的临时目录中，并返回文件路径。
如果你不再需要文件，请删除它。

示例：

```ts
const filePath = provider.loadFilePath("public.movie")
```

***

## 创建 ItemProvider

### fromUIImage

```ts
ItemProvider.fromUIImage(image: UIImage): ItemProvider
```

从 `UIImage` 创建 `ItemProvider`。

- 仅提供静态图片能力
- 不包含 Live Photo 或原始资源信息

***

### fromText

```ts
ItemProvider.fromText(text: string): ItemProvider
```

从文本创建 `ItemProvider`。

***

### fromURL

```ts
ItemProvider.fromURL(url: string): ItemProvider | null
```

从 URL 字符串创建 `ItemProvider`。

- URL 不合法时返回 `null`
- 支持网页 URL 与文件 URL

***

### fromFilePath

```ts
ItemProvider.fromFilePath(path: string): ItemProvider
```

从文件路径创建 `ItemProvider`。

- 保留原始文件
- 适合视频、音频、文档等资源
- 支持原地访问能力判断

***

## 使用建议

- 使用 `hasItemConforming` 进行内容类型判断
- 使用对象加载方法进行 UI 展示
- 使用文件路径加载方法处理大文件
- 文件路径只能在 `perform` 回调作用域内访问
- 不应在回调外部延迟访问安全作用域文件



---
url: /zh/guide/Utilities/OAuth2.md
---

# OAuth2

`OAuth2` 类用于在脚本中实现 OAuth 2.0 授权流程。它支持标准的授权码流程、PKCE（Proof Key for Code Exchange）、访问令牌续期及多种配置选项。

***

## 构造函数

```ts
new OAuth2(options: {
  consumerKey: string
  consumerSecret: string
  authorizeUrl: string
  accessTokenUrl?: string
  responseType: string
  contentType?: string
})
```

### 参数说明

| 参数名            | 类型     | 是否必填 | 说明                                                       |
| -------------- | ------ | ---- | -------------------------------------------------------- |
| consumerKey    | string | 是    | 应用的客户端 ID（Client ID）或 Consumer Key。                      |
| consumerSecret | string | 是    | 应用的客户端密钥（Client Secret）。                                 |
| authorizeUrl   | string | 是    | 用于跳转用户授权的地址。                                             |
| accessTokenUrl | string | 否    | 获取访问令牌（Access Token）的地址，若不提供则使用 authorizeUrl。            |
| responseType   | string | 是    | 一般为 `"code"`，表示使用授权码流程。                                  |
| contentType    | string | 否    | 请求令牌时使用的内容类型，默认值为 `"application/x-www-form-urlencoded"`。 |

### 抛出错误

- 当配置参数无效或实例化失败时抛出错误。

***

## 属性

### `accessTokenBasicAuthentification: boolean`

是否使用 Basic 认证方式发送获取访问令牌的请求。默认值为 `false`。

***

### `allowMissingStateCheck: boolean`

是否禁用 `state` 参数校验（CSRF 保护）。**谨慎使用**，默认值为 `false`。

***

### `encodeCallbackURL: boolean`

是否对回调地址进行 URL 编码。某些服务商要求必须编码。默认值为 `true`。

***

### `encodeCallbackURLQuery: boolean`

是否对整个回调地址的查询参数进行编码。部分服务如 Imgur 要求此值为 `false`。默认值为 `true`。

***

## 方法

### `authorize(options): Promise<OAuthCredential>`

发起 OAuth2 授权流程。将打开一个浏览器窗口，供用户登录并授权。

```ts
authorize(options: {
  callbackURL?: string
  scope: string
  state: string
  parameters?: Record<string, any>
  headers?: Record<string, string>
} & ({
  codeVerifier: string
  codeChallenge: string
  codeChallengeMethod: string
} | {
  codeVerifier?: never
  codeChallenge?: never
  codeChallengeMethod?: never
})): Promise<OAuthCredential>
```

#### 参数说明

| 参数名                 | 类型                      | 是否必填 | 说明                                                |
| ------------------- | ----------------------- | ---- | ------------------------------------------------- |
| callbackURL         | string                  | 否    | 授权成功后的回调地址，默认为 `scripting://oauth_callback/脚本名称`。 |
| scope               | string                  | 是    | 空格分隔的权限列表。                                        |
| state               | string                  | 是    | 防止 CSRF 攻击的随机字符串。                                 |
| parameters          | Record\<string, any>    | 否    | 附加的授权请求参数。                                        |
| headers             | Record\<string, string> | 否    | 附加的请求头。                                           |
| codeVerifier        | string                  | 条件必填 | PKCE 流程中使用的随机码。                                   |
| codeChallenge       | string                  | 条件必填 | 由 `codeVerifier` 生成的哈希值。                          |
| codeChallengeMethod | `"plain"` \| `"S256"`   | 条件必填 | PKCE 中的 challenge 加密方法，默认使用 `"S256"`。             |

#### 返回值

- 返回一个包含授权结果的 `OAuthCredential` 对象。

#### 抛出错误

- 若用户拒绝授权或网络错误将抛出异常。

#### 示例

```ts
const oauth = new OAuth2({
  consumerKey: '你的客户端ID',
  consumerSecret: '你的客户端密钥',
  authorizeUrl: 'https://provider.com/oauth/authorize',
  accessTokenUrl: 'https://provider.com/oauth/token',
  responseType: 'code'
})

const credential = await oauth.authorize({
  scope: 'profile email',
  state: 'secure_random_state',
  callbackURL: Script.createOAuthCallbackURLScheme('my_oauth_script')
})

console.log(credential.oauthToken)
```

***

### `renewAccessToken(options): Promise<OAuthCredential>`

使用刷新令牌（refresh token）重新获取访问令牌。

```ts
renewAccessToken(options: {
  refreshToken: string
  parameters?: Record<string, any>
  headers?: Record<string, string>
}): Promise<OAuthCredential>
```

#### 参数说明

| 参数名          | 类型                      | 是否必填 | 说明             |
| ------------ | ----------------------- | ---- | -------------- |
| refreshToken | string                  | 是    | 上一次授权返回的刷新令牌。  |
| parameters   | Record\<string, any>    | 否    | 额外的 POST 请求参数。 |
| headers      | Record\<string, string> | 否    | 自定义请求头。        |

#### 返回值

- 返回新的 `OAuthCredential` 对象。

#### 抛出错误

- 若刷新失败（如刷新令牌已过期），则抛出错误。

#### 示例

```ts
const newCredential = await oauth.renewAccessToken({
  refreshToken: oldCredential.oauthRefreshToken
})

console.log(newCredential.oauthToken)
```

***

## OAuthCredential 类型定义

授权成功后返回的凭证对象包含以下字段：

```ts
type OAuthCredential = {
  oauthToken: string
  oauthTokenSecret: string
  oauthRefreshToken: string
  oauthTokenExpiresAt: number | null
  oauthVerifier: string
  version: string
  signatureMethod: string
}
```

### 字段说明

| 字段名                 | 类型             | 说明                                       |
| ------------------- | -------------- | ---------------------------------------- |
| oauthToken          | string         | 用于访问资源的 Access Token。                    |
| oauthTokenSecret    | string         | 与访问令牌配套使用的 Token Secret，常用于 OAuth1.0 流程。 |
| oauthRefreshToken   | string         | 用于获取新访问令牌的 Refresh Token。                |
| oauthTokenExpiresAt | number \| null | 访问令牌的过期时间（Unix 毫秒时间戳），若无过期则为 `null`。     |
| oauthVerifier       | string         | 在 PKCE 流程中使用的授权码验证器。                     |
| version             | string         | OAuth 协议版本（例如 `"2.0"`）。                  |
| signatureMethod     | string         | 请求签名方式（如 `"HMAC-SHA1"`、`"PLAINTEXT"`）。   |

***

## 使用建议

- 始终使用 `state` 参数防止 CSRF 攻击，除非明确关闭。
- 使用 `Script.createOAuthCallbackURLScheme(name)` 为脚本生成唯一回调地址。
- 若需要长期授权，请妥善保存 `oauthRefreshToken`。
- 对于公用客户端建议启用 PKCE 增强安全性。



---
url: /zh/guide/Utilities/Path.md
---

# 文件路径工具

`Path` API 提供了一些实用函数，用于处理和转换文件与目录路径。它受到 Node.js 的 `path` 模块启发，提供了开发者熟悉的方法来高效地处理路径。

***

## 概述

`Path` API 提供以下功能：

- 规范化路径。
- 判断路径是否为绝对路径。
- 拼接路径段。
- 提取路径组件，例如目录名、基本名和扩展名。
- 将路径解析为结构化对象。

它通过使用当前操作系统适合的路径分隔符，简化了跨平台的路径处理。

***

### 静态方法

#### `Path.normalize(path: string): string`

通过解析 `..` 和 `.` 段，规范化给定的路径。

- **参数：**
  - `path`：要规范化的输入路径。
- **返回值：**
  - 一个规范化的路径字符串。

#### 示例：

```typescript
const normalizedPath = Path.normalize('/foo/bar//baz/asdf/quux/..')
console.log(normalizedPath) // '/foo/bar/baz/asdf'
```

***

#### `Path.isAbsolute(path: string): boolean`

判断给定路径是否为绝对路径。

- **参数：**
  - `path`：输入路径。
- **返回值：**
  - 如果路径是绝对路径，则返回 `true`，否则返回 `false`。

#### 示例：

```typescript
console.log(Path.isAbsolute('/foo/bar')) // true
console.log(Path.isAbsolute('foo/bar'))  // false
```

***

#### `Path.join(...args: string[]): string`

将多个路径段拼接为一个路径，并进行规范化。

- **参数：**
  - `...args`：要拼接的路径段。
- **返回值：**
  - 一个规范化的路径字符串。

#### 示例：

```typescript
const joinedPath = Path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
console.log(joinedPath) // '/foo/bar/baz/asdf'
```

***

#### `Path.dirname(path: string): string`

返回路径的目录名。

- **参数：**
  - `path`：输入路径。
- **返回值：**
  - 目录名。

#### 示例：

```typescript
console.log(Path.dirname('/foo/bar/baz/asdf/quux')) // '/foo/bar/baz/asdf'
```

***

#### `Path.basename(path: string, ext?: string): string`

返回路径的最后一部分，类似于 Unix 的 `basename` 命令。可选地移除文件扩展名。

- **参数：**
  - `path`：输入路径。
  - `ext`（可选）：要移除的文件扩展名。
- **返回值：**
  - 路径的基本名。

#### 示例：

```typescript
console.log(Path.basename('/foo/bar/baz/asdf/quux.html')) // 'quux.html'
console.log(Path.basename('/foo/bar/baz/asdf/quux.html', '.html')) // 'quux'
```

***

#### `Path.extname(path: string): string`

返回路径的扩展名。

- **参数：**
  - `path`：输入路径。
- **返回值：**
  - 文件扩展名；如果没有扩展名，则返回空字符串。

#### 示例：

```typescript
console.log(Path.extname('/foo/bar/baz/asdf/quux.html')) // '.html'
console.log(Path.extname('/foo/bar/baz/asdf/quux'))     // ''
```

***

#### `Path.parse(path: string): { root: string; dir: string; base: string; ext: string; name: string; }`

将路径解析为包含以下属性的对象：

- `root`：路径的根目录。

- `dir`：目录名。

- `base`：包含扩展名的文件名。

- `ext`：文件扩展名。

- `name`：不带扩展名的文件名。

- **参数：**
  - `path`：输入路径。

- **返回值：**
  - 一个包含解析路径属性的对象。

#### 示例：

```typescript
const parsed = Path.parse('/foo/bar/baz/asdf/quux.html')
console.log(parsed)
// {
//   root: '/',
//   dir: '/foo/bar/baz/asdf',
//   base: 'quux.html',
//   ext: '.html',
//   name: 'quux'
// }
```

***

## 常见用例

### 规范化路径

```typescript
const normalizedPath = Path.normalize('./foo/bar/../baz')
console.log(normalizedPath) // './foo/baz'
```

### 检查路径是否为绝对路径

```typescript
console.log(Path.isAbsolute('/absolute/path')) // true
console.log(Path.isAbsolute('relative/path'))  // false
```

### 拼接多个路径段

```typescript
const fullPath = Path.join('/home', 'user', 'documents', 'file.txt')
console.log(fullPath) // '/home/user/documents/file.txt'
```

### 提取文件名和扩展名

```typescript
const fileName = Path.basename('/path/to/file.txt')
const fileExt = Path.extname('/path/to/file.txt')
console.log(fileName) // 'file.txt'
console.log(fileExt)  // '.txt'
```

### 解析路径

```typescript
const pathDetails = Path.parse('/path/to/file.txt')
console.log(pathDetails)
// {
//   root: '/',
//   dir: '/path/to',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file'
// }
```

***

## 最佳实践

1. **使用规范化功能：** 始终规范化路径以确保跨平台的一致性。
2. **避免硬编码分隔符：** 使用类似 `join` 的方法代替直接拼接字符串 `/` 或 `\\`。

***

## 完整示例

```typescript
import { Path } from 'scripting'

function main() {
  const filePath = '/foo/bar/baz/asdf/quux.html'

  console.log("规范化路径:", Path.normalize(filePath))
  console.log("是否为绝对路径:", Path.isAbsolute(filePath))
  console.log("目录名:", Path.dirname(filePath))
  console.log("基本名:", Path.basename(filePath))
  console.log("扩展名:", Path.extname(filePath))

  const parsedPath = Path.parse(filePath)
  console.log("解析路径:", parsedPath)

  const joinedPath = Path.join('/foo', 'bar', 'baz')
  console.log("拼接路径:", joinedPath)
}

main()
```



---
url: /zh/guide/Utilities/Request/FormData.md
---

# 表单数据

`FormData` 类用于构造表单数据（`multipart/form-data`），以便在网络请求中上传文本字段或文件数据。
它的行为与浏览器中的 **Fetch API FormData** 基本一致，但在 **Scripting app** 中进行了扩展以支持 `Data` 类型（原生二进制对象），从而更方便地上传文件或图片。

你可以将 `FormData` 对象直接作为 `fetch()` 请求的 `body` 参数使用。系统会自动生成带有正确边界的 `multipart/form-data` 请求体。

***

## 定义

```ts
class FormData {
  append(name: string, value: string): void
  append(name: string, value: Data, mimeType: string, filename?: string): void
  get(name: string): string | Data | null
  getAll(name: string): any[]
  has(name: string): boolean
  delete(name: string): void
  set(name: string, value: string): void
  set(name: string, value: Data, filename?: string): void
  forEach(callback: (value: any, name: string, parent: FormData) => void): void
  entries(): [string, any][]
  toJson(): Record<string, any>
}
```

***

## 主要用途

- 构造带文本与文件混合的表单请求
- 用于文件上传接口（如图片、音频、文档等）
- 代替 JSON 结构上传二进制文件或表单信息

***

## 方法说明

### `append(name: string, value: string): void`

### `append(name: string, value: Data, mimeType: string, filename?: string): void`

向表单中添加一个字段。
可以用于添加文本字段或文件数据。

#### 参数说明

| 参数           | 类型           | 说明                                            |                               |
| ------------ | ------------ | --------------------------------------------- | ----------------------------- |
| **name**     | `string`     | 字段名称。                                         |                               |
| **value**    | `string`     | `Data`                                        | 字段值，可以是字符串或 `Data` 对象（二进制文件）。 |
| **mimeType** | `string`     | 文件的 MIME 类型（如 `"image/png"`）。仅在传入 `Data` 时需要。 |                               |
| **filename** | `string`（可选） | 文件名，仅在上传文件时使用。                                |                               |

#### 示例

```tsx
const form = new FormData()
form.append("username", "Tom")
form.append("file", Data.fromFile("/path/to/image.png"), "image/png", "avatar.png")
```

***

### `set(name: string, value: string): void`

### `set(name: string, value: Data, filename?: string): void`

设置一个字段的值。
若该字段已存在，则会被覆盖。
与 `append()` 的区别是：`set()` 仅保留一个值，而 `append()` 可重复添加同名字段。

#### 示例

```tsx
const form = new FormData()
form.set("message", "Hello world")
form.set("file", Data.fromFile("/path/to/file.txt"), "text/plain", "note.txt")
```

***

### `get(name: string): string | Data | null`

获取指定字段的值。
如果字段不存在，则返回 `null`。

#### 示例

```tsx
const form = new FormData()
form.append("title", "My Post")
console.log(form.get("title")) // 输出: "My Post"
```

***

### `getAll(name: string): any[]`

获取同名字段的所有值（如果使用了多次 `append()`）。

#### 示例

```tsx
const form = new FormData()
form.append("tag", "swift")
form.append("tag", "ios")
form.append("tag", "scripting")

console.log(form.getAll("tag")) // ["swift", "ios", "scripting"]
```

***

### `has(name: string): boolean`

检查表单中是否存在指定名称的字段。

#### 示例

```tsx
const form = new FormData()
form.append("username", "Tom")

console.log(form.has("username")) // true
console.log(form.has("password")) // false
```

***

### `delete(name: string): void`

删除指定名称的字段及其所有值。

#### 示例

```tsx
const form = new FormData()
form.append("title", "Hello")
form.append("file", Data.fromFile("/path/to/file.txt"), "text/plain")

form.delete("file")
```

***

### `forEach(callback: (value: any, name: string, parent: FormData) => void): void`

遍历所有表单字段，执行回调函数。

#### 示例

```tsx
const form = new FormData()
form.append("user", "Tom")
form.append("age", "25")

form.forEach((value, name) => {
  console.log(`${name}: ${value}`)
})
```

***

### `entries(): [string, any][]`

返回一个由 `[name, value]` 组成的键值对数组。

#### 示例

```tsx
const form = new FormData()
form.append("username", "Tom")
form.append("age", "25")
console.log(form.entries())
// [["username", "Tom"], ["age", "25"]]
```

***

### `toJson(): Record<string, any>`

将表单数据转换为普通的 JavaScript 对象，用于调试或日志输出。
⚠️ 注意：如果表单中包含文件（`Data` 类型），此方法不会输出二进制内容，而是显示为占位符信息。

#### 示例

```tsx
const form = new FormData()
form.append("name", "Tom")
form.append("photo", Data.fromFile("/path/to/avatar.png"), "image/png", "avatar.png")

console.log(form.toJson())
// { name: "Tom", photo: "[Data: image/png]" }
```

***

## 使用示例

### 示例 1：上传文件

```tsx
const form = new FormData()
form.append("file", Data.fromFile("/path/to/image.png"), "image/png", "avatar.png")
form.append("userId", "1234")

const response = await fetch("https://api.example.com/upload", {
  method: "POST",
  body: form,
})

console.log(await response.json())
```

***

### 示例 2：同时上传多个文件

```tsx
const form = new FormData()
form.append("files", Data.fromFile("/path/to/photo1.jpg"), "image/jpeg", "photo1.jpg")
form.append("files", Data.fromFile("/path/to/photo2.jpg"), "image/jpeg", "photo2.jpg")

await fetch("https://api.example.com/multi-upload", {
  method: "POST",
  body: form,
})
```

***

### 示例 3：构造包含文本与文件的复合请求

```tsx
const form = new FormData()
form.append("title", "Travel Memories")
form.append("description", "A collection of my travel photos.")
form.append("cover", Data.fromFile("/path/to/cover.png"), "image/png", "cover.png")

const response = await fetch("https://example.com/uploadPost", {
  method: "POST",
  body: form,
})

console.log(await response.text())
```

***

### 示例 4：遍历并调试表单内容

```tsx
const form = new FormData()
form.append("name", "Alice")
form.append("file", Data.fromFile("/path/to/file.txt"), "text/plain", "file.txt")

form.forEach((value, name) => {
  console.log(`${name}:`, value instanceof Data ? "Binary Data" : value)
})
```

***

## 与其他类的关系

| 类名             | 说明                                                          |
| -------------- | ----------------------------------------------------------- |
| **`fetch()`**  | 可直接使用 `FormData` 实例作为请求体。系统会自动设置请求头为 `multipart/form-data`。 |
| **`Data`**     | 用于表示文件或图片等二进制内容，作为 `FormData` 字段值传入。                        |
| **`Request`**  | 可通过 `RequestInit.body` 设置 `FormData` 实例。                    |
| **`Response`** | 可使用 `response.formData()` 将响应解析为 `FormData`。                |

***

## 注意事项

- **自动设置 Content-Type**：使用 `FormData` 时，`fetch()` 会自动设置正确的 `Content-Type`（带边界）。不要手动覆盖。
- **同名字段**：支持使用 `append()` 为同一字段名添加多个值。
- **文件上传**：上传文件时需传入 MIME 类型，否则默认可能被识别为 `application/octet-stream`。
- **JSON 转换限制**：`toJson()` 仅用于调试显示，不适合用于真实数据传输。

***

## 小结

`FormData` 是 **Scripting 网络请求体系中用于构造 multipart/form-data 请求的核心类**，具备以下特性：

- 支持文本与文件混合上传
- 与 `fetch()` 无缝集成
- 支持 `Data` 类型文件传递
- 提供便利的 `forEach()`、`entries()`、`toJson()` 等辅助方法
- 完全兼容 Web 标准的 FormData 行为



---
url: /zh/guide/Utilities/Request/Headers.md
---

# 请求头（Headers）

`Headers` 类用于管理 HTTP 请求与响应的头部信息。
它与浏览器 Fetch API 中的同名类保持一致，但在 **Scripting** 环境中提供了更友好的接口方法和 JSON 化能力，以方便脚本中对网络请求进行调试与序列化。

`Headers` 对象可以在以下场景中使用：

- 构造请求时，通过 `RequestInit.headers` 设置请求头
- 从 `Response.headers` 中读取响应头
- 在脚本逻辑中动态添加、修改或删除头部字段

***

## 定义

```ts
class Headers {
  constructor(init?: HeadersInit)
  append(name: string, value: string): void
  get(name: string): string | null
  has(name: string): boolean
  set(name: string, value: string): void
  delete(name: string): void
  forEach(callback: (value: string, name: string) => void): void
  keys(): string[]
  values(): string[]
  entries(): [string, string][]
  toJson(): Record<string, string>
}
```

***

## HeadersInit 类型

`Headers` 的构造函数支持多种初始化格式：

```ts
type HeadersInit = [string, string][] | Record<string, string> | Headers
```

你可以使用以下任意形式创建头部对象：

```tsx
new Headers([["Content-Type", "application/json"]])
new Headers({ "Authorization": "Bearer token" })
new Headers(existingHeaders)
```

***

## 构造函数

### `new Headers(init?: HeadersInit)`

创建一个新的 `Headers` 对象。
可选参数 `init` 用于以已有的头部结构初始化实例。

#### 参数说明

| 参数       | 类型            | 说明                               |
| -------- | ------------- | -------------------------------- |
| **init** | `HeadersInit` | 初始头部数据，可为对象、数组或另一个 `Headers` 实例。 |

***

## 方法说明

### `append(name: string, value: string): void`

向头部中添加一个字段。如果该字段已存在，则追加新的值（不会覆盖旧值）。

#### 示例

```tsx
const headers = new Headers()
headers.append("Accept", "application/json")
headers.append("Accept", "text/plain") // 此时 Accept 拥有两个值
```

***

### `set(name: string, value: string): void`

设置一个头部字段。如果该字段已存在，则会覆盖旧值。

#### 示例

```tsx
const headers = new Headers()
headers.set("Content-Type", "application/json")
headers.set("Authorization", "Bearer token-123")
```

***

### `get(name: string): string | null`

获取指定头部字段的值。
若字段不存在，返回 `null`。

#### 示例

```tsx
const headers = new Headers({ "Content-Type": "application/json" })
console.log(headers.get("Content-Type")) // 输出: application/json
```

***

### `has(name: string): boolean`

判断指定字段是否存在。

#### 示例

```tsx
const headers = new Headers({ "Accept": "application/json" })
console.log(headers.has("Accept")) // true
console.log(headers.has("Authorization")) // false
```

***

### `delete(name: string): void`

删除指定的头部字段。

#### 示例

```tsx
const headers = new Headers({ "Accept": "application/json", "Cache-Control": "no-cache" })
headers.delete("Cache-Control")
```

***

### `forEach(callback: (value: string, name: string) => void): void`

遍历所有头部字段并执行回调。

#### 示例

```tsx
const headers = new Headers({
  "Accept": "application/json",
  "User-Agent": "ScriptingApp/1.0"
})

headers.forEach((value, name) => {
  console.log(`${name}: ${value}`)
})
```

***

### `keys(): string[]`

返回所有头部名称的数组。

```tsx
const headers = new Headers({ "Accept": "application/json", "User-Agent": "Scripting" })
console.log(headers.keys()) // ["accept", "user-agent"]
```

> 注意：头部字段名不区分大小写，返回的名称将被标准化为小写。

***

### `values(): string[]`

返回所有头部字段的值数组。

```tsx
const headers = new Headers({ "Accept": "application/json", "User-Agent": "Scripting" })
console.log(headers.values()) // ["application/json", "Scripting"]
```

***

### `entries(): [string, string][]`

以键值对数组形式返回所有头部字段。

#### 示例

```tsx
const headers = new Headers({ "Accept": "application/json", "Cache-Control": "no-cache" })
console.log(headers.entries())
// [["accept", "application/json"], ["cache-control", "no-cache"]]
```

***

### `toJson(): Record<string, string>`

将所有头部字段转换为普通对象格式，方便序列化或调试输出。

#### 示例

```tsx
const headers = new Headers({
  "Content-Type": "application/json",
  "Authorization": "Bearer token"
})

console.log(headers.toJson())
// { "content-type": "application/json", "authorization": "Bearer token" }
```

***

## 使用示例

### 示例 1：在请求中设置自定义 Headers

```tsx
const headers = new Headers()
headers.set("Content-Type", "application/json")
headers.set("Authorization", "Bearer token-xyz")

const response = await fetch("https://api.example.com/user", {
  method: "POST",
  headers,
  body: JSON.stringify({ name: "Tom" })
})
```

***

### 示例 2：读取响应头部信息

```tsx
const response = await fetch("https://example.com/data")
console.log("Content-Type:", response.headers.get("Content-Type"))
console.log("Server:", response.headers.get("Server"))
```

***

### 示例 3：转换为 JSON 用于日志或持久化

```tsx
const response = await fetch("https://example.com/api")
console.log("Response Headers:", response.headers.toJson())
```

***

### 示例 4：判断响应是否包含特定字段

```tsx
const response = await fetch("https://example.com/info")
if (response.headers.has("Set-Cookie")) {
  console.log("响应包含 Cookie 设置")
}
```

***

## 与其他类的关系

| 类名             | 说明                                               |
| -------------- | ------------------------------------------------ |
| **`Request`**  | 通过 `RequestInit.headers` 设置请求头。                  |
| **`Response`** | 可通过 `response.headers` 访问响应头。                    |
| **`fetch()`**  | 请求与响应过程都会使用 `Headers` 实例来封装头部数据。                 |
| **`Cookie`**   | 与 `Set-Cookie` 头对应的解析结果在 `response.cookies` 中访问。 |

***

## 注意事项

- **字段名大小写不敏感**：所有头部名称在内部会被标准化为小写形式。
- **多值字段处理**：使用 `append()` 方法可以为同一字段添加多个值，例如用于 `Accept` 或 `Cookie` 等字段。
- **安全性**：某些系统保留字段（如 `Host`、`Connection`）可能会被 iOS 网络层忽略或重写。
- **序列化输出**：使用 `toJson()` 可便于调试或日志记录，不影响实际请求头发送。

***

## 小结

`Headers` 是 **Scripting 网络请求体系** 中的基础组件之一，提供了灵活的接口来：

- 添加、修改或删除 HTTP 头部
- 以多种方式读取与遍历响应头
- 在脚本环境中实现与 Web 标准一致的行为
- 支持 JSON 化与日志输出



---
url: /zh/guide/Utilities/Request/ReadableStream.md
---

# 可读流

`ReadableStream` 表示一个 **可读的数据流（data stream）**，用于逐步读取数据而不是一次性加载全部内容。
在 **Scripting app** 中，`ReadableStream<Data>` 通常用于：

- 处理网络响应中的流式数据（如 `Response.body`）
- 实现大文件的分块读取或实时下载
- 支持长连接或持续推送的数据（如 SSE、分块 JSON、日志流）

与标准 Web API 一致，Scripting 的 `ReadableStream` 允许异步迭代（`for await...of`）以及通过读取器 (`ReadableStreamDefaultReader`) 手动读取流内容。

***

## 定义

```ts
class ReadableStream<T = any> {
  constructor(underlyingSource?: UnderlyingSource<T>)

  get locked(): boolean
  cancel(reason?: any): Promise<void>
  getReader(): ReadableStreamDefaultReader<T>
  tee(): [ReadableStream<T>, ReadableStream<T>]
}
```

***

## 基本概念

- `ReadableStream` 代表一个“流式可消费的数据源”。
- 它不会立即持有全部数据，而是按需从源（网络、文件、生成器等）获取。
- 每个流只能由一个读取器（reader）读取，一旦被锁定 (`locked = true`)，必须释放或取消后才能再次读取。

***

## 属性说明

### `locked: boolean`

指示当前流是否已被读取器（reader）锁定。
若为 `true`，则其他代码无法再调用 `getReader()` 或消费该流。

#### 示例

```tsx
const reader = response.body.getReader()
console.log(response.body.locked) // true
```

***

## 方法说明

### `getReader(): ReadableStreamDefaultReader<T>`

返回一个 `ReadableStreamDefaultReader` 实例，用于逐步读取流中的数据块（chunk）。
每次调用 `reader.read()` 会返回一个 Promise，解析为 `{ value, done }` 对象。

#### 示例

```tsx
const reader = response.body.getReader()

while (true) {
  const { done, value } = await reader.read()
  if (done) break
  console.log("Received chunk:", value)
}
```

***

### `cancel(reason?: any): Promise<void>`

取消流的读取操作。
传入的 `reason` 可用于描述取消原因。

#### 示例

```tsx
const reader = response.body.getReader()
await response.body.cancel("User aborted reading")
```

***

### `tee(): [ReadableStream<T>, ReadableStream<T>]`

将当前流复制成两个新的流。
每个分支都可独立消费数据，但需注意内存开销。

#### 示例

```tsx
const [stream1, stream2] = response.body.tee()

const reader1 = stream1.getReader()
const reader2 = stream2.getReader()
```

***

## ReadableStreamDefaultReader（读取器）

当通过 `getReader()` 获取读取器后，你可以手动控制数据的读取过程。

### 读取器定义

```ts
interface ReadableStreamDefaultReader<T> {
  read(): Promise<{ value: T; done: boolean }>
  releaseLock(): void
  cancel(reason?: any): Promise<void>
}
```

#### 方法说明：

| 方法                  | 说明                                                           |
| ------------------- | ------------------------------------------------------------ |
| **read()**          | 读取下一个数据块（chunk），返回 `{ value, done }`。当 `done = true` 时，流已结束。 |
| **releaseLock()**   | 释放读取器，使流可被其他消费者重新读取。                                         |
| **cancel(reason?)** | 取消流读取。                                                       |

#### 示例：读取响应流数据

```tsx
const reader = response.body.getReader()

while (true) {
  const { done, value } = await reader.read()
  if (done) break

  // 处理每个 Data 对象（chunk）
  const text = value.toRawString()
  console.log("Chunk:", text)
}

reader.releaseLock()
```

***

## 与 `Response` 的关系

`Response.body` 属性是一个 `ReadableStream<Data>`，可用于流式读取响应内容。

### 示例：实时处理网络响应

```tsx
const response = await fetch("https://example.com/stream")

const reader = response.body.getReader()
while (true) {
  const { done, value } = await reader.read()
  if (done) break
  console.log("Received:", value.toRawString())
}
```

这种方式可在 **响应尚未完全结束时** 实时处理部分数据，非常适合：

- 实时日志输出
- 大文件下载进度控制
- AI/LLM 流式生成内容（如 ChatGPT 的逐字输出）

***

## 与 `Data` 的关系

在 `Scripting` 中，流的每个块（chunk）通常是一个 `Data` 实例。
你可以使用 `Data` 提供的方法（如 `.toRawString()`、`.toUint8Array()`）读取或转换二进制内容。

#### 示例：将流数据保存到文件

```tsx
const reader = response.body.getReader()
const chunks: Data[] = []

while (true) {
  const { done, value } = await reader.read()
  if (done) break
  chunks.push(value)
}

const fileData = Data.combine(chunks)
FileManager.write(fileData, "/local/download.bin")
```

***

## 示例：使用异步迭代器读取流

`ReadableStream` 支持异步迭代 (`for await...of`)，可简化读取逻辑：

```tsx
for await (const chunk of response.body) {
  console.log("Chunk size:", chunk.size)
}
```

此语法会自动处理 `done` 状态，代码更简洁直观。

***

## 使用场景

| 场景           | 示例                            |
| ------------ | ----------------------------- |
| **大文件下载**    | 按块读取网络响应并写入本地文件，避免内存占用过大。     |
| **AI 输出流接收** | 实时接收服务器的推送内容（如 ChatGPT 流式响应）。 |
| **本地流式处理**   | 对本地文件或输入流实现增量读取或实时处理。         |

***

## 注意事项

- **单次锁定**：一个 `ReadableStream` 在被读取器锁定后，不能被多个消费者同时读取。
- **内存管理**：流式处理有助于降低内存占用，但应及时释放或取消读取器以防资源泄漏。
- **错误处理**：读取过程中出现错误（如网络断开）会导致 `read()` Promise 拒绝，应使用 `try...catch` 捕获。
- **Data 类型约定**：在 `Response.body` 中，流的每个块类型为 `Data`，而不是普通字符串或字节数组。

***

## 小结

`ReadableStream` 是 **Scripting 数据流架构的核心组件**，为开发者提供了高效的流式数据读取方式：

- 支持异步逐块读取
- 可与 `fetch()`、`Response`、`Data` 无缝集成
- 适用于实时处理、分块下载、长连接流等高级场景
- 完全兼容 Web 标准的 Streams API



---
url: /zh/guide/Utilities/Request/Request & RequestInit.md
---

`Request` 类表示一次 HTTP 请求的完整配置。
它可作为 `fetch()` 方法的参数使用，也可用于克隆、修改或重试请求。

在 Scripting 中，`Request` 的行为与浏览器 Fetch API 中的同名接口一致，但额外支持了原生扩展功能，包括：

- 支持二进制 `Data` 类型作为请求体
- 支持自定义重定向处理
- 支持请求超时、取消、与调试标签
- 支持允许不安全请求（HTTP 请求）

***

## 类定义

```ts
class Request {
  url: string
  method: string
  headers: Headers
  body?: Data | FormData | string | ArrayBuffer
  allowInsecureRequest?: boolean
  handleRedirect?: (newRequest: RedirectRequest) => Promise<RedirectRequest | null>
  shouldAllowRedirect?: (newRequest: Request) => Promise<boolean> // 已废弃
  timeout?: DurationInSeconds
  signal?: AbortSignal
  cancelToken?: CancelToken // 已废弃
  debugLabel?: string

  constructor(input: string | Request, init?: RequestInit)
  clone(): Request
}
```

***

## 构造函数

### `new Request(input: string | Request, init?: RequestInit)`

创建一个新的 `Request` 实例。
可通过字符串 URL 或现有的 `Request` 对象来构造。

#### 参数

| 参数        | 类型            | 说明                       |                                 |
| --------- | ------------- | ------------------------ | ------------------------------- |
| **input** | `string`      | `Request`                | 要请求的 URL，或一个现有的 Request 对象用于克隆。 |
| **init**  | `RequestInit` | 可选的初始化参数，用于配置请求的行为（见下文）。 |                                 |

***

## 属性

| 属性名                      | 类型                                                                  | 说明                                              |
| ------------------------ | ------------------------------------------------------------------- | ----------------------------------------------- |
| **url**                  | `string`                                                            | 请求的完整 URL。                                      |
| **method**               | `string`                                                            | 请求方法（默认 `"GET"`）。                               |
| **headers**              | `Headers`                                                           | 请求头部对象，可通过 `.get()`、`.set()`、`.append()` 等方法操作。 |
| **body**                 | `Data` \| `FormData` \| `string` \| `ArrayBuffer` \| `undefined`    | 请求体，仅用于非 `GET` 或 `HEAD` 请求。                     |
| **allowInsecureRequest** | `boolean`                                                           | 是否允许使用 HTTP 明文请求（默认 `false`）。                   |
| **handleRedirect**       | `(newRequest: RedirectRequest) => Promise<RedirectRequest \| null>` | 自定义重定向逻辑；返回 `null` 表示阻止重定向。                     |
| **shouldAllowRedirect**  | `(newRequest: Request) => Promise<boolean>`                         | 已废弃。旧版重定向控制回调。                                  |
| **timeout**              | `number`                                                            | 请求超时时间（单位：秒）。超时会自动中止请求。                         |
| **signal**               | `AbortSignal`                                                       | 用于中止请求的信号，由 `AbortController` 创建。               |
| **cancelToken**          | `CancelToken`                                                       | 已废弃。旧版取消机制，请改用 `signal`。                        |
| **debugLabel**           | `string`                                                            | 调试标签，会在日志面板中显示以方便追踪。                            |

***

## 方法

### `clone(): Request`

创建并返回当前请求对象的副本。
克隆后的对象可安全修改其属性（如 headers、body）而不影响原始请求。

#### 示例

```tsx
const req1 = new Request("https://api.example.com/user", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name: "Alice" })
})

const req2 = req1.clone()
console.log(req2.method) // "POST"
```

***

## 使用示例

### 示例 1：创建一个简单的 Request 对象

```tsx
const request = new Request("https://api.example.com/data", {
  method: "GET",
  headers: {
    "Accept": "application/json",
  },
  debugLabel: "Fetch User Data"
})

const response = await fetch(request)
const result = await response.json()
console.log(result)
```

***

### 示例 2：带请求体的 POST 请求

```tsx
const request = new Request("https://api.example.com/upload", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ fileId: "abc123" }),
  timeout: 15,
})

const response = await fetch(request)
console.log(await response.text())
```

***

### 示例 3：克隆并修改请求

```tsx
const base = new Request("https://api.example.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
})

const cloned = base.clone()
cloned.headers.set("Authorization", "Bearer token-123")
cloned.debugLabel = "Authorized Upload"

await fetch(cloned)
```

***

# RequestInit 类型

`RequestInit` 是一个用于配置请求参数的对象类型，常用于 `fetch()` 或 `Request` 构造函数中。
它与浏览器的标准 Fetch API 相同，但 Scripting 扩展了若干字段。

***

## 类型定义

```ts
type RequestInit = {
  method?: string
  headers?: HeadersInit
  body?: Data | FormData | string | ArrayBuffer
  allowInsecureRequest?: boolean
  handleRedirect?: (newRequest: RedirectRequest) => Promise<RedirectRequest | null>
  shouldAllowRedirect?: (newRequest: Request) => Promise<boolean> // 已废弃
  timeout?: DurationInSeconds
  signal?: AbortSignal
  cancelToken?: CancelToken // 已废弃
  debugLabel?: string
}
```

***

## 字段说明

| 字段名                      | 类型                                                                  | 说明                                                                 |   |
| ------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------ | - |
| **method**               | `string`                                                            | HTTP 方法，如 `"GET"`, `"POST"`, `"PUT"`, `"DELETE"`，默认 `"GET"`。       |   |
| **headers**              | `HeadersInit`                                                       | 请求头部信息，可以是：`Headers` 对象、普通对象 `{key: value}`、或 `[key, value][]` 数组。 |   |
| **body**                 | `Data` \| `FormData` \| `string` \| `ArrayBuffer`                   | 请求体，仅在非 `GET` / `HEAD` 请求中使用。                                      |   |
| **allowInsecureRequest** | `boolean`                                                           | 是否允许发送 HTTP 请求。默认 `false`。                                         |   |
| **handleRedirect**       | `(newRequest: RedirectRequest) => Promise<RedirectRequest \| null>` | 自定义重定向回调。返回新的请求对象以继续，返回 `null` 以阻止跳转。                              |   |
| **shouldAllowRedirect**  | `(newRequest: Request) => Promise<boolean>`                         | 已废弃。旧的布尔型重定向控制回调。                                                  |   |
| **timeout**              | `number`                                                            | 请求超时时间（秒），超时后会自动中止请求。                                              |   |
| **signal**               | `AbortSignal`                                                       | 中止信号，可由 `AbortController` 触发，用于主动取消请求。                             |   |
| **cancelToken**          | `CancelToken`                                                       | 已废弃。旧版取消机制，请使用 `signal` 替代。                                        |   |
| **debugLabel**           | `string`                                                            | 调试标签，在日志面板中显示，用于标识请求。                                              |   |

***

## 与 `fetch()` 的关系

`RequestInit` 是 `fetch()` 的第二个参数，用于定义请求配置：

```tsx
const response = await fetch("https://example.com/data", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ id: 123 }),
  timeout: 10,
  debugLabel: "Upload JSON",
})
```

***

## 与其他类的关系

| 类名                                    | 用途                                           |
| ------------------------------------- | -------------------------------------------- |
| **`Headers`**                         | 管理请求头部的集合，可与 `headers` 字段一起使用。               |
| **`Data`**                            | 表示二进制数据，可作为请求体（body）上传文件或原始字节数据。             |
| **`FormData`**                        | 用于构造 multipart/form-data 表单请求。               |
| **`AbortController` / `AbortSignal`** | 用于在请求过程中主动取消网络操作。                            |
| **`CancelToken`**                     | 旧版取消机制，仅为兼容保留。                               |
| **`RedirectRequest`**                 | 当发生重定向时传入 `handleRedirect` 回调的参数，包含新请求的详细信息。 |

***

## 示例

### 示例 1：使用自定义重定向回调

```tsx
const response = await fetch("https://example.com/start", {
  handleRedirect: async (newRequest) => {
    console.log("收到重定向:", newRequest.url)
    if (newRequest.url.includes("blocked")) return null
    return newRequest
  },
})
```

***

### 示例 2：允许不安全请求

```tsx
const response = await fetch("http://insecure.example.com/data", {
  allowInsecureRequest: true,
})
console.log(await response.text())
```

***

### 示例 3：带调试标签的请求

```tsx
await fetch("https://example.com/api/ping", {
  debugLabel: "Ping Request",
})
// 调试面板中将显示标签 “Ping Request”
```

***

以下是 **`handleRedirect` 回调中 `RedirectRequest` 接口的中文说明文档**，可直接插入至 `Request` 类文档的相关部分，用于解释自定义重定向逻辑的参数结构和用法。

***

## RedirectRequest 接口说明

当请求发生 **重定向 (Redirect)** 时，若在 `Request` 或 `RequestInit` 中设置了 `handleRedirect` 回调函数，系统会在跳转前调用该回调。
`handleRedirect` 的参数类型为 `RedirectRequest`，用于描述即将执行的重定向请求的完整信息。
你可以在回调中检查该对象的属性，并决定是否允许继续重定向，或修改请求后再继续。

***

### 接口定义

```ts
interface RedirectRequest {
  method: string
  url: string
  headers: Record<string, string>
  cookies: Cookie[]
  body?: Data
  timeout?: number
}
```

***

### 字段说明

| 字段          | 类型                       | 说明                                            |
| ----------- | ------------------------ | --------------------------------------------- |
| **method**  | `string`                 | 即将执行的重定向请求方法（例如 `"GET"`、`"POST"`）。            |
| **url**     | `string`                 | 重定向目标的完整 URL。                                 |
| **headers** | `Record<string, string>` | 该重定向请求的 HTTP 头部信息。你可以根据需要修改或记录这些头部。           |
| **cookies** | `Cookie[]`               | 当前请求中携带的 Cookie 列表，类型与 `Response.cookies` 一致。 |
| **body**    | `Data`（可选）               | 若为非 `GET` 请求，则包含请求体数据（例如表单或二进制数据）。            |
| **timeout** | `number`（可选）             | 请求的超时时间（单位：秒）。                                |

***

### 使用场景

通过 `handleRedirect` 回调，你可以：

- 检查重定向目标地址是否安全或符合业务逻辑。
- 修改重定向请求（如添加自定义头部、调整方法或携带 Token）。
- 阻止不必要或可疑的重定向。

当回调返回：

- 一个 `RedirectRequest` 对象 → 表示允许重定向，并使用你返回的对象继续请求。
- `null` → 表示阻止此次重定向，`fetch()` 将在当前响应结束。

***

### 示例：拦截与控制重定向请求

```tsx
const response = await fetch("https://example.com/start", {
  handleRedirect: async (redirect) => {
    console.log("即将重定向至:", redirect.url)

    // 如果跳转到外部域名，则阻止
    if (!redirect.url.startsWith("https://example.com")) {
      console.warn("阻止外部重定向:", redirect.url)
      return null
    }

    // 向重定向请求添加授权头
    redirect.headers["Authorization"] = "Bearer my-token"
    return redirect
  },
})
```

***

### 示例：修改重定向请求方法与体

```tsx
const response = await fetch("https://api.example.com/login", {
  handleRedirect: async (redirect) => {
    // 如果重定向目标为 POST 接口，则保持原始请求体
    if (redirect.url.includes("/finalize")) {
      redirect.method = "POST"
      redirect.body = Data.fromRawString("action=confirm", "utf-8")
    }
    return redirect
  },
})
```

***

### 注意事项

- 若未设置 `handleRedirect`，所有重定向将默认自动执行。
- 若设置了 `handleRedirect` 且返回 `null`，`fetch()` 不会继续跳转。
- 该机制不会自动携带 Cookie，需要手动在 `RedirectRequest.cookies` 中读取并决定是否传递。
- 修改 `RedirectRequest` 返回后，系统会基于修改后的内容重新发起请求。

***

## 小结

`Request` 与 `RequestInit` 是 **Scripting 网络请求系统的核心基础**：

- `Request` 封装了完整的 HTTP 请求对象，可复用、克隆与传递。
- `RequestInit` 定义请求参数，提供灵活的初始化方式。
- 二者与 `fetch()`、`Response`、`Headers`、`Data`、`FormData` 等类型紧密配合。



---
url: /zh/guide/Utilities/Request/Response.md
---

# 响应 （Response）

`Response` 类表示通过 `fetch()` 方法发起的网络请求返回的响应结果。
它提供了访问响应体（body）、头部（headers）、状态码、MIME 类型、以及服务器返回的 Cookies 的接口。

在 **Scripting app** 中，`Response` 的设计基于标准 Fetch API，但进行了原生扩展，支持：

- 原生级 **Cookie 访问与解析**
- **二进制数据 (`Data`)** 支持
- **流式响应 (`ReadableStream<Data>`)** 读取
- 响应的 MIME 类型、编码信息与预期长度
- 完整兼容标准 Web Fetch 行为

***

## 定义

```ts
class Response {
  readonly body: ReadableStream<Data>
  
  constructor(body: ReadableStream<Data>, init?: ResponseInit)

  get bodyUsed(): boolean
  get cookies(): Cookie[]
  json(): Promise<any>
  text(): Promise<string>
  data(): Promise<Data>
  bytes(): Promise<Uint8Array>
  arrayBuffer(): Promise<ArrayBuffer>
  formData(): Promise<FormData>
  get status(): number
  get statusText(): string
  get headers(): Headers
  get ok(): boolean
  get url(): string
  get mimeType(): string | undefined
  get expectedContentLength(): number | undefined
  get textEncodingName(): string | undefined
}
```

***

## 属性说明

| 属性                        | 类型                     | 说明                                   |
| ------------------------- | ---------------------- | ------------------------------------ |
| **body**                  | `ReadableStream<Data>` | 响应体数据的可读流。                           |
| **bodyUsed**              | `boolean`              | 指示响应体是否已被读取。                         |
| **cookies**               | `Cookie[]`             | 服务器通过 `Set-Cookie` 返回的 Cookie 列表。    |
| **status**                | `number`               | HTTP 状态码（如 `200`、`404`、`500`）。       |
| **statusText**            | `string`               | 状态描述（如 `"OK"`、`"Not Found"`）。        |
| **headers**               | `Headers`              | 响应头对象。                               |
| **ok**                    | `boolean`              | 当状态码在 200–299 范围内时为 `true`。          |
| **url**                   | `string`               | 响应的最终 URL（可能经过重定向）。                  |
| **mimeType**              | `string \| undefined`  | 响应的 MIME 类型（如 `"application/json"`）。 |
| **expectedContentLength** | `number \| undefined`  | 响应体的预期长度（字节），由服务器提供。                 |
| **textEncodingName**      | `string \| undefined`  | 文本编码方式（如 `"utf-8"`）。                 |

***

## 方法说明

### `json(): Promise<any>`

将响应体解析为 JSON 对象。

#### 示例

```tsx
const response = await fetch("https://api.example.com/user")
const data = await response.json()
console.log(data.name)
```

***

### `text(): Promise<string>`

将响应体读取为字符串。
默认使用 UTF-8 编码，若服务器返回了编码信息则自动识别。

#### 示例

```tsx
const response = await fetch("https://example.com/message.txt")
const text = await response.text()
console.log(text)
```

***

### `data(): Promise<Data>`

将响应体读取为二进制数据对象 `Data`，适合文件下载、图片处理、或转换为 Base64。

#### 示例

```tsx
const response = await fetch("https://example.com/image.png")
const imageData = await response.data()
FileManager.write(imageData, "/local/image.png")
```

***

### `bytes(): Promise<Uint8Array>`

将响应体读取为字节数组。

#### 示例

```tsx
const response = await fetch("https://example.com/file.bin")
const bytes = await response.bytes()
console.log("Received", bytes.length, "bytes")
```

***

### `arrayBuffer(): Promise<ArrayBuffer>`

将响应体读取为 `ArrayBuffer`，适合进行底层二进制操作。

#### 示例

```tsx
const response = await fetch("https://example.com/file")
const buffer = await response.arrayBuffer()
console.log(buffer.byteLength)
```

***

### `formData(): Promise<FormData>`

将响应体解析为 `FormData`（适用于 `multipart/form-data` 类型的响应）。

#### 示例

```tsx
const response = await fetch("https://example.com/form")
const form = await response.formData()
console.log(form.get("username"))
```

***

## Cookies 支持

### `cookies: Cookie[]`

Scripting 的 `Response` 支持直接访问服务器返回的 `Set-Cookie` 信息。
返回值为一个 `Cookie` 对象数组，每个元素包含完整的 Cookie 元数据。

#### Cookie 类型定义

```ts
interface Cookie {
  name: string
  value: string
  domain: string
  path: string
  isSecure: boolean
  isHTTPOnly: boolean
  isSessionOnly: boolean
  expiresDate?: Date | null
}
```

| 字段                | 类型             | 说明                     |
| ----------------- | -------------- | ---------------------- |
| **name**          | `string`       | Cookie 名称。             |
| **value**         | `string`       | Cookie 值。              |
| **domain**        | `string`       | 所属域名。                  |
| **path**          | `string`       | 作用路径。                  |
| **isSecure**      | `boolean`      | 是否仅通过 HTTPS 发送。        |
| **isHTTPOnly**    | `boolean`      | 是否为 HTTP-only，无法被脚本访问。 |
| **isSessionOnly** | `boolean`      | 是否为会话 Cookie（无过期时间）。   |
| **expiresDate**   | `Date \| null` | 过期时间（若有设置）。            |

***

### 示例：读取响应中的 Cookies

```tsx
const response = await fetch("https://example.com/login")
for (const cookie of response.cookies) {
  console.log(`${cookie.name} = ${cookie.value}`)
}
```

***

### 示例：手动管理 Cookie（跨请求复用）

默认情况下，**Scripting 的 `fetch()` 不会自动存储或携带 Cookie**。
如果希望在多次请求中复用 Cookie，可以手动拼接 `Cookie` 头：

```tsx
const response = await fetch("https://example.com/login")
const cookies = response.cookies
const cookieHeader = cookies.map(c => `${c.name}=${c.value}`).join("; ")

const next = await fetch("https://example.com/dashboard", {
  headers: { "Cookie": cookieHeader },
})
```

这种方式让开发者能够像浏览器开发者工具一样 **完全掌控 Cookie 的发送与存储**。

***

## 与其他类的关系

| 类名             | 说明                                |
| -------------- | --------------------------------- |
| **`Request`**  | 表示生成此响应的请求对象。                     |
| **`Headers`**  | 用于访问响应头部信息。                       |
| **`Data`**     | 表示响应体的二进制数据。                      |
| **`FormData`** | 表示 `multipart/form-data` 格式的表单响应。 |
| **`Cookie`**   | 表示服务器返回的单个 Cookie 对象。             |

***

## 使用示例

### 示例 1：处理 JSON API 响应

```tsx
const response = await fetch("https://api.example.com/profile")
if (response.ok) {
  const user = await response.json()
  console.log(user.email)
} else {
  console.log("请求失败:", response.status, response.statusText)
}
```

***

### 示例 2：下载文件并保存

```tsx
const response = await fetch("https://example.com/photo.jpg")
const fileData = await response.data()
FileManager.write(fileData, "/local/photo.jpg")
```

***

### 示例 3：读取服务器返回的 Cookies

```tsx
const response = await fetch("https://example.com/login")
for (const cookie of response.cookies) {
  console.log(`Cookie: ${cookie.name} = ${cookie.value}`)
}
```

***

### 示例 4：跨请求手动复用 Cookies

```tsx
const loginResponse = await fetch("https://example.com/login", {
  method: "POST",
  body: JSON.stringify({ username: "Tom", password: "1234" }),
  headers: { "Content-Type": "application/json" },
})

// 读取 Cookie 并拼接成请求头
const cookieHeader = loginResponse.cookies.map(c => `${c.name}=${c.value}`).join("; ")

// 携带 Cookie 发起新请求
const dashboard = await fetch("https://example.com/dashboard", {
  headers: { "Cookie": cookieHeader },
})
console.log(await dashboard.text())
```

***

### 示例 5：读取响应的元信息

```tsx
const response = await fetch("https://example.com/video.mp4")
console.log("MIME 类型:", response.mimeType)
console.log("预期长度:", response.expectedContentLength)
```

***

## 小结

`Response` 是 Scripting 网络请求体系中最核心的组成部分之一，具有以下特性：

- 完整兼容标准 Fetch API 行为
- 新增 **原生 Cookie 访问与控制** 能力
- 支持 `Data` 类型的 **二进制数据处理**
- 支持响应流式读取、MIME 类型、编码与长度信息
- 可与 `Request`、`Headers`、`FormData`、`AbortController` 等类型无缝配合



---
url: /zh/guide/Utilities/Request/fetch.md
---

# fetch 函数

`fetch()` 是用于发起 HTTP/HTTPS 网络请求的通用方法，返回一个表示响应 (`Response`) 的 Promise。
它在 Scripting 中的行为与浏览器标准 Fetch API 基本一致，但进行了原生增强以更好地支持 iOS 本地运行环境（包括文件请求、Data 对象、FormData 上传、可控重定向、信号中止与调试标签等）。

***

## 方法定义

```ts
function fetch(url: string, init?: RequestInit): Promise<Response>
function fetch(request: Request): Promise<Response>
```

***

## 参数说明

### 1. `url: string`

要请求的资源地址。
可以是：

- 网络地址（例如 `"https://api.example.com/data"`）
- 本地文件 URL（例如 `"file:///var/mobile/Containers/Data/Application/..."`）

***

### 2. `init?: RequestInit`

可选配置对象，用于自定义请求方法、头部、正文、超时、信号等。
定义如下：

```ts
type RequestInit = {
  method?: string;
  headers?: HeadersInit;
  body?: Data | FormData | string | ArrayBuffer;
  allowInsecureRequest?: boolean;
  handleRedirect?: (newRequest: RedirectRequest) => Promise<RedirectRequest | null>;
  shouldAllowRedirect?: (newRequest: Request) => Promise<boolean>; // 已废弃
  timeout?: number; // 秒
  signal?: AbortSignal;
  cancelToken?: CancelToken; // 已废弃
  debugLabel?: string;
}
```

#### 参数详解：

| 参数                       | 类型                                                                  | 说明                                                               |   |
| ------------------------ | ------------------------------------------------------------------- | ---------------------------------------------------------------- | - |
| **method**               | `string`                                                            | 请求方法，如 `"GET"`, `"POST"`, `"PUT"`, `"DELETE"`。默认为 `"GET"`。       |   |
| **headers**              | `HeadersInit`                                                       | 请求头，可以是 `Headers` 实例、键值对象或 `[key, value]` 数组。                    |   |
| **body**                 | `Data` \| `FormData` \| `string` \| `ArrayBuffer`                   | 请求正文，仅对非 GET/HEAD 请求有效。                                          |   |
| **allowInsecureRequest** | `boolean`                                                           | 允许通过 HTTP 发送请求。默认 `false`。如果主进程运行在 HTTPS 环境下而 URL 为 HTTP，需要显式启用。 |   |
| **handleRedirect**       | `(newRequest: RedirectRequest) => Promise<RedirectRequest \| null>` | 自定义重定向处理逻辑。如果返回 `null`，则阻止重定向。                                   |   |
| **shouldAllowRedirect**  | `(newRequest: Request) => Promise<boolean>`                         | 已废弃，用于兼容旧版重定向判断。                                                 |   |
| **timeout**              | `number`                                                            | 请求超时时间（秒）。超时将抛出 `AbortError`。                                    |   |
| **signal**               | `AbortSignal`                                                       | 可通过 `AbortController` 控制的中止信号，用于主动取消请求。                          |   |
| **cancelToken**          | `CancelToken`                                                       | 已废弃，用于取消请求的旧机制。建议改用 `signal`。                                    |   |
| **debugLabel**           | `string`                                                            | 调试标签，会显示在日志面板中，方便识别请求来源。                                         |   |

***

## 返回值

返回一个 `Promise<Response>` 对象。

`Response` 表示请求的响应数据。
即使返回的 HTTP 状态码为 4xx 或 5xx，`fetch` 仍然会 **成功解析并返回 Response 对象**。
只有当请求本身出错（如网络错误、无效 URL、超时、中止）时，Promise 才会被拒绝。

***

## 异常与错误处理

以下情况会触发 `Promise` 拒绝：

| 错误类型         | 抛出条件                             |
| ------------ | -------------------------------- |
| `TypeError`  | URL 无效、协议不受支持或请求体类型不兼容。          |
| `AbortError` | 请求被 `AbortController` 主动中止或超时触发。 |

***

## 示例

### 示例 1：基础 GET 请求

```tsx
const response = await fetch("https://api.example.com/data")
if (response.ok) {
  const json = await response.json()
  console.log(json)
} else {
  console.log("请求失败:", response.status)
}
```

***

### 示例 2：POST 请求（JSON）

```tsx
const response = await fetch("https://api.example.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Hello", content: "World" }),
})
const result = await response.json()
console.log(result)
```

***

### 示例 3：上传文件（FormData）

```tsx
const form = new FormData()
form.append("file", Data.fromFile("/path/to/image.png"), "image/png", "image.png")
form.append("user", "Tom")

const response = await fetch("https://api.example.com/upload", {
  method: "POST",
  body: form,
})
console.log(await response.json())
```

***

### 示例 4：带超时的请求

```tsx
try {
  const response = await fetch("https://example.com/slow", { timeout: 10 })
  const text = await response.text()
  console.log(text)
} catch (err) {
  if (err.name === "AbortError") {
    console.log("请求超时被中止")
  }
}
```

***

### 示例 5：通过 AbortController 主动中止请求

```tsx
const controller = new AbortController()

setTimeout(() => {
  controller.abort("用户取消了请求")
}, 3000)

try {
  const response = await fetch("https://example.com/large", { signal: controller.signal })
  const data = await response.text()
  console.log(data)
} catch (err) {
  if (err.name === "AbortError") {
    console.log("请求已被用户中止")
  }
}
```

***

### 示例 6：自定义重定向处理

```tsx
const response = await fetch("https://example.com/redirect", {
  handleRedirect: async (newRequest) => {
    console.log("收到重定向:", newRequest.url)
    if (newRequest.url.includes("forbidden")) {
      return null // 阻止跳转
    }
    return newRequest // 允许继续
  },
})
```

***

### 示例 7：调试标签与日志

```tsx
await fetch("https://api.example.com/status", {
  debugLabel: "Health Check",
})
// 日志面板中将显示标签 "Health Check"
```

***

## 与其他类的关系

| 类名                                    | 说明                                                   |
| ------------------------------------- | ---------------------------------------------------- |
| **`Request`**                         | 可直接创建一个请求对象并传入 `fetch(request)`。用于重复请求或在多个函数间复用请求配置。 |
| **`Response`**                        | 表示响应结果，可通过 `.json()`, `.text()`, `.data()` 等方法获取内容。  |
| **`AbortController` / `AbortSignal`** | 用于主动中止请求。                                            |
| **`FormData`**                        | 用于构造 multipart/form-data 请求体。                        |
| **`Headers`**                         | 管理请求与响应头部。                                           |
| **`Data`**                            | 表示二进制数据，可用于请求体或响应数据处理。                               |

***

## 特性说明

- **Cookie 管理**：Scripting 中的 `fetch` 默认不自动保存或携带 Cookie。响应中的 `Set-Cookie` 可通过 `response.cookies` 获取。
- **重定向行为**：默认自动跟随，除非设置了 `handleRedirect`。
- **并发安全**：多个并行请求相互独立。
- **文件支持**：可通过 `Data.fromFile()` 直接上传文件内容。

***

## 小结

`fetch()` 是 Scripting 网络请求体系的核心方法，兼容标准 Web API，同时提供更强的原生扩展能力：

- 支持本地文件访问
- 支持二进制 `Data` 类型
- 支持自定义重定向逻辑
- 支持中止与超时机制
- 支持调试标识与原生日志追踪



---
url: /zh/guide/Utilities/SSH/SFTP Client.md
---

`SFTPClient` 用于通过 SSH 连接访问远程文件系统，基于 **SFTP 协议**。
它提供目录操作、文件操作、路径解析等能力，并可通过 `openFile()` 获得更强大的 `SFTPFile` 对象执行读取、写入等低层操作。

该类实例通常由：

```ts
const sftp = await ssh.openSFTP()
```

返回。

***

## 属性

### `readonly isActive: boolean`

指示当前 SFTP 连接是否仍然有效。

- `true`：连接仍然处于活跃状态
- `false`：连接已关闭或发生错误

***

## 方法

***

## `close(): Promise<void>`

关闭当前 SFTP 连接。

#### 返回值：

- `Promise<void>`：关闭成功后 resolve

#### 示例：

```ts
await sftp.close()
```

***

## `readDirectory(atPath: string): Promise<DirectoryEntry[]>`

读取指定目录下的文件与子目录。

#### 参数：

- **`atPath`**：远程目录路径

#### 返回值：

**`DirectoryEntry[]`** 数组，结构如下：

```ts
{
  filename: string
  longname: string
  attributes: {
    size?: number
    userId?: number
    groupId?: number
    accessTime?: Date
    modificationTime?: Date
    permissions?: number
  }
}[]
```

#### 示例：

```ts
const items = await sftp.readDirectory("/var/log")
```

***

## `createDirectory(atPath: string): Promise<void>`

在指定路径创建一个目录。

#### 参数：

- `atPath`：目标目录路径

#### 返回值：

- `Promise<void>`：创建成功后 resolve

#### 示例：

```ts
await sftp.createDirectory("/home/user/new-folder")
```

***

## `removeDirectory(atPath: string): Promise<void>`

删除一个目录（需为空目录）。

#### 参数：

- `atPath`：要删除的目录路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.removeDirectory("/home/user/empty-dir")
```

***

## `rename(oldPath: string, newPath: string): Promise<void>`

重命名或移动文件 / 目录。

#### 参数：

- `oldPath`：原路径
- `newPath`：目标路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.rename("/home/user/a.txt", "/home/user/b.txt")
```

***

## `getAttributes(atPath: string): Promise<FileAttributes>`

读取文件或目录的信息。

#### 返回值：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

#### 示例：

```ts
const attrs = await sftp.getAttributes("/etc/hosts")
```

***

## `openFile(filePath: string, flags: SFTPOpenFileFlags | SFTPOpenFileFlags[]): Promise<SFTPFile>`

以指定模式打开远程文件，返回 `SFTPFile` 对象进行读写。

#### 参数：

- `filePath`：文件路径
- `flags`：打开文件的模式，可为单个 flag 或数组

可用的 flag：

```
"read" | "write" | "append" | "create" | "truncate" | "forceCreate"
```

#### 返回值：

- `Promise<SFTPFile>`：一个可读写、可关闭的文件对象

#### 示例：

```ts
const file = await sftp.openFile("/home/user/log.txt", ["read"])
const data = await file.readAll()
await file.close()
```

***

## `remove(atPath: string): Promise<void>`

删除指定路径的文件。

#### 参数：

- `atPath`：要删除的文件路径

#### 示例：

```ts
await sftp.remove("/home/user/old.txt")
```

***

## `getRealPath(atPath: string): Promise<string>`

解析符号链接、相对路径、`~` 等，返回绝对路径。

#### 示例：

```ts
const real = await sftp.getRealPath("~/documents")
```

***

# 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "pass")
})

const sftp = await ssh.openSFTP()

// 查看目录内容
const list = await sftp.readDirectory("/home/user")

// 打开文件读取
const file = await sftp.openFile("/home/user/info.txt", "read")
const data = await file.readAll()
await file.close()

// 创建目录
await sftp.createDirectory("/home/user/new-folder")

// 删除文件
await sftp.remove("/home/user/temp.txt")

await sftp.close()
```



---
url: /zh/guide/Utilities/SSH/SFTP File.md
---

`SFTPFile` 表示一个已经通过 SFTP 打开的远程文件句柄。
通过该类，你可以对文件执行读取、写入、获取属性、关闭等底层操作。

实例通常通过：

```ts
const file = await sftp.openFile(path, flags)
```

获得。

***

## 属性

***

### `readonly isActive: boolean`

指示当前文件是否仍然处于打开状态。

- `true`：文件句柄有效，可继续读写
- `false`：文件已关闭或出现错误

***

## 方法

***

# `readAttributes(): Promise<FileAttributes>`

读取文件的元数据属性。

### 返回值：

一个包含文件属性的对象：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

### 示例：

```ts
const attrs = await file.readAttributes()
console.log(attrs.size)
```

***

# `read(options?: { from?: number, length?: number }): Promise<Data>`

按指定范围读取文件内容。

### 参数：

- `from?`：读取的起始偏移（字节），默认从 `0` 开始
- `length?`：读取的字节数，默认读取到文件末尾

### 返回值：

- 一个 `Promise<Data>`，包含读取到的数据

### 示例：

```ts
const data = await file.read({ from: 100, length: 50 })
```

***

# `readAll(): Promise<Data>`

读取文件的全部内容。

### 返回值：

- 一个 `Promise<Data>`，包含完整的文件数据

### 示例：

```ts
const data = await file.readAll()
```

***

# `write(data: Data, at?: number): Promise<void>`

向文件写入数据。

### 参数：

- `data`：要写入的二进制数据
- `at?`：写入的起始偏移（字节）。

  - 若未提供，则根据 flags 的模式决定：

    - 若使用 `"append"` 打开，则追加到文件末尾
    - 若使用 `"write"` 打开，则从当前偏移或默认 0 写入

### 返回值：

- `Promise<void>`，写入成功后 resolve

### 示例：

```ts
await file.write(Data.fromRawString("Hello world"))
```

***

# `close(): Promise<void>`

关闭文件句柄。
关闭后，`isActive` 将变为 `false`，无法继续读写。

### 示例：

```ts
await file.close()
```

***

# 使用示例

```ts
// 打开文件（读取模式）
const file = await sftp.openFile("/home/user/info.txt", ["read"])

// 获取文件属性
const attrs = await file.readAttributes()

// 读取内容
const allData = await file.readAll()

// 部分读取
const partial = await file.read({ from: 50, length: 100 })

// 关闭文件
await file.close()
```



---
url: /zh/guide/Utilities/SSH/SSH Authentication Method.md
---

# SSH 认证方法

表示 SSH 身份验证方法。该类提供多个静态方法用于创建不同类型的 SSH 身份验证方式，包括基于密码、RSA 私钥、ED25519 私钥，以及 ECDSA（P-256、P-384、P-521）私钥的认证方式。

你可以将本类创建的实例传递给 `SSHClient.connect()` 方法中的 `authenticationMethod` 参数，用于连接 SSH 服务器。

## 静态方法

***

### `static passwordBased(username: string, password: string): SSHAuthenticationMethod`

创建一个基于用户名和密码的 SSH 身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录使用的用户名。

- `password`（字符串）：
  用户名对应的密码。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例，使用用户名密码进行身份验证。

#### 示例：

```ts
const auth = SSHAuthenticationMethod.passwordBased("user1", "mypassword")
```

***

### `static ras(username: string, sshRsa: Data, decryptionKey?: Data): SSHAuthenticationMethod | null`

创建一个基于 RSA 私钥的身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录使用的用户名。

- `sshRsa`（`Data` 对象）：
  OpenSSH 格式的 RSA 私钥内容，通常通过 `Data.fromString()` 读取。

- `decryptionKey`（可选的 `Data` 对象）：
  如果私钥加密了，请提供解密密码（同样为 `Data` 类型）。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例。如果密钥无效，则返回 `null`。

#### 示例：

```ts
const rsaKey = Data.fromString(privateKeyContent)!
const auth = SSHAuthenticationMethod.ras("user1", rsaKey)
```

***

### `static ed25519(username: string, sshEd25519: Data, decryptionKey?: Data): SSHAuthenticationMethod | null`

创建一个基于 ED25519 私钥的身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `sshEd25519`（`Data` 对象）：
  ED25519 格式的私钥内容。

- `decryptionKey`（可选的 `Data` 对象）：
  私钥若加密，需提供对应的解密密码。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例。如果密钥无效，则返回 `null`。

#### 示例：

```ts
const edKey = Data.fromString(ed25519KeyContent)!
const auth = SSHAuthenticationMethod.ed25519("user1", edKey)
```

***

### `static p256(username: string, pemRepresentation: string): SSHAuthenticationMethod | null`

使用 PEM 格式的 P-256（ECDSA）私钥创建身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `pemRepresentation`（字符串）：
  PEM 格式的 P-256 私钥内容。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例。如果 PEM 格式无效，则返回 `null`。

#### 示例：

```ts
const auth = SSHAuthenticationMethod.p256("user1", pemKeyContent)
```

***

### `static p384(username: string, pemRepresentation: string): SSHAuthenticationMethod | null`

使用 PEM 格式的 P-384（ECDSA）私钥创建身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `pemRepresentation`（字符串）：
  PEM 格式的 P-384 私钥内容。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例，如果无效则返回 `null`。

***

### `static p521(username: string, pemRepresentation: string): SSHAuthenticationMethod | null`

使用 PEM 格式的 P-521（ECDSA）私钥创建身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `pemRepresentation`（字符串）：
  PEM 格式的 P-521 私钥内容。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例，如果无效则返回 `null`。

***

## 使用示例

```ts
// 使用用户名密码认证
const passwordAuth = SSHAuthenticationMethod.passwordBased("root", "secret123")

// 使用 RSA 私钥认证
const privateKey = await FileManager.readAsData("/path/to/id_rsa")
const rsaAuth = SSHAuthenticationMethod.ras("root", privateKey)

// 建立 SSH 连接
const ssh = await SSHClient.connect({
  host: "192.168.0.1",
  authenticationMethod: rsaAuth
})
```



---
url: /zh/guide/Utilities/SSH/SSH Client.md
---

# SSH 客户端

`SSHClient` 类用于连接远程 SSH 服务器，支持执行命令、打开 TTY/PTY 会话、使用 SFTP 进行文件传输，以及通过跳板主机进行多级 SSH 跳转。该类是建立和管理 SSH 会话的核心接口。

***

## 静态方法

### `SSHClient.connect(options): Promise<SSHClient>`

建立与远程 SSH 服务器的连接。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    服务器的主机名或 IP 地址。

  - `port?`（数字）：
    连接端口，默认是 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    SSH 身份验证方式，例如密码或私钥。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任服务器公钥列表。如果提供，客户端将验证服务器公钥。

  - `reconnect?`（`"never" | "once" | "always"`）：
    可选的重连策略，默认是 `"never"`。

#### 返回值：

- 成功连接时返回 `Promise<SSHClient>` 实例。

#### 示例：

```ts
const ssh = await SSHClient.connect({
  host: "192.168.0.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("root", "password")
})
```

***

## 属性

### `onDisconnect: (() => void) | null`

SSH 连接断开时触发的回调函数。

#### 示例：

```ts
ssh.onDisconnect = () => {
  console.log("SSH 已断开")
}
```

***

## 实例方法

### `executeCommand(command: string, options?): Promise<string>`

在远程服务器上执行命令，并返回结果字符串。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `options?`（对象）：

  - `maxResponseSize?`（数字）：
    最大响应字节数。

  - `includeStderr?`（布尔）：
    是否包含标准错误输出，默认为 `false`。

  - `inShell?`（布尔）：
    是否在 shell 中执行命令（如 `sh -c`），默认是 `false`。

#### 返回值：

- 返回一个 `Promise<string>`，为命令的输出。

#### 示例：

```ts
const result = await ssh.executeCommand("uname -a")
```

***

### `executeCommandStream(command, onOutput, options?): Promise<void>`

以流的形式逐行执行命令并获取输出。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `onOutput`（函数）：
  每一行输出都会调用该回调函数 `(data: Data, isStderr: boolean) => boolean`。返回 `false` 可提前终止输出接收。

- `options?`（对象）：

  - `inShell?`（布尔）：
    是否在 shell 中执行。

#### 返回值：

- 返回一个 `Promise`，命令执行完毕后 resolve。

#### 示例：

```ts
const output = Data.fromIntArray([])
await ssh.executeCommandStream("ping -c 4 google.com", (data, isStderr) => {
  output.append(data)
  return true
})
console.log(output.toDecodedString()())
```

***

### `withPTY(options): Promise<TTYStdinWriter>`

打开一个 PTY（伪终端）会话，支持交互式终端程序（如 `top`、`vim`）。

#### 参数：

- `options`（对象）：

  - `wantReply?`（布尔）：
    是否等待服务器回应，默认 `true`。

  - `term?`（字符串）：
    终端类型，默认是 `"xterm"`。

  - `terminalCharacterWidth?`（数字）：
    字符宽度，默认 `80`。

  - `terminalRowHeight?`（数字）：
    字符行数，默认 `24`。

  - `terminalPixelWidth?`（数字）：
    像素宽度，默认 `0`。

  - `terminalPixelHeight?`（数字）：
    像素高度，默认 `0`。

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>`，可用于写入输入和调整终端大小。

#### 示例：

```ts
let output: Data | undefined
let timerId: number | undefined
const writer = await ssh.withPTY({
  onOutput: (data, isStderr) => {
    if (output == null) {
      output = data
    } else {
      output.append(data)
    }
    clearTimeout(timerId)
    timerId = setTimeout(() => {
      console.log(output.toDecodedString()())
      output = undefined
    }, 500)
    return true
  }
})
await writer.write("top\n")
```

***

### `withTTY(options): Promise<TTYStdinWriter>`

打开一个简化的 TTY 会话（不包含终端尺寸设置）。

#### 参数：

- `options`（对象）：

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>` 实例。

***

### `openSFTP(): Promise<SFTPClient>`

打开一个 SFTP 会话，用于远程文件读写、目录管理等操作。

#### 返回值：

- 一个 `Promise<SFTPClient>` 实例。

#### 示例：

```ts
const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/test.txt", "Hello world")
```

***

### `jump(options): Promise<SSHClient>`

从当前连接跳转（跳板）至另一个远程 SSH 主机。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    目标主机地址。

  - `port?`（数字）：
    端口，默认为 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    跳转主机的身份验证方式。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任主机公钥。

#### 返回值：

- 一个新的 `SSHClient` 实例，表示跳转后的连接。

#### 示例：

```ts
const nextHop = await ssh.jump({
  host: "10.0.0.2",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user2", "pass2")
})
```

***

### `close(): Promise<void>`

关闭 SSH 连接并释放资源。

> **注意：** 当不再需要 SSH 连接时应显式调用该方法，以防资源或 socket 泄漏。

#### 返回值：

- 一个 `Promise`，成功关闭连接时 resolve。

#### 示例：

```ts
await ssh.close()
```

***

## 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "password")
})

const output = await ssh.executeCommand("uptime")
console.log("系统运行时间：", output)

const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/hello.txt", "Hello SSH")

await ssh.close()
```



---
url: /zh/guide/Utilities/SSH/TTY Stdin Writer.md
---

# TTY 标准输入写入器

表示一个可写的 TTY（终端）标准输入流，用于通过 SSH 建立的伪终端（PTY）或 TTY 会话。该类支持将数据写入远程终端的 `stdin`，以及动态调整终端窗口大小。

通常由 `SSHClient.withPTY()` 或 `SSHClient.withTTY()` 方法返回。

***

## 方法

### `write(data: string): Promise<void>`

向远程 TTY 会话的标准输入写入文本数据。

#### 参数：

- `data`（字符串）：
  要发送给远程终端标准输入的字符串，可以包含控制字符（如 `"\r"` 表示回车，`\x03` 表示 Ctrl+C）。

#### 返回值：

- 一个 `Promise`，在数据成功写入后 resolve。

#### 示例：

```ts
const writer = await ssh.withTTY({
  onOutput: (text) => {
    console.log("输出：", text)
    return true
  }
})
await writer.write("ls -la\n")
```

***

### `changeSize(options: { cols: number; rows: number; pixelWidth: number; pixelHeight: number }): Promise<void>`

更改远程终端的窗口尺寸，适用于需要特定终端尺寸的程序（如 `vim`、`htop` 等）。

#### 参数：

- `options`（对象）：
  一个包含终端尺寸信息的对象：

  - `cols`（数字）：
    终端的字符列数，例如 80。

  - `rows`（数字）：
    终端的字符行数，例如 24。

  - `pixelWidth`（数字）：
    终端的像素宽度（如果不适用可设为 0）。

  - `pixelHeight`（数字）：
    终端的像素高度（如果不适用可设为 0）。

#### 返回值：

- 一个 `Promise`，在终端尺寸更改成功后 resolve。

#### 示例：

```ts
await writer.changeSize({
  cols: 100,
  rows: 30,
  pixelWidth: 0,
  pixelHeight: 0
})
```

***

## 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "password")
})

const writer = await ssh.withPTY({
  term: "xterm",
  onOutput: (text, isStderr) => {
    console.log(text)
    return true
  }
})

// 写入命令
await writer.write("top\n")

// 2 秒后调整终端尺寸
await new Promise(resolve => setTimeout(resolve, 2000))
await writer.changeSize({
  cols: 120,
  rows: 40,
  pixelWidth: 0,
  pixelHeight: 0
})
```



---
url: /zh/guide/Utilities/Storage.md
---

`Storage` 模块为脚本提供轻量级的持久化存储能力。
开发者可以在脚本中保存与读取简单的数据类型（如字符串、数字、布尔值、JSON 对象）以及二进制数据（`Data`）。

所有数据默认存储在 **当前脚本的私有存储域**，不会被其他脚本访问。
若希望在多个脚本之间共享数据，可将 `shared: true` 作为选项传入，使数据写入 **共享存储域**。

数据会在后台异步持久化到磁盘，但写入方法同步返回执行结果。

***

# 支持的数据类型

Storage 支持以下类型的数据：

- `string`
- `number`
- `boolean`
- `JSON`（符合 JSON 可序列化类型的结构）
- `Data`（需使用 `setData` / `getData`）

以上类型均可安全持久化。

***

# 存储域说明

| 类型          | 默认                    | 可访问性     | 适用场景                  |
| ----------- | --------------------- | -------- | --------------------- |
| 私有（Private） | 是                     | 仅当前脚本    | 保存当前脚本的配置、状态、用户数据等    |
| 共享（Shared）  | 否（需设置 `shared: true`） | 所有脚本都可访问 | 多脚本之间共享数据，如全局设置、用户偏好等 |

***

# API 参考

## 1. `Storage.set(key, value, options?)`

```ts
function set<T>(key: string, value: T, options?: { shared: boolean }): boolean
```

将值保存到持久化存储中。支持 `string`、`number`、`boolean` 和 `JSON` 类型。

### 参数

| 名称             | 类型        | 必须 | 说明                    |
| -------------- | --------- | -- | --------------------- |
| key            | `string`  | 是  | 要保存的键名                |
| value          | `T`       | 是  | 要持久化的值                |
| options.shared | `boolean` | 否  | 如果为 `true`，将数据写入共享存储域 |

### 返回值

- `boolean`：表示操作是否成功。

***

## 2. `Storage.get(key, options?)`

```ts
function get<T>(key: string, options?: { shared: boolean }): T | null
```

读取已保存的值。如果不存在，返回 `null`。

### 参数

| 名称             | 类型        | 必须 | 说明         |
| -------------- | --------- | -- | ---------- |
| key            | `string`  | 是  | 要读取的键名     |
| options.shared | `boolean` | 否  | 是否从共享存储域读取 |

### 返回值

- `T | null`：对应的值或 `null`。

***

## 3. `Storage.setData(key, data, options?)`

```ts
function setData(key: string, data: Data, options?: { shared: boolean }): void
```

保存二进制数据 `Data` 到持久化存储。

### 参数

- 与 `set` 的参数格式一致，但 `value` 替换为 `Data`。

***

## 4. `Storage.getData(key, options?)`

```ts
function getData(key: string, options?: { shared: boolean }): Data | null
```

读取保存的二进制数据。不存在时返回 `null`。

***

## 5. `Storage.remove(key, options?)`

```ts
function remove(key: string, options?: { shared: boolean }): void
```

移除指定键的数据。

***

## 6. `Storage.contains(key, options?)`

```ts
function contains(key: string, options?: { shared: boolean }): boolean
```

检测存储中是否包含某个键。

***

## 7. `Storage.clear()`

```ts
function clear(): void
```

清空所有存储的键值对。
**注意：该操作仅清空当前脚本的私有存储，不会影响共享存储域。**

***

## 8. `Storage.keys()`

```ts
function keys(): string[]
```

返回当前存储域中所有键名数组。

***

# 使用示例

## 示例 1：保存与读取简单类型

```ts
import { Storage } from "scripting"

Storage.set("username", "Thom")
const name = Storage.get<string>("username")
console.log(name) // "Thom"
```

***

## 示例 2：保存 JSON 对象

```ts
Storage.set("profile", {
  name: "Alice",
  age: 30
})

const profile = Storage.get<{ name: string; age: number }>("profile")
console.log(profile?.age) // 30
```

***

## 示例 3：保存与读取 Data

```ts
import { Data, Storage } from "scripting"

const bytes = Data.fromUTF8("hello")
Storage.setData("payload", bytes)

const result = Storage.getData("payload")
console.log(result?.toUTF8()) // "hello"
```

***

## 示例 4：使用 shared 共享数据

```ts
Storage.set("theme", "dark", { shared: true })

const value = Storage.get<string>("theme", { shared: true })
console.log(value) // "dark"
```

***

## 示例 5：检测与删除键

```ts
if (Storage.contains("token")) {
  Storage.remove("token")
}
```

***

## 示例 6：获取所有键

```ts
console.log(Storage.keys()) // ["username", "profile", ...]
```

***

# 注意事项

1. 所有写入操作异步持久化，但 API 会立即返回成功与否。
2. `Data` 类型不能通过 `Storage.set()` 保存，必须使用 `setData()`。
3. JSON 类型必须是可序列化的结构。
4. 避免将大型二进制数据保存在 Storage；此功能用于轻量级数据存储。
5. `Storage.clear()` 不会清空 shared 存储域。



---
url: /zh/guide/Utilities/Thread.md
---

# 线程（Thread）

Scripting 的 UI 渲染系统以及绝大多数 JavaScript 执行逻辑默认运行在主线程中，因此通常开发者无需主动切换线程。

为了确保 UI 更新安全、避免主线程阻塞，并在必要时执行后台任务，Scripting 提供了全局 `Thread` API。部分系统 API 或运行时逻辑可能会在后台执行，此 API 能帮助你安全地处理复杂场景。

`Thread` 为全局命名空间，无需导入即可使用。

***

## `Thread.isMainThread: boolean`

指示当前 JavaScript 执行环境是否在主线程。

在大多数情况下此值为 `true`，但某些系统回调或内部任务可能会切换到后台线程。在需要进行 UI 更新时，可以通过此属性确认当前线程是否安全。

```ts
if (Thread.isMainThread) {
  console.log('当前在主线程')
} else {
  console.log('当前不在主线程')
}
```

***

## `Thread.runInMain(execute: () => void): void`

在主线程中执行指定的函数。

由于 JavaScript 默认运行在主线程，通常无需手动调用此方法。它主要用于以下情况：

- 某些系统 API 回调在后台线程触发，开发者需要确保 UI 更新在主线程执行
- 希望严格保证某段逻辑在主线程中执行

此方法不会返回值，也不会切回执行前的线程，仅保证同步在主线程执行。

```ts
Thread.runInMain(() => {
  title.value = 'Updated on main thread'
})
```

***

## `Thread.runInBackground<T>(execute: () => T | Promise<T>): Promise<T>`

在后台线程执行指定函数，并以 Promise 形式将结果切回到调用处所在的线程（通常是主线程）。

适用于：

- 计算密集型任务
- 大型数据处理
- 不希望阻塞 UI 的耗时操作

`execute` 可以返回值或 Promise。

```ts
const sum = await Thread.runInBackground(() => {
  let v = 0
  for (let i = 0; i < 5_000_000; i++) v += i
  return v
})

console.log('结果:', sum)
```

异步示例：

```ts
const image = await Thread.runInBackground(async () => {
  const raw = await loadImage()
  return processImage(raw)
})

Thread.runInMain(() => {
  setImage(image)
})
```

***

## 异步 I/O 的自动线程切换行为

Scripting 中 **大量异步 I/O 方法**（包括文件、网络、数据库等）会自动在后台线程执行，无需开发者手动使用 `runInBackground`。

例如：

```ts
const content = await FileManager.readAsString(path)
```

`readAsString` 会自动切换到后台线程执行文件读取操作，然后将结果以 Promise 的方式切回调用时所在的线程（通常是主线程）。
这意味着你可以放心地直接调用异步 API，而无需担心阻塞 UI。

### 只有同步方法会在主线程执行

例如：

```ts
const content = FileManager.readAsStringSync(path)
```

同步方法不会切线程，会在主线程直接执行 I/O 操作。因此：

- 不建议在同步方法中处理大型文件或执行耗时操作
- 如果需要高性能且不阻塞 UI，应使用异步版本（如 readAsString）

***

## 使用建议

- JavaScript 默认在主线程运行，大部分场景不需要调用 `runInMain`
- 异步 I/O（如 FileManager.readAsString）已经自动在后台线程执行
- 仅在执行计算密集型任务或同步 I/O 时需要使用 `runInBackground`
- 如果某些系统 API 回调在后台线程中触发，可使用 `runInMain` 保证 UI 更新安全
- 不应在后台线程中直接访问 UI，应在后台任务完成后再回到主线程处理



---
url: /zh/guide/Utilities/UIImage.md
---

# UIImage

`UIImage` 类表示一个图像对象，可用于加载、编码、转换与显示。它支持从文件路径、二进制数据或 Base64 字符串中创建图像，并提供多种格式转换方法（PNG/JPEG）。
`UIImage` 可直接用于 `Image` 组件显示，也可与 `Data` 类配合用于图像存储、上传、加密等操作。

***

## 概述

`UIImage` 是脚本环境中处理图像的核心类，常用于以下场景：

- 从本地文件、二进制数据、网络URL或 Base64 字符串中加载图像
- 获取图像的像素宽高与缩放比例
- 转换图像格式（如 PNG、JPEG）
- 生成 Base64 字符串
- 调整渲染模式与可拉伸区域
- 对图像进行翻转或着色
- 生成缩略图
- 支持浅色/深色模式切换的动态图像显示

***

## 属性

### `width: number`

图像的宽度（单位：像素）。

```ts
const image = UIImage.fromFile("/path/to/image.png")
console.log(image?.width)
```

***

### `height: number`

图像的高度（单位：像素）。

```ts
const image = UIImage.fromFile("/path/to/image.png")
console.log(image?.height)
```

***

### `scale: number`

图像的缩放比例（Scale Factor），通常为 `1` 或 `2`（Retina 屏幕）。

```ts
console.log(image?.scale)
```

***

### `imageOrientation: string`

图像的方向，可能的值包括：

- `"up"`
- `"down"`
- `"left"`
- `"right"`
- `"upMirrored"`
- `"downMirrored"`
- `"leftMirrored"`
- `"rightMirrored"`
- `"unknown"`

```ts
console.log(image?.imageOrientation)
```

***

### `isSymbolImage: boolean`

指示该图像是否为 SFSymbol 符号图像。

```ts
const symbol = UIImage.fromSFSymbol("heart.fill")
console.log(symbol?.isSymbolImage) // true
```

***

### `renderingMode: "automatic" | "alwaysOriginal" | "alwaysTemplate" | "unknown"`

图像的渲染模式。

- `automatic`: 系统自动决定渲染方式
- `alwaysOriginal`: 显示原始颜色
- `alwaysTemplate`: 使用模板渲染（可通过 tintColor 着色）

***

### `resizingMode: "tile" | "stretch" | "unknown"`

图像的拉伸模式：

- `"tile"`：平铺重复绘制
- `"stretch"`：直接拉伸

***

### `capInsets: { top: number, left: number, bottom: number, right: number }`

定义图像的可拉伸区域边距（Cap Insets）。

***

### `flipsForRightToLeftLayoutDirection: boolean`

是否为右到左（RTL）布局方向自动翻转图像。

***

## 实例方法

### `preparingThumbnail(size: Size): UIImage | null`

生成指定尺寸的缩略图。

- **参数：**

  - `size.width`: 缩略图宽度
  - `size.height`: 缩略图高度

- **返回值：**

  - 新的 `UIImage` 实例或 `null`

**示例：**

```ts
const image = UIImage.fromFile("/path/to/photo.jpg")
const thumb = image?.preparingThumbnail({ width: 200, height: 200 })
```

***

### `withBaselineOffset(offset: number): UIImage`

设置图像的基线偏移量（Baseline Offset），用于调整图像在垂直方向上的显示位置，在文本布局中很有用。

```ts
const image = UIImage.fromFile("/path/to/image.png")
const offset = image?.withBaselineOffset(10)
```

***

### `withHorizontallyFlippedOrientation(): UIImage`

水平翻转图像方向，返回新的 `UIImage` 实例。

```ts
const flipped = image?.withHorizontallyFlippedOrientation()
```

***

### `withTintColor(color: string, renderingMode?: "automatic" | "alwaysOriginal" | "alwaysTemplate"): UIImage | null`

为图像应用指定的渲染模式和颜色着色。

- **参数：**

  - `color`: 要应用的颜色字符串，例如 `"#ffcc00"` 或 `"rgb(255,128,0)"`
  - `renderingMode`: 渲染模式，默认为 `"automatic"`

**示例：**

```ts
const symbol = UIImage.fromSFSymbol("star.fill")
const tinted = symbol?.withTintColor("#ffcc00", "alwaysTemplate")
```

***

### `withRenderingMode(renderingMode: "automatic" | "alwaysOriginal" | "alwaysTemplate"): UIImage | null`

返回使用指定渲染模式的新图像。

```ts
const templated = image?.withRenderingMode("alwaysTemplate")
```

***

### `resizableImage(capInsets, resizingMode?): UIImage | null`

返回带有指定可拉伸区域和模式的新图像。

- **参数：**

  - `capInsets`: `{ top, left, bottom, right }`
  - `resizingMode`: `"tile"` 或 `"stretch"`，默认 `"tile"`

**示例：**

```ts
const resizable = image?.resizableImage(
  { top: 10, left: 10, bottom: 10, right: 10 },
  "stretch"
)
```

***

### `renderedInCircle(radius?: number | null, fitEntireImage?: boolean): UIImage`

返回一个新的圆形渲染版本的图像，可选指定圆的半径和是否完整显示整个图像。

- **参数：**

  - `radius`（可选）：圆的半径（单位：点）。

    - 如果未指定：

      - 当 `fitEntireImage` 为 `false` 时，圆形将使用图像的**最短边**作为直径；
      - 当 `fitEntireImage` 为 `true` 时，圆形将使用图像的**最长边**作为直径。
  - `fitEntireImage`（可选）：是否让整个图像内容都适应在圆形范围内。

    - 默认值为 `true`。
    - 若为 `false`，图像会填满圆形区域，但可能出现内容裁剪。

- **返回值：**

  - 返回一个新的 `UIImage` 实例，表示圆形渲染结果。

**示例 1：创建默认的圆形头像**

```ts
const image = UIImage.fromFile("/path/to/avatar.jpg")
const circle = image?.renderedInCircle()
<Image image={circle} />
```

**示例 2：指定半径并完整显示整个图像**

```ts
const image = UIImage.fromFile("/path/to/photo.png")
const circle = image?.renderedInCircle(60, true)
<Image image={circle} />
```

**示例 3：填充模式（可能裁剪图像部分内容）**

```ts
const image = UIImage.fromFile("/path/to/icon.png")
const circle = image?.renderedInCircle(50, false)
<Image image={circle} />
```

***

### `renderedIn(size: { width: number, height: number }, source?: {  position?: ..., size?: ... }): UIImage | null`

返回一个新的图像，将源图像缩放到指定大小，可选指定源图像的位置和尺寸。

- **参数：**

  - `size`: `{ width: number, height: number }`，目标图像的尺寸（单位：点）
  - `source`: `{ position?: { x: number, y: number }, size?: { width: number, height: number } }`，源图像的位置和尺寸。

- **返回值：**

  - 成功时返回新的 `UIImage` 实例；失败时返回 `null`。

**示例 1：将整张图片缩放绘制到矩形区域**

```ts
const image = UIImage.fromFile("/path/to/photo.jpg")
const rendered = image?.renderedIn({width: 200, height: 200 })
<Image image={rendered} />
```

**示例 2：从源图像中裁剪指定区域并绘制**

```ts
const image = UIImage.fromFile("/path/to/landscape.jpg")
const cropped = image?.renderedIn({
    width: 150,
    height: 150 
  }, {
  position: { x: 100, y: 50 },
  size: { width: 300, height: 300 }
})
<Image image={cropped} />
```

***

### `applySymbolConfiguration(config: UIImageSymbolConfiguration | UIImageSymbolConfiguration[]): UIImage | null`

返回一个应用指定符号配置（`UIImageSymbolConfiguration`）的新图像实例。
该方法主要用于自定义 **SF Symbols** 图标的外观（如颜色、粗细、大小、配色模式等）。

- **参数：**

  - `config`: 要应用的符号配置对象。

    - 可以是单个 `UIImageSymbolConfiguration` 实例；
    - 或由多个配置组成的数组，多个配置将按顺序依次应用（后者可覆盖前者）。

- **返回值：**

  - 返回一个新的 `UIImage` 实例，表示应用配置后的图像。
    如果应用失败，返回 `null`。

**示例 1：设置符号图标为多色显示**

```ts
const image = UIImage.fromFile("/path/to/sf_symbol.png")
const config = UIImageSymbolConfiguration.preferringMulticolor()
const colored = image?.applySymbolConfiguration(config)
<Image image={colored} />
```

**示例 2：同时应用缩放和权重配置**

```ts
const image = UIImage.fromFile("/path/to/sf_symbol.png")
const config = [
  UIImageSymbolConfiguration.scale("large"),
  UIImageSymbolConfiguration.weight("bold")
]
const boldLarge = image?.applySymbolConfiguration(config)
<Image image={boldLarge} />
```

**示例 3：设置分层颜色与调色板颜色**

```ts
const image = UIImage.fromFile("/path/to/symbol.png")
const config = [
  UIImageSymbolConfiguration.hierarchicalColor(Color.blue()),
  UIImageSymbolConfiguration.paletteColors([Color.red(), Color.orange()])
]
const customized = image?.applySymbolConfiguration(config)
<Image image={customized} />
```

***

## UIImageSymbolConfiguration

`UIImageSymbolConfiguration` 是用于配置 **符号图像（SF Symbols）** 外观的类。
可通过其静态方法创建不同的配置对象，并在 `applySymbolConfiguration()` 中使用。

### 可用静态方法

| 方法                          | 说明                                                                                                                       |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `preferringMonochrome()`    | 优先使用单色显示符号。                                                                                                              |
| `preferringMulticolor()`    | 优先使用多色显示符号。                                                                                                              |
| `scale(value)`              | 设置符号缩放比例，可选值：`"default"`, `"large"`, `"medium"`, `"small"`, `"unspecified"`。                                             |
| `weight(value)`             | 设置符号线条粗细，可选值：`"ultraLight"`, `"thin"`, `"light"`, `"regular"`, `"medium"`, `"semibold"`, `"bold"`, `"heavy"`, `"black"`。 |
| `pointSize(value)`          | 设置符号点大小。                                                                                                                 |
| `paletteColors(value)`      | 设置符号调色板颜色数组（用于多层符号）。                                                                                                     |
| `hierarchicalColor(value)`  | 设置符号的层级颜色（分层阴影样式）。                                                                                                       |
| `variableValueMode(value)`  | 设置符号的动态数值显示模式，可选值：`"automatic"`, `"color"`, `"draw"`。                                                                    |
| `colorRenderingMode(value)` | 设置颜色渲染模式，可选值：`"automatic"`, `"flat"`, `"gradient"`。                                                                      |
| `locale(identifier)`        | 设置用于符号本地化的语言标识符（如 `"en"`, `"zh-Hans"`）。                                                                                  |

***

**示例：组合配置符号图标外观**

```ts
const config = [
  UIImageSymbolConfiguration.scale("medium"),
  UIImageSymbolConfiguration.weight("semibold"),
  UIImageSymbolConfiguration.preferringMonochrome(),
  UIImageSymbolConfiguration.colorRenderingMode("flat")
]

const image = UIImage.fromFile("/path/to/symbol.png")
const result = image?.applySymbolConfiguration(config)
<Image image={result} />
```

***

### `toJPEGData(compressionQuality?: number): Data | null`

将图像转换为 JPEG 格式的二进制数据。

- **参数：**

  - `compressionQuality`（可选）: 压缩质量（0–1，默认 1）
- **返回值：**

  - `Data` 实例或 `null`

***

### `toPNGData(): Data | null`

将图像转换为 PNG 格式的二进制数据。
返回 `Data` 实例或 `null`。

***

### `toJPEGBase64String(compressionQuality?: number): string | null`

将图像转换为 Base64 编码的 JPEG 字符串。

***

### `toPNGBase64String(): string | null`

将图像转换为 Base64 编码的 PNG 字符串。

***

## 静态方法

### `UIImage.fromData(data: Data): UIImage | null`

通过 `Data` 创建图像。

***

### `UIImage.fromFile(filePath: string): UIImage | null`

从文件路径加载图像（支持 PNG/JPEG）。

***

### `UIImage.fromBase64String(base64String: string): UIImage | null`

通过 Base64 字符串创建图像。

***

### `UIImage.fromSFSymbol(name: string): UIImage | null`

从 **SFSymbol 名称** 创建系统图标。

**示例：**

```ts
const heart = UIImage.fromSFSymbol("heart.fill")
<Image image={heart} />
```

***

### `UIImage.fromURL(url: string): Promise<UIImage | null>`

通过 URL 加载图像（支持 PNG/JPEG）。

**示例：**

```ts
const image = await UIImage.fromURL("https://example.com/image.jpg")
<Image image={image} />
```

***

## 在 UI 中使用 UIImage

`UIImage` 可以直接用于 `<Image>` 组件中显示图像。

### 组件定义

```ts
declare const Image: FunctionComponent<UIImageProps>
```

***

### 属性定义

```ts
type UIImageProps = {
  image: UIImage | DynamicImageSource<UIImage>
}
```

***

### 类型定义

```ts
type DynamicImageSource<T> = {
  light: T
  dark: T
}
```

***

### 示例：显示单张图片

```ts
const image = UIImage.fromFile("/path/to/avatar.png")
<Image image={image} />
```

***

### 示例：适配浅色与深色模式

```ts
const lightImage = UIImage.fromFile("/path/to/light-logo.png")
const darkImage = UIImage.fromFile("/path/to/dark-logo.png")

<Image image={{ light: lightImage, dark: darkImage }} />
```

***

## 常见用法示例

### 1. 图像转 Base64

```ts
const image = UIImage.fromFile("/path/to/image.png")
const base64 = image?.toPNGBase64String()
```

***

### 2. 压缩为 JPEG 数据并保存

```ts
const image = UIImage.fromFile("/path/to/photo.jpg")
const jpegData = image?.toJPEGData(0.6)
if (jpegData) {
  // 写入到本地文件
}
```

***

### 3. 从 Base64 字符串还原图片并显示

```ts
const base64 = "iVBORw0KGgoAAAANSUhEUgAA..."
const image = UIImage.fromBase64String(base64)
<Image image={image} />
```

***

### 4. 将 PNG 图片转换为 JPEG 并上传

```ts
const image = UIImage.fromFile("/path/to/logo.png")
const jpegData = image?.toJPEGData(0.8)
if (jpegData) {
  const response = await fetch("https://example.com/upload", {
    method: "POST",
    body: jpegData.toUint8Array()
  })
}
```

***

### 5. 创建 SFSymbol 图像并着色

```ts
const symbol = UIImage.fromSFSymbol("star.fill")
const colored = symbol?.withTintColor("#ffcc00", "alwaysTemplate")
<Image image={colored} />
```

***

### 6. 生成缩略图

```ts
const image = UIImage.fromFile("/path/to/large.jpg")
const thumb = image?.preparingThumbnail({ width: 120, height: 120 })
<Image image={thumb} />
```

***

## 总结

`UIImage` 是 Scripting 脚本环境中图像操作的核心类，具备以下特性：

- 从文件、二进制或 Base64 加载图像
- 支持 SFSymbol 系统图标
- 读取图像宽高、比例、方向与渲染信息
- 可进行翻转、着色与可拉伸处理
- 支持 PNG/JPEG 格式转换与 Base64 编码
- 生成缩略图与自定义渲染模式
- 可直接用于 `<Image>` 组件显示，支持浅色/深色模式自动切换



---
url: /zh/guide/Utilities/URLSession/BackgroundURLSession.md
---

# 后台网络会话

`BackgroundURLSession` 提供在 **Scripting app** 中发起、恢复与查询「后台可持续」的下载与上传任务的能力。

> **可用性：** 仅当脚本运行在主应用 (`Script.env === "index"`) 时可用。

***

## 命名空间：`BackgroundURLSession`

### 1) `startDownload(options): URLSessionDownloadTask`

**作用**：启动一个新的后台下载任务。

**签名**

```ts
function startDownload(options: {
  url: string
  destination: string
  headers?: Record<string, string>
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionDownloadTask
```

**参数说明**

- `url` (`string`)：要下载的文件 URL。
- `destination` (`string`)：下载完成后保存的目标文件路径。
- `headers` (`Record<string, string>`, 可选)：HTTP 请求头。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：下载完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionDownloadTask`：下载任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.startDownload({
  url: 'https://example.com/file.zip',
  destination: '/var/mobile/Containers/.../Downloads/file.zip',
  headers: { 'User-Agent': 'Scripting/1.0' },
  notifyOnFinished: {
    success: '下载成功',
    failure: '下载失败'
  }
})

// 开始下载
task.resume()

// 监听进度与完成事件
task.onProgress = d => console.log('进度：', d.progress)
task.onFinishDownload = (err, info) => {
  if (!err) console.log('下载完成，文件保存于：', info.destination)
}
```

***

### 2) `resumeDownload(options): URLSessionDownloadTask`

**作用**：从断点续传数据恢复一个下载任务。

**签名**

```ts
function resumeDownload(options: {
  resumeData: Data
  destination: string
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionDownloadTask
```

**参数说明**

- `resumeData` (`Data`)：通过 `cancelByProducingResumeData()` 获取的断点数据。
- `destination` (`string`)：下载完成后的目标保存路径。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：下载完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionDownloadTask`：下载任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.resumeDownload({
  resumeData,
  destination: '/.../Downloads/file.zip',
  notifyOnFinished: true
})

// 开始续传
task.resume()

task.onFinishDownload = (err, info) => {
  if (!err) console.log('续传完成：', info.destination)
}
```

***

### 3) `getDownloadTasks(): Promise<URLSessionDownloadTask[]>`

**作用**：获取当前系统中仍存在的后台下载任务。
脚本被终止或重启后，可通过该方法重新获取任务实例并重新设置回调。

**签名**

```ts
function getDownloadTasks(): Promise<URLSessionDownloadTask[]>
```

**返回值**

- `Promise<URLSessionDownloadTask[]>`：下载任务对象数组。

**示例**

```ts
const tasks = await BackgroundURLSession.getDownloadTasks()
for (const task of tasks) {
  console.log('任务ID:', task.id, '状态:', task.state)
  task.onComplete = err => {
    if (err) console.error('下载失败：', err)
  }
}
```

***

### 4) `startUpload(options): URLSessionUploadTask`

**作用**：启动一个新的后台上传任务。

**签名**

```ts
function startUpload(options: {
  filePath: string
  toURL: string
  method?: string
  headers?: Record<string, string>
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionUploadTask
```

**参数说明**

- `filePath` (`string`)：要上传的本地文件路径。
- `toURL` (`string`)：服务器目标 URL。
- `method` (`string`, 可选，默认 `"POST"`)：HTTP 请求方法。
- `headers` (`Record<string, string>`, 可选)：HTTP 请求头。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：上传完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionUploadTask`：上传任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.startUpload({
  filePath: '/.../upload.bin',
  toURL: 'https://api.example.com/upload',
  method: 'PUT',
  headers: { Authorization: 'Bearer token' },
  notifyOnFinished: {
    success: '上传成功',
    failure: '上传失败'
  }
})

// 开始上传
task.resume()

task.onComplete = err => {
  if (!err) console.log('上传完成')
  else console.error('上传失败：', err)
}
```

***

### 5) `resumeUpload(options): URLSessionUploadTask`

**作用**：恢复一个可续传的上传任务。

**签名**

```ts
function resumeUpload(options: {
  resumeData: Data
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionUploadTask
```

**参数说明**

- `resumeData` (`Data`)：先前上传任务失败时生成的续传数据。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：上传完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionUploadTask`：新的上传任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.resumeUpload({
  resumeData,
  notifyOnFinished: {
    success: '上传成功',
    failure: '上传失败'
  }
})

// 开始续传
task.resume()

task.onComplete = err => {
  if (!err) console.log('上传续传完成')
}
```

***

### 6) `getUploadTasks(): Promise<URLSessionUploadTask[]>`

**作用**：获取系统中仍存在的后台上传任务，用于脚本重启后恢复任务状态与回调。

**签名**

```ts
function getUploadTasks(): Promise<URLSessionUploadTask[]>
```

**返回值**

- `Promise<URLSessionUploadTask[]>`：上传任务数组。

**示例**

```ts
const tasks = await BackgroundURLSession.getUploadTasks()
for (const t of tasks) {
  console.log('任务ID:', t.id, '状态:', t.state)
  t.onComplete = err => {
    if (err) console.error('上传失败：', err)
  }
}
```

***

## 使用说明与建议

- **暂停与恢复：** 如果调用了 `task.suspend()` 暂停任务，则可通过 `task.resume()` 恢复。
- **断点续传：** 下载任务可通过 `cancelByProducingResumeData()` 生成续传数据；上传任务是否支持续传取决于服务器。
- **任务恢复：** 当脚本被系统终止后，后台任务仍会继续。重新启动脚本后，可使用 `getDownloadTasks()` 或 `getUploadTasks()` 取回并重新绑定事件回调。
- **通知提示：** `notifyOnFinished` 仅影响任务完成时的本地通知显示，不影响任务执行流程。



---
url: /zh/guide/Utilities/URLSession/URLSessionDownloadTask.md
---

# 下载任务

`URLSessionDownloadTask` 表示一个后台下载任务实例。
它由 `BackgroundURLSession.startDownload()` 或 `BackgroundURLSession.resumeDownload()` 创建，用于在前台或后台下载文件，并可在脚本被终止后继续运行。

每个下载任务都由系统负责调度与执行，并提供进度、状态和事件回调等信息。
任务在创建后需手动调用 `resume()` 开始任何。

***

## 属性（Properties）

### `id: string`

下载任务的唯一标识符。
可用于在脚本重启后识别同一个下载任务。

**示例**

```ts
console.log(task.id) // 输出任务唯一 ID
```

***

### `state: URLSessionTaskState`

当前任务的状态。

可能的值包括：

- `"running"`：任务正在进行中
- `"suspended"`：任务已暂停
- `"canceling"`：任务正在取消中
- `"completed"`：任务已完成
- `"unknown"`：状态未知（通常表示任务已被系统移除）

**示例**

```ts
if (task.state === "running") {
  console.log("下载中…")
}
```

***

### `progress: URLSessionProgress`

任务的实时进度信息。

包含以下字段：

- `fractionCompleted: number`：完成比例（0–1）
- `totalUnitCount: number`：总字节数
- `completedUnitCount: number`：已完成字节数
- `isFinished: boolean`：是否已完成
- `estimatedTimeRemaining: number | null`：预计剩余时间（秒），可能为 `null`

**示例**

```ts
const p = task.progress
console.log(`已完成 ${(p.fractionCompleted * 100).toFixed(2)}%`)
```

***

### `priority: number`

任务的优先级（0.0–1.0），默认值为 `0.5`。
值越高，系统越可能优先调度此任务。

**示例**

```ts
task.priority = 0.8
```

***

### `earliestBeginDate?: Date | null`

任务可开始执行的最早时间。
可用于延迟任务开始（例如在网络空闲时再执行）。

**示例**

```ts
task.earliestBeginDate = new Date(Date.now() + 10_000) // 延迟 10 秒后可开始
```

***

### `countOfBytesClientExpectsToSend: number`

客户端预计将要发送的字节数（仅供系统参考，不影响任务执行）。

### `countOfBytesClientExpectsToReceive: number`

客户端预计将要接收的字节数（仅供系统参考，不影响任务执行）。

***

## 回调函数（Callbacks）

### `onProgress?: (details) => void`

当下载进度变化时调用。
`details` 参数包含：

- `progress: number`：完成比例（0–1）
- `bytesWritten: number`：本次写入的字节数
- `totalBytesWritten: number`：已下载的总字节数
- `totalBytesExpectedToWrite: number`：预期的总下载字节数

**示例**

```ts
task.onProgress = details => {
  console.log(`下载进度：${(details.progress * 100).toFixed(1)}%`)
}
```

***

### `onFinishDownload?: (error, details) => void`

当下载完成（或失败）后调用。

**参数说明**

- `error: Error | null`：若下载失败则为错误对象，否则为 `null`。
- `details.temporary: string`：临时文件路径。
- `details.destination: string | null`：目标文件路径（如果下载成功则为目标路径，否则可能为 `null`）。

**注意**：文件在下载完成后系统会自动移动到指定 `destination` 路径。

**示例**

```ts
task.onFinishDownload = (error, details) => {
  if (error) {
    console.error("下载失败：", error)
  } else {
    console.log("下载完成，文件保存于：", details.destination)
  }
}
```

***

### `onComplete?: (error, resumeData) => void`

任务完全结束时调用，无论成功或失败都会触发。

**参数说明**

- `error: Error | null`：若任务失败则为错误对象，否则为 `null`。
- `resumeData: Data | null`：如果任务支持断点续传且失败，可通过此数据恢复下载。

**示例**

```ts
task.onComplete = (error, resumeData) => {
  if (error) {
    console.error("下载失败：", error)
    if (resumeData) {
      console.log("可使用 resumeData 续传")
    }
  } else {
    console.log("任务成功完成")
  }
}
```

***

## 方法（Methods）

### `suspend(): void`

暂停任务。
暂停后不会再产生网络流量，也不会超时。
稍后可通过 `resume()` 继续。

**示例**

```ts
task.suspend()
console.log("任务已暂停")
```

***

### `resume(): void`

恢复被暂停的任务。
仅在任务处于 `"suspended"` 状态时可调用。

**示例**

```ts
task.resume()
console.log("任务已恢复")
```

***

### `cancel(): void`

取消任务。
调用后立即返回，任务状态变为 `"canceling"`，完成后触发 `onComplete` 回调并带上错误信息。

**示例**

```ts
task.cancel()
console.log("任务已取消")
```

***

### `cancelByProducingResumeData(): Promise<Data | null>`

取消任务并生成可续传的数据。
若任务支持断点续传，返回的 `Data` 可用于恢复下载；否则返回 `null`。

可在之后使用：

```ts
BackgroundURLSession.resumeDownload({ resumeData, destination })
```

**示例**

```ts
const resumeData = await task.cancelByProducingResumeData()
if (resumeData) {
  console.log("任务已取消，可通过 resumeData 续传")
}
```

***

## 示例代码（完整流程）

```ts
const task = BackgroundURLSession.startDownload({
  url: "https://example.com/largefile.zip",
  destination: "/.../Downloads/largefile.zip",
  notifyOnFinished: {
    success: "下载成功",
    failure: "下载失败"
  }
})

// 开始任务
task.resume()

task.onProgress = ({ progress }) => {
  console.log(`下载进度：${(progress * 100).toFixed(1)}%`)
}

task.onFinishDownload = (error, details) => {
  if (error) {
    console.error("下载出错：", error)
  } else {
    console.log("下载完成：", details.destination)
  }
}

task.onComplete = async (error, resumeData) => {
  if (error && resumeData) {
    console.log("可继续下载，保存 resumeData 以备后续恢复")
  }
}
```

***

## 注意事项与最佳实践

- 任务创建后需调用 `resume()` 开始下载。
- 任务暂停后（`suspend()`）可稍后用 `resume()` 继续执行。
- 使用 `cancelByProducingResumeData()` 可实现**断点续传**功能。
- 即使脚本退出或被系统终止，下载仍会在后台继续执行。
- 重新启动脚本后可通过 `BackgroundURLSession.getDownloadTasks()` 找回任务并重新绑定回调。
- 建议为长时间任务设置 `notifyOnFinished` 以便用户了解进度完成状态。



---
url: /zh/guide/Utilities/URLSession/URLSessionUploadTask.md
---

# 上传任务

`URLSessionUploadTask` 表示一个后台上传任务实例。
它由 `BackgroundURLSession.startUpload()` 或 `BackgroundURLSession.resumeUpload()` 创建，用于在前台或后台上传文件。
上传任务由系统管理，可以在应用或脚本被暂停、切换到后台甚至被终止后继续执行。

每个上传任务都提供状态、进度信息，以及多个回调事件以便追踪上传过程。

***

## 属性（Properties）

### `id: string`

任务的唯一标识符。
可用于脚本重启后识别并恢复同一个上传任务。

**示例**

```ts
console.log(task.id) // 输出任务唯一ID
```

***

### `state: URLSessionTaskState`

上传任务的当前状态。

可能的值包括：

- `"running"`：任务正在上传中
- `"suspended"`：任务已暂停
- `"canceling"`：任务正在取消
- `"completed"`：任务已完成
- `"unknown"`：状态未知（可能任务已被系统清除）

**示例**

```ts
if (task.state === "running") {
  console.log("文件上传中…")
}
```

***

### `progress: URLSessionProgress`

任务的实时进度信息。

包含以下字段：

- `fractionCompleted: number`：完成比例（0–1）
- `totalUnitCount: number`：总字节数
- `completedUnitCount: number`：已上传的字节数
- `isFinished: boolean`：是否已完成
- `estimatedTimeRemaining: number | null`：预计剩余时间（秒），可能为 `null`

**示例**

```ts
const p = task.progress
console.log(`上传进度 ${(p.fractionCompleted * 100).toFixed(1)}%`)
```

***

### `priority: number`

任务优先级（范围 0.0–1.0），默认值为 `0.5`。
数值越高，系统越倾向于优先调度此任务。

**示例**

```ts
task.priority = 0.8
```

***

### `earliestBeginDate?: Date | null`

任务可以开始的最早时间。
可用于延迟任务启动，例如等到网络空闲或充电时执行。

**示例**

```ts
task.earliestBeginDate = new Date(Date.now() + 5_000) // 5秒后可开始上传
```

***

### `countOfBytesClientExpectsToSend: number`

客户端预估将要上传的字节数，仅供系统参考。

### `countOfBytesClientExpectsToReceive: number`

客户端预估将要接收的字节数，仅供系统参考。

***

## 回调函数（Callbacks）

### `onReceiveData?: (data: Data) => void`

当服务器返回响应数据时触发。
参数 `data` 为服务端返回的二进制内容（`Data` 对象）。

**示例**

```ts
task.onReceiveData = data => {
  console.log("收到响应数据：", data.length, "字节")
}
```

***

### `onComplete?: (error: Error | null, resumeData: Data | null) => void`

当上传任务完成（成功或失败）后触发。

**参数说明**

- `error`：若上传失败则为错误对象，否则为 `null`。
- `resumeData`：若上传失败且支持断点续传，包含可用于恢复的 `Data` 对象，否则为 `null`。

**示例**

```ts
task.onComplete = (error, resumeData) => {
  if (error) {
    console.error("上传失败：", error)
    if (resumeData) {
      console.log("任务支持断点续传，可稍后恢复")
    }
  } else {
    console.log("上传完成！")
  }
}
```

***

## 方法（Methods）

### `suspend(): void`

暂停上传任务。
暂停后不会再产生网络流量，也不会超时。可通过 `resume()` 继续。

**示例**

```ts
task.suspend()
console.log("任务已暂停")
```

***

### `resume(): void`

恢复被暂停的上传任务。
新创建的任何任务都处于暂停状态，需要调用 `resume()` 才能开始上传。

**示例**

```ts
task.resume()
console.log("任务已恢复上传")
```

***

### `cancel(): void`

取消上传任务。
调用后任务会立即进入 `"canceling"` 状态，完成取消后触发 `onComplete` 回调并返回错误信息。

**示例**

```ts
task.cancel()
console.log("任务已取消")
```

***

## 示例代码（完整上传流程）

```ts
const task = BackgroundURLSession.startUpload({
  filePath: "/path/to/file.txt",
  toURL: "https://api.example.com/upload",
  method: "POST",
  headers: { Authorization: "Bearer my_token" },
  notifyOnFinished: true
})

task.resume()

task.onReceiveData = data => {
  console.log("收到服务器响应：", data.length, "字节")
}

task.onComplete = (error, resumeData) => {
  if (error) {
    console.error("上传出错：", error)
    if (resumeData) console.log("可以使用 resumeData 恢复上传")
  } else {
    console.log("上传成功！")
  }
}
```

***

## 注意事项与最佳实践

- 任务暂停（`suspend()`）后可通过 `resume()` 恢复。
- 某些服务器支持断点续传，可利用 `resumeData` 实现上传恢复。
- 即使脚本被终止或应用切换到后台，上传任务仍可继续执行。
- 可通过 `BackgroundURLSession.getUploadTasks()` 在脚本重启后找回仍在执行的任务，并重新绑定回调。
- 使用 `notifyOnFinished` 可在上传完成时显示本地通知，方便用户获知任务状态。
- 若需要携带鉴权信息（如 `Authorization`），请务必安全地管理凭证并在请求头中配置。



---
url: /zh/guide/Utilities/UUID.md
---

# UUID

`UUID` 模块提供了简便的方法来生成唯一的 UUID 字符串。

***

## 函数

### `string(): string`

生成一个新的 UUID（通用唯一标识符）字符串。

- **返回值**：\
  一个 UUID 格式的字符串，例如 `"550e8400-e29b-41d4-a716-446655440000"`。

***

## 使用示例

```tsx
const id = UUID.string()
console.log('生成的 UUID：', id)
```



---
url: /zh/guide/Utilities/WebScoket.md
---

# WebScoket

`WebSocket` 类提供了创建和管理 WebSocket 连接的接口，允许与服务器进行实时通信。你可以通过 WebSocket 连接发送和接收文本和二进制数据，包括字节缓冲区。

***

## 概述

WebSocket 是一种通信协议，允许客户端与服务器之间进行全双工通信。这使其非常适用于实时应用程序，如即时消息、通知或数据流。

***

## 类：`WebSocket`

### 构造函数

#### `new WebSocket(url: string)`

创建一个新的 WebSocket 连接到指定的 URL，并立即尝试建立连接。

- **参数**：
  - `url: string`：要连接的 WebSocket 服务器 URL。示例：`"ws://example.com/socket"` 或 `"wss://example.com/socket"`（对于安全的 WebSocket 连接）。

- **返回**：一个表示连接的 `WebSocket` 对象。

***

### 属性

- **`url: string`**\
  WebSocket 连接的 URL。此属性为只读。

- **`onopen?: () => void`**\
  可选的回调函数，当 WebSocket 连接成功建立时触发。

- **`onerror?: (error: Error) => void`**\
  可选的回调函数，当 WebSocket 连接或通信发生错误时触发。

- **`onmessage?: (message: string | Data) => void`**\
  可选的回调函数，当从 WebSocket 服务器接收到消息时触发。`message` 参数可以是字符串或二进制数据（由 `Data` 类表示）。

- **`onclose?: (reason?: string) => void`**\
  可选的回调函数，当 WebSocket 连接关闭时触发。`reason` 参数提供了关闭连接的可选解释。

***

### 方法

#### `send(message: string | Data): void`

通过 WebSocket 连接向服务器发送数据。

- **参数**：
  - `message: string | Data`：要发送到服务器的数据。可以是字符串或 `Data` 类的实例。

- **返回**：`void`

#### `close(code?: 1000 | 1001 | 1002 | 1003, reason?: string): void`

关闭 WebSocket 连接。如果连接已经关闭，则此方法不执行任何操作。

- **参数**：
  - `code?: 1000 | 1001 | 1002 | 1003`：可选的 WebSocket 连接关闭代码。常见的代码包括：
    - `1000`：正常关闭
    - `1001`：离开
    - `1002`：协议错误
    - `1003`：不支持的数据类型
  - `reason?: string`：可选的关闭连接原因。此字符串的长度不得超过 123 字节（UTF-8 编码）。

- **返回**：`void`

***

### 事件处理

你可以使用 `addEventListener` 来监听 WebSocket 事件，并使用 `removeEventListener` 来移除事件监听器。

#### `addEventListener(event: "open", listener: () => void): void`

为 `"open"` 事件添加事件监听器，该事件在 WebSocket 连接建立时触发。

#### `addEventListener(event: "error", listener: (error: Error) => void): void`

为 `"error"` 事件添加事件监听器，该事件在 WebSocket 连接发生错误时触发。

#### `addEventListener(event: "message", listener: (message: string | Data) => void): void`

为 `"message"` 事件添加事件监听器，该事件在从 WebSocket 服务器接收到消息时触发。

#### `addEventListener(event: "close", listener: (reason?: string) => void): void`

为 `"close"` 事件添加事件监听器，该事件在 WebSocket 连接关闭时触发。

#### `removeEventListener(event: "open", listener: () => void): void`

移除 `"open"` 事件的事件监听器。

#### `removeEventListener(event: "error", listener: (error: Error) => void): void`

移除 `"error"` 事件的事件监听器。

#### `removeEventListener(event: "message", listener: (message: string | Data) => void): void`

移除 `"message"` 事件的事件监听器。

#### `removeEventListener(event: "close", listener: (reason?: string) => void): void`

移除 `"close"` 事件的事件监听器。

***

## 示例使用

### 建立 WebSocket 连接

```ts
const ws = new WebSocket("wss://example.com/socket")

// 设置事件监听器
ws.addEventListener("open", () => {
  console.log("连接已建立！")
  ws.send("你好，服务器！")
})

ws.addEventListener("message", (message) => {
  console.log("接收到消息：", message)
})

ws.addEventListener("error", (error) => {
  console.log("WebSocket 错误：", error)
})

ws.addEventListener("close", (reason) => {
  console.log("连接已关闭：", reason)
})
```

### 发送字符串消息

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("open", () => {
  ws.send("你好，这是测试消息！")
})
```

### 使用 `Data` 发送二进制数据

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("open", () => {
  const data = Data.fromString("一些消息")
  ws.send(data) // 发送二进制数据
})
```

### 处理二进制数据

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("message", (message) => {
  if (message instanceof Data) {
    const byteArray = message.getBytes()
    if (byteArray) {
      console.log("接收到的二进制数据：", byteArray)
    }
  }
})
```

### 关闭 WebSocket 连接

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("open", () => {
  console.log("连接已建立！")
  // 使用自定义原因关闭连接
  ws.close(1000, "测试后关闭连接")
})
```

***

## 注意事项

- `send()` 方法可以处理文本和二进制数据。对于二进制数据，你可以使用 `Data` 类来处理字节缓冲区。
- 对于二进制数据，请确保你的 WebSocket 服务器能够处理二进制数据，例如 `ArrayBuffer` 或 `Uint8Array`。
- `close()` 方法可以接受 `code` 和可选的 `reason` 参数来指定 WebSocket 连接如何关闭。



---
url: /zh/guide/Utilities/socket.io.md
---

# socket.io

`Socket.IO` API 提供强大的工具，用于管理客户端与服务器之间的实时双向通信。它包括 `SocketManager`（用于管理多个命名空间）和 `SocketIOClient`（用于单个 socket 连接）。以下是该 API 的详细使用指南，包括设置、配置和常见用例。

***

## 入门

通过 `SocketManager` 创建和管理 WebSocket 连接。每个 `SocketManager` 可以管理多个命名空间和配置。

### 示例：

```typescript
// 创建一个 SocketManager 实例
const manager = new SocketManager("http://localhost:8080", {
    reconnects: true,
    reconnectAttempts: 5,
    compress: true
})

// 获取默认命名空间的 socket
const defaultSocket = manager.defaultSocket

// 创建特定命名空间的 socket
const roomASocket = manager.socket("/roomA")
```

***

## API 参考

### `SocketManager`

#### 构造函数

**`constructor(url: string, config?: SocketManagerConfig)`**

- **`url`**：Socket.IO 服务器的 URL。
- **`config`**：可选的配置对象。

#### 属性

- **`socketURL: string`**：服务器 URL。
- **`status: SocketIOStatus`**：连接状态（如 `connected`、`connecting`、`disconnected` 等）。
- **`defaultSocket: SocketIOClient`**：默认命名空间（`"/"`）的 socket。

#### 方法

- **`socket(namespace: string): SocketIOClient`**\
  返回指定命名空间的 `SocketIOClient`。

- **`setConfigs(config: SocketManagerConfig): void`**\
  更新管理器配置。

- **`disconnect(): void`**\
  断开所有由此实例管理的 socket 连接。

- **`reconnect(): void`**\
  尝试重新连接服务器。

***

### `SocketIOClient`

#### 属性

- **`id: string | null`**：socket 连接的唯一标识符。
- **`status: SocketIOStatus`**：客户端连接状态（如 `connected`、`connecting` 等）。

#### 方法

- **`connect(): void`**\
  发起连接。

- **`disconnect(): void`**\
  断开连接。

- **`emit(event: string, data: any): void`**\
  向服务器发送带有数据的事件。

- **`on(event: string, callback: (data: any[], ack: (value?: any) => void) => void): void`**\
  注册事件监听器。

***

## 配置

通过 `SocketManagerConfig` 对象自定义连接行为。

### 关键选项：

- **`compress`**：启用 WebSocket 传输的压缩。
- **`connectParams`**：连接 URL 中包含的 GET 参数。
- **`cookies`**：在初始连接中发送的 cookies。
- **`forceNew`**：确保每次连接都创建一个新的引擎实例。
- **`reconnects`**：启用自动重连。
- **`reconnectAttempts`**：最大重连次数。
- **`reconnectWait`**：重连尝试之间的最小时间（秒）。

### 示例：

```typescript
const config: SocketManagerConfig = {
    compress: true,
    reconnects: true,
    reconnectAttempts: 5,
    reconnectWait: 2,
    extraHeaders: {
        Authorization: "Bearer token"
    }
}
const manager = new SocketManager("http://example.com", config)
```

***

## 常见用例

### 发送和监听事件

```typescript
const socket = manager.defaultSocket

socket.on("connect", () => {
    console.log("成功连接服务器")
    socket.emit("joinRoom", { room: "roomA" })
})

socket.on("message", (data) => {
    console.log("收到消息：", data)
})
```

### 处理重连

```typescript
manager.setConfigs({ reconnects: true, reconnectAttempts: 10 })

manager.defaultSocket.on("reconnect", () => {
    console.log("已重新连接服务器")
})
```

### 使用命名空间

```typescript
const chatSocket = manager.socket("/chat")

chatSocket.on("newMessage", (data) => {
    console.log("聊天中收到新消息：", data)
})
```

***

## 最佳实践

1. **生命周期管理**：不再需要时调用 `disconnect()`。
2. **命名空间隔离**：为逻辑上不同的通信通道使用独立命名空间。
3. **重连策略**：根据应用需求配置重连参数。
4. **错误处理**：注册 `on("error")` 监听器以优雅地处理连接问题。
5. **安全连接**：对于敏感数据，使用安全 WebSocket（WSS），并配置 `secure: true`。

***

## 完整示例

```typescript
// 创建一个带配置的 SocketManager
const manager = new SocketManager("https://example.com", {
    reconnects: true,
    reconnectAttempts: -1,
    reconnectWait: 1
})

// 获取默认命名空间
const socket = manager.defaultSocket

// 注册事件处理器
socket.on("connect", () => {
    console.log("已连接到服务器")
    socket.emit("join", { room: "lobby" })
})

socket.on("message", (data) => {
    console.log("收到消息：", data)
})

socket.on("disconnect", () => {
    console.log("已断开连接")
})

// 发送自定义事件
socket.emit("sendMessage", { text: "你好，世界！" })

// 完成后断开连接
setTimeout(() => {
    manager.disconnect()
}, 60000)
```



---
url: /zh/guide/View Modifiers/Animation and Transition.md
---

# 动画和过渡

Scripting 通过 `Observable` / `useObservable`、`Animation`、`Transition`、`withAnimation` 以及视图的 `animation` / `transition` 属性，基本对齐了 SwiftUI 的动画能力，包括：

- **属性动画**：数值、颜色、布局等属性随状态变化平滑过渡
- **过渡动画**：视图插入 / 移除时的进出效果（如淡入淡出、滑入滑出、翻转）
- **显式动画**：通过 `withAnimation` 包裹一段「状态更新代码」统一加动画

## Animation 类

`Animation` 用来描述「属性变化的时间曲线与节奏」，类似 SwiftUI 的 `Animation`。

### 工厂方法（创建动画）

#### `Animation.default()`

```ts
static default(): Animation
```

- 创建一个默认动画（通常是系统预设的 ease-in-out 曲线）
- 无需配置，适合「只想要一个普通的过渡效果」的场景

示例：

```tsx
<Text animation={{
  animation: Animation.default(),
  value: value
}}>默认动画</Text>
```

***

#### `Animation.linear(duration?)`

```ts
static linear(duration?: DurationInSeconds | null): Animation
```

- 匀速动画，整段时间内速度保持恒定
- `duration`：动画持续时间（秒），可选，不传时使用默认时长

适合：进度条数值增长、颜色线性变化等。

***

#### `Animation.easeIn(duration?)`

```ts
static easeIn(duration?: DurationInSeconds | null): Animation
```

- 开始慢、后面加速
- 适合：元素「加速进入」的感觉

***

#### `Animation.easeOut(duration?)`

```ts
static easeOut(duration?: DurationInSeconds | null): Animation
```

- 开始快、结尾慢
- 适合：元素「减速停止」的感觉，如卡片滑入后停在目标位置

***

#### `Animation.bouncy(options?)`

```ts
static bouncy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 带回弹效果的动画
- 参数：

  - `duration`：总时长（秒）
  - `extraBounce`：额外弹性，越大越明显

适合：按钮点击放大回弹、卡片弹出等「有趣」的动效。

***

#### `Animation.smooth(options?)`

```ts
static smooth(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 相对柔和、过渡自然的动画
- 与 `bouncy` 相比，弹性感更弱，更偏「丝滑」

***

#### `Animation.snappy(options?)`

```ts
static snappy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 动作「干脆利落」，响应速度快
- 常见于触控反馈、选中高亮等瞬间反馈场景

***

#### `Animation.spring(options?)`

```ts
static spring(options?: {
  blendDuration?: number
} & ({
  duration?: DurationInSeconds
  bounce?: number
  response?: never
  dampingFraction?: never
} | {
  response?: number
  dampingFraction?: number
  duration?: never
  bounce?: never
})): Animation
```

支持两种配置方式（注意互斥）：

1. **基于时长的弹簧动画**

   - `duration`: 动画持续时间
   - `bounce`: 弹性大小

2. **物理参数模式**

   - `response`: 响应速度（值越小反馈越快）
   - `dampingFraction`: 阻尼系数（0\~1，越大越「稳」，越小越「弹」）

额外参数：

- `blendDuration`：动画混合时长，用于多动画衔接场景（可选）

示例：

```tsx
// 简单弹簧
const anim1 = Animation.spring({
  duration: 0.4,
  bounce: 0.3
})

// 高级弹簧
const anim2 = Animation.spring({
  response: 0.25,
  dampingFraction: 0.7
})
```

***

#### `Animation.interactiveSpring(options?)`

```ts
static interactiveSpring(options?: {
  response?: number
  dampingFraction?: number
  blendDuration?: number
}): Animation
```

- 面向「交互驱动」的弹簧动画，例如拖拽结束后的回弹
- 参数与 `spring` 的物理参数模式类似，语义更偏向手势交互

***

#### 0 `Animation.interpolatingSpring(options?)`

```ts
static interpolatingSpring(options?: {
  mass?: number
  stiffness: number
  damping: number
  initialVelocity?: number
} | {
  duration?: DurationInSeconds
  bounce?: number
  initialVelocity?: number
  mass?: never
  stiffness?: never
  damping?: never
}): Animation
```

两种配置方式（互斥）：

1. **物理参数模式**

   - `mass`: 质量
   - `stiffness`: 刚度
   - `damping`: 阻尼
   - `initialVelocity`: 初速度（可选）

2. **时长 + 弹性模式**

   - `duration`: 动画时长
   - `bounce`: 弹性
   - `initialVelocity`: 初速度（可选）

适合对动态效果「非常在意手感」的高级场景。

***

### 修改已有动画（链式 API）

#### `delay(time)`

```ts
delay(time: DurationInSeconds): Animation
```

- 使动画延迟 `time` 秒后再开始
- 返回一个新的 `Animation` 实例（原动画不变）

示例：

```tsx
const [animValue, setAnimValue] = useState(0)
const anim = Animation
  .spring({ duration: 0.4, bounce: 0.3 })
  .delay(0.2)

<Text animation={{
  animation: anim,
  value: animValue
}>延迟弹簧</Text>
```

***

#### `repeatCount(count, autoreverses?)`

```ts
repeatCount(count: number, autoreverses?: boolean): Animation
```

- 重复执行动画 `count` 次
- `autoreverses`（默认 `true`）：是否来回反向播放

示例：

```tsx
const pulse = Animation
  .easeIn(0.6)
  .repeatCount(3, true)

<Text animation={{
  animation: pulse,
  value: value
}}>闪烁三次</Text>
```

***

#### `repeatForever(autoreverses?)`

```ts
repeatForever(autoreverses?: boolean): Animation
```

- 无限次重复动画
- 适合加载动画、呼吸灯效果等

***

### Animation 实战示例

#### 示例 1：基本大小动画

```tsx
import { VStack, Button, Rectangle, useObservable, Animation, withAnimation } from "scripting"

export function Demo() {
  const size = useObservable(80)

  return <VStack spacing={16}>
    <Rectangle
      frame={{ width: size.value, height: size.value }}
      backgroundColor="blue"
      animation={{
        animation: Animation.spring({ duration: 0.3, bounce: 0.2 }),
        value: size.value
      }}
    />

    <Button
      title="Toggle Size"
      action={() => {
        withAnimation(() => {
          size.setValue(size.value === 80 ? 140 : 80)
        })
      }}
    />
  </VStack>
}
```

***

## Transition 类（视图过渡）

`Transition` 描述的是**视图插入与移除**时的「进场 / 退场效果」，对应 SwiftUI 的 `AnyTransition`。

> 注意：只有当视图在 JSX 中「存在与否」发生变化（如 `{visible.value && <Text ... />}`）时，`transition` 才会生效。

### 实例方法

#### `animation(animation?)`

```ts
animation(animation?: Animation): Transition
```

- 为当前过渡指定（或覆盖）使用的 `Animation`
- 不传时使用默认动画

示例：

```tsx
const t = Transition
  .move("bottom")
  .animation(Animation.spring({ duration: 0.4 }))
```

***

#### `combined(other)`

```ts
combined(other: Transition): Transition
```

- 组合两个过渡效果，类似 SwiftUI 的 `.combined`
- 如：向下滑入 + 淡入

示例：

```tsx
const t = Transition
  .move("bottom")
  .combined(Transition.opacity())
```

在视图中使用：

```tsx
<Text transition={t}>组合过渡</Text>
```

***

### 静态方法（构造不同类型的过渡）

#### `Transition.identity()`

```ts
static identity(): Transition
```

- 「没有任何过渡」，视图插入 / 移除时不会做动画
- 通常用于禁用某些分支的过渡效果

***

#### `Transition.move(edge)`

```ts
static move(edge: Edge): Transition
```

- 从某个边缘移入 / 移出
- `edge` 通常是 `"leading" | "trailing" | "top" | "bottom"` 等（和 SwiftUI 对齐）

示例：

```tsx
<Text transition={Transition.move("leading")}>
  从左侧滑入 / 滑出
</Text>
```

***

#### `Transition.offset(position?)`

```ts
static offset(position?: Point): Transition
```

- 通过偏移实现过渡
- `position`: `{ x: number, y: number }`，默认 `{ x: 0, y: 0 }`

例如：

```tsx
<Text
  transition={Transition.offset({ x: 0, y: 40 })}
>
  从下方位移进出
</Text>
```

***

#### `Transition.pushFrom(edge)`

```ts
static pushFrom(edge: Edge): Transition
```

- 类似导航 push 的效果，从某个边缘推入并把旧内容推走
- 适合做「页面切换」类效果

***

#### `Transition.opacity()`

```ts
static opacity(): Transition
```

- 单纯的淡入 / 淡出
- 与 `Animation` 搭配可以控制淡入淡出的节奏

***

#### `Transition.scale(scale?, anchor?)`

```ts
static scale(
  scale?: number,
  anchor?: Point | KeywordPoint
): Transition
```

- 缩放过渡
- `scale`：缩放比（默认 1）
- `anchor`：缩放基准点，支持：

  - `Point`：如 `{ x: 0.5, y: 0.5 }`
  - `KeywordPoint`：如 `"center"`、`"top"`, `"bottom"` 等（具体值与 Scripting 内部对齐）

示例：

```tsx
<Text
  transition={Transition.scale(0.8, "center")}
>
  缩放进出
</Text>
```

***

#### `Transition.slide()`

```ts
static slide(): Transition
```

- 类似 SwiftUI 的 `.slide`，通常是从一侧滑入 / 滑出（具体方向由系统决定）
- 常用于列表项、简单出现 / 消失效果

***

#### `Transition.fade(duration?)`

```ts
static fade(duration?: DurationInSeconds): Transition
```

- 带时长配置的淡入 / 淡出
- 与 `Transition.opacity()` 类似，但可以直接指定过渡时间

***

#### Flip 系列（翻转过渡）

```ts
static flipFromLeft(duration?: DurationInSeconds): Transition
static flipFromBottom(duration?: DurationInSeconds): Transition
static flipFromRight(duration?: DurationInSeconds): Transition
static flipFromTop(duration?: DurationInSeconds): Transition
```

- 类似卡片翻转的 3D 过渡

示例：

```tsx
<Text
  transition={Transition.flipFromLeft(0.4)}
>
  左侧翻入 / 翻出
</Text>
```

***

#### 0 `Transition.asymmetric(insertion, removal)`

```ts
static asymmetric(
  insertion: Transition,
  removal: Transition
): Transition
```

- 插入和移除使用不同的过渡效果
- 典型用法：进入时从下方滑入，离开时淡出

示例：

```tsx
const appear = Transition
  .move("bottom")
  .combined(Transition.opacity())

const disappear = Transition.opacity()

const t = Transition.asymmetric(appear, disappear)

<Text transition={t}>不对称过渡</Text>
```

***

### Transition 实战示例

#### 示例：多种过渡效果对比

```tsx
const visible = useObservable(true)

return <VStack spacing={12}>
  {visible.value &&
    <Text
      transition={Transition.slide().combined(Transition.opacity())}
    >
      Slide + Fade
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.move("leading")}
    >
      Move leading
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.scale()}
    >
      Scale
    </Text>
  }

  <Button
    title="Toggle"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## withAnimation：显式动画入口

`withAnimation` 用来「显式」地将一段状态更新包裹在动画上下文中，类似 SwiftUI 的 `withAnimation`。
它返回 `Promise<void>`，方便在异步逻辑中等待动画完成。

### 重载签名

```ts
function withAnimation(body: () => void): Promise<void>
function withAnimation(animation: Animation, body: () => void): Promise<void>
function withAnimation(
  animation: Animation,
  completionCriteria: "logicallyComplete" | "removed",
  body: () => void
): Promise<void>
```

- 第一个重载：使用默认动画
- 第二个重载：指定动画曲线 / 弹性等
- 第三个重载：额外指定**完成条件**：

  - `"logicallyComplete"`：动画在时间轴上播放完成时视为完成（典型属性动画）
  - `"removed"`：通常用于涉及过渡的场景，等待相关视图被移出 / 动画结束后再继续逻辑（具体行为依赖底层 SwiftUI）

> 实际等待的精确时机由内部动画系统决定，一般可理解为「该动画相关的视图不再处于动画中」。

***

### 基本用法

#### 默认动画

```tsx
const size = useObservable(100)

<Button
  title="Toggle"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value === 100 ? 200 : 100)
    })
  }}
/>
```

***

#### 指定动画

```tsx
const visible = useObservable(true)

<Button
  title="Toggle Panel"
  action={() => {
    withAnimation(
      Animation.spring({ duration: 0.3, bounce: 0.2 }),
      () => {
        visible.setValue(!visible.value)
      }
    )
  }}
/>
```

***

#### 在异步函数中等待动画结束

```ts
async function hideThenRunTask() {
  await withAnimation(Animation.easeOut(0.25), () => {
    visible.setValue(false)
  })

  // 此处可以认为相关动画已经结束，再继续耗时任务或导航
  await doSomethingHeavy()
}
```

***

## 视图上的 animation / transition 属性

在 Scripting 的视图组件上，可以通过 props 的形式配置动画相关行为：

- `animation?: Animation`（属性动画）
- `transition?: Transition`（插入 / 移除过渡）

### 属性动画（animation）

属性动画的核心逻辑：

- 当某个视图依赖的 `Observable` 的 `value` 发生变化时
- 如果该视图设置了 `animation={...}` 或更新发生在 `withAnimation` 中
- 则 SwiftUI 会对这些属性差异进行插值，从原值平滑过渡到新值

示例：

```tsx
const size = useObservable(80)

<Rectangle
  frame={{
    width: size.value,
    height:size.value
  }}
  backgroundColor="green"
  animation={{
    animation: Animation.spring({ duration: 0.3, bounce: 0.25 }),
    value: size.value
  }}
/>
```

配合 `withAnimation`：

```tsx
<Button
  title="Grow"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value + 20)
    })
  }}
/>
```

***

### 过渡动画（transition）

过渡动画只在「视图从无到有 / 从有到无」时生效。

关键点：

- 通常通过条件渲染控制：

  ```tsx
  {visible.value && <Text transition={...}>Hello</Text>}
  ```

- 状态变化本身需要动画上下文（`withAnimation` 或默认动画）

- `Transition.animation(...)` 可为过渡指定特定 `Animation`

示例：条件面板的进出过渡

```tsx
const visible = useObservable(false)

<VStack>
  {visible.value &&
    <Text
      transition={Transition
        .move("bottom")
        .combined(Transition.opacity())
        .animation(Animation.spring({ duration: 0.35, bounce: 0.3 }))
      }
    >
      Panel
    </Text>
  }

  <Button
    title="Toggle Panel"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## 综合示例：列表增删带过渡与属性动画

```tsx
import {
  VStack,
  HStack,
  Text,
  Button,
  useObservable,
  Animation,
  Transition
} from "scripting"

type Item = { id: string; title: string }

export function AnimatedList() {
  const items = useObservable<Item[]>([
    { id: "1", title: "First" },
    { id: "2", title: "Second" }
  ])

  function addItem() {
    withAnimation(Animation.spring({ duration: 0.3 }), () => {
      const next = items.value.length + 1
      items.setValue([
        ...items.value,
        { id: String(next), title: `Item ${next}` }
      ])
    })
  }

  function removeLast() {
    if (items.value.length === 0) return
    withAnimation(Animation.easeOut(0.25), () => {
      items.setValue(items.value.slice(0, -1))
    })
  }

  return <VStack spacing={12}>
    {items.value.map(item =>
      <HStack
        key={item.id}
        transition={Transition
          .move("trailing")
          .combined(Transition.opacity())
        }
      >
        <Text>{item.title}</Text>
      </HStack>
    )}

    <HStack spacing={12}>
      <Button title="Add" action={addItem} />
      <Button title="Remove Last" action={removeLast} />
    </HStack>
  </VStack>
}
```

这个示例中：

- 使用 `Observable<Item[]>` 作为列表数据源
- `transition` 负责列表项插入 / 删除时的滑动 + 淡入淡出
- `withAnimation` 包裹增删操作，确保这些更新被动画化



---
url: /zh/guide/View Modifiers/Chaining View Modifiers.md
---

# 可链式调用的修饰符

`modifiers` 是一个支持链式调用的视图修饰器集合，允许你为同一个视图应用多个修饰器，并以严格的顺序依次执行。

与传统 TSX 中每个视图只能通过一个 `modifier` 属性传入单个修饰器不同，`modifiers` 支持：

- 同一种修饰器的重复使用（例如多个 `padding()`、`background()`）
- 明确控制修饰器的应用顺序
- 更贴近 SwiftUI 的声明方式和效果

***

## 类型定义

```ts
declare function modifiers(): ViewModifiers;

declare class ViewModifiers {
  padding(value): this;
  background(value): this;
  opacity(value): this;
  frame(value): this;
  font(value): this;
  // ... 还有更多方法（同 `CommonViewProps` 的属性）
}
```

`ViewModifiers` 是一个可链式调用的类，内部方法对应 SwiftUI 中的各类 View Modifier。每个方法返回自身（`this`），以支持流式调用。

***

## 使用优势

- **支持多次使用相同修饰器**
  如：连续嵌套多个 `.padding()` 或 `.background()`，可表达更加丰富的 UI 层级。

- **明确的顺序控制**
  修饰器按调用顺序依次生效，结果与 SwiftUI 一致。

- **更好的结构化与复用**
  可将复杂的修饰器链提取为变量或函数，增强可维护性与复用性。

- **更贴近 SwiftUI**
  如果你熟悉 SwiftUI，会发现 `modifiers()` 的调用方式几乎一模一样。

***

## 使用示例

### 示例 1：多层背景与内边距嵌套

```tsx
<VStack
  modifiers={
    modifiers()
      .padding()
      .background("red")
      .padding()
      .background("blue")
  }
>
  <Text>Hello</Text>
</VStack>
```

等价于 SwiftUI：

```swift
Text("Hello")
  .padding()
  .background(Color.red)
  .padding()
  .background(Color.blue)
```

### 示例 2：提取并复用修饰器链

```ts
const cardStyle = modifiers()
  .padding(12)
  .background("gray")
  .cornerRadius(8)
  .opacity(0.9)

<List modifiers={cardStyle}>
  <Text>Item 1</Text>
</List>
```

### 示例 3：根据条件动态生成修饰器

```ts
const base = modifiers().padding()

if (isDarkMode) {
  base.background("black")
} else {
  base.background("white")
}

return <HStack modifiers={base}>...</HStack>
```

***

## 使用建议

在以下情况中建议使用 `modifiers`：

- 需要对视图多次使用同一个修饰器（如 `padding()`）
- 希望拆分 UI 样式并复用一套完整的样式链
- 需要控制修饰器的执行顺序
- 需要在运行时根据条件动态组装修饰器

***

## 支持的修饰器方法

`ViewModifiers` 提供了超过 200 个修饰器方法，覆盖：

- **布局类**：`padding`、`frame`、`offset`、`position`、`zIndex` 等
- **样式类**：`background`、`foregroundStyle`、`opacity`、`shadow`、`clipShape` 等
- **文本字体类**：`font`、`bold`、`italic`、`kerning`、`underline` 等
- **交互事件类**：`onTapGesture`、`onAppear`、`contextMenu` 等
- **图表类**：`chartXAxis`、`chartYAxisLabel`、`chartSymbolScale` 等
- **组件专属类**：如 `widgetURL`、`widgetBackground` 等

> 可查阅完整的 `ViewModifiers` 类型定义以获取所有支持的方法。

***

## 注意事项

- 每次调用 `modifiers()` 会创建一个新的实例，不会与其他实例合并。
- 修饰器的执行顺序完全依赖于调用顺序。
- 当需要同一个修饰器在同一个视图上多次使用时，可以使用 `modifiers` 进行链式调用。

***

通过 `modifiers`，你可以实现更灵活、结构化、可复用的 UI 风格配置，构建贴近 SwiftUI 的声明式体验。适合构建复杂布局、响应式风格以及脚本组件样式抽象。



---
url: /zh/guide/View Modifiers/ChartMarkProps/index.md
---

# 通用图表标记属性 (ChartMarkProps)

`ChartMarkProps` 用于配置图表中的每一个 mark（例如柱状图的 BarMark、折线图的 LineMark 等），提供一系列通用的修饰属性，支持设置样式、符号、位置、注解、变换等内容。该类型可用于 `BarChart`、`LineChart`、`AreaChart` 等组件的 `marks` 属性中。

***

## 一、样式修饰

### `foregroundStyle`

设置图表内容的填充颜色或样式。

- 类型：`ShapeStyle | DynamicShapeStyle`
- 示例：

  ```tsx
  foregroundStyle: "systemGreen"
  ```

***

### `opacity`

设置透明度，取值范围为 `0.0 ~ 1.0`。

- 类型：`number`
- 示例：

  ```tsx
  opacity: 0.5
  ```

***

### `cornerRadius`

设置图形的圆角半径，常用于柱状图或胶囊图。

- 类型：`number`
- 示例：

  ```tsx
  cornerRadius: 8
  ```

***

### `lineStyle`

设置线条样式，适用于折线图或路径图。

- 类型：`StrokeStyle`
- 结构：

  ```ts
  {
    lineWidth?: number
    lineCap?: 'butt' | 'round' | 'square'
    lineJoin?: 'bevel' | 'miter' | 'round'
    mitterLimit?: number
    dash?: number[]
    dashPhase?: number
  }
  ```
- 示例：

  ```tsx
  lineStyle: {
    lineWidth: 2,
    lineCap: "round",
    dash: [4, 2]
  }
  ```

***

### `interpolationMethod`

设置线图或面积图的插值方式（曲线连接方式）。

- 类型：`ChartInterpolationMethod`
- 可选值：
  `"cardinal"`、`"catmullRom"`、`"linear"`、`"monotone"`、`"stepCenter"`、`"stepEnd"`、`"stepStart"`
- 示例：

  ```tsx
  interpolationMethod: "catmullRom"
  ```

***

### `alignsMarkStylesWithPlotArea`

样式是否与绘图区对齐。

- 类型：`boolean`
- 示例：

  ```tsx
  alignsMarkStylesWithPlotArea: true
  ```

***

## 二、符号设置（用于折线图或散点图）

### `symbol`

设置标记符号的形状，或使用自定义视图作为标记。

- 类型：`ChartSymbolShape | VirtualNode`
- 可选值：
  `"circle"`、`"square"`、`"triangle"`、`"diamond"`、`"cross"`、`"plus"`、`"asterisk"`、`"pentagon"`
- 示例：

  ```tsx
  symbol: "triangle"
  ```

***

### `symbolSize`

设置符号大小，可以是单一数值或包含宽高的对象。

- 类型：`number | { width: number; height: number }`
- 示例：

  ```tsx
  symbolSize: 18
  // 或
  symbolSize: { width: 16, height: 16 }
  ```

***

## 三、注解设置

### `annotation`

为某个 mark 添加注释视图，并可设置位置、对齐、间距及溢出处理策略。

- 类型：`VirtualNode | { position?, alignment?, spacing?, overflowResolution?, content }`
- 示例：

  ```tsx
  annotation: {
    position: "top",
    alignment: "center",
    spacing: 4,
    overflowResolution: {
      x: "fit",
      y: "padScale"
    },
    content: <Text>注解</Text>
  }
  ```

#### `AnnotationPosition` 注解位置

用于控制注解视图相对于 mark 的定位位置。

- 类型：字符串
- 可选值：
  `"automatic"`、`"top"`、`"topLeading"`、`"topTrailing"`、
  `"bottom"`、`"bottomLeading"`、`"bottomTrailing"`、
  `"leading"`、`"trailing"`、`"overlay"`

***

#### `AnnotationOverflowResolutionStrategy` 溢出处理策略

用于处理注解超出图表边界时的排版策略。

- 可选值：

  - `"automatic"`：自动选择合适的策略
  - `"fit"`：自动调整位置以适配边界
  - `"fitToPlot"`：限制在绘图区范围内
  - `"fitToChart"`：限制在整个图表范围内
  - `"fitToAutomatic"`：自动选择图表或绘图区
  - `"padScale"`：扩展坐标范围为注解留出空间
  - `"disabled"`：不处理溢出，允许剪裁

***

## 四、图形变换效果

### `clipShape`

设置图形裁剪区域的形状。

- 类型：`"rect"`、`"circle"`、`"capsule"`、`"ellipse"`、`"buttonBorder"`、`"containerRelative"`
- 示例：

  ```tsx
  clipShape: "capsule"
  ```

***

### `shadow`

为 mark 添加阴影。

- 类型：

  ```ts
  {
    color?: string
    radius: number
    x?: number
    y?: number
  }
  ```
- 示例：

  ```tsx
  shadow: {
    color: "systemGray",
    radius: 4,
    x: 2,
    y: 2
  }
  ```

***

### `blur`

添加模糊效果，数值越大模糊越强。

- 类型：`number`
- 示例：

  ```tsx
  blur: 5
  ```

***

### `zIndex`

控制 mark 在图层中的显示顺序。

- 类型：`number`
- 示例：

  ```tsx
  zIndex: 10
  ```

***

### `offset`

为 mark 设置偏移量，可控制其在 X/Y 轴上的位置偏移。

- 类型支持以下形式：

  - `{ x, y }`
  - `{ x, yStart, yEnd }`
  - `{ xStart, xEnd, y }`
  - `{ xStart, xEnd, yStart, yEnd }`
- 示例：

  ```tsx
  offset: { x: 10, y: -5 }
  ```

***

## 五、数据绑定修饰（`xxxBy`）

通过绑定数据字段实现动态设置样式或位置，不能与相同功能的静态属性同时使用。

***

### `foregroundStyleBy`

根据数据字段动态设置填充样式。

- 类型：`string | number | Date | { value, label }`
- 示例：

  ```tsx
  foregroundStyleBy: {
    value: item.color,
    label: "颜色"
  }
  ```

***

### `lineStyleBy`

根据数据字段动态设置线条样式。

- 示例：

  ```tsx
  lineStyleBy: {
    value: item.type,
    label: "线型"
  }
  ```

***

### `positionBy`

设置 mark 的位置和在图表坐标轴上的作用方向。

- 类型：

  ```ts
  {
    value: string | number | Date
    label?: string
    axis: 'horizontal' | 'vertical'
    span?: MarkDimension
  }
  ```
- 示例：

  ```tsx
  positionBy: {
    value: item.category,
    axis: "horizontal",
    span: {
      type: "ratio",
      value: 0.8
    }
  }
  ```

#### `MarkDimension` 标记尺寸控制

用于控制 mark 在轴向上的占用空间或尺寸。

- 类型：`"automatic"` 或：

  ```ts
  {
    type: "inset" | "fixed" | "ratio"
    value: number
  }
  ```
- 含义说明：

  - `"automatic"`：系统自动决定尺寸
  - `"inset"`：根据设定的边距减少宽度或高度
  - `"fixed"`：固定的像素尺寸
  - `"ratio"`：根据比例占据坐标轴步长（范围 0\~1）

***

### `symbolBy`

根据数据字段动态设置符号形状。

- 示例：

  ```tsx
  symbolBy: {
    value: item.category,
    label: "类型"
  }
  ```

***

### `symbolSizeBy`

根据数据字段动态设置符号大小。

- 示例：

  ```tsx
  symbolSizeBy: {
    value: item.count,
    label: "数量"
  }
  ```

***

## 示例：分组柱状图

```tsx
<BarChart
  marks={data.map(item => ({
    label: item.type,
    value: item.count,
    positionBy: {
      value: item.color,
      axis: "horizontal"
    },
    foregroundStyleBy: item.color,
    cornerRadius: 8
  }))}
/>
```



---
url: /zh/guide/View Modifiers/Charts Style.md
---

# 图表样式

该组件提供了一个高度可定制的界面，用于创建和展示多种类型的图表。本文档详细说明了如何使用 `Chart` 视图的属性来配置轴、比例、标签、图例等。

***

### **1. 轴的可见性**

- **`chartXAxis`**
  - **类型**: `"automatic" | "hidden" | "visible"`
  - **描述**: 设置 X 轴的可见性。
  - **示例**:
    ```tsx
    <Chart chartXAxis="visible">
      <BarChart ... />
    </Chart>
    ```

- **`chartYAxis`**
  - **类型**: `"automatic" | "hidden" | "visible"`
  - **描述**: 设置 Y 轴的可见性。
  - **示例**:
    ```tsx
    <Chart chartYAxis="hidden">
      <LineChart ... />
    </Chart>
    ```

***

### **2. 轴标签**

- **`chartXAxisLabel`**
  - **类型**:
    ```ts
    {
      position?: "automatic" | "bottom" | "bottomLeading" | "bottomTrailing" | "leading" | "overlay" | "top" | "topLeading" | "topTrailing" | "trailing";
      alignment?: "leading" | "center" | "trailing";
      spacing?: number;
      content: VirtualNode;
    }
    ```
  - **描述**: 为 X 轴添加标签。
  - **示例**:
    ```tsx
    <Chart
      chartXAxisLabel={{
        position: "bottom",
        alignment: "center",
        spacing: 10,
        content: <Text>X 轴标签</Text>,
      }}
    >
      <BarChart ... />
    </Chart>
    ```

- **`chartYAxisLabel`**
  - **类型**: 与 `chartXAxisLabel` 相同。
  - **描述**: 为 Y 轴添加标签。
  - **示例**:
    ```tsx
    <Chart
      chartYAxisLabel={{
        position: "leading",
        content: <Text>Y 轴标签</Text>,
      }}
    >
      <LineChart ... />
    </Chart>
    ```

***

### **3. 图例**

- **`chartLegend`**
  - **类型**:
    ```ts
    "automatic" | "hidden" | "visible" | {
      position?: "automatic" | "bottom" | "bottomLeading" | "bottomTrailing" | "leading" | "overlay" | "top" | "topLeading" | "topTrailing" | "trailing";
      alignment?: "leading" | "center" | "trailing";
      spacing?: number;
      content?: VirtualNode;
    }
    ```
  - **描述**: 配置图例。
  - **示例**:
    ```tsx
    <Chart
      chartLegend={{
        position: "top",
        alignment: "center",
        content: <Text>图例</Text>,
      }}
    >
      <AreaChart ... />
    </Chart>
    ```

***

### **4. 比例**

- **`chartXScale` / `chartYScale`**
  - **类型**:
    ```ts
    ClosedRange<number> | ClosedRange<Date> | string[] | "category" | "date" | "linear" | "log" | "squareRoot" | "symmetricLog" | {
      domain: ClosedRange<number> | ClosedRange<Date> | string[];
      type: "category" | "date" | "linear" | "log" | "squareRoot" | "symmetricLog";
    }
    ```
  - **描述**: 配置 X 或 Y 轴的比例。
  - **示例**:
    ```tsx
    <Chart
      chartXScale={{ domain: { from: 0, to: 100 }, type: "linear" }}
      chartYScale={["A", "B", "C"]}
    >
      <LineChart ... />
    </Chart>
    ```

***

### **5. 背景**

- **`chartBackground`**
  - **类型**:
    ```ts
    VirtualNode | {
      alignment?: "leading" | "center" | "trailing";
      content: VirtualNode;
    }
    ```
  - **描述**: 为图表容器添加背景。
  - **示例**:
    ```tsx
    <Chart
      chartBackground={{
        alignment: "center",
        content: <Rectangle fill="gray" />,
      }}
    >
      <PieChart ... />
    </Chart>
    ```

***

### **6. 前景样式**

- **`chartForegroundStyleScale`**
  - **类型**:
    ```ts
    Record<string, ShapeStyle>;
    ```
  - **描述**: 自定义图表标记的颜色。
  - **示例**:
    ```tsx
    <Chart
      chartForegroundStyleScale={{
        "类别 1": { color: "blue" },
        "类别 2": { color: "red" },
      }}
    >
      <BarChart ... />
    </Chart>
    ```

***

### **7. 可滚动轴**

- **`chartScrollableAxes`**
  - **类型**:
    ```ts
    "vertical" | "horizontal" | "all"
    ```
  - **描述**: 启用指定轴的滚动。
  - **示例**:
    ```tsx
    <Chart chartScrollableAxes="horizontal">
      <LineChart ... />
    </Chart>
    ```

***

### **8. 选中**

- **`chartXSelection` / `chartYSelection` / `chartAngleSelection`**
  - **类型**:
    ```ts
    {
      value: string | number | null;
      onChanged: (newValue: string | number | null) => void;
      valueType: "string" | "number";
    }
    ```
  - **描述**: 启用指定轴的选择功能。
  - **示例**:
    ```tsx
    <Chart
      chartXSelection={{
        value: "类别 1",
        onChanged: (newValue) => console.log("已选择:", newValue),
        valueType: "string",
      }}
    >
      <BarChart ... />
    </Chart>
    ```

***

### **9. 滚动位置**

- **`chartScrollPositionX` / `chartScrollPositionY`**
  - **类型**:
    ```ts
    number | string | {
      value: number | string;
      onChanged: (newValue: number | string) => void;
    }
    ```
  - **描述**: 设置 X 或 Y 轴的初始滚动位置。
  - **示例**:
    ```tsx
    <Chart
      chartScrollPositionX={{
        value: 0,
        onChanged: (newValue) => console.log("滚动 X:", newValue),
      }}
    >
      <BarChart ... />
    </Chart>
    ```

***

## **综合示例**

以下示例展示了如何使用多个属性来创建一个完全自定义的图表：

```tsx
<Chart
  chartXAxis="visible"
  chartYAxis="visible"
  chartXAxisLabel={{
    position: "bottom",
    alignment: "center",
    spacing: 8,
    content: <Text>X 轴标签</Text>,
  }}
  chartYAxisLabel={{
    position: "leading",
    content: <Text>Y 轴标签</Text>,
  }}
  chartLegend={{
    position: "top",
    alignment: "center",
    content: <Text>图例</Text>,
  }}
  chartXScale={{ domain: { from: 0, to: 100 }, type: "linear" }}
  chartScrollableAxes="all"
  chartForegroundStyleScale={{
    "类别 A": { color: "green" },
    "类别 B": { color: "blue" },
  }}
  chartBackground={{
    content: <Rectangle fill="lightgray" />,
  }}
>
  <BarChart
    marks={[
      { label: "A", value: 30, foregroundStyle: { color: "red" } },
      { label: "B", value: 70 },
    ]}
  />
  <LineChart
    marks={[
      { label: "A", value: 40 },
      { label: "B", value: 80 },
    ]}
  />
</Chart>
```

此示例在单个 `Chart` 容器中结合了轴标签、滚动、图例、比例、前景样式以及多种图表类型。可将其用作构建自定义图表的模板。



---
url: /zh/guide/View Modifiers/Grid Layout Control.md
---

# 网格布局控制

这些修饰符用于控制视图在 `Grid` 网格布局中的行为，包括单元格的跨列、对齐方式、尺寸限制等，适用于构建灵活且精细的二维界面布局。

***

### `gridCellColumns`

设置某个视图在网格中跨越的列数。

#### 类型

```ts
gridCellColumns?: number
```

#### 说明

用于让单个视图占据多个列，常见用法包括用作区块标题或需要额外水平空间的内容。

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text gridCellColumns={2}>跨越两列的文本</Text>
  </GridRow>
  <GridRow>
    <Text>单元格 A</Text>
    <Text>单元格 B</Text>
  </GridRow>
</Grid>
```

***

### `gridCellAnchor`

设置当前视图在网格单元格内的对齐锚点。

#### 类型

```ts
gridCellAnchor?: KeywordPoint | Point
```

#### 说明

使用关键词（如 `"center"`、`"topLeading"`）或自定义点（如 `{ x: 0.5, y: 0.0 }`）来控制该视图在其单元格中的对齐位置。

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text gridCellAnchor="topLeading">顶部左对齐</Text>
  </GridRow>
</Grid>
```

***

### `gridCellUnsizedAxes`

阻止网格在指定方向上为视图分配额外空间。

#### 类型

```ts
gridCellUnsizedAxes?: AxisSet
```

#### 说明

此修饰符用于告诉网格布局：不要在特定方向（水平或垂直）扩展该视图的尺寸，使其内容尺寸更紧凑。

#### 可选值

- `"horizontal"` – 禁止水平扩展
- `"vertical"` – 禁止垂直扩展
- `"all"` – 禁止两个方向的扩展

#### 示例

```tsx
<Grid>
  <GridRow>
    <Image
      gridCellUnsizedAxes="horizontal"
      imageUrl="https://example.com/icon.png"
    />
    <Text>图标说明</Text>
  </GridRow>
</Grid>
```

***

### `gridColumnAlignment`

设置该视图所在列的水平对齐方式。

#### 类型

```ts
gridColumnAlignment?: "leading" | "center" | "trailing"
```

#### 说明

此修饰符将影响该列中所有视图的水平对齐方式。通常只需要对列中的第一个视图设置即可。

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text gridColumnAlignment="trailing">右对齐列</Text>
    <Text>下一单元格</Text>
  </GridRow>
</Grid>
```

***

## Grid 与 GridRow 结构说明

上述修饰符需在 `Grid` 和 `GridRow` 结构内使用，结构类似 SwiftUI 的 `Grid` 布局系统。

### `Grid`

二维容器，按照行和列排列子视图。

#### 可用属性

- `alignment?: Alignment` — 网格中单元格的默认对齐方式
- `horizontalSpacing?: number` — 列之间的水平间距
- `verticalSpacing?: number` — 行之间的垂直间距

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text>Hello</Text>
    <Image systemName="globe" />
  </GridRow>
  <Divider />
  <GridRow>
    <Image systemName="hand.wave" />
    <Text>World</Text>
  </GridRow>
</Grid>
```

### `GridRow`

表示网格中的一行，包含若干水平排列的单元格。

#### 可用属性

- `alignment?: VerticalAlignment` — 控制整行中内容的垂直对齐方式

***

## 总结

| 修饰符                   | 功能描述              |
| --------------------- | ----------------- |
| `gridCellColumns`     | 设置视图跨越的列数         |
| `gridCellAnchor`      | 设置视图在单元格中的对齐锚点    |
| `gridCellUnsizedAxes` | 指定视图不在特定方向上自动扩展   |
| `gridColumnAlignment` | 控制当前列中所有视图的水平对齐方式 |



---
url: /zh/guide/View Modifiers/Image Style.md
---

# 图片样式

这些修饰符专门用于控制图像视图的缩放、布局与渲染方式。

***

## `scaleToFit`

### 定义

```ts
scaleToFit?: boolean
```

### 描述

将图像按比例缩放，使其完整地**适配容器尺寸**，保持原始宽高比例，不进行裁剪。

等效于 SwiftUI 的：

```swift
.aspectRatio(contentMode: .fit)
```

### 行为说明

- 保留图像的原始宽高比
- 图像完全显示在容器内
- 如果图像比例与容器不一致，可能会留白

### 示例

```tsx
<Image
  filePath="path/to/photo.jpg"
  scaleToFit={true}
/>
```

***

## `scaleToFill`

### 定义

```ts
scaleToFill?: boolean
```

### 描述

将图像按比例缩放，使其**填满整个容器**，保持宽高比，但图像可能会被**裁剪**以适配。

等效于 SwiftUI 的：

```swift
.aspectRatio(contentMode: .fill)
```

### 行为说明

- 图像完全填充容器
- 保持原始宽高比
- 如果比例不同，图像边缘可能会被截断

### 示例

```tsx
<Image
  imageUrl="https://example.com/banner.jpg"
  scaleToFill={true}
/>
```

***

## `aspectRatio`

### 定义

```ts
aspectRatio?: {
  value?: number | null
  contentMode: "fit" | "fill"
}
```

### 描述

强制视图按照指定的**宽高比例**进行布局，可以选择使用 `fit` 或 `fill` 模式控制适配方式。

- `value`: 设置具体的宽高比，例如 `16 / 9`；设为 `null` 表示保持图像原始比例。
- `contentMode`：`"fit"` 表示缩放适配容器但完整显示，`"fill"` 表示缩放填满容器可能被裁剪。

### 示例：设置 3:2 比例并适配显示

```tsx
<Image
  filePath="path/to/photo.jpg"
  aspectRatio={{
    value: 3 / 2,
    contentMode: "fit"
  }}
/>
```

### 示例：保持原始比例并填满容器

```tsx
<Image
  systemName="photo"
  aspectRatio={{
    value: null,
    contentMode: "fill"
  }}
/>
```

***

## `imageScale`

### 定义

```ts
imageScale?: "small" | "medium" | "large"
```

### 描述

设置 SF Symbols 图像的**渲染缩放级别**，不会影响视图的实际布局大小，仅影响图像本身的显示尺寸。

- `"small"`：较小尺寸
- `"medium"`：默认尺寸
- `"large"`：较大尺寸

> 仅适用于通过 `systemName` 创建的系统图标图像。

### 示例

```tsx
<Image
  systemName="bolt.fill"
  imageScale="large"
/>
```

***

## 总结对比

| 修饰符名称         | 功能说明             | 是否影响布局 | 是否裁剪图像 | 是否仅用于符号图像        |
| ------------- | ---------------- | ------ | ------ | ---------------- |
| `scaleToFit`  | 保持比例缩放，完整显示图像    | 是      | 否      | 否                |
| `scaleToFill` | 保持比例缩放，填满容器，可能裁剪 | 是      | 是      | 否                |
| `aspectRatio` | 设置具体宽高比，适配或填充容器  | 是      | 可选     | 否                |
| `imageScale`  | 设置符号图像的渲染尺寸      | 否      | 否      | ✅ 仅用于 SF Symbols |



---
url: /zh/guide/View Modifiers/Lifecycle Events.md
---

# 生命周期事件

Scripting 支持 SwiftUI 风格的生命周期钩子 `onAppear` 与 `onDisappear`，用于在视图显示或从界面中消失时执行自定义逻辑。你可以使用这些钩子执行动画、加载数据、初始化状态或在视图不再可见时清理资源。

***

## 属性定义

```ts
onAppear?: () => void
onDisappear?: () => void
```

### 属性说明

| 属性名           | 类型           | 说明           |
| ------------- | ------------ | ------------ |
| `onAppear`    | `() => void` | 视图可见时触发。     |
| `onDisappear` | `() => void` | 视图从界面上消失时触发。 |

***

## 示例

```tsx
import { VStack, Text, useState } from "scripting"

function Example() {
  const [message, setMessage] = useState("")

  return <VStack
    onAppear={() => setMessage("视图已显示")}
    onDisappear={() => setMessage("视图已隐藏")}
    padding
  >
    <Text>{message}</Text>
  </VStack>
}
```



---
url: /zh/guide/View Modifiers/Liquid Glass/Glass Effect Transition/index.md
---

Liquid Glass 在 iOS 26 引入了更先进的几何匹配与材质过渡能力。
Scripting 完整支持这些特性，并通过 `glassEffectTransition`、`glassEffectID`、`glassEffectUnion`、`GlassEffectContainer` 以及 `NamespaceReader` 组合实现自然、顺滑且结构化的玻璃动画体验。

本文将详细说明：

- 什么是 Glass Effect Transition
- 三种过渡类型
- 为什么需要 glassEffectID 与 namespace
- glassEffectUnion 的作用
- NamespaceReader 的设计目的与机制
- 实际示例解析
- 最佳实践

***

# 1. 概述：什么是 Glass Effect Transition

`glassEffectTransition` 用于指定 Liquid Glass 在视图出现、消失或布局变化期间应如何过渡。

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

Glass Effect Transition 控制三个核心内容：

1. **玻璃材质如何出现 / 消失**
2. **玻璃的几何形状是否会参与动画**
3. **玻璃是否与容器中其他视图的几何形状匹配**

过渡效果只影响“玻璃材质本身”，而不是普通视图的 opacity 或 scale。

***

# 2. 三种过渡类型

## 2.1 identity（无过渡）

```tsx
glassEffectTransition="identity"
```

含义：

- 不应用任何几何或材质动画。
- 内容会直接呈现，不做淡入或几何匹配。

适用于：

- 禁用动画
- 确保界面非常静态
- 开发调试

***

## 2.2 materialize（材质出现动画）

```tsx
glassEffectTransition="materialize"
```

特点：

- 内容会逐渐淡入。
- Liquid Glass 材质会以柔和方式出现和消失。
- 不进行几何匹配，不尝试从其他玻璃形状“过渡”。

适用于：

- 材质出现／消失强调明显
- 不需要几何跟随效果
- 简单切换菜单或按钮

***

## 2.3 matchedGeometry（匹配几何）

```tsx
glassEffectTransition="matchedGeometry"
```

特点：

- 玻璃材质会尝试“继承”同一 namespace 内、相同 ID 的玻璃形状。
- 在视图切换时，从旧形状平滑过渡到新形状。
- 需要使用 `glassEffectID` 指定对应关系。

适用于：

- 复杂菜单切换
- 视图替换（Edit → Home）
- 需要视觉连续性的动画

是 Liquid Glass 最强大也是最常用的模式。

***

# 3. glassEffectID 与 namespace：匹配几何的核心

## 3.1 为什么需要 ID？

几何匹配动画需要知道：

- “旧玻璃”是谁
- “新玻璃”是谁

因此必须给玻璃效果一个身份标识：

```tsx
glassEffectID={{
  id: 1,
  namespace
}}
```

如果两个玻璃视图：

- 位于相同 namespace
- glassEffectID 的 id 相同

系统会认为它们是同一“玻璃实体”的不同状态，允许过渡。

***

## 3.2 为什么必须有 namespace？

SwiftUI 的 matchedGeometry 效果依赖 `@Namespace`，在 Scripting 中我们通过 `NamespaceReader` 暴露给 TSX。

`NamespaceReader` 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ... 在此作用域中所有 glassEffectID 都应使用这个 namespace ...
  )}
</NamespaceReader>
```

原因：

- namespace 用于组织 matchedGeometry 的作用域
- 同一 namespace 内的 ID 才能互相匹配
- 不同 namespace 之间永远不会彼此动画匹配

***

# 4. glassEffectUnion：玻璃材质的联合区域

除了匹配几何形状外，Liquid Glass 还能把多个玻璃区域合并为一个连续材质区域：

```tsx
glassEffectUnion={{
  id: 1,
  namespace
}}
```

效果：

- 相同 union ID 的按钮共享同一个玻璃材质分区
- 多个按钮可看起来像“同一块玻璃切出来的”
- 提升视觉统一性

通常和 matchedGeometry 同时使用。

***

# 5. 示例解析

以下示例展示菜单在两种布局之间切换，并使用动画呈现玻璃过渡：

```tsx
isAlternativeMenu.value
  ? <>
      <Button
        title="Home"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Settings"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
  : <>
      <Button
        title="Edit"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Erase"
        glassEffectID={{id:3, namespace}}
        glassEffectUnion={{id:1,namespace}}
        glassEffectTransition="materialize"
      />
      <Button
        title="Delete"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
```

重点说明：

### 1. 按钮之间共享 Union ID = 1

所有按钮（无论菜单 A 或 B）实际上共享一个玻璃材质“池”。
这样切换时材质背景连续且自然。

### 2. Home / Edit 共享 ID = 1

- 当菜单切换时，Edit → Home 的玻璃材质会自动匹配几何形状，触发 matchedGeometry 动画。

### 3. Delete / Settings 共享 ID = 2

- Delete → Settings 也会使用 matching transition。

### 4. Erase 设置了 materialize

```tsx
glassEffectTransition="materialize"
```

它不会尝试匹配几何，而是用材质淡入淡出的动画。
这可以让某个按钮以不同方式呈现，令人体验变化更明显。

### 5. 整个 HStack 包裹在 GlassEffectContainer

```tsx
<GlassEffectContainer>
  <HStack> ... </HStack>
</GlassEffectContainer>
```

容器提供：

- 匹配几何所需的上下文
- 优化渲染性能
- 让 union 生效

***

# 6. NamespaceReader：Scripting 如何暴露 @Namespace

在 SwiftUI 中：

```swift
@Namespace private var ns
```

只能在 SwiftUI View 中使用，无法直接从 TypeScript 中访问。

因此 Scripting 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ...
  )}
</NamespaceReader>
```

### 作用：

1. 实际内部创建 SwiftUI 的 `@Namespace`
2. 自动管理生命周期
3. 将 namespace 提供给 TS
4. 保证同一 TSX 作用域使用同一个 namespace

等价于：

```tsx
@Namespace var namespace

glassEffectID={{ id: x, namespace }}
```

没有 NamespaceReader，无论 matchedGeometry 还是 union 都无法工作。

***

# 7. 动画触发方式（withAnimation）

玻璃过渡不会自行动画，必须使用动画触发状态切换：

```tsx
withAnimation(() => {
  isAlternativeMenu.setValue(
    !isAlternativeMenu.value
  )
})
```

匹配几何、材质出现动画等会自动附着到这次动画事务中。

***

# 8. 最佳实践

### 1. 所有参与动画的视图必须在同一个 GlassEffectContainer

否则 matchedGeometry 不会生效。

### 2. namespace 必须由同一个 NamespaceReader 提供

**不要跨层级或重复构造 namespace**。

### 3. glassEffectID 必须在两个状态中都出现

否则 SwiftUI 无法关联动画。

### 4. 若要连续的材质外观，应使用 glassEffectUnion

让按键像同一块玻璃切换。

### 5. 除特殊情况外，尽量使用 matchedGeometry

可获得更自然的“流动感”。

***

# 9. 总结

Glass Effect Transition 是 iOS 26 Liquid Glass 系统的核心特性之一，它让玻璃材质在视图切换中具备几何匹配、材质渐变与联合区域动画。

在 Scripting 中：

- `glassEffectTransition` 控制动画类型
- `glassEffectID` + `namespace` 让几何匹配成为可能
- `glassEffectUnion` 提供材质连续感
- `GlassEffectContainer` 管理动画环境
- `NamespaceReader` 使 TSX 能访问 SwiftUI 的 @Namespace



---
url: /zh/guide/View Modifiers/Liquid Glass/Glass Effect Transition/index_example.md
---

# 示例

```tsx
import { Button, GlassEffectContainer, HStack, NamespaceReader, Navigation, Script, VStack, useObservable } from "scripting"

function View() {

  const isAlternativeMenu = useObservable(false)

  return <NamespaceReader>{namespace => <VStack
    spacing={50}
    frame={{
      maxWidth: 'infinity',
      maxHeight: 'infinity'
    }}
    background="systemYellow"
  >
    <GlassEffectContainer
    >
      <HStack
        spacing={0}
        font="largeTitle"
        imageScale="large"
        buttonStyle="glass"
        labelStyle="iconOnly"
      >
        {
          isAlternativeMenu.value
            ? <>
              <Button
                title="Home"
                systemImage="house"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Settings"
                systemImage="gear"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>

            : <>
              <Button
                title="Edit"
                systemImage="pencil"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Erase"
                systemImage="eraser"
                action={() => { }}
                glassEffectID={{
                  id: 3,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
                glassEffectTransition="materialize"
              />
              <Button
                title="Delete"
                systemImage="trash"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>
        }
      </HStack>
    </GlassEffectContainer>

    <Button
      title="Toggle"
      buttonStyle="bordered"
      action={() => {
        withAnimation(() => {
          isAlternativeMenu.setValue(
            !isAlternativeMenu.value
          )
        })
      }}
    />
  </VStack>
  }</NamespaceReader>
}

async function run() {
  await Navigation.present(<View />)

  Script.exit()
}

run()
```



---
url: /zh/guide/View Modifiers/Liquid Glass/Liquid Glass Effect/index.md
---

**GlassEffect、GlassEffectContainer、UIGlass** 等相关 API 基于 SwiftUI 新引入的 Liquid Glass 技术，让开发者能够在脚本中以 TSX 方式使用流体化、动态的玻璃材质效果，并支持过渡动画、匹配几何、联合玻璃区域等高级特性。

***

## 1. Liquid Glass 概述

Liquid Glass 是 iOS 26 新增的视觉效果系统，用于创建带有流动质感、半透明材质与动态边界的玻璃效果。与早期的 `blur` 或 `material` 不同，Liquid Glass 提供了：

- 动态玻璃形状（使用 Shape）
- 基于几何匹配的过渡动画
- 可交互的玻璃（interactive）
- 可指定 tint 色彩的玻璃材质
- 可组合多个视图的玻璃“联合”

***

# 2. GlassEffect 基础用法

所有支持玻璃效果的视图，都可以通过 `glassEffect` 修饰符添加 Liquid Glass 材质。

### 属性定义

```ts
type GlassProps = {
  glassEffect?: boolean | UIGlass | Shape | {
      glass: UIGlass
      shape: Shape
  }

  glassEffectTransition?: GlassEffectTransition

  glassEffectID?: {
      id: string | number
      namespace: NamespaceID
  }

  glassEffectUnion?: {
      id: string | number
      namespace: NamespaceID
  }
}
```

***

## 2.1 `glassEffect`

glassEffect 有四种主要使用方式：

### 方式一：启用默认玻璃材质

```tsx
<Text glassEffect>Foo</Text>
```

使用系统默认的 Liquid Glass 材质（相当于 `UIGlass.regular()`）。

***

### 方式二：使用指定的 UIGlass

```tsx
<Text glassEffect={UIGlass.regular().interactive(false)}>Foo</Text>
```

可以链式配置 tint、interactive 等属性。

***

### 方式三：设置玻璃的形状（Shape）

```tsx
<Text glassEffect={{ glass: UIGlass.regular(), shape: { type: 'rect', cornerRadius: 10 } }}>
  Foo
</Text>
```

或直接传入 Shape：

```tsx
<Text
  glassEffect={{
    type: 'rect',
    cornerRadius: 10
  }}
>
  Foo
</Text>
```

表示该视图的玻璃材质会严格限定在指定几何图形内。

***

### 方式四：Boolean 短写

```tsx
<View glassEffect />
```

等同于默认 UIGlass.regular()。

***

# 3. UIGlass 类

`UIGlass` 用于描述玻璃材质本身，可以选用内置材质或链式组合属性。

### 可用静态方法

| 方法                   | 描述                        |
| -------------------- | ------------------------- |
| `UIGlass.clear()`    | 完全透明的玻璃材质，用于融合或叠加效果。      |
| `UIGlass.regular()`  | 默认的 Liquid Glass 材质。      |
| `UIGlass.identity()` | 身份材质，不会改变内容外观，相当于不应用玻璃效果。 |

### 链式配置方法

```ts
interactive(value?: boolean): UIGlass
tint(color: Color): UIGlass
```

示例：

```tsx
glassEffect={UIGlass.regular().interactive().tint("red")}
```

***

# 4. GlassEffectTransition（玻璃过渡动画）

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

### 三种模式说明

| transition          | 描述                                 |
| ------------------- | ---------------------------------- |
| `'identity'`        | 不应用任何几何或材质的动画变化。                   |
| `'materialize'`     | 内容渐入，同时玻璃材质出现或消失，但不尝试匹配几何形状。       |
| `'matchedGeometry'` | 根据容器内其他玻璃形状的几何信息匹配过渡动画，具备更自然的动画效果。 |

### 使用方式

```tsx
<Text 
  glassEffect
  glassEffectTransition="materialize"
>
  Foo
</Text>
```

matchedGeometry 通常需要配合 `glassEffectID` 或 `glassEffectUnion` 使用。

***

# 5. glassEffectID 与 glassEffectUnion

Liquid Glass 支持“识别”不同视图间的玻璃效果，用于 matched geometry 动画或合并多块玻璃区域。

***

## 5.1 glassEffectID

为玻璃效果赋予唯一的 ID，用于 matchedGeometry 动画。

```tsx
<Text
  glassEffect
  glassEffectID={{ id: "avatar", namespace }}
>
  Foo
</Text>
```

多个视图使用相同 ID + namespace 时，系统会尝试匹配形状，从而产生流体几何动画效果。

***

## 5.2 glassEffectUnion

用于将多个玻璃效果统一为一个更大区域。

```tsx
<Text
  glassEffect
  glassEffectUnion={{ id: 1, namespace }}
/>
```

多个视图的玻璃材质将被合并，形成更一致的视觉区域。

***

# 6. GlassEffectContainer

`GlassEffectContainer` 是用于组织和管理玻璃效果的容器。容器内部的所有 glassEffect 视图，都能参与几何匹配、联合效果和过渡动画。

### 示例

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image glassEffect systemName="1.circle" />
    <Image glassEffect systemName="2.circle" />
  </HStack>
</GlassEffectContainer>
```

在容器中：

- matchedGeometry 正常工作
- glassEffectUnion 可以跨子视图生效
- glassEffectID 的动画效果可互相关联

GlassEffectContainer 不需要额外参数，但提供了玻璃效果组织空间。

***

# 7. 按钮的玻璃样式 buttonStyle

Scripting 在 iOS 26 提供新增按钮样式：

- `"glass"`
- `"glassProminent"`

示例：

```tsx
<Button title="Glass" action={...} buttonStyle="glass" />
<Button title="Glass Prominent" action={...} buttonStyle="glassProminent" />

<Button
  title="Glass & Tint"
  buttonStyle="glass"
  tint="red"
/>
```

这些按钮会自动使用 Liquid Glass 材质，并适配 tint、press 动效。

***

# 8. 实战示例说明

以下示例展示完整的用法，包括：

- 背景图片
- Glass 按钮
- GlassEffectContainer
- 使用 UIGlass 自定义玻璃
- 使用指定形状的玻璃

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image
      systemName="1.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: 30, y: 0 }}
    />
    <Image
      systemName="2.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: -30, y: 0 }}
    />
  </HStack>
</GlassEffectContainer>
```

***

# 9. 使用建议与最佳实践

### 1. 大量玻璃视图应包裹在同一个 GlassEffectContainer

可提高动画一致性与性能。

### 2. 使用 matchedGeometry 时务必提供 glassEffectID

否则无法产生几何跟随动画。

### 3. 复杂的玻璃区域可使用 glassEffectUnion 合并

让多个子视图形成连续材质。

### 4. 为了避免过度渲染，玻璃不应嵌套太深

可以多用 ZStack 管理效果。

### 5. UIGlass.identity 非常适合“禁用玻璃但保持结构”

它允许你保留现有布局但不实际渲染材质。



---
url: /zh/guide/View Modifiers/Liquid Glass/Liquid Glass Effect/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, VStack, ZStack, Image, Path, GlassEffectContainer, HStack } from "scripting"

function View({
  image
}: {
  image: UIImage
}) {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle="GlassEffect DEMO"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <ZStack>
        <Image
          image={image}
          resizable
          scaleToFill
        />
        <VStack>
          <HStack>
            <Button
              title="Glass"
              action={() => { }}
              buttonStyle="glass"
            />
            <Button
              title="Glass & Tint"
              action={() => { }}
              buttonStyle="glass"
              tint="red"
            />
          </HStack>
          <HStack>
            <Button
              title="Glass Prominent"
              action={() => { }}
              buttonStyle="glassProminent"
            />
            <Button
              title="Glass Prominent & Tint"
              action={() => { }}
              buttonStyle="glassProminent"
              tint="red"
            />
          </HStack>
          <GlassEffectContainer>
            <HStack spacing={40}>
              <Image
                systemName="1.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: 30, y: 0 }}
              />
              <Image
                systemName="2.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: -30, y: 0 }}
              />
            </HStack>
          </GlassEffectContainer>
          <HStack spacing={12}>
            <Text
              padding
              glassEffect
            >Foo</Text>
            <Text
              padding
              glassEffect={{
                type: 'rect',
                cornerRadius: 10
              }}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().interactive()}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().tint("red")}
              foregroundStyle="white"
            >Foo</Text>
          </HStack>
        </VStack>
      </ZStack>
    </VStack>
  </NavigationStack>
}

async function run() {
  try {
    const image = (await Photos.pickPhotos(1))?.at(0)
    if (!image) {
      throw new Error("You must pick an image as the background.")
    }
    // Present view.
    await Navigation.present({
      element: <View
        image={image}
      />
    })
  } catch (e) {
    console.present()
    console.error(e)
  }

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /zh/guide/View Modifiers/List and Section View Modifiers/Common.md
---

# 通用修饰符

这些修饰符可用于精细控制 `<List>` 中每一行（Row）或每一个区块（Section）的布局与样式。

## 适用对象：

- 列表中的单个行（如 `<Text>`、`<HStack>`）
- 区块 `<Section>`
- 整个 `<List>`

***

## `listItemTint`

设置该行及其内容使用的 **前景色（tint）**。

### 类型

```ts
listItemTint?: Color
```

### 说明

- 设置为 `null` 表示不覆盖继承颜色。
- 可使用关键词颜色、Hex、或 rgba。

### 示例

```tsx
<Text listItemTint="green">
  带颜色的行
</Text>
```

***

## `listRowInsets`

设置该行的 **内边距（insets）**。

### 类型

```ts
listRowInsets?: number | EdgeInsets
```

### 说明

- 使用单个数字表示上下左右相同的内边距；
- 使用 `EdgeInsets` 对象设置四个方向的独立间距。

### 示例

```tsx
<Text
  listRowInsets={{
    top: 10,
    bottom: 10,
    leading: 20,
    trailing: 20
  }}
>
  自定义边距的行
</Text>
```

***

## `listRowSpacing`

设置 **相邻两行之间的垂直间距**。

### 类型

```ts
listRowSpacing?: number
```

### 示例

```tsx
<List listRowSpacing={12}>
  <Text>第一行</Text>
  <Text>第二行</Text>
</List>
```

***

## `listRowSeparator`

设置当前行的 **分隔线可见性**。

### 类型

```ts
listRowSeparator?: Visibility | {
  visibility: Visibility
  edges: VerticalEdgeSet
}
```

### 可选值（Visibility）：

- `"visible"`：始终显示分隔线
- `"hidden"`：隐藏分隔线
- `"automatic"`：系统默认行为

### 示例

```tsx
<Text
  listRowSeparator={{
    visibility: "hidden",
    edges: "bottom"
  }}
>
  隐藏底部分隔线的行
</Text>
```

***

## `listRowSeparatorTint`

设置该行的 **分隔线颜色**。

### 类型

```ts
listRowSeparatorTint?: Color | {
  color: Color
  edges: VerticalEdgeSet
}
```

### 示例

```tsx
<Text
  listRowSeparatorTint={{
    color: "rgba(255,0,0,0.5)",
    edges: "bottom"
  }}
>
  带红色分隔线的行
</Text>
```

***

## `listRowBackground`

为该行设置一个自定义的 **背景视图**。

### 类型

```ts
listRowBackground?: VirtualNode
```

### 示例

```tsx
<Text
  listRowBackground={
    <Rectangle fill="#f0f0f0" cornerRadius={10} />
  }
>
  带灰色背景的行
</Text>
```

***

## `listSectionSpacing`

设置 **区块（Section）之间的垂直间距**。

### 类型

```ts
listSectionSpacing?: number | "compact" | "default"
```

### 示例

```tsx
<List listSectionSpacing="compact">
  <Section>...</Section>
  <Section>...</Section>
</List>
```

***

## `listSectionSeparator`

控制某个区块的 **顶部或底部分隔线显示情况**。

### 类型

```ts
listSectionSeparator?: Visibility | {
  visibility: Visibility
  edges: VerticalEdgeSet
}
```

### 示例

```tsx
<Section
  listSectionSeparator={{
    visibility: "hidden",
    edges: "top"
  }}
>
  <Text>内容</Text>
</Section>
```

***

## `listSectionSeparatorTint`

设置区块分隔线的 **颜色**。

### 类型

```ts
listSectionSeparatorTint?: Color | {
  color: Color
  edges: VerticalEdgeSet
}
```

### 示例

```tsx
<Section
  listSectionSeparatorTint={{
    color: "#cccccc",
    edges: "bottom"
  }}
>
  <Text>灰色底部分隔线</Text>
</Section>
```

***

## 辅助类型定义

## `EdgeInsets` 示例

```ts
{
  top: number
  bottom: number
  leading: number
  trailing: number
}
```

## `Visibility`

```ts
"automatic" | "visible" | "hidden"
```

## `VerticalEdgeSet`

```ts
"top" | "bottom" | "all"
```

## `Color` 可接受格式：

- 关键词颜色（如 `"green"`、`"label"`）
- Hex 色值（如 `"#ff0000"`）
- RGBA 字符串（如 `"rgba(255,0,0,1)"`）

***

## 修饰符汇总表

| 修饰符                        | 作用说明                 |
| -------------------------- | -------------------- |
| `listItemTint`             | 设置该行内容的前景色           |
| `listRowInsets`            | 设置该行的内边距             |
| `listRowSpacing`           | 设置相邻两行之间的间距          |
| `listRowSeparator`         | 控制该行分隔线的显示           |
| `listRowSeparatorTint`     | 设置该行分隔线的颜色           |
| `listRowBackground`        | 设置该行的背景视图            |
| `listSectionSpacing`       | 设置两个 Section 之间的垂直间距 |
| `listSectionSeparator`     | 控制区块的顶部或底部分隔线是否显示    |
| `listSectionSeparatorTint` | 设置区块分隔线的颜色           |



---
url: /zh/guide/View Modifiers/List and Section View Modifiers/New List View Modifiers.md
---

# 属性概览

| 属性名                          | 类型                                                          | 系统要求      | 说明                         |
| ---------------------------- | ----------------------------------------------------------- | --------- | -------------------------- |
| `listSectionIndexVisibility` | `Visibility`                                                | iOS 26.0+ | 控制 List 右侧 Section 索引条的可见性 |
| `listSectionMargins`         | `number \| EdgeSets \| { edges: EdgeSets; length: number }` | iOS 26.0+ | 自定义 Section 边距，替换系统默认边距规则  |
| `sectionIndexLabel`          | `string`                                                    | iOS 26.0+ | 设置 Section 在索引条中的字符标签      |
| `sectionActions`             | `VirtualNode`                                               | iOS 18.0+ | 为 Section 添加自定义操作区域        |

***

# 1. listSectionIndexVisibility

```ts
/**
 * Sets the visibility of the list section index.
 * @available iOS 26.0+.
 */
listSectionIndexVisibility?: Visibility
```

### 功能说明

控制 List 的右侧索引条是否显示。常用于需要类似通讯录 A-Z 快速跳转的场景。

可选值：

- `"visible"`
- `"hidden"`
- `"automatic"`（系统自行判断）

### 示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```

***

# 2. listSectionMargins

```ts
/**
 * Set the section margins for the specific edges.
 * @available iOS 26.0+.
 */
listSectionMargins?: number | EdgeSets | {
  edges: EdgeSets
  length: number
}
```

### 功能说明

设置 Section 的外边距，完全替换系统默认边距。可使用数值、 EdgeSets，或指定边的写法。

### 三种写法说明

### 2.1 使用单一数字作为四边边距

```tsx
listSectionMargins={12}
```

### 2.2 使用 EdgeInsets

```tsx
listSectionMargins={"all"}
```

### 2.3 针对特定边设置长度

```tsx
listSectionMargins={{
  edges: "horizontal",
  length: 20
}}
```

此写法等同于 SwiftUI 中：

```swift
.listSectionMargins(.horizontal, 20)
```

### 示例

```tsx
<Section
  header={<Text>Favorites</Text>}
  listSectionMargins={{
    edges: "vertical",
    12
  }}
>
  <Text>Item A</Text>
  <Text>Item B</Text>
</Section>
```

***

# 3. sectionIndexLabel

```ts
/**
 * Sets the label that is used in a section index.
 * @available iOS 26.0+.
 */
sectionIndexLabel?: string
```

### 功能说明

为 Section 设置索引条的显示字符，一般为单字母，如 “A”、“B”、“C”。

### 示例

```tsx
<Section
  header={<Text>A</Text>}
  sectionIndexLabel="A"
>
  <Text>Adam</Text>
  <Text>Ana</Text>
</Section>
```

***

# 4. sectionActions

```ts
/**
 * Adds custom actions to a section.
 * @available iOS 18.0+
 */
sectionActions?: VirtualNode
```

### 功能说明

为 Section 添加自定义操作按钮、菜单等 UI，位置通常显示在 Section Header 区域的右侧。

### 示例：添加刷新按钮

```tsx
<Section
  header={<Text>Downloads</Text>}
  sectionActions={
    <Button title="Refresh" action={() => doRefresh()} />
  }
>
  <Text>File 1</Text>
  <Text>File 2</Text>
</Section>
```

### 示例：添加菜单动作

```tsx
<Section
  header={<Text>Photos</Text>}
  sectionActions={
    <Menu title="Actions">
      <Button title="Upload All" action={() => uploadAll()} />
      <Button title="Delete All" action={() => deleteAll()} />
    </Menu>
  }
>
  {photos.map(photo => <Text key={photo.id}>{photo.name}</Text>)}
</Section>
```

***

# 完整示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
        listSectionMargins={12}
        sectionActions={
          <Button title="Refresh" action={() => refreshGroup(group)} />
        }
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```



---
url: /zh/guide/View Modifiers/LiveActivity View Modifiers.md
---

Scripting 支持与 SwiftUI 等效的 Live Activity 外观控制修饰符。这些修饰符专门用于 **锁屏（Lock Screen）中的 Live Activity 界面**，用于自定义背景色和系统动作按钮颜色。

通过为 Activity UI 中的 `content` 视图设置这些修饰符，可使 Live Activity 更符合品牌风格或特定活动主题。

***

# 修饰符定义

```ts
/**
 * 用于设置 Live Activity 在锁屏界面显示时的背景着色。
 */
activityBackgroundTint?: Color | {
  light: Color
  dark: Color
}

/**
 * 用于设置 Live Activity 在锁屏界面显示时，系统提供的辅助操作按钮的文本（前景）颜色。
 */
activitySystemActionForegroundColor?: Color | {
  light: Color
  dark: Color
}
```

***

# 属性说明

## 1. activityBackgroundTint

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置 Live Activity 在锁屏界面显示时的背景 Tint。
这个颜色会影响系统渲染 Live Activity 主卡片的底色。

### 使用示例

- 使用品牌主色作为 Activity 背景
- 为不同活动提供独立主题色
- 让内容在亮色或深色背景下更易阅读

***

## 2. activitySystemActionForegroundColor

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置系统在锁屏的 Live Activity 卡片旁显示的“辅助操作按钮”的文本前景色。
这些操作按钮可能包括暂停、继续、停止等。

### 使用示例

- 在深色背景上显示浅色按钮文本
- 将关键操作按钮突出显示
- 使用和 UI 一致的主题色

***

# 示例：在 Live Activity UI Builder 中使用

Live Activity 的 UI builder 必须返回包含多个区域（content / compactLeading / compactTrailing / minimal等）的对象结构。

以下示例展示了如何在 **content** 区域中使用这两个修饰符：

```tsx
function ActivityView() {
  <LiveActivityUI
    content={
      <ContentView
        activityBackgroundTint={"blue"}
        activitySystemActionForegroundColor={"white"}
      />
    }
    compactLeading={...}
    compactTrailing={...}
    minimal={<Image systemName="clock" />}
  >
    <LiveActivityUIExpandedCenter>
      <ContentView />
    </LiveActivityUIExpandedCenter>
  </LiveActivityUI>
}
```

***

# 使用说明

- **修饰符仅在 Live Activity UI 中有效**，并且只影响 **锁屏界面** 的外观。
- 必须在 Live Activity UI builder 的 `content` 中使用。
- 如果不设置颜色，系统会使用默认样式。



---
url: /zh/guide/View Modifiers/Navigation View Modifiers.md
---

# 导航视图修饰符

Scripting App 提供了一组用于配置导航行为的视图修饰符，允许开发者控制页面标题的展示内容与样式，并自定义返回按钮的显示与否。这些修饰符与 SwiftUI 中的导航系统高度一致，适用于导航栈中的任意视图。

***

## `navigationTitle`

````ts
navigationTitle?: string

设置当前视图在导航栏中显示的标题。

### 说明

* 在 **iOS** 中，当视图被嵌套在导航栈中时，所设置的标题将显示在导航栏中。
* 在 **iPadOS** 中，主导航目的地的标题也会在多任务切换界面中显示为窗口的标题。

---

## `navigationBarTitleDisplayMode`

```ts
navigationBarTitleDisplayMode?: NavigationBarTitleDisplayMode
````

设置导航栏标题的展示样式。

### 枚举类型：`NavigationBarTitleDisplayMode`

```ts
type NavigationBarTitleDisplayMode = "automatic" | "large" | "inline"
```

- **`automatic`**：系统根据上下文自动选择合适的标题样式。
- **`large`**：以大标题样式显示，通常用于导航栈的根视图。
- **`inline`**：将标题与导航栏控件同行显示，采用紧凑布局。

***

## `navigationBarBackButtonHidden`

```ts
navigationBarBackButtonHidden?: boolean
```

控制是否隐藏默认的导航栏返回按钮。

### 说明

- 设为 `true` 时，系统将不显示默认的返回按钮。
- 适用于需要自定义返回行为，或禁止用户返回的界面场景。

***

## 示例

```tsx
<VStack
  navigationTitle={"个人资料"}
  navigationBarTitleDisplayMode={"inline"}
  navigationBarBackButtonHidden={true}
>
  <Text>欢迎来到个人资料页面</Text>
</VStack>
```

在该示例中：

- 设置视图标题为 `"个人资料"`，并展示在导航栏中。
- 标题采用 `inline` 紧凑样式。
- 默认的返回按钮被隐藏。



---
url: /zh/guide/View Modifiers/Picture in Pictuer View Modifiers.md
---

# Picture in Picture （画中画）

Scripting 提供了一组 PiP（Picture in Picture，画中画）相关的 View Modifiers，用于将任意 SwiftUI View 以系统级 PiP 窗口的形式呈现。
开发者无需直接接触底层 AVPictureInPicture API，即可完整控制 PiP 的展示、隐藏、交互行为及生命周期。

PiP 适用于以下典型场景：

- 实时状态展示（计时、运动、任务进度）
- 音频 / 视频播放的辅助 UI
- 应用进入后台后仍需持续展示的轻量信息视图

***

## 一、PiPProps API 定义

```ts
type PiPProps = {
  pip?: {
    isPresented: Observable<boolean>
    maximumUpdatesPerSecond?: number
    content: VirtualNode
  }
  
  onPipStart?: () => void
  onPipStop?: () => void
  onPipPlayPauseToggle?: (isPlaying: boolean) => void
  onPipSkip?: (isForward: boolean) => void
  onPipRenderSizeChanged?: (size: Size) => void

  pipHideOnForeground?: boolean
  pipShowOnBackground?: boolean
}
```

***

## 二、核心属性详解

### 1. `pip.isPresented`

```ts
isPresented: Observable<boolean>
```

- PiP 的**唯一控制开关**
- `true`：系统 PiP 窗口展示
- `false`：PiP 窗口关闭

通常由用户操作（按钮、手势）或应用生命周期驱动。

***

### 2. `pip.content`

```ts
content: VirtualNode
```

- 指定 PiP 窗口中实际渲染的视图
- 强烈建议使用**专门为 PiP 设计的 View**
- 视图结构应尽量简单、稳定、可预测

***

### 3. `pip.maximumUpdatesPerSecond`

```ts
maximumUpdatesPerSecond?: number
```

- **默认值：30**
- 用于限制 PiP 视图每秒最大刷新次数
- 是影响 PiP 稳定性和性能的关键参数

#### 使用建议

- **无动画 / 低频更新场景**
  建议设置为 `1 ~ 5`

- **包含动画的 PiP 视图**
  可设置为 `60`

**重要提示**
将该值设置为 `60` 会显著增加 CPU 与 GPU 压力，对系统性能影响非常明显，应谨慎使用，仅适用于确有必要的动画场景。

***

## 三、PiP 生命周期回调（仅限 PipView 使用）

### `onPipStart`

```ts
onPipStart?: () => void
```

- 当 PiP 窗口**成功开始展示**时触发
- 适合执行以下操作：

  - 启动定时器
  - 开始状态更新
  - 订阅数据流

***

### `onPipStop`

```ts
onPipStop?: () => void
```

- 当 PiP 被关闭或系统回收时调用
- 必须在此清理所有副作用：

  - 定时器
  - 订阅
  - 长时间运行任务

***

## 四、PiP 交互回调（仅限 PipView 使用）

### 1. 播放 / 暂停切换

```ts
onPipPlayPauseToggle?: (isPlaying: boolean) => void
```

- 当用户点击 PiP 控制区的播放 / 暂停按钮
- `isPlaying` 表示切换后的状态
- 常用于音频、视频、运动记录等场景

***

### 2. 快进 / 快退按钮

```ts
onPipSkip?: (isForward: boolean) => void
```

- `true`：向前
- `false`：向后

***

## 五、PiP 渲染尺寸变化

### `onPipRenderSizeChanged`

```ts
onPipRenderSizeChanged?: (size: Size) => void
```

- 当 PiP 窗口尺寸发生变化时触发
- 可根据尺寸动态调整布局
- 适用于横竖屏切换或系统自动调整 PiP 大小时

***

## 六、前后台行为控制（仅限 PipView 使用）

### `pipHideOnForeground`

```ts
pipHideOnForeground?: boolean
```

- 当应用进入前台时：

  - 若 PiP 正在运行，是否自动关闭
- 默认：`false`

***

### `pipShowOnBackground`

```ts
pipShowOnBackground?: boolean
```

- 当应用进入后台时是否自动启动 PiP
- 常用于音频播放、实时状态展示类场景

***

## 七、完整代码示例

### 1. PiP 内容视图（PipView）

```tsx
function PipView() {
  const started = useObservable(false)
  const count = useObservable(0)

  useEffect(() => {
    if (!started.value) {
      return
    }

    let timerId: number

    function startTimer() {
      timerId = setTimeout(() => {
        count.setValue(count.value + 1)
        startTimer()
      }, 1000)
    }

    startTimer()

    return () => {
      clearTimeout(timerId)
    }
  }, [started.value])

  return <HStack
    onPipStart={() => {
      started.setValue(true)
    }}
    frame={{
      width: Device.screen.width,
      height: 50
    }}
    background="systemBlue"
  >
    <Image
      systemName="figure.walk"
      font="title"
    />
    <Text foregroundStyle="white">
      Count: {count.value}
    </Text>
  </HStack>
}
```

***

### 2. 页面中启用 PiP

```tsx
function PageView() {
  const dismiss = Navigation.useDismiss()
  const pipPresented = useObservable(false)

  return <NavigationStack>
    <List
      navigationTitle="PiP Demo"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
      pip={{
        isPresented: pipPresented,
        content: <PipView />
      }}
    >
      <Button
        title="Toggle PiP"
        action={() => {
          pipPresented.setValue(!pipPresented.value)
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 八、重要注意事项（必须阅读）

### 1. PiPView 在 `isPresented = false` 时仍会被构建

- PiPView **不可见**
- 但仍然参与状态绑定与生命周期
- 不应在构建阶段执行任何重计算或副作用

**推荐做法**

- 所有逻辑延迟到 `onPipStart`
- 在 `onPipStop` 中彻底释放资源

***

### 2. PiP 专用修饰符只能在 PipView 中使用

以下属性和回调：

- `onPipStart`
- `onPipStop`
- `onPipPlayPauseToggle`
- `onPipSkip`
- `onPipRenderSizeChanged`
- `pipHideOnForeground`
- `pipShowOnBackground`

**只能定义在 PiP 内容视图（PipView）中**

如果定义在普通页面 View 中：

- 不会触发
- 无法获取正确状态
- 行为不可预测

***

### 3. PiP 不适合复杂 UI

不建议在 PiP 中使用：

- `List`、`ScrollView`
- 复杂动画
- 高频状态更新
- 网络请求驱动的 UI

PiP 的设计目标是：

> 轻量、稳定、可持续展示的系统级辅助视图

***

## 九、推荐实践总结

- 为 PiP 单独设计一个最小化 View
- 控制更新频率，合理设置 `maximumUpdatesPerSecond`
- 所有副作用延迟到 `onPipStart`
- 始终在 `onPipStop` 中清理资源
- 不在 PiP 中复用页面级复杂视图



---
url: /zh/guide/View Modifiers/Presentation View Modifiers.md
---

# 弹出视图修饰符（Presentation

这些修饰符用于配置通过 `sheet` 呈现的视图的行为和外观，包括在不同尺寸环境下的适配方式、拖拽指示器、支持的尺寸（detents）、背景交互、滚动与调整优先级等。

> 这些修饰符应作用于 **被 sheet 弹出显示的根视图**（例如 `<VStack>`、`<NavigationStack>` 或 `<List>`）。

***

## `presentationCompactAdaptation`

定义当设备处于 **横向或纵向紧凑尺寸类（Compact Size Class）** 时，sheet 的适配方式。

### 类型

```ts
presentationCompactAdaptation?: PresentationAdaptation | {
  horizontal: PresentationAdaptation
  vertical: PresentationAdaptation
}
```

### `PresentationAdaptation` 可选值：

- `"automatic"`：系统默认行为
- `"fullScreenCover"`：使用全屏显示
- `"sheet"`：使用普通 sheet 弹出样式
- `"popover"`：使用气泡样式（部分平台支持）
- `"none"`：不进行适配（尽可能维持原样）

### 示例

```tsx
<NavigationStack
  presentationCompactAdaptation={{
    horizontal: "fullScreenCover",
    vertical: "sheet"
  }}
>
  {/* 弹出内容 */}
</NavigationStack>
```

***

## `presentationDragIndicator`

控制 sheet 顶部是否显示 **拖拽指示器**（即小横条）。

### 类型

```ts
presentationDragIndicator?: "visible" | "hidden" | "automatic"
```

### 示例

```tsx
<VStack presentationDragIndicator="visible">
  <Text>可以拖动顶部指示器来改变高度</Text>
</VStack>
```

***

## `presentationDetents`

定义 sheet 支持的 **高度位置（detents）**，用户可以通过拖拽在这些高度间切换。

### 类型

```ts
presentationDetents?: PresentationDetent[]
```

### `PresentationDetent` 可选值：

- `"medium"`：大约为屏幕高度的一半（在紧凑纵向尺寸下无效）
- `"large"`：占满整个屏幕高度
- `number > 1`：表示固定的高度（单位为 pt）
- `0 < number <= 1`：表示按屏幕高度的百分比（例如 `0.5` 表示 50% 高度）

### 示例

```tsx
<VStack presentationDetents={[200, "medium", "large"]}>
  <Text>拖动可在不同高度之间切换</Text>
</VStack>
```

***

## `presentationBackgroundInteraction`

定义在弹出页面显示时，用户是否可以与 **底层视图交互**。

### 类型

```ts
presentationBackgroundInteraction?:
  | "automatic"
  | "enabled"
  | "disabled"
  | { enabledUpThrough: PresentationDetent }
```

### 示例：仅在 sheet 高度较小时允许背景交互

```tsx
<VStack presentationBackgroundInteraction={{
  enabledUpThrough: "medium"
}}>
  <Text>当 sheet 为中等高度时，背景可交互</Text>
</VStack>
```

***

## `presentationContentInteraction`

控制在向上滑动手势中，sheet 是优先 **调整高度** 还是 **滚动内容**。

### 类型

```ts
presentationContentInteraction?: "automatic" | "resizes" | "scrolls"
```

### 说明

- `"resizes"`：优先调整 detent 高度，滚动内容居后
- `"scrolls"`：立即滚动内部内容（如 ScrollView）
- `"automatic"`：系统默认行为（通常优先调整 detent）

### 示例

```tsx
<ScrollView presentationContentInteraction="scrolls">
  {/* 向上滑时会立即滚动，而不会先调整 sheet 高度 */}
</ScrollView>
```

***

## `presentationCornerRadius`

设置 sheet 背景的 **圆角半径**。

### 类型

```ts
presentationCornerRadius?: number
```

### 示例

```tsx
<VStack presentationCornerRadius={16}>
  <Text>该 sheet 具有圆角背景</Text>
</VStack>
```

***

## 完整使用示例

```tsx
function SheetPage({ onDismiss }: {
  onDismiss: () => void
}) {
  return <NavigationStack>
    <List navigationTitle="弹出页">
      <Text font="title" padding={50}>
        拖动指示器可改变 sheet 高度。
      </Text>
      <Button
        title="关闭"
        action={onDismiss}
      />
    </List>
  </NavigationStack>
}

<Button
  title="显示"
  action={() => setIsPresented(true)}
  sheet={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    content: <SheetPage
      presentationDragIndicator="visible"
      presentationDetents={[200, "medium", "large"]}
      onDismiss={() => setIsPresented(false)}
    />
  }}
/>
```

***

## 修饰符汇总

| 修饰符                                 | 功能说明                  |
| ----------------------------------- | --------------------- |
| `presentationCompactAdaptation`     | 设置在紧凑尺寸类下的适配方式        |
| `presentationDragIndicator`         | 控制是否显示拖拽指示器           |
| `presentationDetents`               | 定义 sheet 可拖拽的高度（支持多个） |
| `presentationBackgroundInteraction` | 设置是否允许与背景内容交互         |
| `presentationContentInteraction`    | 控制是优先滚动还是优先调整高度       |
| `presentationCornerRadius`          | 设置 sheet 的圆角大小        |



---
url: /zh/guide/View Modifiers/Redaction View Modifiers.md
---

# 数据遮罩视图修饰符

Scripting App 支持用于视图层级的数据遮罩（Redaction）修饰符。通过这些修饰符，开发者可以将视图内容以占位符、隐私保护或失效状态的形式展示，常用于加载中、隐私信息隐藏或内容待更新的场景。

这些修饰符的行为与 SwiftUI 中的 `redacted(reason:)` 和 `unredacted()` 完全一致。

***

## `redacted`

```ts
redacted?: RedactedReason | null
```

为当前视图及其子视图应用数据遮罩效果，根据传入的遮罩原因改变内容的显示方式。

### 描述

`redacted` 会在不改变原始数据的情况下，以视觉形式替代原始内容。常用于提升用户体验，例如在内容加载时使用占位图形，或在展示敏感信息时进行遮罩。

### 枚举类型：`RedactedReason`

```ts
type RedactedReason = "placeholder" | "invalidated" | "privacy"
```

- **`placeholder`**：以占位符形式展示数据，适用于加载中状态。
- **`invalidated`**：表示数据已失效或正在等待更新。
- **`privacy`**：对内容进行遮罩，以保护用户隐私或敏感信息。

### 示例

```tsx
<Text
  redacted={"placeholder"}
>
  加载中...
</Text>
```

上述示例中，文本内容将以占位符样式展示，适用于数据尚未加载完成的情况。

***

## `unredacted`

```ts
unredacted?: boolean
```

用于移除继承自父视图的遮罩效果，使当前视图恢复原始样式。

### 描述

当上层视图应用了 `redacted` 后，可以在子视图中通过设置 `unredacted: true` 取消遮罩，使该子视图内容正常显示。

### 示例

```tsx
<VStack redacted={"placeholder"}>
  <Text>加载中...</Text>
  <Text unredacted={true}>此内容不遮罩</Text>
</VStack>
```

在此示例中，整个 `VStack` 应用了遮罩，但第二个 `Text` 通过 `unredacted: true` 显示真实内容，不受遮罩影响。

***

## 使用说明

- 遮罩效果仅影响视图的外观，不会影响布局或无障碍功能（如 VoiceOver）。
- `unredacted` 仅在其所在视图受到父视图遮罩影响时才会生效。
- 设置 `redacted: null` 可移除当前视图的遮罩状态（不推荐同时使用 `unredacted`）。



---
url: /zh/guide/View Modifiers/Safe Area.md
---

# 安全区域

Scripting 提供与 SwiftUI 类似的安全区域控制功能，允许你灵活地**向安全区域内插入视图内容**，或让视图**忽略安全区域限制**进行全屏布局。安全区域通常指设备屏幕上的“刘海”、工具栏、键盘等系统 UI 所保留的边距。

***

## `safeAreaPadding`

为视图的安全区域添加自定义内边距。该修饰符可调整视图在系统安全区域内的显示范围（例如避开刘海、Home 指示器或圆角），用于保持内容在合理的可视范围内。

### 类型

```ts
safeAreaPadding?: 
  true | 
  number | 
  {
    horizontal?: number | true
    vertical?: number | true
    leading?: number | true
    trailing?: number | true
    top?: number | true
    bottom?: number | true
  }
```

***

### 描述

该修饰符允许你为视图的安全区域内边距进行灵活设置：

- 传入 `true`：在所有安全区域边缘应用系统默认的内边距；
- 传入一个数字：为所有边缘应用统一的内边距值；
- 传入对象：分别设置各个方向或边缘的内边距，支持数值或 `true` 表示使用系统默认值。

适合在你希望视图保持适配安全区域的同时进行自定义布局的场景使用。

***

### 用法说明

- `true`：在所有安全区域边缘应用系统默认内边距
- `number`：为所有边缘应用指定数值的内边距
- `object`：为不同方向或边缘单独设置内边距

***

### 对象属性说明

- `horizontal`：左右（`leading` 和 `trailing`）方向的内边距
- `vertical`：上下（`top` 和 `bottom`）方向的内边距
- `leading`、`trailing`、`top`、`bottom`：各个边缘的单独内边距
- 值可以是具体的数值，也可以是 `true`（表示使用系统默认值）

***

### 示例：默认内边距

```tsx
<VStack safeAreaPadding={true}>
  <Text>Hello</Text>
</VStack>
```

在所有安全区域边缘应用系统默认的内边距。

***

### 示例：自定义内边距

```tsx
<VStack
  safeAreaPadding={{
    top: 20,
    bottom: true,
    horizontal: 12
  }}
>
  <Text>内容</Text>
</VStack>
```

上边距为 20 点，下边距为系统默认值，左右边距为 12 点。

***

## `safeAreaInset`

在指定的安全区域边缘插入一个视图内容（如底部工具栏、顶部标题等）。

### 类型

```ts
safeAreaInset?: {
  top?: {
    alignment?: HorizontalAlignment
    spacing?: number
    content: VirtualNode
  },
  bottom?: {
    alignment?: HorizontalAlignment
    spacing?: number
    content: VirtualNode
  },
  leading?: {
    alignment?: VerticalAlignment
    spacing?: number  // 实际为 spacing
    content: VirtualNode
  },
  trailing?: {
    alignment?: VerticalAlignment
    spacing?: number  // 实际为 spacing
    content: VirtualNode
  }
}
```

### 参数说明

- `top` / `bottom`：向顶部或底部安全区域插入内容，使用 **水平对齐（HorizontalAlignment）**。
- `leading` / `trailing`：向左右安全区域插入内容，使用 **垂直对齐（VerticalAlignment）**。
- `alignment`：内容在插入区域内的对齐方式。
- `spacing`：原始视图与插入内容之间的额外间距。
- `content`：要插入的视图节点，如 `<Text>`、`<HStack>` 等。

### 示例

```tsx
<ScrollView
  safeAreaInset={{
    bottom: {
      alignment: "center",
      spacing: 8,
      content: <Text>底部工具栏</Text>
    }
  }}
>
  <VStack>
    <Text>滚动内容</Text>
  </VStack>
</ScrollView>
```

### 对齐方式

- **水平对齐（top / bottom）**：`"leading"`、`"center"`、`"trailing"`
- **垂直对齐（leading / trailing）**：`"top"`、`"center"`、`"bottom"`

> 注意：`spacing` 是拼写错误，实际应为 `spacing`。

***

## `ignoresSafeArea`

让视图内容**扩展至安全区域之外**，用于构建沉浸式或全屏背景内容。

### 类型

```ts
ignoresSafeArea?: boolean | {
  regions?: SafeAreaRegions
  edges?: EdgeSet
}
```

### 简单用法（布尔值）

```tsx
<Image
  imageUrl="https://example.com/background.jpg"
  ignoresSafeArea
/>
```

> 整个视图将忽略所有边缘的安全区域，填满全屏。

### 配置用法（对象形式）

```tsx
<VStack
  ignoresSafeArea={{
    regions: "all",
    edges: "bottom"
  }}
>
  <Text>底部内容扩展到系统栏下方</Text>
</VStack>
```

***

### `regions`（可选）

| 值             | 描述                         |
| ------------- | -------------------------- |
| `"all"`       | 忽略所有安全区域（默认）               |
| `"container"` | 忽略容器级别的 UI（如导航栏、标签栏）       |
| `"keyboard"`  | 忽略键盘弹出区域（适用于需要背景填满键盘下方的场景） |

### `edges`（可选）

| 值              | 描述         |
| -------------- | ---------- |
| `"top"`        | 忽略顶部安全区域   |
| `"bottom"`     | 忽略底部安全区域   |
| `"leading"`    | 忽略左侧安全区域   |
| `"trailing"`   | 忽略右侧安全区域   |
| `"vertical"`   | 忽略上下       |
| `"horizontal"` | 忽略左右       |
| `"all"`        | 忽略所有边缘（默认） |



---
url: /zh/guide/View Modifiers/Search Interactions.md
---

# 搜索交互

Scripting 支持与 SwiftUI 类似的搜索功能。你可以为列表等滚动视图添加搜索栏，控制搜索栏的显示位置、状态，监听输入变化，并动态显示搜索建议。

***

## `searchable`

为视图添加搜索栏，并将搜索文本与状态绑定。

### 类型

```ts
searchable?: {
  value: string
  onChanged: (value: string) => void
  placement?: SearchFieldPlacement
  prompt?: string
  presented?: {
    value: boolean
    onChanged: (value: boolean) => void
  }
}
```

### 参数说明

- `value`: 当前搜索输入的文本（受控状态）。
- `onChanged`: 每当用户输入发生变化时调用，传入新的搜索内容。
- `placement`: 控制搜索栏的显示位置（可选）。
- `prompt`: 搜索栏中的提示占位文本（可选）。
- `presented`: 控制搜索栏是否处于激活状态，可以主动打开或关闭搜索界面（可选）。

### 示例

```tsx
function SearchExample() {
  const [query, setQuery] = useState("")
  const [showSearch, setShowSearch] = useState(false)

  return (
    <List
      searchable={{
        value: query,
        onChanged: setQuery,
        placement: "navigationBarDrawer",
        prompt: "搜索项目",
        presented: {
          value: showSearch,
          onChanged: setShowSearch,
        }
      }}
    >
      <Text>当前搜索内容：{query}</Text>
    </List>
  )
}
```

### `SearchFieldPlacement` 可选值

| 值                                       | 描述                           |
| --------------------------------------- | ---------------------------- |
| `'automatic'`                           | 系统自动决定搜索栏位置（默认）。             |
| `'navigationBarDrawer'`                 | 在导航栏下方作为抽屉式显示。               |
| `'navigationBarDrawerAlwaysDisplay'`    | 始终显示抽屉搜索栏。                   |
| `'navigationBarDrawerAutomaticDisplay'` | 根据需要自动显示抽屉搜索栏。               |
| `'toolbar'`                             | 显示在工具栏中。                     |
| `'sidebar'`                             | 显示在侧边栏（适用于 iPad 或 macOS 风格）。 |

***

## `searchSuggestions`

设置搜索建议的内容区域，在用户输入时显示一组建议项。

### 类型

```ts
searchSuggestions?: VirtualNode
```

### 示例

```tsx
const suggestions = useMemo(() => [
  {
    label: "🍎 Apple",
    value: "Apple"
  },
  {
    label: "🍌 Bananer",
    value: "Bananer"
  }
], [])
const filteredSuggestions = useMemo(() => {
  if (!/\S+/.test(query)) {
    return suggestions
  }
  const q = query.toLowerCase()
  return suggestions.filter(s =>
    s.label.toLowerCase().includes(q) ||
    s.value.toLowerCase().includes(q))
}, [query, suggestions])

<List
  searchable={{
    value: query,
    onChanged: setQuery
  }}
  searchSuggestions={
    <>
      {filteredSuggestions.map(s =>
        <Text
          searchCompletion={s.value}
        >{s.label}</Text>
      )}
    </>
  }
/>
```

***

## `searchSuggestionsVisibility`

控制搜索建议的显示位置和是否可见。

### 类型

```ts
searchSuggestionsVisibility?: {
  visibility: 'visible' | 'hidden'
  placements: SearchSuggestionsPlacementSet
}
```

### `SearchSuggestionsPlacementSet` 可选值

| 值           | 描述                |
| ----------- | ----------------- |
| `'content'` | 在主内容区域中显示建议项。     |
| `'menu'`    | 在弹出菜单或下拉列表中显示建议项。 |
| `'all'`     | 同时适用于所有可用位置。      |

### 示例

```tsx
<List
  searchSuggestionsVisibility={{
    visibility: 'visible',
    placements: 'menu'
  }}
/>
```

***

## `searchCompletion`

将某个视图（如 `<Text>`）标记为可点击的搜索建议项，并指定点击后填入搜索框的值。

### 类型

```ts
searchCompletion?: string
```

### 示例

```tsx
<Text searchCompletion="Mango">🥭 芒果</Text>
```

当用户点击该建议项后，搜索栏将自动填入 `"Mango"`。

***

## 小结

| 修饰符                           | 功能说明               |
| ----------------------------- | ------------------ |
| `searchable`                  | 添加搜索栏，绑定搜索状态与行为。   |
| `searchSuggestions`           | 提供搜索建议项列表。         |
| `searchSuggestionsVisibility` | 控制建议项的显示位置和是否可见。   |
| `searchCompletion`            | 设置建议项点击后自动填入搜索栏的值。 |



---
url: /zh/guide/View Modifiers/Set environment values (environments).md
---

`environments` 是 Scripting 新增的视图修饰符，用于向当前视图树（View Hierarchy）注入特定的 environment values。
它的作用与 SwiftUI 的 `.environment()` 类似，但基于 Scripting 的设计进行了显式声明和类型收敛，避免隐式行为。

目前 `environments` 支持以下 environment 值：

- `editMode`: 控制视图的编辑模式（如 List 的编辑状态）
- `openURL`: 自定义打开链接（URL）的处理方式

这些 environment 值会影响其子视图中的行为与交互能力。

***

# 修饰符定义

```ts
environments?: {
  editMode?: Observable<EditMode>;
  openURL?: (url: string) => OpenURLActionResult;
};
```

***

# 一、editMode（编辑模式）

`editMode` 用于设置当前视图树中所有支持编辑模式的组件的编辑状态。

典型用途：

- 控制 `List` 的编辑状态
- 启用批量删除、移动操作
- 与用户交互同步（如切换编辑按钮）

## 类型定义

```ts
class EditMode {
  readonly value: "active" | "inactive" | "transient" | "unknown"
  readonly isEditing: boolean

  static active(): EditMode
  static inactive(): EditMode
  static transient(): EditMode
}
```

### `value` 含义

| 值           | 描述           |
| ----------- | ------------ |
| `active`    | 编辑模式已开启      |
| `inactive`  | 编辑模式已关闭      |
| `transient` | 临时状态（如交互中切换） |
| `unknown`   | 非预期状态，通常不需使用 |

### 与 `Observable` 配合使用

由于 editMode 是动态值，必须使用 `Observable<EditMode>` 传递，以便视图随编辑状态变化而刷新。

***

## editMode 使用示例

```tsx
const editMode = useObservable(() => EditMode.active())

<List
  environments={{
    editMode: editMode
  }}
>
  <ForEach
    editActions="all"
    data={items}
    builder={item => <Text key={item.id}>{item}</Text>}
  />
</List>
```

说明：

- 将 `editMode` 设置到 List 的 environment 中
- List 中的 `ForEach` 会根据该状态启用、禁用删除/移动等编辑能力
- 修改 `editMode.value` 将自动刷新界面

***

# 二、openURL（自定义 URL 打开行为）

`openURL` environment 允许为当前视图树定义一套自定义的 URL 打开逻辑。
这会覆盖如 `<Link>`、`Text(url:)` 等组件的默认行为。

用途示例：

- 控制 URL 在 App 内打开还是系统浏览器打开
- 根据 URL 类型执行不同逻辑
- 拦截 URL 点击并进行验证或跳转处理

## 类型定义

```ts
openURL?: (url: string) => OpenURLActionResult;
```

***

# OpenURLActionResult

自定义 URL 打开逻辑的返回类型。

```ts
class OpenURLActionResult {
  type: string

  static handled(): OpenURLActionResult
  static discarded(): OpenURLActionResult

  static systemAction(options?: {
    url?: string
    prefersInApp: boolean // Requires iOS26.0+
  }): OpenURLActionResult
}
```

## 作用说明

| 返回值                     | 含义                         |
| ----------------------- | -------------------------- |
| `handled()`             | URL 已处理，不执行默认行为            |
| `discarded()`           | 忽略该 URL                    |
| `systemAction(options)` | 要求系统打开给定 URL（支持 App 内或外打开） |

***

## openURL 使用示例

```tsx
<Group
  environments={{
    openURL: (url) => {
      return OpenURLActionResult.systemAction({
        url,
        prefersInApp: false
      })
    }
  }}
>
  {urls.map(url =>
    <Link url={url}>{url}</Link>
  )}
</Group>
```

说明：

- 所有 `<Link>` 均会交给自定义的 `openURL` 方法处理
- 示例将所有 URL 交由系统处理，并要求“非 App 内打开（prefersInApp: false）”

***

# 使用总结

| environment key | 类型                             | 作用范围      | 使用场景         |
| --------------- | ------------------------------ | --------- | ------------ |
| `editMode`      | `Observable<EditMode>`         | 影响所有可编辑组件 | List 编辑、批量操作 |
| `openURL`       | `(url) => OpenURLActionResult` | 所有链接组件    | 自定义 URL 处理逻辑 |

***

# 完整示例：同时使用 editMode 与 openURL

```tsx
const editMode = useObservable(() => EditMode.inactive())

<VStack
  environments={{
    editMode,
    openURL: (url) => {
      if (url.startsWith("https://safe.com")) {
        return OpenURLActionResult.systemAction({ url, prefersInApp: true })
      }
      return OpenURLActionResult.discarded()
    }
  }}
>
  <Button
    title="Toggle Edit"
    action={() => {
      editMode.value = editMode.value.isEditing
        ? EditMode.inactive()
        : EditMode.active()
    }}
  />

  <List>
    ...
  </List>

  <Link url="https://safe.com">Safe Link</Link>
  <Link url="https://blocked.com">Blocked Link</Link>
</VStack>
```

***

# 注意事项

1. `environments` 为局部作用域，仅影响其子视图。
2. `editMode` 必须是 `Observable<EditMode>` 才能触发界面更新。
3. `openURL` 若返回 `handled()`，将阻止默认行为。
4. `systemAction` 中的 `prefersInApp` 会影响是否在 App 内打开链接。
5. 与 SwiftUI 不同，Scripting 的 `environment` 是显式声明，不会隐式传播所有 key。



---
url: /zh/guide/View Modifiers/Swipe Actions/index.md
---

# 滑动操作

在 **Scripting** 中，你可以为用作 `<List>` 列表行的视图（如 `<HStack>`）添加滑动操作按钮，支持如“删除”、“编辑”、“收藏”等常见交互。

为了更清晰地支持 TypeScript，Scripting 将 SwiftUI 的 `swipeActions` 拆分为两个方向明确的修饰符：

- `leadingSwipeActions`: 向右滑动（从左到右）
- `trailingSwipeActions`: 向左滑动（从右到左）

***

## `leadingSwipeActions`

为列表行的 **左侧（leading）** 添加滑动操作。

### 类型

```ts
leadingSwipeActions?: {
  allowsFullSwipe?: boolean
  actions: VirtualNode[]
}
```

### 参数说明

- `actions`: 滑动后显示的按钮组件数组（通常为 `<Button>`）。
- `allowsFullSwipe`: 是否允许“完全滑动”直接执行第一个按钮的操作。默认值为 `true`。

***

## `trailingSwipeActions`

为列表行的 **右侧（trailing）** 添加滑动操作。

### 类型

```ts
trailingSwipeActions?: {
  allowsFullSwipe?: boolean
  actions: VirtualNode[]
}
```

### 参数说明

- `actions`: 滑动后显示的按钮组件数组（通常为 `<Button>`）。
- `allowsFullSwipe`: 是否允许“完全滑动”直接执行第一个按钮的操作。默认值为 `true`。

***

## 示例用法

```tsx
<List>
  {list.map(item => 
    <HStack
      trailingSwipeActions={{
        allowsFullSwipe: true,
        actions: [
          <Button
            title="删除"
            role="destructive"
            action={() => deleteItem(item)}
          />,
          <Button
            title="编辑"
            tint="accentColor"
            action={() => editItem(item)}
          />
        ]
      }}
    >
      <Image systemName={item.icon} />
      <Text>{item.title}</Text>
    </HStack>
  )}
</List>
```

添加左滑操作（向右滑）示例：

```tsx
<HStack
  leadingSwipeActions={{
    actions: [
      <Button
        title="收藏"
        tint="orange"
        action={() => markAsFavorite(item)}
      />
    ]
  }}
>
  <Text>{item.title}</Text>
</HStack>
```

***

## `<Button>` 属性说明

每个滑动操作项都是一个 `<Button>`，你可以使用以下属性来自定义外观与行为：

- `title`: 按钮显示文本
- `action`: 点击按钮时执行的函数
- `role`（可选）: 设置为 `"destructive"` 会显示红色，适用于“删除”操作
- `tint`（可选）: 自定义按钮颜色，例如 `"accentColor"` 或系统颜色名

***

## 注意事项

- `leadingSwipeActions` 和 `trailingSwipeActions` 可以在同一个行视图上同时使用。
- 仅用于列表行中的视图（例如 `<List>` 中的 `<HStack>`）才支持滑动操作。
- 当 `allowsFullSwipe` 为 `false` 时，用户必须点击按钮，而不能通过滑动全程触发操作。



---
url: /zh/guide/View Modifiers/Swipe Actions/index_example.md
---

# 示例

```tsx
import { Button, Circle, HStack, Label, List, Navigation, NavigationStack, Script, Text, useState, VStack } from "scripting"

type Message = {
  from: string
  content: string
  isUnread: boolean
}

function MessageCell({
  message
}: {
  message: Message
}) {
  return <HStack>
    <Circle
      fill={message.isUnread ? "systemBlue" : "clear"}
      frame={{
        width: 16,
        height: 16,
      }}
    />
    <VStack
      alignment={"leading"}
    >
      <Text font={"headline"}>{message.from}</Text>
      <Text>{message.content}</Text>
    </VStack>
  </HStack>
}

function Example() {
  const [messages, setMessages] = useState<Message[]>(() => [
    {
      from: "Maria Ruiz",
      content: "If you have a list of messages, you can add an action to toggle a message as unread on a swipe from the leading edge, and actions to delete or flag messages on a trailing edge swipe.",
      isUnread: true,
    },
    {
      from: "Mei Chen",
      content: "Actions appear in the order you list them, starting from the swipe’s originating edge. In the example, the Delete action appears closest to the screen’s trailing edge",
      isUnread: true,
    },
    {
      from: "Maria Ruiz",
      content: "By default, the user can perform the first action for a given swipe direction with a full swipe. The user can perform both the toggle unread and delete actions with full swipes. You can opt out of this behavior for an edge by setting the allowsFullSwipe parameter to false.",
      isUnread: false,
    },
    {
      from: "Mei Chen",
      content: "When you set a role for a button using one of the values from the ButtonRole, system styles the button according to its role. In the example above, the delete action appears in red because it has the destructive role. If you want to set a different color, add the tint property to the button",
      isUnread: true,
    }
  ])

  function toggleUnread(message: Message) {
    setMessages(messages.map(item => item !== message ? item : {
      ...message,
      isUnread: !item.isUnread
    }))
  }

  function deleteMessage(message: Message) {
    setMessages(messages.filter(item => item !== message))
  }

  return <NavigationStack>
    <List
      navigationTitle={"Messages"}
      navigationBarTitleDisplayMode={"inline"}
      listStyle={"inset"}
    >
      {messages.map(message =>
        <MessageCell
          message={message}
          leadingSwipeActions={{
            allowsFullSwipe: false,
            actions: [
              <Button
                action={() => toggleUnread(message)}
                tint={"systemBlue"}
              >
                {message.isUnread
                  ? <Label title={"Read"} systemImage={"envelope.open"} />
                  : <Label title={"Unread"} systemImage={"envelope.badge"} />
                }
              </Button>
            ]
          }}
          trailingSwipeActions={{
            actions: [
              <Button
                role={"destructive"}
                action={() => deleteMessage(message)}
              >
                <Label title={"Delete"} systemImage={"trash"} />
              </Button>,
              <Button
                action={() => { }}
                tint={"systemOrange"}
              >
                <Label title={"Flag"} systemImage={"flag"} />
              </Button>
            ]
          }}
        />
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/View Modifiers/Symbol Style.md
---

# 符号样式

这些修饰符用于配置 SF Symbols（系统符号图标）的显示样式和动画效果，常用于 `<Image systemName="...">` 组件。

***

### `symbolRenderingMode`

设置符号图像的 **渲染模式**。

#### 类型

```ts
symbolRenderingMode?: SymbolRenderingMode
```

#### 可选值（SymbolRenderingMode）：

- `"monochrome"`：单色模式，使用当前前景色绘制
- `"hierarchical"`：层次渲染，根据不同图层设置不透明度（适合语义着色）
- `"multicolor"`：使用符号内置颜色
- `"palette"`：分层渲染，可自定义每一层的颜色样式（需搭配 `foregroundStyle`）

#### 示例

```tsx
<Image
  systemName="star.fill"
  symbolRenderingMode="palette"
  foregroundStyle={{
    primary: "red",
    secondary: "orange",
    tertiary: "yellow"
  }}
/>
```

***

### `foregroundStyle`

设置符号或前景元素的颜色样式。

#### 类型

```ts
foregroundStyle?: 
  | ShapeStyle
  | DynamicShapeStyle
  | {
      primary: ShapeStyle | DynamicShapeStyle
      secondary: ShapeStyle | DynamicShapeStyle
      tertiary?: ShapeStyle | DynamicShapeStyle
    }
```

#### 说明：

- 在 `"monochrome"` 模式下使用单个颜色或渐变；
- 在 `"palette"` 模式下使用 `{ primary, secondary, tertiary }` 对象指定多层样式；
- `tertiary` 可选，仅在符号有三层图层时有效。

***

### `symbolVariant`

为符号添加特定的 **视觉变体**。

#### 类型

```ts
symbolVariant?: SymbolVariants
```

#### 可选值（SymbolVariants）：

- `"none"`：无变体，原始符号样式
- `"fill"`：填充样式
- `"circle"`：包裹在圆形轮廓中
- `"square"`：包裹在方形轮廓中
- `"rectangle"`：包裹在矩形轮廓中
- `"slash"`：斜杠样式，表示禁止/关闭等状态

#### 示例

```tsx
<Image
  systemName="wifi"
  symbolVariant="slash"
/>
```

***

### `symbolEffect`

为符号添加 **动画效果**，支持静态应用或绑定数值以触发动画。

#### 类型

```ts
symbolEffect?: SymbolEffect
```

#### 使用方式：

##### 1. 静态符号效果（SymbolEffect 简写字符串）

```tsx
<Image
  systemName="checkmark"
  symbolEffect="scaleUp"
/>
```

##### 2. 动态绑定符号效果（每次值变化时触发动画）

```tsx
<Image
  systemName="heart"
  symbolEffect={{
    effect: "bounce",
    value: isLiked
  }}
/>
```

每次 `isLiked` 状态变化时，图标会执行 bounce 动画。

***

### 可用 Symbol 动效分类（DiscreteSymbolEffect）

| 类别                 | 动效关键字                                                                                                                                                                                 |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 弹跳 Bounce          | `bounce`, `bounceByLayer`, `bounceDown`, `bounceUp`, `bounceWholeSymbol`                                                                                                              |
| 呼吸 Breathe         | `breathe`, `breatheByLayer`, `breathePlain`, `breathePulse`, `breatheWholeSymbol`                                                                                                     |
| 脉冲 Pulse           | `pulse`, `pulseByLayer`, `pulseWholeSymbol`                                                                                                                                           |
| 旋转 Rotate          | `rotate`, `rotateByLayer`, `rotateClockwise`, `rotateCounterClockwise`, `rotateWholeSymbol`                                                                                           |
| 颜色变化 VariableColor | `variableColor`, `variableColorIterative`, `variableColorDimInactiveLayers`, `variableColorHideInactiveLayers`, `variableColorCumulative`                                             |
| 摇晃 Wiggle          | `wiggle`, `wiggleLeft`, `wiggleRight`, `wiggleUp`, `wiggleDown`, `wiggleForward`, `wiggleBackward`, `wiggleByLayer`, `wiggleWholeSymbol`, `wiggleClockwise`, `wiggleCounterClockwise` |

***

### 综合示例

```tsx
<Image
  systemName="bell.fill"
  symbolRenderingMode="hierarchical"
  symbolVariant="circle"
  foregroundStyle="indigo"
  symbolEffect={{
    effect: "breathePulse",
    value: isNotified
  }}
/>
```

上述示例中：

- 使用了分层渲染（hierarchical）；
- 添加了圆形变体（circle）；
- 设置了 `indigo` 颜色；
- 每当 `isNotified` 变化时，符号执行 `breathePulse` 动画。

***

## 修饰符汇总表

| 修饰符                   | 说明                        |
| --------------------- | ------------------------- |
| `symbolRenderingMode` | 设置符号图标的渲染模式（单色、多色、层次、调色板） |
| `foregroundStyle`     | 设置符号的颜色风格，可支持多图层配色        |
| `symbolVariant`       | 添加符号样式变体，如填充、圆形、斜杠等       |
| `symbolEffect`        | 添加符号动画，可静态或绑定值驱动          |



---
url: /zh/guide/View Modifiers/Text Field.md
---

# 文本输入框

这些修饰符可用于自定义 `TextField` 组件的行为和外观，包括键盘类型、自动更正、自动大写、提交操作等。

***

## `onSubmit`

为文本字段添加提交时触发的操作。

### 类型

```ts
onSubmit?: (() => void) | {
  triggers: SubmitTriggers
  action: () => void
}
```

### 行为说明

- 若直接提供函数形式：

  ```tsx
  <TextField onSubmit={() => console.log('提交了')} />
  ```

  等价于：

  ```tsx
  <TextField
    onSubmit={{
      triggers: 'text',
      action: () => console.log('提交了')
    }}
  />
  ```

- 也可以明确指定触发提交操作的方式：

  ```tsx
  <TextField
    onSubmit={{
      triggers: 'search',
      action: () => console.log('搜索提交')
    }}
  />
  ```

### `SubmitTriggers` 可选值：

- `"text"`：由文本输入控件（如 `TextField`、`SecureField`）触发。
- `"search"`：由搜索输入框（使用 `searchable` 修饰符）触发。

***

## `keyboardType`

设置聚焦输入时显示的键盘类型。

### 类型

```ts
keyboardType?: KeyboardType
```

### 可选值：

- `'default'`
- `'numberPad'`
- `'phonePad'`
- `'namePhonePad'`
- `'URL'`
- `'decimalPad'`
- `'asciiCapable'`
- `'asciiCapableNumberPad'`
- `'emailAddress'`
- `'numbersAndPunctuation'`
- `'twitter'`
- `'webSearch'`

### 示例

```tsx
<TextField keyboardType="emailAddress" />
```

***

## `autocorrectionDisabled`

控制是否启用系统的自动更正功能。

### 类型

```ts
autocorrectionDisabled?: boolean
```

### 默认值

- `true` — 默认禁用自动更正。

### 示例

```tsx
<TextField autocorrectionDisabled={false} />
```

***

## `textInputAutocapitalization`

设置文本输入时的自动大写行为。

### 类型

```ts
textInputAutocapitalization?: TextInputAutocapitalization
```

### 可选值

- `"never"` – 不自动大写。
- `"characters"` – 每个字母都大写。
- `"sentences"` – 每个句子的首字母大写。
- `"words"` – 每个单词的首字母大写。

### 示例

```tsx
<TextField textInputAutocapitalization="words" />
```

***

## `submitScope`

阻止当前视图触发的提交操作向上传递到父级视图的 `onSubmit` 处理器。

### 类型

```ts
submitScope?: boolean
```

### 默认值

- `false` — 默认允许事件向上传递。

### 示例

```tsx
<TextField submitScope />
```

启用此项后，该字段的提交事件将不会触发父视图中的提交处理逻辑。

## `submitLabel`

设置提交按钮的文本。

### 类型

```ts
submitLabel?: "continue" | "return" | "send" | "go" | "search" | "join" | "done" | "next" | "route"
```

### 示例

```tsx
<TextField submitLabel="send" />
```



---
url: /zh/guide/View Modifiers/Text View Modifiers.md
---

# 文本修饰符

以下属性可用于为基于文本的视图（如 `Text` 或 `Label`）设置样式和格式，其功能与 SwiftUI 的内建修饰符类似。通过自定义这些属性，您可以控制文本的字体、字重、设计、间距及其他排版特性。

## 概览

这些属性通常作为属性传递给与文本相关的组件，如 `Text` 或 `Label`。例如，您可以设置字体大小、启用加粗格式，或添加自定义颜色的下划线——无需手动调用多个修饰符。

```tsx
<Text
  font={{ name: 'SystemFontName', size: 18 }}
  fontWeight="semibold"
  italic
  underline="red"
  lineLimit={2}
  multilineTextAlignment="center"
>
  Stylish Text Here
</Text>
```

在上面的示例中，文本使用了自定义字体、半粗体、斜体风格、红色下划线，限制为两行，并居中对齐。

***

## 字体配置

### `font`

定义文本的字体和大小。

- **数字**：提供一个数字（例如 `14`）时，将应用该大小的系统字体。
- **预设字体名称**（`Font` 类型）：使用内建的文本样式之一（如 `"largeTitle"`、`"title"`、`"headline"`、`"subheadline"`、`"body"`、`"callout"`、`"footnote"`、`"caption"`）。系统会根据样式决定大小和字重。
- **包含名称和大小的对象**：指定 `name` 和 `size` 来应用自定义字体。

```tsx
<Text font={20}>系统字体，大小为 20</Text>
<Text font="headline">系统标题字体</Text>
<Text font={{ name: "CustomFontName", size: 16 }}>自定义字体</Text>
```

***

### `fontWeight`

设置字体的粗细程度。可选值包括从 `"ultraLight"` 到 `"black"`。

```tsx
<Text fontWeight="bold">加粗文本</Text>
```

***

### `fontWidth`

指定字体的宽度变体（如果可用）。可选值有 `"compressed"`、`"condensed"`、`"expanded"` 和 `"standard"`，也可以使用数字（如果支持）。

```tsx
<Text fontWidth="condensed">压缩宽度字体</Text>
```

***

### `fontDesign`

修改字体设计风格。可选值包括 `"default"`、`"monospaced"`、`"rounded"`、`"serif"`。

```tsx
<Text fontDesign="rounded">圆角字体设计</Text>
```

***

## 文本格式

### `minScaleFactor`

一个介于 0 到 1 之间的数字，表示当文本超出空间限制时最多可以缩小到原始大小的多少。例如，`0.5` 表示文本可以缩小到 50%。

```tsx
<Text minScaleFactor={0.8}>当文本超出时会稍微缩小。</Text>
```

***

### `bold`

如果为 `true`，应用加粗字体。

```tsx
<Text bold>这是加粗文本</Text>
```

***

### `baselineOffset`

调整文本相对于基线的垂直位置。正值向上移动，负值向下移动。

```tsx
<Text baselineOffset={5}>文本向上偏移</Text>
```

***

### `kerning`

控制字符间距。正值增加间距，负值减小间距。

```tsx
<Text kerning={2}>字符间距增加</Text>
```

***

### `italic`

如果为 `true`，应用斜体样式。

```tsx
<Text italic>斜体文本</Text>
```

***

### `monospaced`

强制所有子文本使用等宽字体（如果可用）。

```tsx
<Text monospaced>等宽字体文本</Text>
```

***

### `monospacedDigit`

使用固定宽度数字，而其他字符保持原样。适用于表格或计时器中的数字对齐。

```tsx
<Text monospacedDigit>数字等宽对齐 1234</Text>
```

***

## 文本装饰

### `strikethrough`

应用删除线（贯穿文本）。可以提供颜色，或一个包含样式和颜色的对象。

- **仅颜色**：`strikethrough="red"`
- **对象**：`strikethrough={{ pattern: 'dash', color: 'blue' }}`

```tsx
<Text strikethrough="gray">灰色删除线文本</Text>
<Text strikethrough={{ pattern: 'dot', color: 'red' }}>红色点状删除线</Text>
```

***

### `underline`

以下划线方式装饰文本，使用方式与 `strikethrough` 类似。

- **仅颜色**：`underline="blue"`
- **对象**：`underline={{ pattern: 'dashDot', color: 'green' }}`

```tsx
<Text underline="blue">蓝色下划线文本</Text>
<Text underline={{ pattern: 'dot', color: 'pink' }}>粉色点状下划线</Text>
```

***

## 行数、行间距与布局控制

### `lineLimit`

指定文本最多显示的行数。可以：

- 提供一个数字来设置最大行数；
- 或提供一个对象 `{ min?: number; max: number; reservesSpace?: boolean }`，来指定最小和最大行数，并选择是否预留最大行数空间以避免布局跳动。

```tsx
<Text lineLimit={1}>如果超出一行将被截断。</Text>
<Text lineLimit={{ min: 2, max: 4, reservesSpace: true }}>
  可显示 2 到 4 行文本，并始终预留 4 行空间，避免布局变化。
</Text>
```

***

### `lineSpacing`

设置行间距，单位为像素。

```tsx
<Text lineSpacing={5}>设置行间距为 5 像素</Text>
```

***

### `multilineTextAlignment`

设置多行文本的对齐方式：`"leading"`（左对齐）、`"center"`（居中）或 `"trailing"`（右对齐）。

```tsx
<Text multilineTextAlignment="center">
  多行文本居中显示。
</Text>
```

***

### `truncationMode`

指定文本太长时的截断方式。

#### 类型

```ts
type TruncationMode = "head" | "middle" | "tail"
```

#### 描述

定义截断的位置：

- `"head"`：截断行首，保留末尾。
- `"middle"`：截断中间，保留首尾。
- `"tail"`：截断尾部，保留开头。

```tsx
<Text truncationMode="middle">
  这是一段可能会被截断的很长文本。
</Text>
```

***

### `allowsTightening?: boolean`

是否允许系统在必要时压缩字符间距以适应一行内显示。

#### 类型

`boolean`

#### 默认值

`false`

#### 描述

设置为 `true` 时，系统可以压缩字距以避免截断，并改善在受限空间下的布局适应性。

```tsx
<Text allowsTightening={true}>
  在需要时压缩的文本
</Text>
```

***

## 总结

通过组合这些属性，您可以完全掌控文本视图的排版，而无需多个包装组件或修饰符。无论您需要加粗、斜体、带自定义字符间距和下划线的标题，还是仅限两行显示的正文文本，这些选项都能满足广泛的文本样式需求。



---
url: /zh/guide/View Modifiers/Toast.md
---

# Toast提示

`toast` 修饰器用于在视图上显示一个临时提示框（Toast）。
它通常用于短暂地展示消息或反馈信息，例如“保存成功”、“操作完成”、“网络错误”等。

Toast 可以包含简单的文本消息，也可以自定义内容视图。
你可以控制其显示位置、持续时间、背景颜色、圆角、阴影等外观属性。

***

## 类型定义

```ts
toast?: {
  duration?: number | null
  position?: "top" | "bottom" | "center"
  backgroundColor?: Color | null
  textColor?: Color | null
  cornerRadius?: number | null
  shadowRadius?: number | null
} & (
  | { message: string; content?: never }
  | { message?: never; content: VirtualNode }
) & ({
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
} | {
  isPresented: Observable<boolean>
})
```

***

## 属性说明

### `isPresented: boolean` 和 `onChanged(isPresented: boolean): void`

**说明**：
使用`isPresented`和`onChanged`来控制Toast的显示和隐藏。

**示例**：

```tsx
const [showToast, setShowToast] = useState(false)

toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  message: "Saved successfully"
}}
```

***

### `isPresented: Observable<boolean>`

**说明**：使用 `isPresented` 作为 `Observable` 来控制 Toast 的显示和隐藏。

**示例**：

````tsx
const showToast = useObservable(false)

toast={{
  isPresented: showToast,
  message: "Saved successfully"
}}

---

### `duration?: number | null`

**说明**：
Toast 显示的持续时间（单位：秒）。
默认值为 `2` 秒。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  duration: 3,
  message: "Action completed"
}}
````

***

### `position?: "top" | "bottom" | "center"`

**说明**：
控制 Toast 在屏幕上的显示位置。
可选值：

- `"top"`：顶部显示
- `"bottom"`：底部显示（默认）
- `"center"`：居中显示

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  position: "top",
  message: "New message received"
}}
```

***

### `backgroundColor?: Color | null`

**说明**：
设置 Toast 的背景颜色。可以使用任意支持的 `Color` 类型。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  backgroundColor: "blue",
  message: "Upload successful"
}}
```

***

### `textColor?: Color | null`

**说明**：
设置 Toast 文本的颜色。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  textColor: "white",
  message: "Download failed"
}}
```

***

### `cornerRadius?: number | null`

**说明**：
设置 Toast 的圆角大小。
默认值为 `16`。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  cornerRadius: 8,
  message: "Item added"
}}
```

***

### `shadowRadius?: number | null`

**说明**：
设置阴影的模糊半径。
默认值为 `4`。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  shadowRadius: 6,
  message: "Success"
}}
```

***

## 显示文本消息

**示例**：

```tsx
function View() {
  const [showToast, setShowToast] = useState(false)

  return (
    <List
      toast={{
        isPresented: showToast,
        onChanged: setShowToast,
        message: "Data saved successfully",
        duration: 2,
        position: "bottom",
        backgroundColor: "green",
        textColor: "white"
      }}
    >
      <Button
        title="Save"
        action={() => setShowToast(true)}
      />
    </List>
  )
}
```

该示例中，当点击按钮后，会在底部显示一个绿色背景的提示“Data saved successfully”，持续 2 秒后自动消失。

***

## 显示自定义内容

**说明**：
除了简单文本，你还可以传入一个 `VirtualNode` 来自定义 Toast 的内容，例如包含图标、布局或按钮的自定义组件。

**示例**：

```tsx
function View() {
  const [showToast, setShowToast] = useState(false)

  return (
    <List
      toast={{
        isPresented: showToast,
        onChanged: setShowToast,
        content: (
          <HStack spacing={8}>
            <Image systemName="checkmark.circle.fill" />
            <Text foregroundStyle="white">Upload Complete</Text>
          </HStack>
        ),
        backgroundColor: "black",
        cornerRadius: 12
      }}
    >
      <Button
        title="Show Toast"
        action={() => setShowToast(true)}
      />
    </List>
  )
}
```

该示例展示了一个包含图标与文本的自定义 Toast。

***

## 使用建议

1. **保持状态同步**：
   `isPresented` 必须与 `onChanged` 回调保持同步，否则 Toast 无法正确关闭。

2. **简洁提示**：
   Toast 应用于短暂、轻量级的信息提示，而非需要交互的复杂内容。

3. **避免同时显示多个 Toast**：
   屏幕上同时出现多个 Toast 可能造成用户困惑。

4. **可组合使用**：
   你可以与 `Button`、`List` 等组件配合使用，用于即时反馈用户操作。



---
url: /zh/guide/View Modifiers/ToolBar View Modifiers.md
---

# 工具栏修饰符

Scripting App 支持一系列视图修饰符，用于控制系统工具栏（包括导航栏、底部工具栏、标签栏等）的可见性、外观样式以及行为。这些修饰符参考了 SwiftUI 的设计，允许你在每个视图中以声明式方式对工具栏进行个性化配置。

***

## 可见性控制修饰符

以下修饰符用于控制系统界面中各类栏（bar）的显示与隐藏：

```ts
bottomBarVisibility?: Visibility
navigationBarVisibility?: Visibility
tabBarVisibility?: Visibility
```

### Visibility 类型定义

```ts
type Visibility = "automatic" | "hidden" | "visible"
```

- **`automatic`**：由系统自动决定是否显示。
- **`hidden`**：强制隐藏该栏。
- **`visible`**：强制显示该栏。

***

## 工具栏标题菜单

```ts
toolbarTitleMenu?: VirtualNode
```

为导航栏的标题添加一个可点击菜单。点击导航标题后，系统会展示该菜单内容。常用于展示与当前页面相关的上下文操作选项。

***

## 工具栏背景样式

```ts
toolbarBackground?: ShapeStyle | DynamicShapeStyle | {
  style: ShapeStyle | DynamicShapeStyle
  bars?: ToolbarPlacement[]
}
```

配置工具栏的背景样式。支持颜色、材质、渐变等形式，可通过 `bars` 参数限定应用到特定栏位。

### bars（可选）

```ts
type ToolbarPlacement = "automatic" | "tabBar" | "bottomBar" | "navigationBar"
```

- 若未设置 `bars`，系统会自动决定应用范围。
- 可指定应用到 `tabBar`、`bottomBar` 或 `navigationBar` 等栏位。

***

## 工具栏背景可见性（仅限 iOS 18+）

```ts
toolbarBackgroundVisibility?: Visibility | {
  visibility: Visibility
  bars?: ToolbarPlacement[]
}
```

控制工具栏背景的可见性。例如，可使导航栏背景透明、半透明或完全不显示。

- **`visibility`**：可选值包括 `"automatic"`、`"visible"`、`"hidden"`。
- **`bars`**（可选）：指定希望应用该设置的栏位。若不指定，默认作用于所有工具栏。

***

## 工具栏配色方案

```ts
toolbarColorScheme?: ColorScheme | {
  colorScheme: ColorScheme | null
  bars?: ToolbarPlacement[]
}
```

指定工具栏的配色风格（亮色或暗色），影响工具栏内容的颜色（如按钮、标题等）。

### ColorScheme 类型定义

```ts
type ColorScheme = "light" | "dark"
```

- **`light`**：使用浅色配色风格。
- **`dark`**：使用深色配色风格。
- **`null`**：恢复系统默认配色。

`bars` 参数可限制仅对特定工具栏应用该配色设置。

***

## 工具栏标题展示模式

```ts
toolbarTitleDisplayMode?: ToolbarTitleDisplayMode
```

控制导航栏中标题的展示样式。

### ToolbarTitleDisplayMode 类型定义

```ts
type ToolbarTitleDisplayMode = "automatic" | "large" | "inline" | "inlineLarge"
```

- **`automatic`**：由系统自动决定使用大标题或小标题。
- **`large`**：使用大标题样式（通常在导航栈顶显示）。
- **`inline`**：标题与导航栏控件同行显示。
- **`inlineLarge`**：使用 inline 布局，但保留大标题的视觉风格（适用于自定义标题样式）。

***

## 使用说明

- 所有修饰符可组合使用，为每个视图实现精细化的工具栏配置。
- `toolbarBackground`、`toolbarColorScheme` 和 `toolbarBackgroundVisibility` 可通过 `bars` 参数作用于特定栏位，提供精准的外观控制。
- `toolbarBackgroundVisibility` 仅在 iOS 18 及以上版本有效。
- `toolbarTitleMenu` 适用于具备导航栏的视图，用于增强导航标题的交互性。



---
url: /zh/guide/View Modifiers/blur.md
---

# 模糊

对视图应用高斯模糊效果。

## 类型

```ts
blur?: number | {
  radius: number
  opaque: boolean
}
```

## 示例

简单模糊：

```tsx
<Image blur={10} />
```

自定义模糊：

```tsx
<Image
  blur={{
    radius: 12,
    opaque: false
  }}
/>
```



---
url: /zh/guide/View Modifiers/border.md
---

# 边框

`border` 属性用于为视图添加边框，可指定边框样式与可选的宽度。支持使用纯色、渐变、系统材质等视觉样式，并能根据系统浅色/深色模式自动切换。

## 定义

```ts
border?: {
  style: ShapeStyle | DynamicShapeStyle
  width?: number
}
```

- **`style`**：必填，定义边框的视觉样式，支持 `ShapeStyle` 或 `DynamicShapeStyle`。
- **`width`**：选填，设置边框的粗细（像素单位），默认值为 `1`。

## 使用示例

### 纯色边框

```tsx
<Text
  border={{
    style: "systemRed",
    width: 2
  }}
>
  带边框的文字
</Text>
```

### 默认宽度（1px）边框

```tsx
<HStack
  border={{
    style: "#000000"
  }}
>
  ...
</HStack>
```

### 渐变边框

```tsx
<Text
  border={{
    style: {
      gradient: [
        { color: "red", location: 0 },
        { color: "blue", location: 1 }
      ],
      startPoint: { x: 0, y: 0 },
      endPoint: { x: 1, y: 1 }
    },
    width: 3
  }}
>
  渐变边框
</Text>
```

### 动态边框样式（浅色/深色模式自动切换）

```tsx
<Text
  border={{
    style: {
      light: "gray",
      dark: "white"
    },
    width: 1.5
  }}
>
  自适应边框
</Text>
```

## 注意事项

- 边框将包裹整个视图边缘，并与视图尺寸和 `frame` 设置一起作用。
- `style` 支持所有 `ShapeStyle` 类型，也可使用系统材质（如 `"regularMaterial"`、`"ultraThinMaterial"`）来创建原生 iOS 风格的边框。



---
url: /zh/guide/View Modifiers/buttonStyle.md
---

# 按钮样式

该属性用于自定义 UI 中视图层次结构内按钮的交互行为和外观。

***

## 属性声明

```tsx
buttonStyle?: ButtonStyle;
```

### 描述

`buttonStyle` 属性为视图层次结构中的所有按钮应用特定样式，从而自定义它们的外观和交互行为。

***

### 可接受的值

`buttonStyle` 属性接受以下字符串值：

- **`automatic`**: 默认按钮样式，根据按钮的上下文进行自适应。
- **`bordered`**: 应用基于按钮上下文的标准边框样式。
- **`borderedProminent`**: 应用突出显示的边框样式，适合需要重点强调的按钮。
- **`borderless`**: 无边框样式。
- **`plain`**: 在空闲状态下不添加装饰，但会在按钮被按下、聚焦或启用时以视觉方式指示其状态。

***

### 默认行为

如果未指定 `buttonStyle`，则会根据按钮的上下文自动应用默认样式（`automatic`）。

***

## 使用示例

以下展示如何在 TypeScript 代码中使用 `buttonStyle` 属性：

### 示例：带边框的按钮样式

```tsx
<Button
  title="按下我"
  buttonStyle="bordered"
  action={() => console.log('按钮被按下！')}
/>
```

此示例创建了一个带有标准边框的按钮。

***

### 示例：无边框的按钮样式

```tsx
<Button
  title="按下我"
  buttonStyle="borderless"
  action={() => console.log('按钮被按下！')}
/>
```

此示例创建了一个无边框的按钮。

***

### 示例：纯样式按钮

```tsx
<Button
  title="按下我"
  buttonStyle="plain"
  action={() => console.log('按钮被按下！')}
/>
```

此示例创建了一个在空闲状态下不装饰内容，但在交互时会通过视觉效果指示状态的按钮。

***

## 注意事项

- `buttonStyle` 属性直接映射到 SwiftUI 的 `buttonStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。



---
url: /zh/guide/View Modifiers/clipShape.md
---

# 裁剪形状

将视图裁剪为指定形状，并保持内容比例。

### 类型

```ts
clipShape?: Shape
```

### 示例

```tsx
<Image 
  filePath="path/to/photo.jpg"
  clipShape="Circle"
/>

<Image 
  filePath="path/to/photo.jpg"
  clipShape={
    type: "rect",
    cornerRadius: 12
  }
/>
```



---
url: /zh/guide/View Modifiers/clipped.md
---

# 裁剪形状

将视图裁剪为其矩形边界。若为 `true`，启用裁剪；否则忽略该修饰符。可用于避免内容超出布局。

## 类型

```ts
clipped?: boolean
```

## 示例

```tsx
<Text
  fixedSize
  frame={{
    width: 175,
    height: 100
  }}
  clipped={true}
  border={{
    style: "gray"
  }}
>This long text string is clipped</Text>
```



---
url: /zh/guide/View Modifiers/colorConvert.md
---

# 反转颜色

反转该视图的颜色，用于视觉强调或辅助功能场景。

### 类型

```ts
colorConvert?: boolean
```

### 示例

```tsx
<Image
  colorConvert={true}
  imageUrl="https://example.com/imgs/example.jpg"
/>
```



---
url: /zh/guide/View Modifiers/containerRelativeFrame.md
---

# containerRelativeFrame

将当前视图放置在一个相对于其最近容器尺寸的“隐形框架”中。该修饰符适用于 `ScrollView`、`Grid`、布局栈等容器中，用于实现按比例布局或视图对齐。

## 类型定义

```ts
containerRelativeFrame?: {
  axes: AxisSet
  alignment?: Alignment
  count: never
  span: never
  spacing: never
} | {
  axes: AxisSet
  alignment?: Alignment
  count: number
  span?: number
  spacing: number
}
```

***

## 描述

该修饰符允许视图根据其父容器的尺寸进行相对的布局和定位。常用于构建按比例划分空间的布局，或配合滚动视图对视图进行精准定位。

***

## 属性说明

- **`axes`** (`AxisSet`，必填)
  指定在哪些轴向上应用相对布局（可选值：`horizontal`、`vertical` 或 `all`）。

- **`alignment`** (`Alignment`，可选，默认值：`"center"`）
  控制视图在容器内的对齐方式。

- **`count`** (`number`，可选，仅在第二种用法中有效)
  容器会被划分为多少等分。

- **`span`** (`number`，可选，默认值为 `1`)
  当前视图应占据多少等分。

- **`spacing`** (`number`，仅在第二种用法中为必填)
  分段之间的间距。

***

## 使用方式

该修饰符支持两种配置模式：

### 1. **自动适应模式**

仅指定对齐方向和轴向，不设置具体划分方式。

```tsx
containerRelativeFrame={{
  axes: 'horizontal',
  alignment: 'leading'
}}
```

### 2. **按比例划分模式**

将容器划分为若干等分，并为每个视图分配所占比例及间距。

```tsx
containerRelativeFrame={{
  axes: 'horizontal',
  count: 4,
  span: 2,
  spacing: 10
}}
```

***

## 示例

```tsx
<HStack>
  <Text
    containerRelativeFrame={{
      axes: 'horizontal',
      count: 3,
      span: 1,
      spacing: 8,
      alignment: 'center'
    }}
  >
    占据三分之一宽度
  </Text>
</HStack>
```

该示例将文字放入一个宽度为容器三分之一的区域内，视图之间的间距为 8。

***

## 参考资料

- [Apple 官方文档](https://developer.apple.com/documentation/swiftui/view/containerrelativeframe%28_:alignment:%29)
- [Hacking with Swift 教程](https://www.hackingwithswift.com/quick-start/swiftui/how-to-adjust-the-size-of-a-view-relative-to-its-container)



---
url: /zh/guide/View Modifiers/contentMargins.md
---

# 内容外边距

`contentMargins` 修饰符用于为视图内容添加自定义的外边距（Margins）。它支持统一设置所有边，也支持根据指定方向（如顶部、底部、水平、垂直）以及不同位置（内容区域或滚动指示器区域）灵活设置边距。

***

## 类型定义

```ts
contentMargins?: 
  | number
  | EdgeInsets
  | {
      edges?: EdgeSet
      insets: number | EdgeInsets
      placement?: ContentMarginPlacement
    }
```

***

## 参数说明

## `insets`（必填）

指定要添加的边距数值：

- 可传入一个数字，表示所有边统一使用该数值；
- 或传入 `EdgeInsets` 对象，分别设置 `top`、`bottom`、`leading`、`trailing`。

### 示例：统一边距

```tsx
<ScrollView contentMargins={20}>
  <Text>上下左右各添加 20 点边距</Text>
</ScrollView>
```

### 示例：分别设置边距

```tsx
<ScrollView
  contentMargins={{
    top: 10,
    bottom: 30,
    leading: 16,
    trailing: 16
  }}
>
  <Text>自定义边距</Text>
</ScrollView>
```

***

## `edges`（可选）

设置要在哪些方向上应用边距，默认是全部方向。

### 类型

```ts
type EdgeSet = "top" | "bottom" | "leading" | "trailing" | "vertical" | "horizontal" | "all"
```

### 示例：仅设置上下边距

```tsx
<ScrollView
  contentMargins={{
    edges: "vertical",
    insets: 12
  }}
>
  <Text>仅上下有边距</Text>
</ScrollView>
```

***

## `placement`（可选）

指定边距的作用区域，适用于滚动容器（如 ScrollView）中需要区分内容区域和滚动条指示区域的场景。

### 类型

```ts
type ContentMarginPlacement = "automatic" | "scrollContent" | "scrollIndicators"
```

### 可选值说明：

| 值                    | 描述                  |
| -------------------- | ------------------- |
| `"automatic"`        | 默认行为，系统决定边距应用位置     |
| `"scrollContent"`    | 边距应用于可滚动的内容区域       |
| `"scrollIndicators"` | 边距仅应用于滚动指示器（如滚动条）区域 |

### 示例：边距仅作用于内容区域

```tsx
<ScrollView
  contentMargins={{
    insets: 24,
    placement: "scrollContent"
  }}
>
  <Text>内容区域设置边距，滚动条不受影响</Text>
</ScrollView>
```

***

## 完整示例

```tsx
<ScrollView
  contentMargins={{
    edges: "horizontal",
    insets: { leading: 20, trailing: 20, top: 0, bottom: 0 },
    placement: "scrollContent"
  }}
>
  <VStack spacing={10}>
    <Text>仅在横向内容区域添加边距</Text>
  </VStack>
</ScrollView>
```

***

## 参数汇总

| 参数          | 说明                                         |
| ----------- | ------------------------------------------ |
| `insets`    | 必填。边距数值，可为统一数字或 `EdgeInsets` 对象            |
| `edges`     | 可选。应用边距的方向，如 `"vertical"`、`"horizontal"` 等 |
| `placement` | 可选。边距作用区域（内容区域或滚动条区域）                      |



---
url: /zh/guide/View Modifiers/contentShape.md
---

# 内容形状

`contentShape` 属性用于定义视图内容的**交互区域或视觉边界形状**。该形状可影响视图在点击、拖放、辅助功能、悬停等场景中的行为。常用于精确控制**命中测试（hit-testing）区域**或指定用于辅助功能和交互反馈的自定义轮廓。

这在如下场景中特别有用：

- 控制按钮或自定义视图的可点击区域；
- 定义拖放预览或上下文菜单的形状；
- 指定辅助功能的可聚焦区域；
- 优化鼠标悬停的交互体验。

## 定义

```ts
contentShape?: Shape | {
  kind: ContentShapeKinds
  shape: Shape
}
```

***

## 支持的写法

### 1. 简单形状（适用于所有用途）

直接传入一个 `Shape` 值，作为默认交互区域，用于所有情境（点击、辅助功能、拖放等）。

```tsx
contentShape="circle"
```

***

### 2. 按用途定义的指定形状

使用结构体形式设置指定类型的内容形状：

```ts
{
  kind: ContentShapeKinds
  shape: Shape
}
```

用于为特定交互类型（如 `accessibility`、`dragPreview`）设置不同的区域。

***

## 支持的 `ContentShapeKinds`

| 类型名称                   | 用途说明                      |
| ---------------------- | ------------------------- |
| `"interaction"`        | 命中测试区域（如点击、手势）            |
| `"dragPreview"`        | 拖放操作中的预览形状                |
| `"contextMenuPreview"` | 上下文菜单预览的形状                |
| `"hoverEffect"`        | 鼠标悬停交互区域（适用于连接鼠标的设备）      |
| `"accessibility"`      | 辅助功能可聚焦区域，用于朗读、排序、高亮等辅助操作 |

***

## 示例

### 为所有交互设置默认形状

```tsx
<Button
  title="点击我"
  action={() => {}}
  contentShape="capsule"
/>
```

***

### 仅为辅助功能定义内容形状

```tsx
<Button
  title="可访问按钮"
  action={() => {}}
  contentShape={{
    kind: "accessibility",
    shape: {
      type: "rect",
      cornerRadius: 12
    }
  }}
/>
```

***

### 自定义点击区域为椭圆形

```tsx
<Text
  contentShape={{
    kind: "interaction",
    shape: "ellipse"
  }}
>
  自定义点击区域
</Text>
```

***

## 注意事项

- `contentShape` **不会影响视图的外观**，只影响其**交互行为**；
- 如果使用自定义形状，建议确保其与视图的 `frame` 对齐合理；
- 对于只有图标的按钮或较小区域，设置合适的 `contentShape` 有助于提升点击命中率与可访问性。



---
url: /zh/guide/View Modifiers/contentTransition.md
---

# 内容过渡动画

`contentTransition` 修饰符用于指定当视图 **内容发生变化** 时所应用的动画过渡效果。不同于 `.transition(...)` 这种控制视图出现或消失的动画，`contentTransition` 仅作用于视图内部内容的更新，例如 `Text` 文本变化、`Image` 图标替换等。

适用于需要在数据变化时提供平滑视觉过渡的场景，增强界面响应性和用户体验。

***

## 类型定义

```ts
contentTransition?: ContentTransition
```

***

## 可选值说明（`ContentTransition`）

\| 值 | 说明 |

***

### `"identity"`

- 默认行为，不进行任何动画处理。
- 内容会直接更新，无任何过渡效果。

```tsx
<Text contentTransition="identity">{value}</Text>
```

***

### `"interpolate"`

- 尝试在旧内容与新内容之间进行插值动画。
- 适用于颜色、形状、可插值视图等类型。

```tsx
<Rectangle fill={color} contentTransition="interpolate" />
```

***

### `"opacity"`

- 使用透明度进行过渡：旧内容淡出，新内容淡入。
- 通用型过渡动画，适用于各种视图。

```tsx
<Text contentTransition="opacity">{message}</Text>
```

***

### `"numericText"`

- 专为数字文本（`Text`）设计的过渡动画。
- 适用于数字更新场景，如统计数字或分数显示。

```tsx
<Text contentTransition="numericText">{score}</Text>
```

***

### `"numericTextCountsUp"`

- 适用于 **数字递增** 的动画优化。
- 类似计数器的上升效果。

```tsx
<Text contentTransition="numericTextCountsUp">{level}</Text>
```

***

### `"numericTextCountsDown"`

- 适用于 **数字递减** 的动画优化。
- 常用于倒计时、剩余时间等场景。

```tsx
<Text contentTransition="numericTextCountsDown">{remainingTime}</Text>
```

***

### `"symbolEffect"`

- 针对 SF Symbols 图标（如 `Image(systemName)`）的默认动画。
- 仅对符号图标生效，其他视图不受影响。

```tsx
<Image
  systemName={isOn ? "lightbulb.fill" : "lightbulb"}
  contentTransition="symbolEffect"
/>
```

***

### `"symbolEffectAutomatic"`

- 系统自动选择合适的符号动画方式。
- 常用于上下文自适应的图标切换。

```tsx
<Image
  systemName={icon}
  contentTransition="symbolEffectAutomatic"
/>
```

***

### `"symbolEffectReplace"`

- 以过渡方式替换符号图层。
- 提供比直接替换更平滑的过渡效果。

```tsx
<Image
  systemName={currentSymbol}
  contentTransition="symbolEffectReplace"
/>
```

***

### `"symbolEffectAppear"` / `"symbolEffectDisappear"`

- 控制符号图标的显现或消失动画。
- 通常结合条件渲染（`if`）使用。

```tsx
{isShown
  ? <Image
    systemName="checkmark"
    contentTransition="symbolEffectAppear"
  />
  : null
}
```

***

### `"symbolEffectScale"`

- 内容变化时应用缩放动画。
- 常用于状态切换或强调某个图标时使用。

```tsx
<Image
  systemName={statusIcon}
  contentTransition="symbolEffectScale"
/>
```

***

## 用法总结

| 过渡类型                               | 使用场景              |
| ---------------------------------- | ----------------- |
| `identity`                         | 无动画，直接更新内容        |
| `interpolate`                      | 可插值类型（颜色、形状）之间的过渡 |
| `opacity`                          | 通用型淡入淡出           |
| `numericText`                      | 数字变动过渡            |
| `numericTextCountsUp`              | 数字递增动画（计数器）       |
| `numericTextCountsDown`            | 数字递减动画（倒计时）       |
| `symbolEffect`                     | SF Symbols 图标切换动画 |
| `symbolEffectAutomatic`            | 系统自动选择图标过渡方式      |
| `symbolEffectReplace`              | 符号图层替换过渡          |
| `symbolEffectAppear` / `Disappear` | 控制符号显现或消失动画       |
| `symbolEffectScale`                | 缩放动画，用于状态变更反馈     |

***

## 说明

- 该修饰符不会影响视图的布局或层级，仅作用于“内部内容”的视觉表现。
- 对于 SF Symbols 图标变化，推荐使用符号专属的过渡类型以获得最佳动画效果。



---
url: /zh/guide/View Modifiers/contextMenu.md
---

# 上下文菜单

`contextMenu` 属性用于为任意视图添加系统风格的上下文菜单。在触控设备上通过长按触发，在使用鼠标的设备上则可通过右键点击触发。开发者可以自定义菜单项内容，并可选地添加一个预览视图，与菜单同时显示。

***

## 定义

```ts
contextMenu?: {
  menuItems: VirtualNode
  preview?: VirtualNode
}
```

***

## 字段说明

- **`menuItems`**：定义菜单项内容的 `VirtualNode`。通常包含多个 `Button` 组件，并建议使用 `Group` 元素进行组织，以确保良好的布局与交互。

- **`preview`**（可选）：一个预览视图，类型为 `VirtualNode`。该视图会在上下文菜单旁边展示，用于提供可视化的上下文提示，例如当前操作的对象缩略图或详细信息。

***

## 行为说明

当用户对视图进行长按（触控设备）或右键点击（指针设备）时，系统将展示由 `menuItems` 定义的上下文菜单；如果提供了 `preview` 属性，则在菜单旁边显示对应的预览内容。

***

## 示例

```tsx
function View() {
  return <Text
    contextMenu={{
      menuItems: <Group>
        <Button
          title="添加"
          action={() => {
            // 执行添加操作
          }}
        />
        <Button
          title="删除"
          role="destructive"
          action={() => {
            // 执行删除操作
          }}
        />
      </Group>
    }}
  >
    长按以打开上下文菜单
  </Text>
}
```

上述示例中，`Text` 视图被添加了上下文菜单。在长按该文本时，系统会展示两个操作项：“添加” 和 “删除”，其中“删除”按钮带有破坏性角色样式（`destructive`）。

***

## 注意事项

- 上下文菜单的样式由系统自动管理，符合各平台的界面规范。
- `preview` 字段为可选项，未提供时仅展示菜单项。
- 推荐使用 `Group` 对 `menuItems` 进行结构化组织，以确保良好的交互体验和渲染效果。



---
url: /zh/guide/View Modifiers/controlGroupStyle.md
---

# 控件组样式

通过该属性，你可以为视图中的控件组设置视觉和交互样式，模仿 SwiftUI 的外观和体验。通过定义 `ControlGroupStyle`，可以影响相关控件（如按钮、切换开关或其他可交互元素）如何被分组和呈现给用户。

***

## 概述

在 SwiftUI 中，你可以像这样设置 `controlGroupStyle`：

```swift
ControlGroup {
    Button("操作 1") { ... }
    Button("操作 2") { ... }
}
.controlGroupStyle(.navigation)
```

**在 Scripting（TypeScript/TSX）中**，可以通过 `controlGroupStyle` 属性在包含控件组的视图上实现类似的样式设置：

```tsx
<ControlGroup
  title="文本格式化"
  controlGroupStyle="navigation"
>
  <Button title="加粗" action={() => console.log('加粗按钮被按下')} />
  <Button title="斜体" action={() => console.log('斜体按钮被按下')} />
  <Button title="下划线" action={() => console.log('下划线按钮被按下')} />
</ControlGroup>
```

***

## 可用样式

你可以将以下字符串值分配给 `controlGroupStyle`，以定义控件组的显示方式：

- **`automatic`**：让系统根据上下文决定合适的样式。
- **`compactMenu`**：将控件以紧凑菜单的形式展示，点击后展开，或者作为嵌套菜单的一部分。
- **`menu`**：将控件以菜单形式显示，按下时呈现为一个菜单或嵌套子菜单。
- **`navigation`**：将控件样式化以适应导航上下文，通常与平台特定的导航样式一致。
- **`palette`**：以调色板式分组显示控件，通常同时显示多个操作选项。

***

## 使用示例

### 设置 `controlGroupStyle` 为菜单样式

```tsx
<ControlGroup
  controlGroupStyle="menu"
>
  {/* 在此添加你的控件内容 */}
</ControlGroup>
```

在此示例中，控件组将以菜单形式显示。点击或与该组交互时，会以菜单界面呈现项目。

***

### 使用调色板样式

```tsx
<ControlGroup
  title="文本格式化"
  controlGroupStyle="palette"
>
  <Button title="加粗" action={() => console.log('加粗按钮被按下')} />
  <Button title="斜体" action={() => console.log('斜体按钮被按下')} />
  <Button title="下划线" action={() => console.log('下划线按钮被按下')} />
</ControlGroup>
```

在此示例中，控件会以调色板样式显示，多个样式选项可以同时展示，方便用户快速选择。

***

### 自动样式

如果不确定哪种样式最佳，或者希望让系统选择合适的样式，可以使用 `automatic`：

```tsx
<ControlGroup
  title="媒体控制"
  controlGroupStyle="automatic"
>
  <Button title="操作 A" action={() => console.log('操作 A')} />
  <Button title="操作 B" action={() => console.log('操作 B')} />
</ControlGroup>
```

在此示例中，系统会根据上下文自动选择适合的控件组样式。

***

## 小结

通过设置 `controlGroupStyle`，你可以决定控件组的显示和交互方式。无论是选择 `menu`、`compactMenu`、`navigation`、`palette`，还是依赖系统默认的 `automatic` 样式，该属性都能帮助你的脚本控件自然地融入平台的 UI 规范和用户期望。



---
url: /zh/guide/View Modifiers/datePickerStyle.md
---

# 日期选择器样式

该属性用于自定义 `DatePicker` 视图在 UI 中的外观和交互方式。

***

## 属性声明

```tsx
DatePickerStyle = "automatic" | "compact" | "graphical" | "wheel" | "field" | "stepperField"
DatePickerComponents = "hourAndMinute" | "date" | "hourMinuteAndSecond"
```

***

## `DatePickerStyle` 值

`DatePickerStyle` 属性接受以下字符串值，用于定义日期选择器的外观和交互方式：

- **`automatic`**: 日期选择器的默认样式。
- **`compact`**: 将日期选择器组件以紧凑的文本格式显示。
- **`graphical`**: 将日期选择器显示为交互式日历或时钟。
- **`wheel`**: 将日期选择器组件显示为可滚动的轮状列。
- **`field`** _(仅 macOS)_: 将组件显示为可编辑的字段。
- **`stepperField`** _(仅 macOS)_: 将组件显示为带有递增/递减控件的可编辑字段。

***

## `DatePickerComponents` 值

`displayedComponents` 属性指定日期选择器显示和可编辑的日期组件。可接受的值包括：

- **`date`**: 显示基于本地化的日、月、年。
- **`hourAndMinute`**: 显示基于本地化的小时和分钟。
- **`hourMinuteAndSecond`** _(仅 watchOS)_: 显示基于本地化的小时、分钟和秒。

***

## 使用示例

### 示例 1: 图形化日期选择器

```tsx
function View() {
  const [date, setDate] = useState(Date.now())

  return <DatePicker
    title="选择日期"
    value={date}
    onChanged={setDate}
    startDate={Date.now() - 31556926000} // 1 年前
    endDate={Date.now() + 31556926000}  // 1 年后
    displayedComponents={["date"]}
    datePickerStyle="graphical"
  />
}
```

此示例创建了一个用于选择日期的图形化日期选择器。

***

### 示例 2: 紧凑型时间选择器

```tsx
function View() {
  const [time, setTime] = useState(Date.now())
  return <DatePicker
    title="选择时间"
    value={time}
    onChanged={setTime}
    displayedComponents={["hourAndMinute"]}
    datePickerStyle="compact"
  />
}
```

此示例创建了一个紧凑型日期选择器，用于选择小时和分钟。

***

### 示例 3: 滚轮日期选择器

```tsx
function View() {
  const [date, setDate] = useState(Date.now())
  return <DatePicker
    title="选择日期和时间"
    value={date}
    onChanged={setDate}
    displayedComponents={["hourAndMinute", "date"]}
    datePickerStyle="wheel"
  />
}
```

此示例创建了一个带滚轮的日期选择器，用于选择日期和时间。

***

## 注意事项

- `DatePickerStyle` 属性直接映射到 SwiftUI 的 `datePickerStyle` 修饰符。
- 确保 `displayedComponents` 和 `datePickerStyle` 的值与目标平台兼容，以避免运行时错误。
- 对于 macOS 特定的样式（`field` 和 `stepperField`），请确保应用在 macOS 上运行。

通过使用 `DatePickerStyle`，可以创建多功能的日期选择器，满足应用设计和功能需求。



---
url: /zh/guide/View Modifiers/disabled.md
---

# 禁用

禁用当前视图及其子视图的用户交互行为，视觉上通常为半透明状态。

## 类型

```ts
disabled?: boolean
```

## 示例

```tsx
<Button
 title="提交" 
 disabled={submitDisabled}
 action={submit}
/>
```



---
url: /zh/guide/View Modifiers/fixedSize.md
---

# 固定大小

将视图固定在其理想大小，防止其被压缩或扩展超出其内容本身所需的尺寸。

## 类型

```ts
fixedSize?: boolean | {
  horizontal: boolean
  vertical: boolean
}
```

## 概述

`fixedSize` 修饰符会告诉布局系统使用视图的“理想尺寸”进行布局，而不是根据父视图的限制拉伸或压缩视图。这在你希望文本不被截断、内容完整显示时非常有用，或者在你希望视图不随父容器大小变化而自动调整尺寸时使用。

该行为与 SwiftUI 中的 [`fixedSize()`](https://developer.apple.com/documentation/swiftui/view/fixedsize%28%29) 一致。

## 使用方式

你可以通过两种方式设置 `fixedSize`：

### 1. 布尔值形式

```tsx
<Text fixedSize>
  这段文字不会被压缩或截断。
</Text>
```

等价于：

```tsx
<Text fixedSize={{ horizontal: true, vertical: true }}>
  这段文字不会被压缩或截断。
</Text>
```

### 2. 对象形式

通过对象形式可以分别控制水平和垂直方向是否固定：

```tsx
<Text fixedSize={{ horizontal: true, vertical: false }}>
  水平方向不压缩，垂直方向仍可适应内容。
</Text>
```

## 行为说明

- `horizontal: true`：视图水平方向保持其理想宽度，不会被压缩或拉伸，常用于防止文字被截断。
- `vertical: true`：视图垂直方向保持理想高度，不会被压缩或拉伸。
- 两个方向都为 `false` 时，该修饰符不生效。
- 父容器在布局时如果给定了较小的空间，设置了 `fixedSize` 的视图将优先保持其理想尺寸，可能导致内容溢出。

## 示例

```tsx
<VStack>
  <Text fixedSize>
    一段较长的文字，不应被截断，应完整显示。
  </Text>
  <Text fixedSize={{ horizontal: true, vertical: false }}>
    这段文字保持水平方向的尺寸，但可以在垂直方向自动换行或扩展。
  </Text>
</VStack>
```

## 注意事项

- 常用于防止 `Text` 视图在父容器中被截断。
- 与 `HStack`、`VStack` 等布局组件结合时，可以更精确地控制某个子视图不随整体布局缩放。
- 使用该修饰符时，应考虑可能出现的内容溢出或布局冲突问题。



---
url: /zh/guide/View Modifiers/flipsForRightToLeftLayoutDirection.md
---

# flipsForRightToLeftLayoutDirection

设置当系统使用从右到左（Right-to-Left, RTL）布局方向时，当前视图是否应水平镜像其内容。

## 类型

`flipsForRightToLeftLayoutDirection?: boolean`

## 描述

当设为 `true` 时，视图会在 RTL 布局环境下水平翻转其内容，以符合阿拉伯语、希伯来语等从右到左语言的阅读方向。这在需要手动控制视图镜像行为的自定义组件中尤为有用。

若设为 `false`，则视图无论当前系统布局方向如何，都会保持从左到右的默认布局。

## 默认值

`false`（默认不会自动翻转视图）

## 示例

```tsx
<Image
  filePath="path/to/icon.png"
  flipsForRightToLeftLayoutDirection={true}
/>
```

在上述示例中，当界面处于 RTL 布局时，图像会自动进行水平翻转。



---
url: /zh/guide/View Modifiers/foregroundStyle & background.md
---

# 前景色和背景样式

`foregroundStyle` 和 `background` 是用于设置视图前景与背景视觉效果的两个常用属性，支持颜色、渐变、系统材质，以及深浅模式自动切换等丰富的样式能力。

***

## `foregroundStyle`

### 定义

```ts
foregroundStyle?: ShapeStyle | DynamicShapeStyle | {
  primary: ShapeStyle | DynamicShapeStyle
  secondary: ShapeStyle | DynamicShapeStyle
  tertiary?: ShapeStyle | DynamicShapeStyle
}
```

用于设置视图前景的样式，如文字、图形或符号的颜色。支持单一样式或三层样式（primary、secondary、tertiary），可用于 SF Symbols 或富文本等需要多层渲染的内容。

### 示例

#### 基础颜色前景

```tsx
<Text foregroundStyle="white">
  Hello World!
</Text>
```

#### 动态前景色（根据深浅模式切换）

```tsx
<Text
  foregroundStyle={{
    light: "black",
    dark: "white"
  }}
>
  自适应文本
</Text>
```

#### 多层前景样式

```tsx
<Text
  foregroundStyle={{
    primary: "red",
    secondary: "orange",
    tertiary: "yellow"
  }}
>
  多层样式
</Text>
```

> 多层样式常用于 SF Symbols 或支持图层渲染的系统图标。

***

## `background`

### 定义

```ts
background?: 
  | ShapeStyle 
  | DynamicShapeStyle 
  | { style: ShapeStyle | DynamicShapeStyle, shape: Shape }
  | VirtualNode 
  | { content: VirtualNode, alignment: Alignment }
```

设置视图的背景。支持使用颜色、渐变、材质等样式，也可以自定义形状或组件作为背景，甚至指定对齐方式。

### 支持格式说明

1. **`ShapeStyle`**：颜色、渐变或材质等。
2. **`DynamicShapeStyle`**：根据系统深浅模式切换样式。
3. **`shape + style`**：将样式应用于指定形状，如圆角矩形。
4. **`VirtualNode`**：使用另一个组件作为背景。
5. **`content + alignment`**：设置背景内容并指定对齐方式。

### 示例

#### 纯色背景

```tsx
<Text background="systemBlue">
  Hello
</Text>
```

#### 渐变背景

```tsx
<Text
  background={{
    gradient: [
      { color: "purple", location: 0 },
      { color: "blue", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  }}
>
  渐变背景
</Text>
```

#### 动态背景（根据系统模式自动切换）

```tsx
<Text
  background={{
    light: "white",
    dark: "black"
  }}
>
  模式自适应背景
</Text>
```

#### 使用形状作为背景

```tsx
<Text
  background={
    <RoundedRectangle fill="systemBlue" />
  }
>
  Hello World!
</Text>
```

#### 自定义背景内容与对齐方式

```tsx
<Text
  background={{
    content: <Image filePath="path/to/background.jpg" />,
    alignment: "center"
  }}
>
  覆盖文字
</Text>
```

***

## 相关类型说明

- **`ShapeStyle`**
  定义颜色、渐变或材质的样式，可使用字符串颜色（如 `"red"`、`"#FF0000"`）、渐变对象、系统材质等。

- **`DynamicShapeStyle`**
  根据浅色或深色模式分别定义不同的样式，系统自动切换。

- **`VirtualNode`**
  表示一个视图组件，例如 `<Image />`、`<RoundedRectangle />` 等 JSX 元素。

- **`Shape`**
  用于设置背景形状，如 `RoundedRectangle`、`Circle`、`Capsule` 等。

***

## 小结

| 属性名称              | 功能描述          | 支持的类型说明                                       |
| ----------------- | ------------- | --------------------------------------------- |
| `foregroundStyle` | 设置前景样式（如文字颜色） | `ShapeStyle`、`DynamicShapeStyle` 或三层样式对象      |
| `background`      | 设置背景内容        | `ShapeStyle`、`DynamicShapeStyle`、形状样式、组件或对齐配置 |

通过灵活使用 `foregroundStyle` 与 `background`，你可以快速构建出具有丰富视觉表现力且适应系统样式的 UI 界面。



---
url: /zh/guide/View Modifiers/formStyle.md
---

# 表单样式

通过设置 `FormStyle`，你可以定义表单内容的视觉排列方式和呈现方式，从而提供更清晰、更直观的用户体验。

***

## 概述

一个 `Form` 视图可以包含多种控件（如文本框、切换开关、选择器等），以行的形式排列。`FormStyle` 决定了这些行的显示方式——是标签和值分列对齐，还是控件以视觉上分组的形式显示。

***

## 可用样式

- **`automatic`**：\
  让系统根据上下文选择最适合的样式。这通常是一个不错的默认选择，适合没有特定布局需求的场景。

- **`columns`**：\
  显示一个不可滚动的表单，标签在左侧的列中右对齐，对应的值或控件在右侧的列中左对齐。这种样式非常适合需要清晰查看标签-值对的场景。

- **`grouped`**：\
  将表单组织成视觉上分组的部分。每行通常是左对齐的标签和右对齐的控件。这种样式有助于将相关的输入字段划分为不同的类别，适合较长或复杂的表单，方便用户导航。

***

## 使用示例

### **列样式 (Columns Style)**

```tsx
<Form formStyle="columns">
  <TextField
    title="名字"
    value={firstName} 
    onChanged={setFirstName}
  />
  <TextField 
    title="姓氏" 
    value={lastName} 
    onChanged={setLastName} 
  />
  <Toggle 
    title="订阅" 
    value={subscribe} 
    onChanged={setSubscribe} 
  />
</Form>
```

在此布局中，标签（如“名字”、“姓氏”、“订阅”）整齐地排列在一列中，输入字段或切换开关与其对应对齐。

***

### **分组样式 (Grouped Style)**

```tsx
<Form formStyle="grouped">
  <Section 
    header={
      <Text>个人信息</Text>
    }>
    <TextField 
      title="电子邮件" 
      value={email} 
      onChanged={setEmail} 
    />
    <TextField 
      title="电话" 
      value={phone} 
      onChanged={setPhone} 
    />
  </Section>
  <Section 
    header={
      <Text>设置</Text>
    }>
    <Toggle 
      title="启用通知" 
      value={notificationsEnabled} 
      onChanged={setNotificationsEnabled} 
    />
    <Toggle 
      title="自动更新" 
      value={autoUpdate} 
      onChanged={setAutoUpdate} 
    />
  </Section>
</Form>
```

在此示例中，输入字段被分组为“个人信息”和“设置”两部分。每个部分的行都呈现为清晰的标签和控件对，帮助用户理解输入字段的逻辑分组。

***

### **自动样式 (Automatic Style)**

```tsx
<Form formStyle="automatic">
  <TextField 
    title="用户名" 
    value={username} 
    onChanged={setUsername} 
  />
  <SecureField 
    title="密码" 
    value={password} 
    onChanged={setPassword} 
  />
</Form>
```

使用 `automatic` 样式时，系统会选择默认样式。此选项适合简单表单或希望让系统根据不同上下文或平台自动调整样式的场景。

***

## 总结

- 选择 **`columns`** 用于结构化的两列布局，便于快速扫描标签和值。
- 选择 **`grouped`** 用于将控件分组成视觉上独立的部分，适合更复杂的表单。
- 选择 **`automatic`** 让系统自动处理布局决策，适合简单或需要适应多平台的界面。

通过在 `Form` 上设置 `formStyle`，你可以根据表单的复杂性和用户需求微调其显示方式，提供最佳的用户体验。



---
url: /zh/guide/View Modifiers/frame.md
---

# frame

`frame` 属性用于设置视图的尺寸（固定或弹性）以及在容器中的对齐方式。支持两种不同的配置格式：

***

### 1. 固定尺寸格式

```ts
frame?: {
  width?: number
  height?: number
  alignment?: Alignment
}
```

用于指定固定的宽度和高度，并设置在该区域内的对齐方式。

#### 示例

```tsx
<VStack
  frame={{
    width: 100,
    height: 100,
    alignment: 'center'
  }}
>
  <Text>固定尺寸</Text>
</VStack>
```

***

### 2. 弹性尺寸格式

```ts
frame?: {
  alignment?: Alignment
  minWidth?: number
  minHeight?: number
  maxWidth?: number | 'infinity'
  maxHeight?: number | 'infinity'
  idealWidth?: number | 'infinity'
  idealHeight?: number | 'infinity'
}
```

用于设置最小、最大和理想尺寸。数值可以为具体数值或字符串 `'infinity'`，表示尽可能占满可用空间。

#### 示例

```tsx
<HStack
  frame={{
    minWidth: 100,
    maxWidth: 'infinity',
    minHeight: 50,
    idealHeight: 100,
    alignment: 'leading'
  }}
>
  <Text>可扩展宽度</Text>
</HStack>
```

***

## 对齐方式（Alignment）

`alignment` 决定视图在其 frame 内的布局位置。支持的值包括：

- `'center'`（居中）
- `'top'`（顶部对齐）
- `'bottom'`（底部对齐）
- `'leading'`（前导边对齐，LTR 中为左）
- `'trailing'`（尾部边对齐，LTR 中为右）
- `'topLeading'`（左上角）
- `'topTrailing'`（右上角）
- `'bottomLeading'`（左下角）
- `'bottomTrailing'`（右下角）

> **注意**：仅当 frame 的尺寸大于内容视图的自然尺寸时，对齐方式才会起作用。

#### 示例

```tsx
<Text
  frame={{
    width: 200,
    height: 100,
    alignment: 'bottomTrailing'
  }}
>
  对齐文本
</Text>
```

***

## 使用建议

- 如果需要精确控制尺寸，建议使用固定格式的 `width` 和 `height`。
- 如果希望布局适应不同屏幕或内容，推荐使用弹性尺寸的 `min` / `max` / `ideal` 格式。
- 请勿在同一个 `frame` 对象中混合使用 `width` / `height` 与 `minWidth` / `maxWidth` 等，以避免冲突。

***

## 总结

`frame` 属性是布局控制的基础工具，可用于设定视图尺寸和定位方式。借助 `CommonViewProps`，你可以灵活地构建适配性强、结构清晰的界面布局。



---
url: /zh/guide/View Modifiers/gaugeStyle.md
---

# 仪表盘样式

通过设置 `GaugeStyle`，你可以定义仪表（Gauge）的视觉表示方式，从而控制其外观是否显示为环形、条形或通过标记指示当前值。一些样式仅适用于特定平台（如 watchOS），其他样式则具有更广泛的适用性。

***

## 概述

`Gauge` 组件用来以视觉方式表示指定范围内的值。例如，你可以用它显示电池电量、下载进度或温度读数。通过结合 `Gauge` 和指定的 `GaugeStyle`，你可以调整仪表的外观，以匹配应用的设计语言或功能需求。

**关键点：**

- 根据数据的性质选择合适的样式——环形适用于圆形上下文，条形适用于线性上下文。
- 有些样式使用标记指示当前值；其他样式使用填充段表示部分容量。
- 某些样式仅适用于 watchOS，具体见下文说明。

***

## 可用样式

- **`automatic`**：\
  使用系统为当前平台和上下文选择的默认样式。如果你没有特定偏好，这是一个很好的起点。

- **`accessoryCircular`**：\
  显示一个开口的环形，标记指针沿环的圆周指向当前值。适用于以紧凑圆形表示水平或百分比的场景。

- **`accessoryCircularCapacity`**：\
  类似于 `accessoryCircular`，但显示一个闭合的部分环形，填充到当前值。这种样式非常适合显示容量级别，例如存储使用情况。

- **`circular`** _(仅适用于 watchOS)_：\
  类似于 `accessoryCircular`，显示一个带标记指针的开口环形。适合用于 watchOS 的复杂功能或类似小型设备显示。

- **`linearCapacity`**：\
  显示一个水平条，从左侧填充到右侧，表示值的增长。非常适合用作进度条、电池电量或内存使用指示器。

- **`accessoryLinear`**：\
  一个线性仪表，通过条形上的标记指示当前值，而不是填充段。

- **`accessoryLinearCapacity`**：\
  结合了 `linearCapacity` 和 `accessoryLinear` 样式，显示一个随值增长的填充条段，非常适合显示容量或整体进度。

- **`linear`** _(仅适用于 watchOS)_：\
  类似于 `accessoryLinear`，但专为 watchOS 提供。通过条形上的标记指示当前值。

***

## 使用示例

### 环形容量仪表

```tsx
<Gauge
  value={0.7}
  min={0}
  max={1}
  label={<Text>电池</Text>}
  currentValueLabel={<Text>70%</Text>}
  minValueLabel={<Text>0%</Text>}
  maxValueLabel={<Text>100%</Text>}
  gaugeStyle="accessoryCircularCapacity"
/>
```

此示例展示了一个部分填充的环形仪表，表示电池电量为 70%。

***

### 线性容量样式

```tsx
<Gauge
  value={0.7}
  min={0}
  max={1}
  label={<Text>下载进度</Text>}
  currentValueLabel={<Text>70%</Text>}
  gaugeStyle="linearCapacity"
/>
```

此示例展示了一个从左到右填充 70% 的水平条形进度仪表。

***

### 标记样式仪表

```tsx
<Gauge
  value={0.7}
  min={0}
  max={1}
  label={<Text>温度</Text>}
  currentValueLabel={<Text>温暖</Text>}
  gaugeStyle="accessoryCircular"
/>
```

此示例使用标记样式显示一个开口环形，标记指针指向当前值（70%），而不是显示填充段。

***

## 适用场景

- **`circular` 和 `accessoryCircular` 样式：**\
  适用于直观表示圆形数据的场景，例如计时器、速度表或以环形显示容量的情况。

- **`linear` 和 `accessoryLinear` 样式：**\
  最适合用于线性数据的场景，如进度条、完成百分比或从左到右读取的水平值。

- **`Capacity` 样式：**\
  适用于需要通过填充段表示“已满”或“已完成”状态的场景，例如电池电量、存储空间使用情况或加载进度。

- **`automatic`：**\
  让系统根据上下文选择样式，适合用作默认选择。

***

## 总结

通过为 `Gauge` 设置 `gaugeStyle`，你可以完全控制数据的视觉表示方式。无论是环形仪表、线性条形、简单标记还是填充容量指示器，`GaugeStyle` 提供了灵活的选项，让信息的呈现既直观又美观，满足不同的设计需求和功能要求。



---
url: /zh/guide/View Modifiers/hidden.md
---

# 隐藏

若为 `true`，视图不可见且无法交互，但仍保留在视图层级中并参与布局。

### 类型

```ts
hidden?: boolean
```

### 示例

```tsx
<Text hidden={true}>这段文字被隐藏</Text>
```



---
url: /zh/guide/View Modifiers/labelsHidden.md
---

# 隐藏标签

隐藏视图内控件（如 `Picker`, `DatePicker`）的标签部分，但控件本身仍然显示。

## 类型

```ts
labelsHidden?: boolean
```

## 示例

```tsx
<Picker
  title="Picker"
  labelsHidden={true}
  value={value}
  onChanged={onChanged}
>
  <Text tag={0}>Option 1</Text>
  <Text tag={1}>Option 2</Text>
</Picker>
```



---
url: /zh/guide/View Modifiers/layoutPriority.md
---

# 布局优先级

`layoutPriority` 用于控制父级布局在空间不足或需要分配空间时，优先给予哪些子视图更多空间。

在同一个父视图下，如果多个子视图竞争空间，设置了较高 `layoutPriority` 的视图将被优先分配更多空间，而较低或未设置的则可能被压缩或裁剪。

## 参数说明

- `layoutPriority`（可选）
  一个数字，表示该视图的布局优先级。
  数值越大，优先级越高。默认值为 `0`。支持小数值。

## 使用场景示例

假设你有一组水平排列的文本视图，在空间受限时希望某些内容尽量显示完整，而其他内容可以被压缩：

```tsx
<HStack>
  <Text layoutPriority={1}>标题</Text>
  <Text>副标题（可压缩）</Text>
</HStack>
```

在这个示例中，`"标题"` 的视图被设置了较高的布局优先级，因此在空间不足时 `"副标题"` 会优先被压缩，而 `"标题"` 会尽可能完整显示。

## 注意事项

- `layoutPriority` 仅在其父视图需要对多个子视图进行空间分配时生效。
- 若所有子视图都具有相同的优先级，系统将均衡分配空间。
- 适用于 `HStack`, `VStack`, `ZStack` 等可组合视图布局中存在内容冲突或布局紧缩的场景。

***

如需控制内容在受限空间下的显示优先顺序，`layoutPriority` 是非常有效的布局控制工具。通过合理设置优先级，可以提升界面的适应性与可读性。



---
url: /zh/guide/View Modifiers/listStyle.md
---

# 列表样式

通过该属性，你可以自定义 `List` 视图在 UI 中的行为和外观。

***

## 属性声明

```tsx
listStyle?: ListStyle;
```

### 描述

`listStyle` 属性定义了列表的视觉样式，允许你从多种预定义样式中选择合适的样式。

***

### 可接受的值

`listStyle` 属性接受以下字符串值：

- **`automatic`**：使用平台的默认列表行为和外观。
- **`bordered`**：以标准边框显示列表。
- **`carousel`**：将列表设置为类似于旋转木马的外观。
- **`elliptical`**：为列表提供椭圆形的样式。
- **`grouped`**：以分组格式显示列表。
- **`inset`**：为列表应用内嵌外观。
- **`insetGroup`**：结合内嵌和分组样式。
- **`plain`**：以简单样式显示列表，不添加额外的装饰。
- **`sidebar`**：将列表呈现为类似侧边栏的外观。

***

### 默认行为

如果未指定 `listStyle`，系统会根据平台选择默认样式。

***

## 使用示例

以下展示了如何在 TypeScript 代码中应用 `listStyle` 属性：

### 示例 1：简单列表样式 (Plain Style)

```tsx
<List
  listStyle="plain"
>
  <Text>项目 1</Text>
  <Text>项目 2</Text>
  <Text>项目 3</Text>
</List>
```

此示例创建了一个简单样式的列表。

***

### 示例 2：分组列表样式 (Grouped Style)

```tsx
<List
  listStyle="grouped"
>
  <Section header={
    <Text>水果</Text>
  }>
    <Text>苹果</Text>
    <Text>香蕉</Text>
  </Section>
  <Section header={
    <Text>蔬菜</Text>
  }>
    <Text>胡萝卜</Text>
    <Text>西兰花</Text>
  </Section>
</List>
```

此示例创建了一个分组样式的列表，每个分组有一个标题。

***

### 示例 3：侧边栏列表样式 (Sidebar Style)

```tsx
<List
  listStyle="sidebar"
>
  <Text>主页</Text>
  <Text>设置</Text>
  <Text>个人资料</Text>
</List>
```

此示例创建了一个类似于侧边栏的列表。

***

## 注意事项

- `listStyle` 属性直接映射到 SwiftUI 的 `listStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过选择合适的 `listStyle`，你可以根据设计需求调整列表的外观，从而为用户提供更符合场景的视觉体验。



---
url: /zh/guide/View Modifiers/mask.md
---

# 遮罩

`mask` 修饰符使用另一个视图的 **透明度（alpha 通道）** 作为遮罩，将目标视图按形状进行裁剪。遮罩中不透明的区域会显示目标视图，透明区域则被隐藏。

该修饰符常用于图像裁剪、聚光灯效果、遮挡与图形渐显等视觉表现中。

***

## 类型定义

```ts
mask?: VirtualNode | {
  alignment: Alignment
  content: VirtualNode
}
```

***

## 使用方式

## 1. 简洁形式（默认居中遮罩）

直接传入一个视图作为遮罩，系统默认使用居中对齐。

```tsx
<Image
  filePath="path/to/photo.png"
  frame={{ width: 100, height: 100 }}
  mask={<Circle />}
/>
```

上例中，图像将被裁剪成一个圆形，仅圆形区域可见，其他部分被遮罩隐藏。

***

## 2. 对象形式（带对齐方式）

如果需要控制遮罩的位置，可使用对象形式指定对齐方式。

### 对象结构：

```ts
{
  alignment: Alignment
  content: VirtualNode
}
```

### 可选对齐方式（`Alignment`）：

- `"top"` | `"bottom"` | `"leading"` | `"trailing"`
- `"topLeading"` | `"topTrailing"` | `"bottomLeading"` | `"bottomTrailing"`
- `"center"`

### 示例：顶部对齐的矩形遮罩

```tsx
<Rectangle
  fill="blue"
  frame={{ width: 100, height: 100 }}
  mask={{
    alignment: "top",
    content: <Rectangle frame={{ width: 100, height: 50 }} />
  }}
/>
```

上述示例中，蓝色矩形的顶部一半区域可见，底部部分被遮罩隐藏。

***

## 行为说明

- 遮罩视图的 **透明度** 决定了显示区域：

  - 完全不透明（alpha = 1）区域将显示原始内容；
  - 完全透明（alpha = 0）区域将被遮挡。
- 遮罩不会影响布局，仅影响视图渲染效果；
- 为了确保遮罩尺寸与对齐正确，建议对遮罩和目标视图都设置 `frame={{ width, height }}`。

***

## 常见用途

- 图像裁剪（如圆形头像）
- 创建局部显示或聚焦效果
- 与动画结合实现遮罩揭示
- 仅显示特定形状区域内容

***

## 总结

| 字段                  | 说明                |
| ------------------- | ----------------- |
| `mask`（VirtualNode） | 遮罩视图，默认居中叠加在当前视图上 |
| `alignment`         | 可选，控制遮罩相对于当前视图的位置 |
| `content`           | 遮罩内容视图，用于控制可见区域   |



---
url: /zh/guide/View Modifiers/matchedGeometryEffect.md
---

# 匹配几何效果（matchedGeometryEffect）

`matchedGeometryEffect` 用于在 **不同视图之间建立几何关联关系**，使视图在：

- 位置变化
- 尺寸变化
- 布局层级变化
- 条件渲染切换

这些场景中，仍然保持 **连续、平滑、空间一致的动画过渡效果**。

该能力对应 SwiftUI 中的 `matchedGeometryEffect`，属于 **组件级几何联动动画系统**，不依赖导航系统。

***

## 一、API 定义

```ts
matchedGeometryEffect?: {
  id: string | number
  namespace: NamespaceID
  properties?: MatchedGeometryProperties
  anchor?: Point | KeywordPoint
  isSource?: boolean
}
```

```ts
type MatchedGeometryProperties = "frame" | "position" | "size"
```

***

## 二、核心作用

`matchedGeometryEffect` 的核心作用是：

> 让两个“逻辑上是同一个元素”的视图，在 **不同布局结构中共享几何信息**，从而产生连续的过渡动画。

它解决的问题包括：

- 视图从一个容器移动到另一个容器时的“跳变”
- 视图尺寸变化时的“突变”
- 列表项展开为详情页时的“断层感”
- Tab 切换指示器的“瞬移感”

***

## 三、参数详解

### 1. id（几何匹配唯一标识）

```ts
id: string | number
```

- 用于标识这是 **哪一个几何元素**
- 在同一个 `namespace` 下：

  - **id 相同的视图才会参与几何匹配**
- 通常来自：

  - 数据模型 ID
  - 索引值
  - 业务唯一标识

规则：

- id 必须稳定
- 动画期间不能频繁变化
- 同一时刻：

  - 一个 id 只能有一个 `isSource = true`

***

### 2. namespace（几何命名空间）

```ts
namespace: NamespaceID
```

- 用于将多个匹配动画分组隔离
- 不同 namespace 之间：

  - 即使 id 相同，也不会产生动画
- 必须由 `NamespaceReader` 创建并注入

规则：

- source 与 target 必须使用 **同一个 namespace**
- 不允许跨 namespace 匹配

***

### 3. properties（参与匹配的几何属性）

```ts
properties?: "frame" | "position" | "size"
```

默认值：

```ts
properties = "frame"
```

含义说明：

| 值            | 含义          |
| ------------ | ----------- |
| `"frame"`    | 同时匹配位置 + 尺寸 |
| `"position"` | 仅匹配中心点位置    |
| `"size"`     | 仅匹配尺寸，不匹配位置 |

选择原则：

- `"frame"`：最完整、最自然的动画
- `"position"`：指示器、滑块、选中背景
- `"size"`：放大缩小、展开收起

***

### 4. anchor（锚点）

```ts
anchor?: Point | KeywordPoint
```

默认值：

```ts
anchor = "center"
```

作用：

- 决定动画进行时：

  - 元素是从哪个相对位置进行对齐和计算的

常见取值：

- `"center"`
- `"topLeading"`
- `"topTrailing"`
- `"bottomLeading"`
- `"bottomTrailing"`

使用场景：

- 卡片从左上角展开
- 头像从右上角放大
- 底部元素向上弹出

***

### 5. isSource（是否作为几何数据的“源”）

```ts
isSource?: boolean
```

默认值：

```ts
isSource = true
```

含义说明：

| 值       | 行为             |
| ------- | -------------- |
| `true`  | 当前视图向外“提供”几何数据 |
| `false` | 当前视图“接收”几何动画结果 |

标准使用模式：

- 原始视图：`isSource = true`
- 目标视图：`isSource = false`

如果省略：

- 第一个出现的视图默认作为 source
- 其余作为接收方

***

## 四、最小可用示例（位置 + 尺寸联动）

该示例演示：
一个圆形在两个区域之间切换位置与尺寸，并保持连续动画。

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <VStack spacing={40}>
      <Button
        title="Toggle"
        action={() => {
          expanded.setValue( !expanded.value)
        }}
      />

      <ZStack
        frame={{ width: 300, height: 200 }}
        background="systemGray6"
      >
        {!expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 60, height: 60 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace
            }}
          />
        )}
      </ZStack>

      <ZStack
        frame={{ width: 300, height: 300 }}
        background="systemGray4"
      >
        {expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 150, height: 150 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace,
              isSource: false
            }}
          />
        )}
      </ZStack>
    </VStack>
  )}
</NamespaceReader>
```

该示例实现的动画效果：

- 同一个圆：

  - 从上方小尺寸区域
  - 平滑移动并放大到下方大区域
- 无跳变、无突变、无瞬移

***

## 五、仅同步“位置”的示例（指示器动画）

```tsx
const selected = useObservable(0)

return <NamespaceReader>
  {namespace => (
    <HStack spacing={24}>
      <Text
        onTapGesture={() => selected.setValue(0)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 0
        }}
      >
        Tab 1
      </Text>

      <Text
        onTapGesture={() => selected.setValue(1)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 1
        }}
      >
        Tab 2
      </Text>
    </HStack>
  )}
</NamespaceReader>
```

适用于：

- Tab 选中动画
- 滑块指示器
- 选中背景平移

***

## 六、仅同步“尺寸”的示例（放大缩小）

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <ZStack>
      <Circle
        fill="systemBlue"
        frame={{
          width: expanded.value ? 200 : 80,
          height: expanded.value ? 200 : 80
        }}
        matchedGeometryEffect={{
          id: "avatar",
          namespace,
          properties: "size"
        }}
        onTapGesture={() => {
          expanded.setValue(!expanded.value)
        }}
      />
    </ZStack>
  )}
</NamespaceReader>
```

适用于：

- 头像放大
- 卡片展开
- 按钮按压动画

***

## 七、多元素联动示例（卡片 → 详情）

```tsx
<NamespaceReader>
  {namespace => (
    <ZStack>
      {!showDetail.value && (
        <VStack spacing={16}>
          <Image
            source="cover"
            matchedGeometryEffect={{
              id: "card.image",
              namespace
            }}
          />
          <Text
            matchedGeometryEffect={{
              id: "card.title",
              namespace
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}

      {showDetail.value && (
        <VStack spacing={24}>
          <Image
            source="cover"
            frame={{ width: 300, height: 200 }}
            matchedGeometryEffect={{
              id: "card.image",
              namespace,
              isSource: false
            }}
          />
          <Text
            font="largeTitle"
            matchedGeometryEffect={{
              id: "card.title",
              namespace,
              isSource: false
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}
    </ZStack>
  )}
</NamespaceReader>
```

效果说明：

- 图片与标题同时参与几何匹配
- 从卡片形态平滑过渡为详情页布局
- 无需使用导航动画

***

## 八、关键使用规则总结

1. **namespace 必须完全相同**
2. **id 必须完全一致**
3. 同一时刻：

   - 一个 id 只能有一个 `isSource = true`
4. 默认行为：

   ```ts
   properties = "frame"
   anchor = "center"
   isSource = true
   ```
5. source 与 target 必须：

   - 同一渲染周期内完成切换
6. 如果 source 和 target：

   - 同时存在，且都为 `isSource = true`
     → 动画不确定，可能失效
7. Widget 与 Live Activity 环境不支持完整 matchedGeometry 动画能力

***

## 九、适用场景总结

适合使用 `matchedGeometryEffect` 的场景：

- Tab 指示器动画
- 卡片 → 详情展开
- 图片放大预览
- 列表项选中动画
- 分栏布局中的选中项切换

不适合使用的场景：

- 高频数据刷新列表
- 大量同时进行几何动画的复杂视图树
- 帧率敏感的实时图表



---
url: /zh/guide/View Modifiers/matchedTransitionSource.md
---

# 匹配过渡源（matchedTransitionSource）

`matchedTransitionSource` 用于 **标记某个视图作为“导航转场动画的几何源视图”**，使该视图在页面跳转时可以作为：

- 缩放动画的起点
- 位置过渡的起点
- 共享几何动画的起始帧

该能力对应 SwiftUI 中的 `matchedTransitionSource`，主要用于：

- 页面级导航动画
- Zoom（缩放）转场
- Hero 动画（共享元素转场）

它 **只用于导航转场**，不用于组件级几何联动（组件级联动应使用 `matchedGeometryEffect`）。

***

## 一、API 定义

```ts
/**
 * Identifies this view as the source of a navigation transition, such as a zoom transition.
 * @available iOS 18.0+
 */
matchedTransitionSource?: {
  id: string | number
  namespace: NamespaceID
}
```

***

## 二、核心作用

`matchedTransitionSource` 的核心作用是：

> 在一次导航跳转中，指定“从哪个视图开始做几何过渡动画”。

它解决的问题是：

- 页面跳转时视图“瞬间消失 + 新页面突然出现”的割裂感
- 图片、卡片、头像等元素在跳转时缺乏空间连续性
- 无法实现从“点击的那个元素”缩放进入目标页面的效果

通过 `matchedTransitionSource`，可以实现典型的：

- 图片 → 图片详情页的缩放动画
- 卡片 → 详情页的 Hero 动画
- 头像 → 个人主页的放大过渡

***

## 三、参数详解

### 1. id（转场源唯一标识）

```ts
id: string | number
```

含义：

- 标识“这是哪一个转场源视图”
- 必须与目标页面中 `navigationTransition.sourceID` 完全一致

规则：

- 同一个 `namespace` 内：

  - `id` 必须唯一
- 一次导航转场中：

  - 只能有一个 `matchedTransitionSource` 与 `sourceID` 对应

***

### 2. namespace（转场命名空间）

```ts
namespace: NamespaceID
```

含义：

- 用于把“源视图”和“目标页面”放入同一个转场作用域
- 由 `NamespaceReader` 创建并注入

规则：

1. 源视图与目标页面 **必须使用同一个 namespace**
2. 不同 namespace 之间 **绝对不会发生转场匹配**
3. 即使 `id` 相同，只要 namespace 不同，也不会触发动画

***

## 四、matchedTransitionSource 的工作机制

一次完整的导航缩放转场，必须同时满足以下四个条件：

1. **源视图定义了 `matchedTransitionSource`**
2. **目标页面定义了 `navigationTransition`**
3. **`sourceID === matchedTransitionSource.id`**
4. **两者使用的是同一个 `namespace`**

只有在这四个条件全部满足时，系统才会：

- 读取源视图的：

  - 真实 Frame
  - 屏幕位置
  - 缩放比例
- 读取目标页面的最终布局 Frame
- 自动计算：

  - 初始缩放比例
  - 平移路径
  - 最终尺寸
- 并生成完整的缩放过渡动画

***

## 五、最小可用示例：图片缩放进入详情页

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        frame={{
          width: 120,
          height: 160
        }}
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

### 该示例实现的效果

1. 用户点击封面图片
2. 页面开始跳转到 `DetailPage`
3. 新页面并不是“直接出现”
4. 而是：

   - 从点击的那张图片位置开始
   - 按比例放大
   - 平滑过渡到详情页的最终布局

***

## 六、卡片 → 详情页 Hero 动画示例

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "card-1"
          }}
        />
      }
    >
      <VStack
        frame={{
          width: 280,
          height: 180
        }}
        background="systemGray6"
        matchedTransitionSource={{
          id: "card-1",
          namespace
        }}
      >
        <Text>Card Title</Text>
      </VStack>
    </NavigationLink>
  )}
</NamespaceReader>
```

该示例实现：

- 整个卡片作为转场起点
- 跳转后卡片“变形为”详情页容器
- 具备典型的 Hero 动画特征

***

## 七、matchedTransitionSource 与 matchedGeometryEffect 的本质区别

| 对比项             | matchedTransitionSource | matchedGeometryEffect |
| --------------- | ----------------------- | --------------------- |
| 使用场景            | 页面级导航转场                 | 组件级几何联动               |
| 是否依赖 Navigation | 是                       | 否                     |
| 是否支持多个元素同步      | 否                       | 是                     |
| 是否需要 sourceID   | 是                       | 否                     |
| 是否控制 properties | 否                       | 是                     |
| 是否支持布局内动画       | 否                       | 是                     |

一句话总结：

- `matchedTransitionSource`：**只负责“从哪儿开始跳页面”**
- `matchedGeometryEffect`：**负责“布局内部怎么动”**

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- `sourceID` 是否与 `matchedTransitionSource.id` 完全一致
- 是否使用了同一个 `namespace`
- 是否真的发生了 `NavigationLink` 跳转

***

### 2. 动画方向异常或缩放错位

常见原因：

- 源视图有 `scaleEffect`、`offset` 等变换
- 源视图所在的容器使用了：

  - `clipShape`
  - `mask`
  - `containerShape`

这些变换会影响系统获取“真实几何 Frame”。

***

### 3. 同时存在多个 source

错误示例：

- 同一个页面中：

  - 多个视图都使用了相同 `id`
  - 且都设置了 `matchedTransitionSource`

后果：

- 系统无法判定哪个才是转场源
- 动画结果不可预测

***

## 九、使用限制说明

1. `matchedTransitionSource` 仅适用于：

   - `NavigationLink`
   - 基于 Navigation 的页面跳转
2. 在以下环境中不支持或行为受限：

   - Widget
   - Live Activity
3. 不适用于：

   - 组件内部状态切换
   - tab 切换
   - 展开折叠菜单

这些场景应使用 `matchedGeometryEffect`。

***

## 十、适用场景总结

非常适合使用 `matchedTransitionSource` 的场景：

- 图片点击 → 图片详情页
- 文章封面 → 阅读页
- 商品卡片 → 商品详情页
- 用户头像 → 个人主页
- 卡片列表 → 大卡详情页

不适合使用的场景：

- 高频切换的 UI 状态
- 大量小组件同时动画
- 实时刷新型界面



---
url: /zh/guide/View Modifiers/offset.md
---

# 设置偏移

将视图从其默认位置沿 x 和 y 方向偏移指定的距离。

## 类型

```ts
offset?: {
  x: number
  y: number
}
```

## 示例

```tsx
<Text 
  offset={{
    x: 10,
    y: -20
  }}
>偏移内容</Text>
```



---
url: /zh/guide/View Modifiers/onDrag and onDrop View Modifiers.md
---

# onDrag 和 onDrop 修饰符

Scripting 提供了一套与 SwiftUI Drag & Drop 行为模型高度一致的 API，用于在脚本中实现视图间、应用内或跨应用的拖拽与放置操作。

该能力主要由以下三部分构成：

- **onDrag**：将当前视图声明为拖拽源
- **onDrop**：将当前视图声明为放置目标
- **DropInfo / ItemProvider / UTType**：描述拖拽内容与状态的上下文对象

拖拽与放置是一个严格受系统控制的交互流程，部分 API 只能在特定回调中调用，文档中会明确指出这些限制。

***

## 核心数据类型

### DropInfo

`DropInfo` 描述一次拖拽在当前放置视图上的实时状态。该对象仅在 `onDrop` 相关回调中有效。

#### 属性

##### location: Point

- 表示拖拽当前位置
- 坐标空间为 **放置视图自身的本地坐标系**
- 可用于实现基于位置的高亮、插入指示线、排序逻辑等

#### 方法

##### hasItemsConforming(types: UTType\[]): boolean

- 用于判断拖拽内容中，是否至少有一个项目符合指定的 UTType
- 常用于：

  - `validateDrop`
  - `dropEntered`
  - `dropUpdated`
- 不会实际加载数据，仅用于能力判断

##### itemProviders(types: UTType\[]): ItemProvider\[]

- 返回符合指定 UTType 的 `ItemProvider` 列表
- **仅允许在 `performDrop` 回调中调用**
- 在该方法返回后，系统将撤销对拖拽数据的访问权限

> 重要约束
> 必须在 `performDrop` 方法作用域内 **立即开始** 对 ItemProvider 的数据加载（如 `loadData`、`loadText`）。
> 不允许延迟到其他回调或异步逻辑中再发起加载。

***

## DropOperation

`DropOperation` 用于描述当前拖拽更新阶段，目标视图期望执行的操作类型。

可选值如下：

- `"copy"`
  表示复制数据（最常见，用于文件、文本、图片等）

- `"move"`
  表示移动数据（通常仅用于应用内部拖拽）

- `"cancel"`
  取消本次拖拽，不执行任何数据传输

- `"forbidden"`
  明确禁止当前拖拽行为，系统通常会显示禁止指示

`DropOperation` 通常由 `dropUpdated` 回调返回，用于动态控制拖拽行为。

***

## DragDropProps

`DragDropProps` 是所有支持拖拽与放置能力的视图可选属性集合。

***

## onDrag

### 用途

将当前视图声明为 **拖拽源**，允许用户从该视图开始一次拖拽操作。

### 定义

```ts
onDrag?: {
  data: () => ItemProvider
  preview: VirtualNode
}
```

### 参数说明

#### data

```ts
data: () => ItemProvider
```

- 返回一个 `ItemProvider`
- 用于描述拖拽时传递的数据内容
- 支持文本、图片、文件、URL、自定义类型等
- 每次拖拽开始时调用

> 建议
> 仅在该回调中构造 ItemProvider，不要复用旧实例，以确保数据状态正确。

#### preview

```ts
preview: VirtualNode
```

- 指定拖拽开始后显示的预览视图
- 系统会自动将其渲染为拖拽浮层
- 预览视图默认居中于源视图

***

## onDrop

### 用途

将当前视图声明为 **放置目标**，并通过一组回调精细控制拖拽验证、状态变化与最终数据接收。

### 定义

```ts
onDrop?: {
  types: UTType[]
  validateDrop?: (info: DropInfo) => boolean
  dropEntered?: (info: DropInfo) => void
  dropUpdated?: (info: DropInfo) => DropOperation | null
  dropExited?: (info: DropInfo) => void
  performDrop: (info: DropInfo) => boolean
}
```

***

### onDrop.types

```ts
types: UTType[]
```

- 声明该视图 **允许接收的内容类型**
- 如果拖拽内容不包含任意一个匹配类型：

  - 放置区域不会激活
  - `validateDrop` 不会被调用
  - 视觉高亮不会出现

***

### validateDrop

```ts
validateDrop?: (info: DropInfo) => boolean
```

- 用于判断是否允许开始一次放置操作
- 返回 `false` 将直接拒绝拖拽
- 常见用途：

  - 检查类型数量
  - 校验业务状态（如只允许空列表接收）

默认行为：始终返回 `true`

***

### dropEntered

```ts
dropEntered?: (info: DropInfo) => void
```

- 当拖拽进入放置区域时触发
- 通常用于：

  - 显示高亮
  - 显示插入占位符
  - 触发动画状态

***

### dropUpdated

```ts
dropUpdated?: (info: DropInfo) => DropOperation | null
```

- 当拖拽在放置区域内部移动时反复调用
- 用于动态返回期望的 `DropOperation`

返回值说明：

- 返回具体的 `DropOperation`：更新当前拖拽行为
- 返回 `null`：

  - 使用上一次返回的有效值
  - 若没有历史值，默认使用 `"copy"`

***

### dropExited

```ts
dropExited?: (info: DropInfo) => void
```

- 当拖拽离开放置区域时触发
- 常用于清理高亮、移除占位 UI

***

### performDrop

```ts
performDrop: (info: DropInfo) => boolean
```

- **最关键的回调**
- 表示用户已松手，系统允许你读取拖拽数据
- 返回值：

  - `true`：表示成功接收并处理了拖拽
  - `false`：表示放置失败

#### 重要约束（必须遵守）

- 必须在该方法作用域内：

  - 调用 `info.itemProviders(...)`
  - 并立即开始数据加载
- 不允许：

  - 将 ItemProvider 保存到外部
  - 在异步回调中延迟访问拖拽数据

这是系统级安全限制，不遵守将导致数据无法访问。

***

## 典型使用流程总结

1. 用户从 `onDrag` 视图开始拖拽
2. 系统根据 `onDrop.types` 判断是否激活目标
3. 调用 `validateDrop`
4. 进入放置区域 → `dropEntered`
5. 移动过程中 → 多次 `dropUpdated`
6. 离开区域 → `dropExited`
7. 松手 → `performDrop`
8. 在 `performDrop` 中读取并处理数据

***

## 设计建议与最佳实践

- 始终精确声明 `UTType`，避免过于宽泛
- 在 `dropUpdated` 中返回 `"forbidden"` 可显式阻止非法拖拽
- 复杂数据解析逻辑应在 `ItemProvider` 加载完成后的异步回调中完成，而不是在 `performDrop` 中同步阻塞
- 跨应用拖拽时，优先使用系统标准类型（text、image、file、url）



---
url: /zh/guide/View Modifiers/onDropContent.md
---

# 接收外部拖拽内容

`onDropContent` 是 Scripting 提供的一个视图修饰符，用于将当前视图设置为**拖放目标（Drop Target）**，以接收从其他 App 拖拽进入的文件、图片或文本内容。

***

## 功能说明

通过 `onDropContent`，你可以实现以下能力：

- 接收来自其他 App 的拖拽内容
- 使用 UTType 精确限制可接收的数据类型
- 实时感知拖拽指针是否悬停在视图上方
- 在内容被放下时，通过 `ItemProvider` 启动数据加载流程
- 对安全作用域文件建立持久访问权限

***

## 修饰符定义

```ts
onDropContent?: {
  types: UTType[]
  isTarget: {
    value: boolean
    onChanged: (value: boolean) => void
  } | Observable<boolean>
  perform: (attachments: ItemProvider[]) => boolean
}
```

***

## 参数说明

### types

用于指定当前视图**可以接收的内容类型列表**，类型值为 UTType 字符串。

当拖拽内容不包含任意匹配的类型时：

- 当前视图不会激活为放置目标
- `isTarget` 不会发生变化
- `perform` 不会被调用

示例：

```ts
types: ["public.image", "public.movie"]
```

***

### isTarget

用于表示拖拽操作是否悬停在当前视图上方。

- 当拖拽进入视图区域时，值为 `true`
- 当拖拽移出视图区域时，值为 `false`

支持以下两种形式：

- 绑定对象形式

  ```ts
  {
    value: boolean
    onChanged: (value: boolean) => void
  }
  ```

- Observable 形式

  ```ts
  Observable<boolean>
  ```

Observable 形式适合与 `useObservable` 搭配使用，语义更简洁。

***

### perform

当符合 `types` 要求的内容被成功放下时触发。

```ts
perform: (attachments: ItemProvider[]) => boolean
```

- 参数 `attachments` 为 `ItemProvider` 数组
- 每一个 `ItemProvider` 表示一个被拖入的内容项
- 函数返回值表示是否成功处理了此次拖放操作

返回值说明：

- 返回 `true` 表示拖放被成功接收
- 返回 `false` 表示未处理该拖放内容

***

## perform 的执行规则（重要）

在 `perform` 中需要遵循以下规则：

- 必须在 `perform` 函数的同步执行过程中**启动对 ItemProvider 的加载**
- 允许使用 `Promise` / `then` 等方式延迟完成加载
- 不允许在 `perform` 返回之后，再通过其他回调或事件启动加载
- 返回 `false` 时，系统会认为该拖放未被接受

原因说明：

- 拖放内容受系统安全机制保护
- 只有在 `perform` 执行期间，脚本才拥有对拖放数据的访问权限
- 若未在此期间启动加载，后续将无法访问对应资源

***

## ItemProvider 的使用方式

在 `perform` 中，开发者应当通过 `ItemProvider` 判断类型并启动加载。

常见流程包括：

- 使用 `hasItemConforming` 判断内容类型
- 根据内容类型选择合适的加载方式
- 对文件类资源获取路径并进行后续处理

***

## 示例用法

```tsx
const isTarget = useObservable(false)

return <VStack
  onDropContent={{
    types: ["public.image", "public.movie"],
    isTarget: isTarget,
    perform: (attachments) => {
      const images: UIImage[] = []
      const videos: string[] = []

      let found = false

      for (const attachment of attachments) {
        if (attachment.hasItemConforming("public.png")) {
          found = true
          attachment.loadUIImage().then(image => {
            if (image != null) {
              images.push(image)
            }
          })
        } else if (attachment.hasItemConforming("public.movie")) {
          found = true
          attachment.loadFilePath("public.movie").then(filePath => {
            if (filePath != null) {
              // 为安全作用域文件创建书签
              FileManager.addFileBookmark(filePath)
              videos.push(filePath)
            }
          })
        }
      }

      return found
    }
  }}
>
  ...
</VStack>
```

***

## 安全作用域文件访问

通过 `onDropContent` 获取的文件路径，通常属于**安全作用域资源**。

这类路径在以下情况下可能失效：

- `perform` 返回之后
- App 重启
- 脚本生命周期结束

为保证后续仍可访问文件，建议在获取路径后创建文件书签。

***

## FileManager.addFileBookmark

```ts
FileManager.addFileBookmark(path: string, name?: string): string | null
```

说明：

- 为指定文件或文件夹创建安全作用域书签
- 适用于通过 `Photos`、`onDropContent` 等 API 获取的路径
- 返回书签名称，用于后续访问或移除

示例：

```ts
const bookmarkName = FileManager.addFileBookmark(filePath)
```

***

## FileManager.removeFileBookmark

```ts
FileManager.removeFileBookmark(name: string): boolean
```

说明：

- 移除指定名称的文件书签
- 当不再需要访问对应文件时应及时调用
- 返回是否成功移除

示例：

```ts
FileManager.removeFileBookmark(bookmarkName)
```

***

## 使用建议

- 在 `types` 中尽量明确声明可接收的内容类型
- 在 `perform` 中只负责启动加载，不要等待加载完成
- 对图片等轻量内容可直接加载为对象
- 对视频、音频、文档等资源优先使用文件路径
- 对需要长期访问的文件务必创建书签
- 在资源不再使用时移除对应书签



---
url: /zh/guide/View Modifiers/opacity.md
---

# 不透明度

设置视图的不透明度。`0` 表示完全透明不可见，`1` 表示完全不透明。

## 类型

```ts
opacity?: number
```

## 示例

```tsx
<Text opacity={0.5}>半透明文本</Text>
```



---
url: /zh/guide/View Modifiers/overlay.md
---

# overlay

`overlay` 修饰符用于在当前视图的上方叠加一个额外视图，形成层叠的视觉效果。这在添加装饰元素（如徽章）、加载指示器、半透明遮罩或交互按钮等场景中非常有用。

***

## 类型定义

```ts
overlay?: VirtualNode | {
  alignment: Alignment
  content: VirtualNode
}
```

***

## 参数说明

### 1. 简洁形式：直接传入 `VirtualNode`

直接将一个视图叠加在当前视图之上，默认对齐方式为 **居中（center）**。

```tsx
<Image
  imageUrl="https://example.com/avatar.png"
  overlay={<Circle fill="black" opacity={0.2} />}
/>
```

该例会在头像图上方添加一个半透明黑色圆形遮罩。

***

### 2. 对象形式：带对齐方式的 Overlay

提供 `content` 和 `alignment`，用于指定叠加视图的内容与对齐方式。

#### 对象结构：

```ts
{
  alignment: Alignment
  content: VirtualNode
}
```

#### `Alignment` 可选值包括：

- `"top"` | `"bottom"` | `"leading"` | `"trailing"`
- `"topLeading"` | `"topTrailing"` | `"bottomLeading"` | `"bottomTrailing"`
- `"center"`

#### 示例：右上角徽章叠加

```tsx
<Image
  imageUrl="https://example.com/avatar.png"
  overlay={{
    alignment: "topTrailing",
    content: <Circle
      fill="red"
      frame={{
        width: 10,
        height: 10
      }}
    />
  }}
/>
```

该例会在图像右上角叠加一个红色圆形小徽章。

***

## 行为说明

- `overlay` 的内容会绘制在目标视图之上。
- 叠加内容不会改变原始视图的尺寸与布局。
- 若未设置 `clip`，叠加内容可能超出边界。

***

## 常见用途

- 添加通知角标或状态徽章
- 显示加载指示器或遮罩层
- 高亮视图特定区域
- 显示动画图标或文字提示

***

## 示例：居中文字叠加

```tsx
<Rectangle
  fill="blue"
  frame={{
    width: 100,
    height: 100
  }}
  overlay={{
    alignment: "center",
    content: <Text foregroundColor="white">你好</Text>
  }}
/>
```

该示例会在一个蓝色矩形中央叠加白色文字“你好”。

***

## 总结

| 参数            | 说明               |
| ------------- | ---------------- |
| `VirtualNode` | 要叠加的视图内容（默认居中）   |
| `alignment`   | 可选。叠加视图在目标视图中的位置 |
| `content`     | 要显示的叠加内容视图       |

`overlay` 是构建多层 UI、实现状态标记、视觉效果叠加等的核心修饰符之一，可灵活组合使用，适配各种视觉需求。



---
url: /zh/guide/View Modifiers/padding.md
---

# 间距

`padding` 属性用于设置视图内容与其边缘之间的间距，相当于 SwiftUI 中的 `padding` 修饰符。它有助于视图之间的分隔与整体布局美观。

## 定义

```ts
padding?: true | number | {
  horizontal?: number | true
  vertical?: number | true
  leading?: number | true
  trailing?: number | true
  top?: number | true
  bottom?: number | true
}
```

## 支持的写法

***

### 1. 默认边距

```ts
padding: true
```

为所有边应用系统默认的内边距。

#### 示例：

```tsx
<Text padding={true}>
  默认边距
</Text>
```

***

### 2. 统一边距

```ts
padding: 8
```

为所有边设置相同的数值边距。

#### 示例：

```tsx
<VStack padding={12}>
  <Text>统一边距</Text>
</VStack>
```

***

### 3. 指定边距对象

可以分别设置特定方向的边距。

```ts
padding: {
  horizontal: 16,
  vertical: 8
}
```

#### 可用属性说明：

| 属性名          | 含义说明                           |
| ------------ | ------------------------------ |
| `horizontal` | 同时设置 `leading` 和 `trailing` 边距 |
| `vertical`   | 同时设置 `top` 和 `bottom` 边距       |
| `leading`    | 设置前导边距（在 LTR 语言中为左侧）           |
| `trailing`   | 设置尾部边距（在 LTR 语言中为右侧）           |
| `top`        | 设置顶部边距                         |
| `bottom`     | 设置底部边距                         |

每个值可以是具体数值，也可以是 `true`，`true` 表示使用系统默认边距。

#### 示例：

```tsx
<Text
  padding={{
    top: 10,
    bottom: 10,
    horizontal: 16
  }}
>
  自定义边距
</Text>
```

#### 使用 `true` 设置特定边：

```tsx
<Text
  padding={{
    top: true,
    horizontal: 12
  }}
>
  混合边距
</Text>
```

***

## 注意事项

- `padding` 不会直接改变视图内容的大小，但会影响它与外部内容之间的间距。
- 可以灵活组合 `horizontal` / `vertical` 与 `leading` / `top` 等单项配置，单项配置会覆盖对应方向的组合配置。
- 合理使用 `padding` 能提升界面排版的整洁性与可读性。



---
url: /zh/guide/View Modifiers/pickerStyle.md
---

# 选择器样式

通过该属性，你可以自定义视图层次结构中选择器（Picker）的外观和行为。

***

## 属性声明

```tsx
pickerStyle?: PickerStyle;
```

### 描述

`pickerStyle` 属性用于设置选择器的视觉样式，使其能够适应不同的上下文和用户体验需求。

***

### 可接受的值

`pickerStyle` 属性接受以下字符串值：

- **`automatic`**：默认选择器样式，根据选择器的上下文进行适配。
- **`inline`**：将每个选项内嵌显示在当前容器中的其他视图之间。
- **`menu`**：当用户按下按钮时，将选项作为菜单显示，或者作为嵌套菜单的一部分。
- **`navigationLink`**：通过导航链接将选项呈现为推送列表样式的选择器视图。
- **`palette`**：将选项以紧凑元素行的形式呈现。
- **`segmented`**：以分段控件的形式显示选项。
- **`wheel`**：将选项显示为可滚动的轮状视图，同时展示所选选项及其附近的一些选项。

***

### 默认行为

如果未指定 `pickerStyle`，则根据选择器的上下文自动应用默认样式（`automatic`）。

***

## 使用示例

以下示例展示了如何在 TypeScript 代码中应用 `pickerStyle` 属性：

### 示例 1：内嵌样式 (Inline Style)

```tsx
function View() {
  const [value, setValue] = useState(0)

  return <Picker
    title="选择器"
    pickerStyle="inline"
    value={value}
    onChanged={(value) => {
      setValue(value)
      console.log('选择了:', value)
    }}
  >
    <Text tag={0}>选项 1</Text>
    <Text tag={1}>选项 2</Text>
    <Text tag={2}>选项 3</Text>
  </Picker>
}
```

此示例创建了一个内嵌样式的选择器。

***

### 示例 2：分段样式 (Segmented Style)

```tsx
function View() {
  const [value, setValue] = useState(0)

  return <Picker
    title="选择器"
    pickerStyle="segmented"
    value={value}
    onChanged={(value) => {
      setValue(value)
      console.log('选择了:', value)
    }}
  >
    <Text tag={0}>选项 1</Text>
    <Text tag={1}>选项 2</Text>
    <Text tag={2}>选项 3</Text>
  </Picker>
}
```

此示例创建了一个以分段控件形式显示的选择器。

***

### 示例 3：滚轮样式 (Wheel Style)

```tsx
function View() {
  const [value, setValue] = useState(0)

  return <Picker
    title="选择器"
    pickerStyle="wheel"
    value={value}
    onChanged={(value) => {
      setValue(value)
      console.log('选择了:', value)
    }}
  >
    <Text tag={0}>选项 1</Text>
    <Text tag={1}>选项 2</Text>
    <Text tag={2}>选项 3</Text>
  </Picker>
}
```

此示例创建了一个滚轮样式的选择器。

***

## 注意事项

- `pickerStyle` 属性直接映射到 SwiftUI 的 `pickerStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过使用 `pickerStyle`，你可以根据不同的上下文自定义选择器的外观，从而提供流畅的用户体验。



---
url: /zh/guide/View Modifiers/position.md
---

# 设置位置

将视图的**中心点**定位到父视图坐标空间中的指定位置。

## 类型

```ts
position?: {
  x: number
  y: number
}
```

## 示例

```tsx
<Text
  position={{ 
    x: 100,
    y: 200 
  }}
>Positioned Text</Text>
```



---
url: /zh/guide/View Modifiers/preferredColorScheme.md
---

# 首选配色模式

指定该视图层级使用的系统配色模式（浅色或深色）。通常用于控制系统覆盖元素的显示样式。

### 类型

```ts
preferredColorScheme?: "light" | "dark"
```

### 示例

```tsx
<NavigationStack>
  <List preferredColorScheme="dark">
    <Text>暗色模式视图</Text>
  </List>
</NavigationStack>
```



---
url: /zh/guide/View Modifiers/progressViewStyle.md
---

# 进度视图样式

通过该属性，你可以自定义进度视图在 UI 中的外观。

***

## 属性声明

```tsx
progressViewStyle?: ProgressViewStyle;
```

### 描述

`progressViewStyle` 属性定义了进度视图的样式，允许你选择最适合应用上下文的视觉表示形式。

***

### 可接受的值

`progressViewStyle` 属性接受以下字符串值：

- **`automatic`**：使用默认的进度视图样式，适配视图当前的上下文。
- **`circular`**：以环形仪表显示，用于指示活动的部分完成情况。在非 macOS 平台上，该样式可能显示为不确定的加载指示器。
- **`linear`**：以水平条的形式显示进度，直观地指示任务完成情况。

***

### 默认行为

如果未指定 `progressViewStyle`，则根据视图上下文自动应用默认样式（`automatic`）。

***

## 进度视图属性

### 定时器进度视图属性

这些属性用于为基于时间的任务显示进度视图：

- **`timerFrom`**：进度开始的时间戳。
- **`timerTo`**：进度结束的时间戳。
- **`countsDown`** _(可选)_：如果为 true（默认值），随着时间推移进度将逐渐减少。
- **`label`** _(可选)_：描述正在进行的任务的视图。
- **`currentValueLabel`** _(可选)_：描述任务已完成进度的视图。

***

### 普通进度视图属性

这些属性用于为具有明确范围的任务显示进度视图：

- **`value`** _(可选)_：当前任务已完成的部分，范围为 0.0 到 `total`；如果进度不确定，则为 `nil`。
- **`total`** _(可选)_：任务的完整范围（默认值为 1.0）。
- **`title`** _(可选)_：描述正在进行任务的标题。
- **`label`** _(可选)_：描述正在进行任务的视图。
- **`currentValueLabel`** _(可选)_：描述任务已完成进度的视图。

***

## 使用示例

### 示例 1：定时器进度视图

```tsx
<ProgressView
  progressViewStyle="circular"
  timerFrom={Date.now()}
  timerTo={Date.now() + 3600000}
  countsDown={true}
  label={<Text>定时器进度</Text>}
  currentValueLabel={<Text>剩余时间</Text>}
/>
```

此示例为定时器任务创建了一个环形进度视图。

***

### 示例 2：普通进度视图

```tsx
<ProgressView
  progressViewStyle="linear"
  value={0.5}
  total={1.0}
  title="文件上传"
  label={<Text>正在上传...</Text>}
  currentValueLabel={<Text>50%</Text>}
/>
```

此示例为一个完成 50% 的任务创建了一个线性进度视图。

***

## 注意事项

- `progressViewStyle` 属性直接映射到 SwiftUI 的 `progressViewStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过设置 `progressViewStyle`，你可以根据任务的不同需求自定义进度视图的外观，提供直观且符合设计语言的用户体验。



---
url: /zh/guide/View Modifiers/refresable/index.md
---

# 可刷新修饰符

将可滚动视图标记为 **可刷新**，允许用户下拉以触发异步的数据刷新操作。

## 类型

```ts
refreshable?: () => Promise<void>
```

***

## 概述

在如 `<List>` 这样的可滚动视图上使用 `refreshable` 修饰符，可以启用下拉刷新的交互行为。当用户在页面顶部下拉时，框架会调用你提供的异步处理函数。

在处理函数中，你可以执行异步操作（例如请求网络数据或更新本地状态），当该函数返回后，刷新指示器将自动隐藏。

此行为与 SwiftUI 的 [`refreshable`](https://developer.apple.com/documentation/swiftui/view/refreshable%28action:%29) 非常相似。

***

## 使用示例

```tsx
<List
  navigationTitle="可刷新列表"
  navigationBarTitleDisplayMode="inline"
  refreshable={refresh}
/>
```

### 完整示例

```tsx
function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 2000) // 模拟2秒刷新
    })
  }

  return <NavigationStack>
    <List
      navigationTitle="可刷新列表"
      navigationBarTitleDisplayMode="inline"
      refreshable={refresh}
    >
      <Section header={<Text textCase={null}>下拉即可刷新</Text>}>
        {data.map(item =>
          <Text>数字：{item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}
```

***

## 行为说明

- `refreshable` 必须返回一个 `Promise<void>`。只有在该 promise 被解析（`resolve`）后，刷新指示器才会消失。
- 在处理函数内部可以使用 `await` 进行异步操作：

  ```ts
  refreshable={async () => {
    const result = await fetchData()
    setData(result)
  }}
  ```
- 此修饰符 **仅适用于可滚动容器**（如 `<List>`）。
- 在刷新逻辑中应更新相关状态，以反映新的数据。
- 避免长时间运行或无反馈的任务，必须确保 promise 能被及时解析以防止界面卡住。

***

## 使用建议

- 保持刷新逻辑简洁高效。
- 始终在逻辑结束后调用 `resolve`。
- 开发时可使用延迟模拟加载动画：

  ```ts
  await new Promise(resolve => setTimeout(resolve, 1000))
  ```



---
url: /zh/guide/View Modifiers/refresable/refreshable_list.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Script, Section, Text, useState } from "scripting"

function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 1000 * 2)
    })
  }

  return <NavigationStack>
    <List
      navigationTitle={"Refreshable List"}
      navigationBarTitleDisplayMode={"inline"}
      refreshable={refresh}
    >
      <Section header={
        <Text textCase={null}>Pull down to refresh</Text>
      }>
        {data.map(item =>
          <Text>Number: {item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/View Modifiers/rotationEffect.md
---

# 旋转效果

将视图绕指定锚点旋转指定角度。默认锚点为 `center`。

## 类型

```ts
rotationEffect?: number | {
  degrees: number
  anchor: KeywordPoint | Point
}
```

## 示例

默认锚点：

```tsx
<Text rotationEffect={45}>旋转内容</Text>
```

自定义锚点：

```tsx
<Text
  rotationEffect={{
    degrees: 30,
    anchor: "bottomTrailing"
  }}
>
  自定义锚点旋转
</Text>
```



---
url: /zh/guide/View Modifiers/scaleEffect.md
---

# 缩放效果

按指定倍数缩放视图的渲染结果。支持统一缩放值，或分别设置横向与纵向缩放，并可指定锚点。

## 类型

```ts
scaleEffect?: number | {
  x: number
  y: number
  anchor?: KeywordPoint | Point
}
```

## 示例

统一缩放：

```tsx
<Text scaleEffect={1.5}>放大内容</Text>
```

非等比缩放：

```tsx
<Text
  scaleEffect={{
    x: 1.2,
    y: 0.8,
    anchor: "center"
  }}
>
  非等比缩放
</Text>
```



---
url: /zh/guide/View Modifiers/shadow.md
---

# 阴影

为视图添加阴影效果。可设置颜色、模糊半径以及偏移量。

## 类型

```ts
shadow?: {
  color: Color
  radius: number
  x?: number
  y?: number
}
```

## 示例

```tsx
<Text
  shadow={{
    color: "black",
    radius: 5,
    x: 2,
    y: 4
  }}
>
  有阴影的文字
</Text>
```



---
url: /zh/guide/View Modifiers/textFieldStyle.md
---

# 文本输入框样式

通过该属性，你可以定义文本框的视觉样式，从而影响其边框、背景和布局的外观。不同的样式可以帮助文本框在各种 UI 设计中无缝融合，或提供功能上的提示。

***

## 概述

`TextField` 为用户提供了一个输入文本的方式。通过选择 `textFieldStyle`，你可以决定文本框是以简洁、无边框的样式呈现，还是以更加明显的圆角边框显示，从而突出输入区域。

***

## 可用样式

- **`automatic`**：\
  让系统根据平台和上下文选择合适的样式。如果没有明确的样式偏好，这是一个方便的默认选择。

- **`plain`**：\
  以最少的装饰显示文本框。这种样式通常看起来像纯文本，适合不希望输入框过于显眼的布局。

- **`roundedBorder`**：\
  为文本框添加一个圆角矩形边框。这种样式能让输入区域更加突出，清楚地表明用户可以在其中输入内容。适合用于表单或需要用户进行主要操作的场景。

***

## 基本用法

以下示例展示了如何使用具有特定样式的 `TextField`：

```tsx
<TextField
  title="用户名"
  value={username}
  onChanged={newVal => setUsername(newVal)}
  textFieldStyle="roundedBorder"
  prompt="输入您的用户名"
/>
```

在此示例中，`textFieldStyle="roundedBorder"` 会用视觉效果突出输入框，让用户明确知道可以点击并输入。

***

## 其他常用属性

- **`value: string`**：\
  文本框当前的内容。用户输入时更新该值以保持显示内容同步。

- **`onChanged: (value: string) => void`**：\
  每当文本框内容更改时调用的回调函数，可用于响应用户输入。

- **`prompt?: string`**：\
  提示或占位符文本，用于指导用户输入内容。

- **`axis?: Axis`**：\
  决定当文本超出显示范围时的滚动方向。如果预期用户输入的内容较长，可以使用此属性。

- **`autofocus?: boolean`** _(默认值: false)_：\
  如果设置为 `true`，文本框会在显示时自动获得焦点，方便用户立即输入。

- **`onFocus?: () => void` 和 `onBlur?: () => void`**：\
  分别在文本框获得或失去焦点时调用的回调函数，可用于提供视觉反馈、执行验证或更新其他 UI 部分。

***

## 示例

```tsx
<TextField
  label={<Text style={{fontWeight: 'bold'}}>邮箱：</Text>}
  value={email}
  onChanged={setEmail}
  prompt="you@example.com"
  textFieldStyle="plain"
  autofocus={true}
  onFocus={() => console.log('获得焦点')}
  onBlur={() => console.log('失去焦点')}
/>
```

在此示例中，文本框被设置为 `plain` 样式，与周围内容更融为一体。`autofocus` 属性确保用户在进入此视图后可以立即开始输入。

***

## 总结

通过 `textFieldStyle`，你可以根据不同的上下文调整输入框的外观。无论是选择低调的 `plain` 样式，还是选择更加结构化的 `roundedBorder` 样式，合适的样式能够帮助创建清晰、直观的用户体验。如果不确定样式选择，可以使用 `automatic` 让系统决定最合适的外观。



---
url: /zh/guide/View Modifiers/tint.md
---

# 强调色

`tint` 属性用于为视图设置局部的强调色，覆盖默认的系统 accent color。与应用的全局 accent color 不同，`tint` 不会被用户偏好覆盖，始终有效，适合用来强调控件的语义意义或视觉重点。

## 定义

```ts
tint?: ShapeStyle | DynamicShapeStyle
```

## 支持的值

- **`ShapeStyle`**：可为纯色、渐变或系统材质。
- **`DynamicShapeStyle`**：可根据浅色/深色模式自动切换的样式。

## 常见用途

- 设置如 `Toggle`、`Slider`、`Button`、`ProgressView` 等控件的本地着色。
- 在表单、列表或弹窗中标记具有特定意义的组件。
- 保证 UI 色彩在不同用户主题下始终一致。

## 示例：基础颜色着色

```tsx
<Toggle
  tint="systemGreen"
  // ...
/>
```

## 示例：渐变着色

```tsx
<ProgressView
  value={0.6}
  tint={{
    gradient: [
      { color: "red", location: 0 },
      { color: "orange", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  }}
/>
```

## 示例：深浅模式适配

```tsx
<Slider
  tint={{
    light: "blue",
    dark: "purple"
  }}
  // ...
/>
```



---
url: /zh/guide/View Modifiers/toggleStyle.md
---

# 切换开关样式

通过该属性，你可以定义 `Toggle`（通常称为开关或复选框）的视觉外观和行为。

***

## 概述

`Toggle` 用于表示布尔值的开/关状态。它可以显示为开关、可点击的按钮，或者根据上下文使用平台的默认样式。`toggleStyle` 属性允许你指定要使用的外观，确保你的 UI 与应用的整体设计语言保持一致。

***

## 可用样式

- **`automatic`**：\
  让系统根据平台和上下文选择最适合的样式。如果不确定使用哪种样式，`automatic` 是一个不错的默认选择。

- **`switch`**：\
  将 `Toggle` 渲染为经典的开关，类似于 iOS 设置中的开关。开关通过滑动切换状态，为大多数用户提供熟悉的交互体验。

- **`button`**：\
  将 `Toggle` 呈现为按钮样式。与滑动不同，点击按钮即可切换状态。这种样式适合需要将 `Toggle` 作为可选择选项的 UI 布局。

***

## 使用示例

### 开关样式

```tsx
<Toggle
  title="启用通知"
  value={notificationsEnabled}
  onChanged={(newVal) => setNotificationsEnabled(newVal)}
  toggleStyle="switch"
/>
```

在此示例中，`Toggle` 显示为开关。用户点击时，开关滑动，切换状态为开或关。

***

### 按钮样式

```tsx
<Toggle
  title="深色模式"
  value={darkMode}
  onChanged={(newVal) => setDarkMode(newVal)}
  toggleStyle="button"
/>
```

在这种情况下，`Toggle` 看起来像一个按钮，点击时状态切换。适合需要更突出、可点击样式的场景。

***

### 自动样式

```tsx
<Toggle
  title="使用蜂窝数据"
  value={useCellular}
  onChanged={(newVal) => setUseCellular(newVal)}
  toggleStyle="automatic"
/>
```

使用 `automatic` 样式时，系统自动选择样式。这适用于信任系统默认样式以匹配平台约定的情况，或者希望在无需手动指定样式的情况下实现最大一致性。

***

## 其他 Toggle 属性

- **`value: boolean`**：\
  指示 `Toggle` 的当前状态（开或关）。

- **`onChanged(value: boolean): void`**：\
  当 `Toggle` 状态发生变化时触发的回调。可以用来相应地更新应用的数据模型。

- **`intent: AppIntent<any>`（可选）**：\
  你可以将 `Toggle` 与 `AppIntent` 关联，而不是本地处理状态变化。这样可以直接从 `Toggle` 的状态变化中触发预定义的应用动作（例如小组件或 Live Activity 场景）。

- **`title` 和 `systemImage`**：\
  提供一个描述性文本标签，并可选地添加一个图像，以清晰传达 `Toggle` 的用途。

- **`children`**：\
  你可以提供自定义内容（如文本节点、图标或两者的组合）作为 `Toggle` 的标签，而不是使用 `title` 或 `systemImage`。

***

## 总结

通过调整 `toggleStyle` 属性，你可以控制 `Toggle` 的外观和体验。无论你选择熟悉的开关样式、按钮样式，还是依赖 `automatic` 自动选择，该属性都能确保 `Toggle` 无缝融入你的脚本设计，同时为用户提供直观清晰的方式来更改布尔值设置。



---
url: /zh/guide/View Modifiers/toolbar/Use with Toolbar Component.md
---

Scripting 的工具栏系统不仅支持直接在 `toolbar` 属性中传入 `ToolBarProps` 对象，也支持使用与 SwiftUI 结构一致的 `<Toolbar>`、`<ToolbarItem>`、`<ToolbarItemGroup>`、`<ToolbarSpacer>`、`<DefaultToolbarItem>` 等组件，构建更灵活、更强大的导航栏和工具栏布局。

这些组件能够提供更精细的控制，允许开发者像 SwiftUI 一样以声明式方式编排工具栏内容，并为复杂布局提供更高可读性和可维护性。

***

# 基本概念

工具栏组件始终通过视图的 `toolbar` 属性使用：

```tsx
<List
  toolbar={
    <Toolbar>
      {/* 工具栏项 */}
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

`toolbar` 可以接受：

- `ToolBarProps` 对象（与原机制一致）
- `VirtualNode`（必须为 `<Toolbar>` 组件）

使用 `<Toolbar>` 时，所有内容都通过 `<ToolbarItem>` 系列组件明确定义位置和呈现方式。

***

# Toolbar

`Toolbar` 组件是工具栏的容器，用于包含多个工具栏项。它本身不定义位置，内部的 `ToolbarItem` 或 `ToolbarItemGroup` 决定实际布局。

## 用法示例

```tsx
<List
  toolbar={
    <Toolbar>
      <ToolbarItem placement="topBarLeading">
        <Button title="关闭" action={() => dismiss()} />
      </ToolbarItem>
      <ToolbarItem placement="topBarTrailing">
        <Button title="完成" action={() => handleDone()} />
      </ToolbarItem>
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

***

# ToolbarItem

`ToolbarItem` 表示放置在工具栏指定位置的单个项目。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明                                                       |
| ----------- | ---------------------- | ----------- | -------------------------------------------------------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 指定工具栏位置，如 `topBarLeading`、`navigation`、`primaryAction` 等 |
| `children`  | `VirtualNode`          | 无           | 工具栏项的实际内容，例如按钮或文本                                        |

## 示例

```tsx
<Toolbar>
  <ToolbarItem placement="navigation">
    <Button title="返回" action={Navigation.useDismiss()} />
  </ToolbarItem>
</Toolbar>
```

***

# ToolbarItemGroup

`ToolbarItemGroup` 用于在同一位置放置多个工具栏项目，所有子项目将作为一组呈现。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明      |
| ----------- | ---------------------- | ----------- | ------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 工具栏位置   |
| `children`  | 多个 VirtualNode         | 无           | 多个工具栏元素 |

## 示例

```tsx
<Toolbar>
  <ToolbarItemGroup placement="topBarTrailing">
    <Button title="刷新" action={reload} />
    <Button title="更多" action={openMenu} />
  </ToolbarItemGroup>
</Toolbar>
```

***

# ToolbarSpacer

`ToolbarSpacer` 用于在工具栏项之间添加空白区域，适合需要自定义布局的场景。

## 参数说明

| 参数          | 类型                      | 默认值         | 说明                   |
| ----------- | ----------------------- | ----------- | -------------------- |
| `sizing`    | `'fixed' \| 'flexible'` | `flexible`  | 控制 Spacer 是否固定大小或可伸缩 |
| `placement` | `ToolbarItemPlacement`  | `automatic` | Spacer 所在位置          |

### 行为说明

- `flexible`: 工具栏中的弹性空间，它会占据剩余区域。
- `fixed`: 提供固定间隔，适合多个按钮之间进行细微布局。

## 示例：在同一组中强制按钮分隔

```tsx
<Toolbar>
  <ToolbarItem placement="topBarTrailing">
    <Button title="Edit" action={edit} />
  </ToolbarItem>
  <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
  <ToolbarItem placement="topBarTrailing">
    <Button title="Save" action={save} />
  </ToolbarItem>
</Toolbar>
```

***

# DefaultToolbarItem

```ts
type ToolbarDefaultItemKind = "sidebarToggle" | "search" | "title";

type DefaultToolbarItemProps = {
  kind: ToolbarDefaultItemKind;
  placement?: ToolbarItemPlacement;
};

declare const DefaultToolbarItem: FunctionComponent<DefaultToolbarItemProps>;
```

用于渲染系统提供的默认工具栏项目，例如侧边栏切换按钮、搜索按钮、标题显示等。

## 参数说明

| 参数          | 类型                                       | 默认值         | 说明         |
| ----------- | ---------------------------------------- | ----------- | ---------- |
| `kind`      | `"sidebarToggle" \| "search" \| "title"` | 无           | 选择系统默认项目类型 |
| `placement` | `ToolbarItemPlacement`                   | `automatic` | 放置位置       |

## 示例：添加默认的搜索栏按钮

```tsx
<Toolbar>
  <DefaultToolbarItem kind="search" placement="topBarTrailing" />
</Toolbar>
```

***

# 综合示例：使用 Toolbar 构建复杂工具栏

```tsx
<NavigationStack>
  <List
    toolbar={
      <Toolbar>

        {/* 左侧导航按钮 */}
        <ToolbarItem placement="navigation">
          <Button title="返回" action={Navigation.useDismiss()} />
        </ToolbarItem>

        {/* 标题 */}
        <DefaultToolbarItem kind="title" />

        {/* 右侧一组按钮 */}
        <ToolbarItem placement="topBarTrailing">
          <Button title="编辑" action={edit} />
        </ToolbarItem>
        <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
        <ToolbarItem placement="topBarTrailing">
          <Button title="完成" action={finish} />
        </ToolbarItem>

        {/* 底部区域按钮 */}
        <ToolbarItem placement="bottomBar">
          <Button title="帮助" action={showHelp} />
        </ToolbarItem>

      </Toolbar>
    }
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

此结构灵活而清晰，可复现 SwiftUI 中复杂的工具栏布局。

***

# 与 ToolBarProps 的关系

在 API 层面：

| 方式                                          | 说明                  |
| ------------------------------------------- | ------------------- |
| `toolbar={ { topBarTrailing: <Button/> } }` | 简洁、直观，适合简单场景        |
| `toolbar={<Toolbar>...</Toolbar>}`          | 可组合，可精确布局，适合复杂、多组内容 |

两种方式完全兼容，可根据需要选择。

***

# 总结

Toolbar 组件提供了高度灵活的工具栏布局能力，包括：

- 单项工具栏项 (`ToolbarItem`)
- 工具栏项目组 (`ToolbarItemGroup`)
- 自适应空白区域 (`ToolbarSpacer`)
- 系统默认工具栏元素 (`DefaultToolbarItem`)
- 容器式声明 (`<Toolbar>`)



---
url: /zh/guide/View Modifiers/toolbar/Use with ToolbarProps.md
---

# 使用 ToolbarProps

通过该属性，你可以为视图的导航栏或工具栏区域添加各种项目，类似于 SwiftUI 的 `toolbar` 修饰符功能。

***

## 概述

`toolbar` 属性接受一个 `ToolBarProps` 对象。`ToolBarProps` 中的每个键都对应特定的工具栏位置或操作类型。你提供的值可以是单个 `VirtualNode` 或一个包含多个 `VirtualNode` 元素的数组，这些节点代表自定义的 UI 项目。

**SwiftUI 示例（参考）**

```swift
// SwiftUI 示例代码
YourView()
    .toolbar {
        ToolbarItem(placement: .confirmationAction) {
            Button("保存") {
                // 处理保存操作
            }
        }
    }
```

**Scripting 示例（TypeScript/TSX）**

```tsx
<NavigationStack>
  <List
    toolbar={{
      confirmationAction: <Button title="保存" action={() => handleSave()} />,
      cancellationAction: <Button title="取消" action={() => handleCancel()} />,
      topBarLeading: [
        <Button title="编辑" action={() => handleEdit()} />,
        <Button title="刷新" action={() => handleRefresh()} />
      ]
    }}
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

***

## 工具栏位置

以下是 `ToolBarProps` 中可用的键，用于指定项目的位置和行为：

- **automatic**：根据上下文和平台自动确定位置。
- **bottomBar**：将项目放置在底部工具栏。
- **cancellationAction**：在模态界面中表示取消操作。
- **confirmationAction**：在模态界面中表示确认操作（例如，“保存”）。
- **destructiveAction**：表示执行破坏性任务的操作（例如，“删除”）。
- **keyboard**：将项目放置在与键盘关联的工具栏中。
- **navigation**：表示导航相关的操作（例如，“返回”或“关闭”）。
- **primaryAction**：表示界面的主要操作。
- **principal**：将项目放置在工具栏的主区域（通常在导航栏中居中）。
- **topBarLeading**：将项目放置在顶部栏的靠前位置（例如左侧）。
- **topBarTrailing**：将项目放置在顶部栏的靠后位置（例如右侧）。

***

## 使用示例

### 单个项目

如果想在工具栏中添加一个 `confirmationAction` 按钮：

```tsx
<NavigationStack>
  <VStack
    toolbar={{
      confirmationAction: <Button
        title="保存"
        action={() => console.log('正在保存...')}
      />
    }}
  >
    {/* 主内容 */}
  </VStack>
</NavigationStack>
```

***

### 多个项目

可以将节点数组传递给单个位置，从而在同一区域添加多个项目：

```tsx
<NavigationStack>
  <VStack
    toolbar={{
      topBarLeading: [
        <Button title="编辑" action={() => console.log('编辑被点击')} />,
        <Button title="设置" action={() => console.log('设置被点击')} />
      ],
      topBarTrailing: <Button title="完成" action={() => console.log('完成被点击')} />
    }}
  >
    {/* 主内容 */}
  </VStack>
</NavigationStack>
```

***

### 组合多个工具栏位置

可以根据需要混合和匹配不同的工具栏位置：

```tsx
<NavigationStack>
  <List
    toolbar={{
      navigation: <Button title="返回" action={() => console.log('返回被点击')} />,
      principal: <Text fontWeight={"bold"}>标题</Text>,
      primaryAction: <Button title="分享" action={() => console.log('分享被点击')} />,
      bottomBar: <Button title="帮助" action={() => console.log('帮助被点击')} />
    }}
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

***

## 总结

通过使用 `toolbar` 属性，你可以轻松在 Scripting 应用中复制 SwiftUI 的 `toolbar` 修饰符行为。将 `VirtualNode` 元素分配给 `ToolBarProps` 中的合适键，能够为你的页面构建丰富的上下文工具栏和导航栏，从而增强用户体验。



---
url: /zh/guide/View Modifiers/translationHost.md
---

# 翻译宿主

`translationHost` 是一个视图修饰符，用于为当前页面提供翻译服务上下文。它支持系统级的交互提示，例如下载语言包或在语言不明确时提示用户选择。

***

## 作用

当你使用 `Translation` 类进行文本翻译时，**应将 `translationHost` 应用于页面的根视图**，以确保：

- 如果**源语言或目标语言未安装**，系统会**提示用户下载所需语言**。
- 如果未指定源语言（即 `source: null`），且系统**无法从文本中判断语言**，系统会**提示用户手动选择源语言**。

如果不设置此修饰符，系统提示可能无法正常弹出，翻译过程可能失败或抛出错误。

***

## 类型定义

```ts
translationHost?: Translation
```

该修饰符的值必须是一个 `Translation` 实例。

***

## 使用示例

```tsx
function View() {
  const translation = useMemo(() => new Translation(), [])
  const [translated, setTranslated] = useState<{[key: string]: string}>({})
  const texts = ["Hello", "Goodbye"]
  
  useEffect(() => {
    translation.translateBatch({
      texts,
      source: "en",
      target: "fr"
    }).then(result => {
      const map: {[key: string]: string} = {}
      result.forEach((item, index) => {
        map[texts[index]] = item
      })
      setTranslated(map)
    })
  }, [])

  return <VStack translationHost={translation}>
    {texts.map(text => (
      <Text key={text}>
        {translated[text] || text}
      </Text>
    ))}
  </VStack>
}
```

在上面的示例中：

- 使用 `useMemo` 创建了一个 `Translation` 实例。
- 批量将英语文本翻译为法语。
- 最外层的 `VStack` 使用了 `translationHost={translation}`，确保系统在需要时可以弹出下载或语言选择提示。

***

## 最佳实践

- 始终将 `translationHost` 应用于**页面的顶层容器视图**。
- 确保传入的 `Translation` 实例与用于调用 `.translate()` 或 `.translateBatch()` 的实例一致。
- 避免在同一个页面中重复创建多个 `Translation` 实例。



---
url: /zh/guide/View Modifiers/widgetBackground.md
---

# 小组件背景

`widgetBackground` 是一个专用于**小组件**的视图修饰符，用于在不同的渲染模式下设置背景样式，特别是为适配 **iOS 18 的 tinted（强调色）模式**而设计。

## 功能说明

在 **tinted 模式**下，iOS 会将所有视图颜色（包括背景）渲染为白色，除非该视图使用了 `widgetAccentable` 标记。这可能会导致背景显示异常或视觉效果失真。

使用 `widgetBackground` 可以避免这种问题：

- **在 accented 模式下自动隐藏背景**，避免被系统渲染为纯白色；
- **在默认模式或全彩模式下正常显示背景**。

这样可以确保你的小组件在不同系统渲染环境下都具有良好的视觉一致性。

***

## 支持的背景设置方式

`widgetBackground` 支持以下几种格式：

### 1. **纯色背景（ShapeStyle）**

使用简单颜色作为背景：

```tsx
<Text widgetBackground="systemBlue">
  Hello
</Text>
```

***

### 2. **动态背景（DynamicShapeStyle）**

根据系统的浅色/深色模式动态切换背景样式：

```tsx
<Text
  widgetBackground={{
    light: "white",
    dark: "black"
  }}
>
  模式感知背景
</Text>
```

***

### 3. **带形状的背景样式**

使用指定的\*\*形状（Shape）\*\*配合填充样式，实现结构化的背景设计：

```tsx
<Text
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12,
      style: "continuous"
    }
  }}
>
  圆角背景
</Text>
```

支持的形状包括：

- 预设形状：`'rect'`、`'circle'`、`'capsule'`、`'ellipse'`、`'buttonBorder'`、`'containerRelative'`
- 自定义圆角矩形：支持统一圆角、椭圆角尺寸、每个角独立设定

***

## 在 accented 模式下的行为

- **在 iOS 的 accented（tinted）模式下**：背景会被自动隐藏，以避免出现纯白色遮盖问题；
- **在默认或全彩渲染模式下**：背景将按设定正常显示。

此行为可有效避免系统渲染方式对 UI 布局和层级的干扰。

***

## 使用建议

- 仅在小组件中使用 `widgetBackground`，以避免在普通视图中出现不必要的隐藏行为；
- 不要使用背景传达重要信息，因为在 accented 模式下它可能会被隐藏；
- 搭配 `widgetAccentable` 使用，以精确控制哪些内容应参与系统色彩渲染，哪些内容应独立呈现。



---
url: /zh/guide/Views/AVPlayerView.md
---

# 视频播放组件(AVPlayerView)

`AVPlayerView` 是 Scripting 提供的视频播放组件，基于系统原生 `AVPlayerViewController` 封装。
与 `VideoPlayer` 不同，`AVPlayerView` **完整支持系统级 Picture in Picture（画中画，PiP）**，并允许脚本层监听 PiP 的生命周期变化。

该组件适用于对**原生播放行为、后台播放、PiP、锁屏与控制中心联动**有明确需求的媒体类场景。

***

## 一、何时使用 AVPlayerView

当你的场景满足以下任意条件时，应使用 `AVPlayerView`：

- 需要视频进入系统 PiP 模式
- 需要原生播放控制 UI
- 需要在后台持续播放视频
- 需要与系统 Now Playing / 锁屏 / 控制中心联动
- 需要精确感知 PiP 的开始与结束

如果仅做简单的视频展示且不需要 PiP，`VideoPlayer` 仍然是更轻量的选择。

***

## 二、核心属性详解

### 1. `player`

```ts
player: AVPlayer
```

- 实际执行播放的核心对象
- 由开发者自行创建和管理
- 支持网络视频、本地文件、HLS 等格式

`AVPlayerView` **不会管理播放器的生命周期**，播放器在 PiP 期间必须保持存活。

***

### 2. `pipStatus`

```ts
pipStatus: Observable<PIPStatus>
```

用于监听系统 PiP 的生命周期状态变化。

可能的取值如下：

| 状态                 | 含义            |
| ------------------ | ------------- |
| `willStart`        | PiP 即将开始      |
| `didStart`         | PiP 已开始       |
| `willStop`         | PiP 即将结束      |
| `didStop`          | PiP 已结束       |
| `undefined / null` | 尚未进入 PiP 生命周期 |

该状态完全由系统控制，**只能监听，不应手动修改**。

***

## 三、PiP 相关配置项

### 1. `allowsPictureInPicturePlayback`

```ts
allowsPictureInPicturePlayback?: boolean
```

- 是否允许视频进入 PiP
- 默认值：`true`

若设为 `false`：

- 系统 PiP 按钮不会显示
- 视频无法进入画中画模式

***

### 2. `canStartPictureInPictureAutomaticallyFromInline`

```ts
canStartPictureInPictureAutomaticallyFromInline?: boolean
```

- 当应用从前台切换到后台时，是否自动进入 PiP
- 默认值：`false`

适合以下场景：

- 用户按下 Home 键离开应用
- 希望播放不中断并自动进入 PiP

***

### 3. `updatesNowPlayingInfoCenter`

```ts
updatesNowPlayingInfoCenter?: boolean
```

- 是否自动更新系统 Now Playing 信息
- 默认值：`true`

开启后，视频信息会显示在：

- 锁屏界面
- 控制中心
- 外接播放设备

***

## 四、全屏播放行为

### 1. `entersFullScreenWhenPlaybackBegins`

```ts
entersFullScreenWhenPlaybackBegins?: boolean
```

- 播放开始时是否自动进入全屏
- 默认值：`false`

***

### 2. `exitsFullScreenWhenPlaybackEnds`

```ts
exitsFullScreenWhenPlaybackEnds?: boolean
```

- 播放结束时是否自动退出全屏
- 默认值：`false`

***

## 五、视频显示方式（videoGravity）

```ts
videoGravity?: AVLayerVideoGravity
```

| 值                  | 行为说明           |
| ------------------ | -------------- |
| `resize`           | 拉伸填满，不保持比例     |
| `resizeAspect`     | 保持比例，完整显示（默认）  |
| `resizeAspectFill` | 保持比例，填满区域，可能裁剪 |

***

## 六、完整 DEMO 示例

以下示例演示了：

- 创建并配置 `AVPlayer`
- 正确配置音频会话
- 监听 PiP 生命周期
- 控制播放 / 暂停
- 正确释放资源

```tsx
function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(
    TimeControlStatus.paused
  )
  const pipstatus = useObservable<PIPStatus>()

  console.log(pipstatus.value)

  const player = useMemo(() => {
    const player = new AVPlayer()

    player.setSource(
      "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
    )

    player.onTimeControlStatusChanged = status => {
      setStatus(status)
    }

    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      "playback",
      ["defaultToSpeaker"]
    )

    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="VideoPlayer"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        cancellationAction: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <AVPlayerView
        player={player}
        pipStatus={pipstatus}
        canStartPictureInPictureAutomaticallyFromInline
        updatesNowPlayingInfoCenter
        entersFullScreenWhenPlaybackBegins
      />

      <Button
        title={
          status === TimeControlStatus.paused
            ? "Play"
            : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 七、PiP 生命周期说明

PiP 状态通常按以下顺序变化：

1. `willStart`
2. `didStart`
3. PiP 运行中
4. `willStop`
5. `didStop`

在异常或系统打断情况下，部分状态可能被跳过，因此应以 `didStart` 和 `didStop` 作为最终判断依据。

***

## 八、重要注意事项

### 1. AVPlayerView 使用的是系统级视频 PiP

- 基于系统原生视频 PiP
- 与 Scripting 的自定义 PiP View Modifiers **完全不同**
- 两种 PiP 机制不可混用

***

### 2. PiP 依赖正确的音频会话配置

要保证 PiP 正常工作，必须：

- 激活音频会话
- 使用 `playback` 类别
- 正确配置后台音频能力

否则可能出现 PiP 无法启动或静默失败的情况。

***

### 3. PiP 期间不要销毁 AVPlayer

- PiP 运行中销毁或替换 `AVPlayer`
- 会导致 PiP 异常退出
- 甚至触发系统错误

应在 `pipStatus` 变为 `didStop` 后再释放播放器资源。

***

## 九、推荐实践总结

- 视频 PiP 场景始终使用 `AVPlayerView`
- 将 `pipStatus` 视为只读状态
- PiP 期间保持 `AVPlayer` 生命周期稳定
- 显式配置音频会话
- 避免频繁创建或替换播放器
- 在 PiP 完全结束后再释放资源



---
url: /zh/guide/Views/AccessoryWidgetBackground.md
---

# AccessoryWidgetBackground

一个自适应的背景视图，根据小组件当前的环境提供系统标准外观。

## 概述

`AccessoryWidgetBackground` 组件适用于配件类小组件（Accessory Widgets），如锁屏小组件或待机模式（StandBy）小组件。它会自动根据系统环境（如浅色/深色模式、透明度、系统主题）应用合适的背景样式，确保小组件与系统视觉风格一致。

通常你可以将此视图作为背景层，配合 `ZStack` 等布局使用，将自定义内容覆盖其上方，从而获得既美观又系统一致的外观。

## 示例

```tsx
import { AccessoryWidgetBackground, Text, ZStack } from "scripting"

function AccessoryView() {
  return (
    <ZStack>
      <AccessoryWidgetBackground />
      <Text font="caption">Weather</Text>
    </ZStack>
  )
}
```

在此示例中，`AccessoryWidgetBackground` 提供了系统适配的背景，`Text` 文本则显示在其上方。此布局非常适合锁屏小组件，确保内容在各种系统外观下保持清晰可读。

## 使用建议

- 通常应将 `AccessoryWidgetBackground` 放在 `ZStack` 的底层，以作为背景视图。
- 不建议对该组件直接设置颜色或样式，它会根据系统环境自动调整。
- 可与其他 SwiftUI 风格的组件结合使用，构建与原生系统一致的小组件外观。

## 兼容性

此组件主要用于配件类小组件，在普通视图中使用可能不会有任何视觉效果。建议仅在小组件开发中使用，以获得最佳系统一致性体验。



---
url: /zh/guide/Views/Button.md
---

# 按钮

在 **Scripting** 应用中，`Button` 组件允许您创建具有可自定义动作、标签、样式和角色的交互式元素。按钮可以触发动作、执行意图，并根据配置显示不同的视觉样式。本指南提供了关于如何使用 `Button` API 的详细说明，包括其属性、角色、样式及示例。

***

## `Button`

### 描述

您可以通过提供一个 **动作**（action）或 **意图**（intent）以及一个 **标签**（label）来创建按钮。标签可以是简单的文本、图标或复杂的视图。按钮是创建交互界面的关键，例如提交表单或在页面之间导航。

### 属性

| **属性**        | **类型**                                                     | **描述**                                                                                |
| ------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| `title`       | `string`                                                   | 按钮上显示的文本标签。                                                                           |
| `systemImage` | `string` _(可选)_                                            | 按钮标题旁边显示的系统图标名称。                                                                      |
| `children`    | `VirtualNode` 或 `VirtualNode[]`                            | 用作按钮标签的自定义视图，替代 `title`。                                                              |
| `role`        | `'destructive' \| 'cancel' \| 'close' \| 'confirm'` _(可选)_ | 描述按钮的用途。`destructive` 用于标记执行潜在危险操作的按钮，`cancel` 表示取消操作。                                |
| `intent`      | `AppIntent<any>`                                           | 当按钮被触发时执行的意图。适用于 `Widget` 或 `LiveActivity`。详情见 `Interactive Widget and LiveActivity`。 |
| `action`      | `() => void`                                               | 用户触发按钮时执行的函数。                                                                         |

***

### `ButtonStyle`

定义按钮的视觉外观。

| **值**               | **描述**                               |
| ------------------- | ------------------------------------ |
| `automatic`         | 根据按钮的上下文设置默认样式。                      |
| `bordered`          | 标准的带边框样式。                            |
| `borderedProminent` | 突出的带边框样式，更加醒目。                       |
| `borderless`        | 无边框样式。                               |
| `plain`             | 简洁的样式，具有最少的装饰，但仍可在按下、聚焦或启用状态下提供视觉反馈。 |

***

### `ButtonBorderShape`

指定 `bordered` 或 `borderedProminent` 样式按钮的边框形状。

| **值**                                | **描述**        |
| ------------------------------------ | ------------- |
| `automatic`                          | 由系统决定适当的形状。   |
| `capsule`                            | 胶囊形状的边框。      |
| `circle`                             | 圆形边框。         |
| `roundedRectangle`                   | 带圆角的矩形边框。     |
| `buttonBorder`                       | 由环境决定最终的边框形状。 |
| `{ roundedRectangleRadius: number }` | 带特定角半径的圆角矩形。  |

***

### `ControlSize`

定义按钮和其他控件的尺寸。

| **值**        | **描述**                 |
| ------------ | ---------------------- |
| `mini`       | 最小的控件尺寸。               |
| `small`      | 紧凑的控件尺寸。               |
| `regular`    | 标准的控件尺寸。               |
| `large`      | 较大的控件尺寸。               |
| `extraLarge` | 最大的控件尺寸，通常用于高强调或无障碍场景。 |

***

### `CommonViewProps`

这些属性可用于自定义视图中按钮的外观和行为。

| **属性**              | **类型**              | **描述**                                         |
| ------------------- | ------------------- | ---------------------------------------------- |
| `controlSize`       | `ControlSize`       | 设置视图中控件的尺寸。                                    |
| `buttonStyle`       | `ButtonStyle`       | 应用自定义交互行为和按钮外观。                                |
| `buttonBorderShape` | `ButtonBorderShape` | 指定 `bordered` 和 `borderedProminent` 按钮样式的边框形状。 |

***

## 示例用法

### 带动作的基础按钮

```tsx
<Button title="Sign in" action={handleSignIn} />
```

### 带系统图标的按钮

```tsx
<Button title="Delete" systemImage="trash" role="destructive" action={handleDelete} />
```

### 自定义标签按钮

```tsx
<Button>
  <Text>Custom Label</Text>
</Button>
```

### 执行 AppIntent 的按钮

```tsx
<Button
  title="Start Workout"
  intent={MyStartWorkoutIntent({ duration: 30 })}
  buttonStyle="borderedProminent"
/>
```

### 设置按钮样式

```tsx
<Group
  buttonStyle="bordered"
  buttonBorderShape={{ roundedRectangleRadius: 8 }}
  controlSize="large"
>
  <Button title="Save" action={handleSave} />
</Group>
```

***

### 注意事项

- 使用 `role` 指定具有特定用途的按钮，例如取消或危险操作按钮。
- 将 `buttonStyle` 和 `buttonBorderShape` 结合使用，为整个视图提供一致的主题。
- `intent` 属性将按钮与 `Widget` 和 `LiveActivity` 集成，实现无缝交互。

关于 `AppIntent` 的更多细节，请参阅 `Interactive Widget and LiveActivity` 文档。



---
url: /zh/guide/Views/Charts/AreaStackChart/index.md
---

# 堆叠面积图（AreaStackChart）

`AreaStackChart` 是用于展示堆叠区域图的组件，可将一系列数值以堆叠区域的方式呈现在共享坐标轴上，适用于展示各分类数据在一段时间内的变化趋势及其组合占比。

## 使用示例

```tsx
<Chart frame={{ height: 300 }}>
  <AreaStackChart
    marks={[
      {
        category: "Cheese",
        label: "2020",
        value: 0.26,
        stacking: "standard"
      },
      ...
    ]}
  />
</Chart>
```

## 属性说明

### `marks: Array<object>` **(必填)**

用于定义图表数据的数组。每一项表示一个图表标记，支持以下字段：

- `category: string`
  数据所属的分类名称，用于堆叠图中分组。

- `label: string | Date`
  图表横轴的标签，可为字符串或日期，常用于表示时间（如年份）。

- `value: number`
  对应的数值，用于绘制堆叠区域的高度。

- `unit?: CalendarComponent`
  指定时间单位，如 `"year"`、`"month"`、`"day"` 等。用于基于时间的标记。

- `stacking?: ChartMarkStackingMethod`
  设置堆叠方式，可选值包括：

  - `"standard"`：从基线开始正常堆叠（默认）。
  - `"normalized"`：将每组值归一化为总值的百分比。
  - `"center"`：以中心轴为基线对称堆叠。
  - `"unstacked"`：不进行堆叠，单独绘制。

- 其他可选的 `ChartMarkProps` 属性：
  支持丰富的样式和行为配置，如：

  - `foregroundStyle`（前景样式）
  - `opacity`（透明度）
  - `cornerRadius`（圆角）
  - `interpolationMethod`（插值方式）
  - `symbol`、`symbolSize`、`annotation`（注释）、`clipShape`、`shadow`、`blur`、`zIndex`、`offset` 等

详细配置请参考 `ChartMarkProps` 定义。

### `labelOnYAxis?: boolean`

是否将 `label` 值显示在 Y 轴上（默认在 X 轴）。默认为 `false`。

## 示例

```tsx
<AreaStackChart
  labelOnYAxis={false}
  marks={[
    {
      category: "Burger",
      label: 2020,
      value: 0.6,
      stacking: "standard"
    },
    {
      category: "Cheese",
      label: 2020,
      value: 0.26,
      stacking: "standard"
    },
    {
      category: "Bun",
      label: 2020,
      value: 0.24,
      stacking: "standard"
    }
  ]}
/>
```



---
url: /zh/guide/Views/Charts/AreaStackChart/index_example.md
---

# 示例

```tsx
import { AreaStackChart, Chart, ChartMarkStackingMethod, Navigation, NavigationStack, Picker, Script, Text, useState, VStack } from "scripting"

const data = [
  { name: "Burger", price: 0.07, year: 1960 },
  { name: "Cheese", price: 0.03, year: 1960 },
  { name: "Bun", price: 0.05, year: 1960 },

  { name: "Burger", price: 0.10, year: 1970 },
  { name: "Cheese", price: 0.04, year: 1970 },
  { name: "Bun", price: 0.06, year: 1970 },

  { name: "Burger", price: 0.15, year: 1980 },
  { name: "Cheese", price: 0.10, year: 1980 },
  { name: "Bun", price: 0.1, year: 1980 },

  { name: "Burger", price: 0.23, year: 1990 },
  { name: "Cheese", price: 0.12, year: 1990 },
  { name: "Bun", price: 0.13, year: 1990 },

  { name: "Burger", price: 0.32, year: 2000 },
  { name: "Cheese", price: 0.15, year: 2000 },
  { name: "Bun", price: 0.15, year: 2000 },

  { name: "Burger", price: 0.49, year: 2010 },
  { name: "Cheese", price: 0.20, year: 2010 },
  { name: "Bun", price: 0.19, year: 2010 },

  { name: "Burger", price: 0.60, year: 2020 },
  { name: "Cheese", price: 0.26, year: 2020 },
  { name: "Bun", price: 0.24, year: 2020 },
]

const stackings: ChartMarkStackingMethod[] = [
  'center',
  'normalized',
  'standard',
  'unstacked'
]

function Example() {
  const [stacking, setStacking] = useState<ChartMarkStackingMethod>('standard')

  return <NavigationStack>
    <VStack
      navigationTitle={"AreaStackChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Picker
        title={"StackingMethod"}
        value={stacking}
        onChanged={setStacking as any}
        pickerStyle={"menu"}
      >
        {stackings.map(item =>
          <Text tag={item}>{item}</Text>
        )}
      </Picker>
      <Chart
        frame={{
          height: 300
        }}
      >
        <AreaStackChart
          marks={data.map(item => ({
            category: item.name,
            label: item.year.toString(),
            value: item.price,
            stacking: stacking,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/Bar1DChart/index.md
---

# 一维柱状图（Bar1DChart）

`Bar1DChart` 是一种一维条形图组件，用于在多个离散分类之间直观比较数值大小。每一个条形代表一个分类及其对应的数值，适合用于构建简洁的横向或纵向柱状对比图。

## 使用示例

```tsx
<Chart
  padding={0}
  frame={{ height: 400 }}
>
  <Bar1DChart
    marks={[
      { category: "Gadgets", value: 3800 },
      { category: "Gizmos", value: 4400 },
      { category: "Widgets", value: 6500 },
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

是否在 Y 轴上显示分类标签。当设置为 `true` 时，条形将以横向方式排列。
默认为 `false`，即在 X 轴上显示标签，条形图为纵向排列。

### `marks: Array<object>` **（必填）**

定义要渲染的每一个条形的数据项。每个标记包含以下字段：

- `category: string`
  条形所对应的分类名称。

- `value: number`
  条形的数值，用于决定长度。

- 其他可选的 `ChartMarkProps` 样式属性：
  可通过 `ChartMarkProps` 自定义样式和行为，包括：

  - `foregroundStyle`（颜色样式）
  - `opacity`（透明度）
  - `symbol`（图形符号）
  - `annotation`（注释）
  - `offset`（偏移位置）
  - `zIndex`（显示层级）等

## 示例代码

```tsx
const data = [
  { type: "Gadgets", profit: 3800 },
  { type: "Gizmos", profit: 4400 },
  { type: "Widgets", profit: 6500 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"Bar1DChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        padding={0}
        frame={{ height: 400 }}
      >
        <Bar1DChart
          marks={data.map(item => ({
            category: item.type,
            value: item.profit,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}
```

## 运行图表示例

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

## 使用场景

`Bar1DChart` 适用于：

- 比较多个分类项的数值差异
- 展示排行榜、排序结果等
- 以极简方式可视化清晰、有限的数据集



---
url: /zh/guide/Views/Charts/Bar1DChart/index_example.md
---

# 示例

```tsx
import { Bar1DChart, Chart, Navigation, NavigationStack, Script, VStack } from "scripting"

const data = [
  { type: "Gadgets", profit: 3800 },
  { type: "Gizmos", profit: 4400 },
  { type: "Widgets", profit: 6500 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"Bar1DChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        padding={0}
        frame={{
          height: 400
        }}
      >
        <Bar1DChart
          marks={data.map(item => ({
            category: item.type,
            value: item.profit,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack >
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/BarChart/index.md
---

# 柱状图（BarChart）

`BarChart`（柱状图）组件用于以条形的形式直观比较不同分类的数值大小。每个柱形条对应一个标签，并通过其高度（纵向布局）或长度（横向布局）表示具体数值。

## 场景示例

本示例展示了三种玩具形状（`Cube`、`Sphere`、`Pyramid`）的数量，并提供一个开关用于切换柱状图的展示方向（横向或纵向），通过 `labelOnYAxis` 属性控制。

## 使用示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarChart
    labelOnYAxis={false}
    marks={[
      { label: "Cube", value: 5 },
      { label: "Sphere", value: 4 },
      { label: "Pyramid", value: 4 },
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

- 设置为 `true` 时，标签显示在 **Y 轴**，图表将以 **横向柱状图** 的形式展示。
- 设置为 `false`（默认），标签显示在 **X 轴**，图表将以 **纵向柱状图** 的形式展示。

### `marks: Array<object>` **（必填）**

每个数据点定义一个柱状条，包含以下字段：

- `label: string | Date`
  分类的标签或标识。

- `value: number`
  柱状条对应的数值。

- `unit?: CalendarComponent`（可选）
  用于表示时间单位的字段，在处理时间数据时可设置。

- 可选的 `ChartMarkProps` 属性
  用于进一步自定义柱状条的样式，例如：

  - `foregroundStyle`（前景颜色）
  - `opacity`（透明度）
  - `cornerRadius`（圆角）
  - `symbol`（图形标记）
  - `annotation`（注释）等

## 示例代码

```tsx
const toysData = [
  { type: "Cube", count: 5 },
  { type: "Sphere", count: 4 },
  { type: "Pyramid", count: 4 },
]

<BarChart
  labelOnYAxis={labelOnYAxis}
  marks={toysData.map(toy => ({
    label: toy.type,
    value: toy.count,
  }))}
/>
```

## 支持动态布局切换

示例中使用 `Toggle` 实现横向 / 纵向图表的切换：

```tsx
<Toggle
  title="labelOnYAxis"
  value={labelOnYAxis}
  onChanged={setLabelOnYAxis}
/>
```

## 使用场景

`BarChart` 非常适用于：

- 对比多个分类的数值差异
- 展示调查结果、数量统计或排行榜数据
- 需要根据布局场景自由切换方向的图表展示



---
url: /zh/guide/Views/Charts/BarChart/index_example.md
---

# 示例

```tsx
import { BarChart, Chart, List, Navigation, NavigationStack, Script, Section, Toggle, useState, } from "scripting"

type ToyShape = {
  type: string
  count: number
}

const toysData: ToyShape[] = [
  {
    type: "Cube",
    count: 5,
  },
  {
    type: "Sphere",
    count: 4,
  },
  {
    type: "Pyramid",
    count: 4
  }
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"BarChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart
        chartXVisibleDomain={10}
        frame={{
          height: 400
        }}
      >
        <BarChart
          labelOnYAxis={labelOnYAxis}
          marks={toysData.map(toy => ({
            label: toy.type,
            value: toy.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/BarGanttChart/index.md
---

# 甘特柱状图（BarGanttChart）

`BarGanttChart`（甘特条形图）组件用于可视化多个分类下的时间区间，非常适合展示日程安排、任务持续时间或项目时间线。每条条形从 `start` 延伸至 `end`，表示某项任务或事件在时间轴上的跨度。

## 使用示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarGanttChart
    labelOnYAxis
    marks={[
      { label: "Job 1", start: 0, end: 15 },
      { label: "Job 2", start: 5, end: 25 },
      ...
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

是否在 Y 轴显示分类标签。当为 `true` 时，图表将以横向方式绘制（即典型甘特图布局），条形沿 X 轴表示时间跨度。
默认为 `false`，即条形纵向排列，标签显示在 X 轴。

### `marks: Array<object>` **（必填）**

定义要渲染的时间区间。每个对象必须包含以下字段：

- `label: string`
  条形所代表的分类名称（例如任务名或工种）。

- `start: number`
  条形的起始位置，通常代表开始时间或起点值。

- `end: number`
  条形的结束位置，代表结束时间或终点值。图表将绘制一条从 `start` 到 `end` 的条形。

你也可以提供其他 `ChartMarkProps` 来自定义样式和行为。

## 示例代码

```tsx
const data = [
  { job: "Job 1", start: 0, end: 15 },
  { job: "Job 2", start: 5, end: 25 },
  { job: "Job 1", start: 20, end: 35 },
  { job: "Job 1", start: 40, end: 55 },
  { job: "Job 2", start: 30, end: 60 },
  { job: "Job 2", start: 30, end: 60 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"BarGanttChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart frame={{ height: 400 }}>
        <BarGanttChart
          labelOnYAxis
          marks={data.map(item => ({
            label: item.job,
            start: item.start,
            end: item.end,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}
```

## 运行图表示例

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

## 使用场景

`BarGanttChart` 非常适用于：

- 项目计划与任务排程
- 展示任务重叠与时间持续分布
- 表达资源在时间轴上的分配情况



---
url: /zh/guide/Views/Charts/BarGanttChart/index_example.md
---

# 示例

```tsx
import { BarGanttChart, Chart, Navigation, NavigationStack, Script, VStack } from "scripting"

const data = [
  { job: "Job 1", start: 0, end: 15 },
  { job: "Job 2", start: 5, end: 25 },
  { job: "Job 1", start: 20, end: 35 },
  { job: "Job 1", start: 40, end: 55 },
  { job: "Job 2", start: 30, end: 60 },
  { job: "Job 2", start: 30, end: 60 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"BarGanttChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 400
        }}
      >
        <BarGanttChart
          labelOnYAxis
          marks={data.map(item => ({
            label: item.job,
            start: item.start,
            end: item.end
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/BarGroupChart/index.md
---

# 分组柱状图（BarGroupChart）

本示例演示如何在 `BarChart` 中使用 `positionBy` 属性将柱状图按子分类（如颜色）进行分组，并使用 `foregroundStyleBy` 对每组数据应用不同的颜色样式。此方式适用于在主分类下对多个子类进行对比展示。

## 场景说明

数据包含了不同颜色（如 `Green`, `Purple`, `Pink`, `Yellow`）下的三种物体类型（`Cube`, `Sphere`, `Pyramid`）及其数量（`count`）。图表展示了每种颜色下各类型物体的数量，按颜色分组并以不同颜色区分。

## 核心概念说明

### `positionBy`

```ts
positionBy: {
  value: item.color,
  axis: 'horizontal',
}
```

- 将柱状图按照 `value`（此处为颜色）进行分组。
- `axis` 指定分组的方向：

  - `'horizontal'`：按 Y 轴进行分组（即按颜色垂直堆叠或排列）。
  - `'vertical'`：按 X 轴分组（通常用于横向柱状图）。

### `foregroundStyleBy`

```ts
foregroundStyleBy: item.color
```

- 根据指定的字段值（颜色）为每个柱状条应用前景样式（颜色）。
- 有助于在图表中清晰地区分不同的分组。

## 代码摘要

```tsx
const data = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Purple", type: "Sphere", count: 1 },
  ...
]

const list = data.map(item => ({
  label: item.type,              // 主标签（如 Cube、Sphere）
  value: item.count,             // 数值高度
  positionBy: {
    value: item.color,           // 分组依据（颜色）
    axis: 'horizontal',
  },
  foregroundStyleBy: item.color, // 应用不同颜色
  cornerRadius: 8,
}))
```

## 完整示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarChart marks={list} />
</Chart>
```

该图表将以颜色为分组单位，每组包含三种类型（Cube、Sphere、Pyramid）的柱状条，每种颜色对应一组条，并应用统一的颜色样式。

## 适用场景

此类分组柱状图适用于：

- 展示主分类下的子分类对比（例如不同行业中不同岗位数量对比）。
- 展示结构化数据的分布情况。
- 强调多个子类在各分组中的占比和数量。



---
url: /zh/guide/Views/Charts/BarGroupChart/index_example.md
---

# 示例

```tsx
import { BarChart, BarChartProps, Button, Chart, Navigation, NavigationStack, Script, VStack, useMemo } from "scripting"

const data = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Green", type: "Sphere", count: 0 },
  { color: "Green", type: "Pyramid", count: 1 },
  { color: "Purple", type: "Cube", count: 1 },
  { color: "Purple", type: "Sphere", count: 1 },
  { color: "Purple", type: "Pyramid", count: 1 },
  { color: "Pink", type: "Cube", count: 1 },
  { color: "Pink", type: "Sphere", count: 2 },
  { color: "Pink", type: "Pyramid", count: 0 },
  { color: "Yellow", type: "Cube", count: 1 },
  { color: "Yellow", type: "Sphere", count: 1 },
  { color: "Yellow", type: "Pyramid", count: 2 },
]

function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  const list = useMemo(() => {
    return data.map(item => ({
      label: item.type,
      value: item.count,
      positionBy: {
        value: item.color,
        axis: 'horizontal',
      },
      foregroundStyleBy: item.color,
      cornerRadius: 8,
    }) as BarChartProps["marks"][0])
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <Chart
        frame={{
          height: 400
        }}
      >
        <BarChart
          marks={list}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  // Present view.
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/BarStackChart/index.md
---

# 堆叠柱状图（BarStackChart）

`BarStackChart`（堆叠柱状图）组件用于将多个子分类的数据值以堆叠条形的方式展现在同一个主分类下，便于对比每组数据的总量及其组成部分。每条柱状条会被拆分为多个颜色段，每段代表一个子分类。

## 场景示例

本示例展示了按玩具形状（`Cube`、`Sphere`、`Pyramid`）分组的数据，每组下根据颜色（`Green`、`Purple`、`Pink`、`Yellow`）堆叠显示各颜色的数量占比。

## 使用示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarStackChart
    labelOnYAxis={false}
    marks={[
      { label: "Cube", value: 2, category: "Green" },
      { label: "Cube", value: 1, category: "Purple" },
      ...
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

- 设置为 `true` 时，分类标签显示在 **Y 轴**，图表呈 **横向柱状图**。
- 设置为 `false`（默认值）时，标签显示在 **X 轴**，图表呈 **纵向柱状图**。

### `marks: Array<object>` **（必填）**

每个数据项代表堆叠柱中的一个区块，包含以下字段：

- `label: string | Date`
  主分类标签，用于将多个子分类堆叠在同一条柱状图上（例如 `"Cube"`、`"Sphere"`）。

- `category: string`
  子分类标识，用于区分堆叠条形的不同组成部分（例如颜色：`"Green"`、`"Pink"`）。

- `value: number`
  数值，决定堆叠部分的高度或长度。

- `unit?: CalendarComponent`
  （可选）用于时间序列的单位。

- 其他可选的 `ChartMarkProps` 样式属性，支持个性化设置，如：

  - `foregroundStyle`（前景样式）
  - `cornerRadius`（圆角）
  - `symbol`（标记）
  - `annotation`（注释）
  - 等其他可视化属性

## 完整示例

```tsx
const data = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Purple", type: "Cube", count: 1 },
  ...
]

<BarStackChart
  labelOnYAxis={labelOnYAxis}
  marks={data.map(item => ({
    label: item.type,
    value: item.count,
    category: item.color,
  }))}
/>
```

## 布局切换

示例中提供了 `Toggle` 开关，可动态切换柱状图的显示方向（横向或纵向），通过控制 `labelOnYAxis` 实现。

## 执行视图

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}
```

## 适用场景

`BarStackChart` 适合用于以下场景：

- 展示各分类下的组成部分及总量对比
- 可视化每组数据中子项的占比关系
- 比较多个项目中相同结构的变化趋势



---
url: /zh/guide/Views/Charts/BarStackChart/index_example.md
---

# 示例

```tsx
import { BarStackChart, Chart, List, Navigation, NavigationStack, Script, Section, Toggle, useState, } from "scripting"

type ToyShape = {
  color: string
  type: string
  count: number
}

const toyWithColorData: ToyShape[] = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Green", type: "Sphere", count: 0 },
  { color: "Green", type: "Pyramid", count: 1 },
  { color: "Purple", type: "Cube", count: 1 },
  { color: "Purple", type: "Sphere", count: 1 },
  { color: "Purple", type: "Pyramid", count: 1 },
  { color: "Pink", type: "Cube", count: 1 },
  { color: "Pink", type: "Sphere", count: 2 },
  { color: "Pink", type: "Pyramid", count: 0 },
  { color: "Yellow", type: "Cube", count: 1 },
  { color: "Yellow", type: "Sphere", count: 1 },
  { color: "Yellow", type: "Pyramid", count: 2 },
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"BarStackChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart
        frame={{
          height: 400
        }}
      >
        <BarStackChart
          labelOnYAxis={labelOnYAxis}
          marks={toyWithColorData.map(toy => ({
            label: toy.type,
            value: toy.count,
            category: toy.color,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/DonutChart/index.md
---

# 环形图（DonutChart）

`DonutChart`（环形图）组件用于以圆环的形式展示各分类在整体中的占比。每一个扇形区域代表一个数据项，角度大小与其数值成比例。相比传统的饼图，`DonutChart` 中央有一个空心区域，视觉上更清晰且易于叠加标签或图标。

## 属性

### `marks: Array<object>` **（必填）**

用于定义每个环形扇区的数据项。每个标记包含以下字段：

***

### `category: string`

分类名称，表示该扇区所属的标签（例如产品名、地区等）。

### `value: number`

用于计算该扇区的角度，数值越大，所占比例越大。角度将与该值在所有值中的占比成正比。

***

### `innerRadius?: MarkDimension`

**内半径**，即环形中间空心区域的大小。

- 格式如下：

  ```ts
  {
    type: 'ratio' | 'inset';
    value: number;
  }
  ```

- `type: 'ratio'`
  使用外半径的比例（如 `0.618`）表示内半径大小。

- `type: 'inset'`
  表示从外边缘向内缩进的固定距离（单位为 pt）。

***

### `outerRadius?: MarkDimension`

**外半径**，控制每个扇区向外延伸的范围。

- 格式如下：

  ```ts
  {
    type: 'inset';
    value: number;
  }
  ```

- `type: 'inset'`
  指定从绘图区域边缘向内缩进的距离。

***

### `angularInset?: number`

设置每个扇区之间的间隙角度（单位为度），可用于增加视觉分隔效果或实现圆角扇形。

***

### 继承自 `ChartMarkProps`

还支持所有 `ChartMarkProps` 提供的样式和行为属性，包括：

- `foregroundStyle` – 设置扇区颜色
- `annotation` – 为扇区添加标签或图标
- `opacity`、`cornerRadius`、`offset`、`shadow` 等

## 示例代码

```tsx
<DonutChart
  marks={data.map(item => ({
    category: item.name,
    value: item.sales,
    innerRadius: {
      type: 'ratio',
      value: 0.618
    },
    outerRadius: {
      type: 'inset',
      value: 10
    },
    angularInset: 1
  }))}
/>
```

## 适用场景

- 展示不同产品的销售占比
- 可视化市场份额、人口结构等整体分布
- 对多个分类在总体中的比例进行对比



---
url: /zh/guide/Views/Charts/DonutChart/index_example.md
---

# 示例

```tsx
import { Chart, DonutChart, Navigation, NavigationStack, Script, VStack } from "scripting"

let data = [
  { name: "Cachapa", sales: 9631 },
  { name: "Crêpe", sales: 6959 },
  { name: "Injera", sales: 4891 },
  { name: "Jian Bing", sales: 2506 },
  { name: "American", sales: 1777 },
  { name: "Dosa", sales: 625 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"DonutChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <DonutChart
          marks={
            data.map(item => ({
              category: item.name,
              value: item.sales,
              innerRadius: {
                type: 'ratio',
                value: 0.618
              },
              outerRadius: {
                type: 'inset',
                value: 10,
              },
              angularInset: 1,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/HeatMapChart/index.md
---

# 热力图（HeatMapChart）

`HeatMapChart`（热力图）组件用于以网格形式展示二维数据的分布情况，其中每个单元格的颜色深浅表示该位置对应的数值大小。非常适合用于可视化两个分类维度之间的关系、频率或强度。

## 使用示例

```tsx
<Chart
  aspectRatio={{
    value: 1,
    contentMode: 'fit'
  }}
>
  <HeatMapChart
    marks={[
      { x: "+", y: "+", value: 125 },
      { x: "+", y: "-", value: 10 },
      { x: "-", y: "-", value: 80 },
      { x: "-", y: "+", value: 1 },
    ]}
  />
</Chart>
```

## 属性说明

### `marks: Array<object>` **（必填）**

每个项表示热力图中的一个网格单元，包括其位置（X/Y 坐标）和用于计算颜色强度的数值。

#### 字段：

- `x: string`
  横轴坐标（例如某个分类或标签）。

- `y: string`
  纵轴坐标（例如另一分类或标签）。

- `value: number`
  该坐标点对应的数值，用于映射颜色的深浅。数值越大，颜色通常越深或越饱和。

- 继承自 `ChartMarkProps` 的其他样式属性：
  支持进一步的样式配置，包括：

  - `foregroundStyle`（前景颜色）
  - `opacity`（透明度）
  - `annotation`（注释）
  - `cornerRadius`（圆角）
  - `zIndex` 等

## 适用场景

`HeatMapChart` 适用于以下数据可视化需求：

- 展示相关性矩阵（correlation matrix）
- 分析两个分类维度之间的分布关系
- 可视化频率、密度或绩效指标的强弱分布

## 完整示例

```tsx
const data = [
  { positive: "+", negative: "+", num: 125 },
  { positive: "+", negative: "-", num: 10 },
  { positive: "-", negative: "-", num: 80 },
  { positive: "-", negative: "+", num: 1 },
]

<HeatMapChart
  marks={data.map(item => ({
    x: item.positive,
    y: item.negative,
    value: item.num,
  }))}
/>
```



---
url: /zh/guide/Views/Charts/HeatMapChart/index_example.md
---

# 示例

```tsx
import { Chart, HeatMapChart, Navigation, NavigationStack, Script, VStack } from "scripting"

const data = [
  { positive: "+", negative: "+", num: 125 },
  { positive: "+", negative: "-", num: 10 },
  { positive: "-", negative: "-", num: 80 },
  { positive: "-", negative: "+", num: 1 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"HeatMapChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        aspectRatio={{
          value: 1,
          contentMode: 'fit'
        }}
      >
        <HeatMapChart
          marks={
            data.map(item => ({
              x: item.positive,
              y: item.negative,
              value: item.num,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/LineCategoryChart/index.md
---

# 分类折线图（LineCategoryChart）

`LineCategoryChart` 是一款用于展示多类别折线图的组件，支持在共享的标签轴上，对多个分类的数值趋势进行对比。每条折线代表一个分类，其在每个标签上的数值以点连接成线。

此图表非常适合可视化多个子类别（如产品线、部门、地区）在某些阶段、步骤或时间点上的对比和变化趋势。

***

## 示例场景

本示例展示了多个部门（如 `Production`、`Marketing`、`Finance`）的数值表现，并通过三条线分别代表不同的产品分类（`Gizmos`、`Gadgets`、`Widgets`）。

***

## 使用方式

```tsx
<LineCategoryChart
  labelOnYAxis={false}
  marks={[
    { label: "Production", value: 4000, category: "Gizmos" },
    { label: "Marketing", value: 2000, category: "Gizmos" },
    ...
  ]}
/>
```

***

## 属性说明

### `labelOnYAxis?: boolean`

- 如果为 `true`，标签（如 `"Production"`、`"Marketing"`）显示在 **Y 轴**，折线图将以 **横向** 展示。
- 默认为 `false`，标签显示在 **X 轴**，折线图以 **纵向** 展示。

***

### `marks: Array<object>` **（必填）**

每个数据项表示图表中的一个点，需包含以下字段：

- `label: string | Date`
  标签轴的值（例如：阶段、部门、月份），所有分类共享此轴。

- `value: number`
  此分类在该标签位置上的数值。

- `category: string`
  分类标识，相同分类的点将自动连接成一条折线。

此外还支持 `ChartMarkProps` 中的样式扩展字段，如：

- `foregroundStyle`（颜色）
- `symbol`（标记符号）
- `annotation`（注释）等

***

## 完整示例

```tsx
const data = [
  { label: "Production", value: 4000, category: "Gizmos" },
  { label: "Marketing", value: 2000, category: "Gizmos" },
  { label: "Finance", value: 2000.5, category: "Gizmos" },

  { label: "Production", value: 5000, category: "Gadgets" },
  { label: "Marketing", value: 1000, category: "Gadgets" },
  { label: "Finance", value: 3000, category: "Gadgets" },

  { label: "Production", value: 6000, category: "Widgets" },
  { label: "Marketing", value: 5000.9, category: "Widgets" },
  { label: "Finance", value: 5000, category: "Widgets" },
]

<LineCategoryChart
  labelOnYAxis={labelOnYAxis}
  marks={data}
/>
```

***

## 适用场景

`LineCategoryChart` 适合用于：

- 展示多个分类在各阶段的趋势对比
- 可视化结构化标签（如月份、部门、步骤）上的分类数据演变
- 比较多维业务指标（如营收、预算、产能等）的走势



---
url: /zh/guide/Views/Charts/LineCategoryChart/index_example.md
---

# 示例

```tsx
import { Chart, LineCategoryChart, List, Navigation, NavigationStack, Script, Section, Toggle, useState } from "scripting"

const data = [
  { label: "Production", value: 4000, category: "Gizmos" },
  { label: "Production", value: 5000, category: "Gadgets" },
  { label: "Production", value: 6000, category: "Widgets" },
  { label: "Marketing", value: 2000, category: "Gizmos" },
  { label: "Marketing", value: 1000, category: "Gadgets" },
  { label: "Marketing", value: 5000.9, category: "Widgets" },
  { label: "Finance", value: 2000.5, category: "Gizmos" },
  { label: "Finance", value: 3000, category: "Gadgets" },
  { label: "Finance", value: 5000, category: "Widgets" },
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"LineCategoryChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart
        frame={{
          height: 300
        }}
      >
        <LineCategoryChart
          labelOnYAxis={labelOnYAxis}
          marks={data}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/LineChart/index.md
---

# 折线图（LineChart）

`LineChart`（折线图）组件用于在一组带标签的离散点之间绘制一条连续的折线，适合用于展示简单趋势、变化过程或阶段对比。
该组件的 API 与 `BarChart` 相同，适合用于单条折线的基础可视化。

***

## 示例场景

本示例展示了三种玩具形状（`Cube`、`Sphere`、`Pyramid`）的数量变化。用户可以通过切换 `labelOnYAxis` 控制折线图的横向或纵向布局。

***

## 使用示例

```tsx
<Chart>
  <LineChart
    labelOnYAxis={false}
    marks={[
      { label: "Cube", value: 5 },
      { label: "Sphere", value: 4 },
      { label: "Pyramid", value: 4 },
    ]}
  />
</Chart>
```

***

## 属性说明

### `labelOnYAxis?: boolean`

- 设置为 `true` 时，标签显示在 **Y 轴**，折线将以 **横向** 方式绘制。
- 默认为 `false`，标签显示在 **X 轴**，折线以 **纵向** 方式绘制。

***

### `marks: Array<object>` **（必填）**

每个标记代表图上的一个数据点，包含以下字段：

- `label: string | Date`
  点所对应的标签（如分类、时间点等）。

- `value: number`
  此标签下对应的数值。

- 也支持 `ChartMarkProps` 中的其他样式字段，例如：

  - `foregroundStyle`（颜色）
  - `symbol`（标记图形）
  - `annotation`（注释）
  - `cornerRadius`（圆角）
  - `opacity` 等

***

## 完整示例

```tsx
const toysData = [
  { type: "Cube", count: 5 },
  { type: "Sphere", count: 4 },
  { type: "Pyramid", count: 4 },
]

<LineChart
  marks={toysData.map(toy => ({
    label: toy.type,
    value: toy.count,
  }))}
/>
```

***

## 适用场景

`LineChart` 适用于以下情况：

- 展示标签序列下的基本趋势或阶段变化
- 表示单一维度随时间或分类的变化
- 构建清晰、简洁的折线可视化图表



---
url: /zh/guide/Views/Charts/LineChart/index_example.md
---

# 示例

```tsx
import { Chart, LineChart, List, Navigation, NavigationStack, Script, Section, Toggle, useState, } from "scripting"

type ToyShape = {
  type: string
  count: number
}

const toysData: ToyShape[] = [
  {
    type: "Cube",
    count: 5,
  },
  {
    type: "Sphere",
    count: 4,
  },
  {
    type: "Pyramid",
    count: 4
  }
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"LineChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart>
        <LineChart
          labelOnYAxis={labelOnYAxis}
          marks={toysData.map(toy => ({
            label: toy.type,
            value: toy.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/Multiple Charts Example/index.md
---

# 多个图表示例

本示例展示了如何在同一个图表中结合多种图表类型（折线图、面积图、参考线图），并根据用户交互动态展示注解内容，打造具有交互性的可视化图表。

## 示例代码

```tsx
const data = [
  { sales: 1200, year: '2020', growth: 0.14, },
  { sales: 1400, year: '2021', growth: 0.16, },
  { sales: 2000, year: '2022', growth: 0.42, },
  { sales: 2500, year: '2023', growth: 0.25, },
  { sales: 3600, year: '2024', growth: 0.44, },
]

function Example() {
  const [chartSelection, setChartSelection] = useState<string | null>()
  const selectedItem = useMemo(() => {
    if (chartSelection == null) {
      return null
    }
    return data.find(item => item.year === chartSelection)
  }, [chartSelection])

  return <NavigationStack>
    <VStack
      navigationTitle={"Multiple Charts"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Text>
        Press and move on the chart to view the details.
      </Text>
      <Chart
        frame={{
          height: 300,
        }}
        chartXSelection={{
          value: chartSelection,
          onChanged: setChartSelection,
          valueType: "string"
        }}
      >
        <LineChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            symbol: "circle",
          }))}
        />
        <AreaChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            foregroundStyle: ["rgba(255,100,0,1)", "rgba(255,100,0,0.2)"]
          }))}
        />
        {selectedItem != null
          ? <RuleLineForLabelChart
            marks={[{
              label: selectedItem.year,
              foregroundStyle: { color: "gray", opacity: 0.5 },
              annotation: {
                position: "top",
                overflowResolution: {
                  x: "fit",
                  y: "disabled"
                },
                content: <ZStack
                  padding
                  background={
                    <RoundedRectangle
                      cornerRadius={4}
                      fill={"regularMaterial"}
                    />
                  }
                >
                  <Text
                    foregroundStyle={"white"}
                  >Sales: {selectedItem.sales}</Text>
                </ZStack>
              }
            }]}
          />
          : null}
      </Chart>
    </VStack>
  </NavigationStack>
}
```

## 总览

本示例中使用了以下组件：

- [`LineChart`](#折线图)：绘制离散点并以平滑曲线连接。
- [`AreaChart`](#面积图)：在曲线下方填充区域，增强视觉效果。
- [`RuleLineForLabelChart`](#标签参考线图)：在选中的标签位置绘制参考线并添加注解。
- `chartXSelection`：启用用户在图表上的交互选择。

***

## 数据格式

本示例使用的数据结构如下：

```ts
const data = [
  { sales: 1200, year: '2020', growth: 0.14 },
  { sales: 1400, year: '2021', growth: 0.16 },
  { sales: 2000, year: '2022', growth: 0.42 },
  { sales: 2500, year: '2023', growth: 0.25 },
  { sales: 3600, year: '2024', growth: 0.44 },
]
```

每条数据包含：

- `sales`：销售额，作为主要数值
- `year`：年份，用作 X 轴标签
- `growth`：增长率（本例未用于图表展示）

***

## 主要功能

### 图表选择功能

```tsx
chartXSelection={{
  value: chartSelection,
  onChanged: setChartSelection,
  valueType: "string"
}}
```

- 允许用户在图表上点击或拖动，选中某个横轴标签（`year`）。
- 使用 `setChartSelection` 设置当前选择项。

### 折线图（LineChart）

```tsx
<LineChart
  marks={data.map(item => ({
    label: item.year,
    value: item.sales,
    interpolationMethod: "catmullRom",
    symbol: "circle",
  }))}
/>
```

- 以圆形符号表示每个数据点，并用平滑曲线连接。
- 使用 `"catmullRom"` 插值方法使曲线更自然平滑。

### 面积图（AreaChart）

```tsx
<AreaChart
  marks={data.map(item => ({
    label: item.year,
    value: item.sales,
    interpolationMethod: "catmullRom",
    foregroundStyle: ["rgba(255,100,0,1)", "rgba(255,100,0,0.2)"]
  }))}
/>
```

- 覆盖在折线图之下的区域，增强趋势的视觉表达。
- 应用了从橙色不透明到透明的渐变填充。

### 标签参考线图（RuleLineForLabelChart）

```tsx
<RuleLineForLabelChart
  marks={[{
    label: selectedItem.year,
    foregroundStyle: { color: "gray", opacity: 0.5 },
    annotation: {
      position: "top",
      overflowResolution: { x: "fit", y: "disabled" },
      content: <ZStack
        padding
        background={<RoundedRectangle cornerRadius={4} fill={"regularMaterial"} />}
      >
        <Text foregroundStyle={"white"}>Sales: {selectedItem.sales}</Text>
      </ZStack>
    }
  }]}
/>
```

- 在用户选中的年份上绘制一条灰色参考线。
- 上方浮动注解展示销售额数据。
- 使用 `ZStack` 和 `RoundedRectangle` 构建注解背景样式。

***

## 交互流程

1. 用户触摸图表。
2. 系统根据触摸位置更新 `chartSelection`。
3. 使用 `useMemo` 查找对应的数据项。
4. 在相应位置绘制参考线。
5. 展示注解气泡显示详细数据（如 `Sales: 2500`）。

***

## 总结

通过本示例你可以学习如何：

- 在同一图表中组合多个图表（如折线图、面积图、参考线图）。
- 通过 `chartXSelection` 响应用户交互。
- 使用 `annotation` 显示动态注解内容。
- 利用渐变、透明度、圆角背景等样式增强展示效果。

该模式非常适合用于数据仪表盘、年度报告等需要交互性和可视化解释的数据展示场景。



---
url: /zh/guide/Views/Charts/Multiple Charts Example/index_example.md
---

# 示例

```tsx
import { AreaChart, Chart, LineChart, Navigation, NavigationStack, RoundedRectangle, RuleLineForLabelChart, Script, Text, useMemo, useState, VStack, ZStack } from "scripting"

const data = [
  { sales: 1200, year: '2020', growth: 0.14, },
  { sales: 1400, year: '2021', growth: 0.16, },
  { sales: 2000, year: '2022', growth: 0.42, },
  { sales: 2500, year: '2023', growth: 0.25, },
  { sales: 3600, year: '2024', growth: 0.44, },
]

function Example() {
  const [chartSelection, setChartSelection] = useState<string | null>()
  const selectedItem = useMemo(() => {
    if (chartSelection == null) {
      return null
    }
    return data.find(item => item.year === chartSelection)
  }, [chartSelection])

  return <NavigationStack>
    <VStack
      navigationTitle={"Multiple Charts"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Text>
        Press and move on the chart to view the details.
      </Text>
      <Chart
        frame={{
          height: 300,
        }}
        chartXSelection={{
          value: chartSelection,
          onChanged: setChartSelection,
          valueType: "string"
        }}
      >
        <LineChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            symbol: "circle",
          }))}
        />
        <AreaChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            foregroundStyle: ["rgba(255,100,0,1)", "rgba(255,100,0,0.2)"]
          }))}
        />
        {selectedItem != null
          ? <RuleLineForLabelChart
            marks={[{
              label: selectedItem.year,
              foregroundStyle: { color: "gray", opacity: 0.5 },
              annotation: {
                position: "top",
                overflowResolution: {
                  x: "fit",
                  y: "disabled"
                },
                content: <ZStack
                  padding
                  background={
                    <RoundedRectangle
                      cornerRadius={4}
                      fill={"regularMaterial"}
                    />
                  }
                >
                  <Text
                    foregroundStyle={"white"}
                  >Sales: {selectedItem.sales}</Text>
                </ZStack>
              }
            }]}
          />
          : null}
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/PieChart/index.md
---

# 饼图（PieChart）

`PieChart`（饼图）组件用于以圆形扇区的方式展示各分类在整体中的占比。每一个扇区代表一个分类，其角度根据该分类对应数值在总值中的占比自动计算，适合用于展示比例、分布或市场份额等数据。

***

## 使用示例

```tsx
<PieChart
  marks={[
    { category: "Cachapa", value: 9631 },
    { category: "Crêpe", value: 6959 },
    { category: "Injera", value: 4891 },
    ...
  ]}
/>
```

***

## 属性说明

### `marks: Array<object>` **（必填）**

定义图表中每一个扇区的数据项。

每个数据项需包含以下字段：

- `category: string`
  分类标签，用于标识该扇区所代表的内容（例如产品名称、国家、类型等）。

- `value: number`
  数值，用于计算该分类所占的角度比例。所有值会被加总，并按比例生成各扇区。

- 支持继承 `ChartMarkProps` 中的可选样式属性，包括：

  - `foregroundStyle`（前景颜色样式）
  - `annotation`（注释或标签）
  - `opacity`（透明度）
  - `cornerRadius`（圆角）
  - `zIndex`（绘制层级）等

***

## 完整示例

```tsx
const data = [
  { name: "Cachapa", sales: 9631 },
  { name: "Crêpe", sales: 6959 },
  { name: "Injera", sales: 4891 },
  { name: "Jian Bing", sales: 2506 },
  { name: "American", sales: 1777 },
  { name: "Dosa", sales: 625 },
]

<PieChart
  marks={data.map(item => ({
    category: item.name,
    value: item.sales
  }))}
/>
```

***

## 适用场景

`PieChart` 适合用于：

- 展示固定分类的占比关系
- 表达销售构成、投票分布、市场份额等
- 可视化整体数据在不同部分间的拆分情况



---
url: /zh/guide/Views/Charts/PieChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, PieChart, Script, VStack } from "scripting"

let data = [
  { name: "Cachapa", sales: 9631 },
  { name: "Crêpe", sales: 6959 },
  { name: "Injera", sales: 4891 },
  { name: "Jian Bing", sales: 2506 },
  { name: "American", sales: 1777 },
  { name: "Dosa", sales: 625 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"PieChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <PieChart
          marks={
            data.map(item => ({
              category: item.name,
              value: item.sales,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}


async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/PointCategoryChart/index.md
---

# 分类点状图（PointCategoryChart）

`PointCategoryChart`（分类点图）组件用于在二维平面上绘制带有分类信息的数据点，并支持通过颜色、图形符号或符号大小来区分不同分类。适用于展示分组散点图、调查数据、或多分类指标对比等可视化场景。

***

## 使用示例

```tsx
<PointCategoryChart
  representsDataUsing="foregroundStyle"
  marks={[
    { category: "Apple", x: 10, y: 42 },
    { category: "Apple", x: 20, y: 37 },
    { category: "Orange", x: 30, y: 62 },
    ...
  ]}
/>
```

***

## 属性说明

### `marks: Array<object>` **（必填）**

每个标记表示图表上的一个数据点，需包含以下字段：

- `x: number`
  横轴数值（例如年龄、时间、评分等）。

- `y: number`
  纵轴数值（例如数量、比例、次数等）。

- `category: string`
  分类标识。不同分类的数据点会通过图形、颜色或大小加以区分。

- 支持继承 `ChartMarkProps` 的其他样式属性，包括：

  - `foregroundStyle`（颜色）
  - `symbol`（点形状）
  - `symbolSize`（点大小）
  - `annotation`（注释）
  - `opacity`、`offset`、`zIndex` 等

***

### `representsDataUsing?: "foregroundStyle" | "symbol" | "symbolSize"`

用于控制图表如何视觉区分不同分类的数据点：

- `"foregroundStyle"`：通过颜色区分分类
- `"symbol"`：通过不同形状的符号（如圆形、方形）区分分类
- `"symbolSize"`：通过符号大小表现分类或数值差异

> 该属性是 `foregroundStyleBy`、`symbolBy` 或 `symbolSizeBy` 的简化替代方案。

***

## 完整示例

```tsx
const favoriteFruitsData = [
  { fruit: "Apple", age: 10, count: 42 },
  { fruit: "Apple", age: 20, count: 37 },
  ...
]

<PointCategoryChart
  representsDataUsing="symbol"
  marks={favoriteFruitsData.map(item => ({
    category: item.fruit,
    x: item.age,
    y: item.count,
  }))}
/>
```

你可以通过 `<Picker>` 控件动态选择 `representsDataUsing` 的显示方式，以改变分类的可视化方式。

***

## 适用场景

`PointCategoryChart` 适合用于以下场景：

- 多分类数据在二维坐标中的对比展示
- 可视化多维调查数据或打分结果
- 通过符号特征突出分类差异性
- 构建具有视觉分组效果的散点图



---
url: /zh/guide/Views/Charts/PointCategoryChart/index_example.md
---

# 示例

```tsx
import { Chart, List, Navigation, NavigationStack, Picker, PointCategoryChart, Script, Text, useState, VStack } from "scripting"

const favoriteFruitsData = [
  { fruit: 'Apple', age: 10, count: 42 },
  { fruit: 'Apple', age: 20, count: 37 },
  { fruit: 'Apple', age: 30, count: 11 },

  { fruit: 'Bananer', age: 10, count: 23 },
  { fruit: 'Bananer', age: 20, count: 58 },
  { fruit: 'Bananer', age: 30, count: 79 },

  { fruit: 'Orange', age: 10, count: 36 },
  { fruit: 'Orange', age: 20, count: 24 },
  { fruit: 'Orange', age: 30, count: 62 },
]

function Example() {
  const [representsDataUsing, setRepresentsDataUsing] = useState<string>('foregroundStyle')
  const options: string[] = [
    'foregroundStyle',
    'symbol',
    'symbolSize'
  ]

  return <NavigationStack>
    <List
      navigationTitle={"PointCategoryChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Picker
        title={"representsDataUsing"}
        value={representsDataUsing}
        onChanged={setRepresentsDataUsing}
        pickerStyle={"menu"}
      >
        {options.map(option =>
          <Text tag={option}>{option}</Text>
        )}
      </Picker>
      <Chart
        frame={{
          height: 300
        }}
      >
        <PointCategoryChart
          representsDataUsing={representsDataUsing as any}
          marks={favoriteFruitsData.map(item => ({
            category: item.fruit,
            x: item.age,
            y: item.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/PointChart/index.md
---

# 点状图（PointChart）

`PointChart`（点图）组件用于在二维坐标系中绘制一组独立的数值点，即经典的散点图。每个点由一个 `(x, y)` 数值对表示，可通过样式属性进一步自定义其外观。

该组件适用于可视化两个连续变量之间的关系、分布或数值测量结果。

***

## 使用示例

```tsx
<PointChart
  marks={[
    { x: 0, y: 2 },
    { x: 1, y: 3 },
    { x: 2, y: 4 },
    { x: 3, y: 3 },
    { x: 4, y: 6 },
  ]}
/>
```

***

## 属性说明

### `marks: Array<object>` **（必填）**

定义要绘制的所有点。每个点包含以下字段：

- `x: number`
  点在 X 轴上的位置。

- `y: number`
  点在 Y 轴上的位置。

可选地，您还可以通过 `ChartMarkProps` 提供更多自定义属性：

- `symbol`：点的形状（如圆形、方形等）
- `foregroundStyle`：点的颜色
- `symbolSize`：点的大小
- 其他属性如 `opacity`（透明度）、`annotation`（注释）、`offset`（偏移）、`zIndex` 等

***

## 完整示例

```tsx
const data = [
  { x: 0, y: 2 },
  { x: 1, y: 3 },
  { x: 2, y: 4 },
  { x: 3, y: 3 },
  { x: 4, y: 6 },
]

<PointChart marks={data} />
```

上述示例将在坐标系中绘制 5 个点，构成一个基础的散点图。

***

## 适用场景

`PointChart` 适合以下场景：

- 显示两个连续变量之间的关系（如相关性）
- 表示实验数据、坐标点或数值测量结果
- 创建简洁的散点图，可叠加注释或符号样式



---
url: /zh/guide/Views/Charts/PointChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, PointChart, Script, VStack } from "scripting"

const data = [
  { x: 0, y: 2 },
  { x: 1, y: 3 },
  { x: 2, y: 4 },
  { x: 3, y: 3 },
  { x: 4, y: 6 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"PointChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}>
        <PointChart
          marks={data}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/RangeAreaChart/index.md
---

# 范围面积图（RangeAreaChart）

`RangeAreaChart` 是一种范围区域图表组件，用于展示每个数据点的值区间，通常包括 `start` 和 `end` 值。它适合用来可视化温度范围、置信区间、最大值与最小值等。

***

## 使用示例

```tsx
<RangeAreaChart
  marks={[
    { label: "Jan", start: 0, end: 4 },
    { label: "Feb", start: 2, end: 6 },
    ...
  ]}
/>
```

***

## 属性（Props）

### `marks: Array<object>` **(必填)**

每个 `mark` 定义一个范围区间。

- `label: string | Date`
  对应 X 轴的标签，例如月份、类别名称或时间点。

- `start: number`
  范围的起始值（下界）。

- `end: number`
  范围的结束值（上界）。

- _(可选)_ 支持 `ChartMarkProps` 中的通用属性：

  - `foregroundStyle` – 区域的填充颜色
  - `opacity`、`interpolationMethod`、`annotation` 等

***

### `interpolationMethod?: string`

指定图表区域在点之间的插值方式。
例如，`'catmullRom'` 会生成光滑的曲线。

***

## 完整示例

```tsx
const weatherData = [
  { month: "Jan", min: 0, max: 4 },
  { month: "Feb", min: 2, max: 6 },
  ...
]

<RangeAreaChart
  marks={weatherData.map(item => ({
    label: item.month,
    start: item.min,
    end: item.max,
    interpolationMethod: "catmullRom"
  }))}
/>
```

这个示例以平滑曲线的形式绘制了每个月的温度范围。

***

## 适用场景

`RangeAreaChart` 特别适用于以下场景：

- 显示温度等物理量的时间范围变化
- 可视化统计中的置信区间
- 展示股票价格的最小/最大波动区间
- 表达预测结果的不确定性范围等



---
url: /zh/guide/Views/Charts/RangeAreaChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, RangeAreaChart, Script, VStack } from "scripting"

const weatherData = [
  { month: 'Jan', min: 0, max: 4 },
  { month: 'Feb', min: 2, max: 6 },
  { month: 'Mar', min: 3, max: 8 },
  { month: 'Apr', min: 5, max: 10 },
  { month: 'May', min: 7, max: 14 },
  { month: 'Jun', min: 10, max: 25 },
  { month: 'Jul', min: 15, max: 30 },
  { month: 'Aug', min: 20, max: 33 },
  { month: 'Sep', min: 24, max: 35 },
  { month: 'Oct', min: 18, max: 30 },
  { month: 'Nov', min: 10, max: 23 },
  { month: 'Dec', min: 5, max: 10 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"RangeAreaChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <RangeAreaChart
          marks={weatherData.map(item => ({
            label: item.month,
            start: item.min,
            end: item.max,
            interpolationMethod: 'catmullRom'
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/RectAreaChart/index.md
---

# 矩形面积图（RectAreaChart）

`RectAreaChart` 组件用于在二维图表中绘制矩形区域，适合用来突出显示特定区域、数据分布、容差区间或标注感兴趣的范围。可与其他图表（如 `PointChart`）叠加使用以增强可视化效果。

***

## 使用示例

```tsx
<RectAreaChart
  marks={[
    { xStart: 2.5, xEnd: 3.5, yStart: 4.5, yEnd: 5.5 },
    { xStart: 1.0, xEnd: 2.0, yStart: 1.0, yEnd: 2.0 },
  ]}
/>
```

***

## 属性（Props）

### `marks: Array<object>` **(必填)**

每个 `mark` 定义一个矩形区域，包含以下字段：

- `xStart: number`
  矩形在 X 轴上的起始值。

- `xEnd: number`
  矩形在 X 轴上的结束值。

- `yStart: number`
  矩形在 Y 轴上的起始值。

- `yEnd: number`
  矩形在 Y 轴上的结束值。

#### 可选通用属性（继承自 `ChartMarkProps`）：

- `opacity` – 设置矩形的透明度。
- `foregroundStyle` – 设置矩形的填充颜色或样式。
- `annotation` – 为该区域添加注释或标签。

***

## 完整示例

```tsx
const data = [
  { x: 5, y: 5 },
  { x: 2.5, y: 2.5 },
  { x: 3, y: 3 },
]

<RectAreaChart
  marks={data.map(item => ({
    xStart: item.x - 0.25,
    xEnd: item.x + 0.25,
    yStart: item.y - 0.25,
    yEnd: item.y + 0.25,
    opacity: 0.2,
  }))}
//>

<PointChart marks={data} />
```

此示例在每个点的周围绘制了一个半透明的矩形区域，表示误差范围或聚集区。

***

## 应用场景

- 在散点图上突出显示数据密集区域。
- 可视化特定值域范围或容差带。
- 表示测量误差或预测区间。
- 叠加图层展示用户关注区域。



---
url: /zh/guide/Views/Charts/RectAreaChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, PointChart, RectAreaChart, Script, VStack } from "scripting"

const data = [
  { x: 5, y: 5 },
  { x: 2.5, y: 2.5 },
  { x: 3, y: 3 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"RectAreaChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <RectAreaChart
          marks={
            data.map(item => ({
              xStart: item.x - 0.25,
              xEnd: item.x + 0.25,
              yStart: item.y - 0.25,
              yEnd: item.y + 0.25,
              opacity: 0.2,
            }))
          }
        />

        <PointChart
          marks={data}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/RectChart/index.md
---

# 矩形图（RectChart）

`RectChart` 是一个矩形条形图组件，用于可视化基于标签的数值数据。其用法与 `BarChart` 类似，使用相同的 `BarChartProps` 接口。

***

## 示例

```tsx
<RectChart
  labelOnYAxis={false}
  marks={[
    { label: "Cube", value: 5 },
    { label: "Sphere", value: 4 },
    { label: "Pyramid", value: 4 },
  ]}
/>
```

***

## 属性说明

### `labelOnYAxis`（可选）

- **类型：** `boolean`
- **默认值：** `false`
- **说明：**
  若设置为 `true`，标签将显示在 Y 轴上，图表将以横向条形展示；若为 `false`，标签位于 X 轴，显示为纵向条形。

***

### `marks`（必填）

- **类型：**
  `Array<{ label: string | Date; value: number; unit?: CalendarComponent } & ChartMarkProps>`
- **说明：**
  指定每个矩形条的标签和值。

#### 每个 mark 对象包含：

- `label`: 类别标签（如 "Cube"），用于坐标轴显示。
- `value`: 数值，决定矩形条的高度或宽度。
- `unit`: _(可选)_ 时间单位（如为时间序列数据时使用）。

此外，还可以使用继承自 `ChartMarkProps` 的可视属性，如：

- `foregroundStyle`: 设置颜色样式
- `cornerRadius`: 设置圆角
- `annotation`: 添加标注
- `opacity`: 设置透明度

***

## 完整示例

```tsx
const toysData = [
  { type: "Cube", count: 5 },
  { type: "Sphere", count: 4 },
  { type: "Pyramid", count: 4 },
]

<RectChart
  labelOnYAxis={true}
  marks={toysData.map(toy => ({
    label: toy.type,
    value: toy.count,
  }))}
/>
```

***

## 适用场景

- 分类数据的可视化对比
- 报表或仪表盘中的数量展示
- 替代传统柱状图的简洁矩形展示风格



---
url: /zh/guide/Views/Charts/RectChart/index_example.md
---

# 示例

```tsx
import { Chart, List, Navigation, NavigationStack, RectChart, Script, Section, Toggle, useState } from "scripting"

type ToyShape = {
  type: string
  count: number
}

const toysData: ToyShape[] = [
  {
    type: "Cube",
    count: 5,
  },
  {
    type: "Sphere",
    count: 4,
  },
  {
    type: "Pyramid",
    count: 4
  }
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"RectChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart>
        <RectChart
          labelOnYAxis={labelOnYAxis}
          marks={toysData.map(toy => ({
            label: toy.type,
            value: toy.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/RuleChart/index.md
---

# 标尺图（RuleChart）

`RuleChart` 用于展示每个分类项的数值范围或持续时间。每条规则表示一个起始值和结束值的跨度，适用于展示周期、持续时间或数值范围的可视化数据。

***

## 示例

```tsx
<RuleChart
  labelOnYAxis
  marks={[
    { label: "Trees", start: 1, end: 10 },
    { label: "Grass", start: 3, end: 11 },
    { label: "Weeds", start: 4, end: 12 },
  ]}
/>
```

***

## 属性（Props）

### `labelOnYAxis`（可选）

- **类型：** `boolean`
- **默认值：** `false`
- **说明：**
  若设置为 `true`，图表会将分类标签放置在 Y 轴，并以横向方式展示每条规则（水平规则）。若为 `false`，则标签在 X 轴，规则为垂直方向。

***

### `marks`（必填）

- **类型：**

  ```ts
  Array<{
    label: string | Date;
    start: number;
    end: number;
    unit?: CalendarComponent;
  } & ChartMarkProps>
  ```
- **说明：**
  用于定义每条规则的起止范围。

#### 每项 mark 包含以下字段：

- `label`：分类标签或时间单位（如 `"Trees"` 或一个 `Date`）。
- `start`：规则的起始数值。
- `end`：规则的结束数值。
- `unit`：（可选）时间单位，如 `.month`、`.day`，用于表示基于时间的规则范围。

也可结合 `ChartMarkProps` 使用，支持以下自定义样式：

- `foregroundStyle` — 设置颜色或样式
- `annotation` — 添加标注标签
- `opacity` — 控制透明度

***

## 完整示例

```tsx
const data = [
  { startMonth: 1, numMonths: 9, source: "Trees" },
  { startMonth: 12, numMonths: 1, source: "Trees" },
  { startMonth: 3, numMonths: 8, source: "Grass" },
  { startMonth: 4, numMonths: 8, source: "Weeds" },
]

<RuleChart
  labelOnYAxis
  marks={data.map(item => ({
    start: item.startMonth,
    end: item.startMonth + item.numMonths,
    label: item.source,
  }))}
/>
```

***

## 适用场景

- 展示活动周期或生长季节（如花粉季）
- 显示任务或项目的起止时间
- 比较不同类别的数据范围



---
url: /zh/guide/Views/Charts/RuleChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, RuleChart, Script, VStack } from "scripting"

const data = [
  { startMonth: 1, numMonths: 9, source: "Trees" },
  { startMonth: 12, numMonths: 1, source: "Trees" },
  { startMonth: 3, numMonths: 8, source: "Grass" },
  { startMonth: 4, numMonths: 8, source: "Weeds" },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"RuleChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <RuleChart
          labelOnYAxis
          marks={
            data.map(item => ({
              start: item.startMonth,
              end: item.startMonth + item.numMonths,
              label: item.source,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Charts/RuleLineForLabelChart.md
---

# 标签线图（RuleLineForLabelChart）

`RuleLineForLabelChart` 用于在图表中根据标签（或日期）位置绘制垂直或水平的参考线。通常与其他图表类型（如 `BarChart` 或 `LineChart`）配合使用，用于高亮特定的分类或时间点。

***

## 类型定义

```ts
declare const RuleLineForLabelChart: FunctionComponent<{
  /**
   * 是否在 Y 轴显示标签。如果为 true，则参考线将水平绘制。默认为 false（垂直绘制）。
   */
  labelOnYAxis?: boolean;

  /**
   * 参考线标记数组，每个标记表示在哪个标签或日期处绘制参考线。
   */
  marks: Array<{
    /**
     * 要绘制参考线的位置，可以是字符串标签或 Date 类型。
     */
    label: string | Date;

    /**
     * 可选，仅在 label 为 Date 类型时有效，指定日期单位（如 'month', 'day'）。
     */
    unit?: CalendarComponent;
  } & ChartMarkProps>;
}>;
```

***

## 属性说明

| 属性名            | 类型        | 说明                                         |
| -------------- | --------- | ------------------------------------------ |
| `labelOnYAxis` | `boolean` | 是否在 Y 轴绘制标签。为 `true` 时参考线为 **水平线**，默认为垂直线。 |
| `marks`        | `Array`   | 包含多个参考线定义的数组，每个参考线可以包含样式配置，如颜色、不透明度等。      |

每个 `marks` 项支持以下属性：

- `label`：要绘制参考线的位置（字符串或日期）。
- `unit`：可选，仅用于日期类型。
- `foregroundStyle`：可选，线条颜色。
- `opacity`：可选，线条透明度。
- `lineStyle`：可选，自定义虚线样式（如 `[3, 2]` 表示3个点的实线和2个点的空格交替）。

***

## 示例：在柱状图中标记关键分类

```tsx
import {
  Chart,
  RuleLineForLabelChart,
  BarChart,
  Navigation,
  NavigationStack,
  Script,
  VStack
} from "scripting"

const data = [
  { label: "Q1", value: 1500 },
  { label: "Q2", value: 2300 },
  { label: "Q3", value: 1800 },
  { label: "Q4", value: 2700 },
]

const referenceLines = [
  { label: "Q2", foregroundStyle: "blue", lineStyle: { dash: [3, 2] } },
  { label: "Q4", foregroundStyle: "red", opacity: 0.5 },
]

function Example() {
  return (
    <NavigationStack>
      <VStack
        navigationTitle="带参考线的柱状图"
        navigationBarTitleDisplayMode="inline"
      >
        <Chart frame={{ height: 300 }}>
          <BarChart marks={data} />
          <RuleLineForLabelChart marks={referenceLines} />
        </Chart>
      </VStack>
    </NavigationStack>
  )
}

async function run() {
  await Navigation.present({ element: <Example /> })
  Script.exit()
}

run()
```

***

## 典型用途

- 在时间轴中高亮关键事件或时间点。
- 在分类图中划分视觉区域。
- 表示特殊标签、阈值或比较基准。



---
url: /zh/guide/Views/Charts/RuleLineForValueChart.md
---

# 值线图（RuleLineForValueChart）

`RuleLineForValueChart` 组件用于在图表上绘制一条或多条参考线（水平或垂直），基于指定的数值位置。常用于标示阈值、目标线或参考线，增强图表的可读性与数据对比。

***

## 使用示例

```tsx
<Chart>
  <RuleLineForValueChart
    marks={[
      { value: 50 },
      { value: 75, lineStyle: { dash: [2, 4] } },
    ]}
  />
</Chart>
```

上面的示例会绘制两条规则线：

- 在值为 `50` 的位置绘制一条实线
- 在值为 `75` 的位置绘制一条虚线，样式为 2 点实线 + 4 点间隔

***

## 参数说明

### `labelOnYAxis`（可选）

- **类型：** `boolean`
- **默认值：** `false`
- **说明：**
  是否在 Y 轴显示标签：

  - 若设为 `true`，线条将 **垂直显示**，标签显示在 Y 轴。
  - 若设为 `false`，线条将 **水平显示**，标签显示在 X 轴。

***

### `marks`（必填）

- **类型：**

  ```ts
  Array<{
    value: number;
  } & ChartMarkProps>
  ```
- **说明：**
  用于定义所有参考线的位置和样式。

#### `value`

- 要绘制规则线的数值位置。

#### 附加属性（继承 `ChartMarkProps`）：

你可以通过这些属性进一步自定义每条线的外观：

- `foregroundStyle`：设置颜色或渐变
- `opacity`：设置线条透明度
- `lineStyle`：设置线条样式（如虚线）

***

## 使用场景

- 标注统计阈值（如平均值、中位数）
- 标示上下限、控制范围
- 显示目标线、指标值

***

## 总结

`RuleLineForValueChart` 是一个简洁的叠加图组件，能够帮助你在任意图表中标注关键数值，使图表更加直观易读。它可以与其他图表类型（如 `BarChart`、`LineChart`、`PointChart` 等）搭配使用，提升数据展示的专业度与清晰度。



---
url: /zh/guide/Views/ConcentricRectangle.md
---

# 同心圆矩形（ConcentricRectangle）

`ConcentricRectangle` 是 iOS 26+ 引入的一种**同心矩形（Concentric Rectangle）形状视图**，用于创建具有“向内递进圆角”特性的矩形结构。
该形状特别适合用于：

- 现代玻璃风格按钮
- 卡片容器背景
- 交互裁剪区域（命中测试形状）
- 玻璃过渡动画遮罩
- 动态层级 UI 结构

在 Scripting 中，`ConcentricRectangle` 既可以作为一个**独立 Shape 视图渲染**，也可以作为：

- `clipShape`
- `background`
- `contentShape`

中的**专用形状类型使用**。

***

## 一、ConcentricRectangle 基本定义

```ts
type ConcentricRectangleProps = ShapeProps & ConcentricRectangleShape

/**
 * A concentric rectangle aligned inside the frame of the view containing it.
 * @available iOS 26+.
 */
declare const ConcentricRectangle: FunctionComponent<ConcentricRectangleProps>
```

### 说明

- `ConcentricRectangle` 是一个标准 `Shape` 组件
- 同时支持：

  - 填充（fill）
  - 描边（stroke）
  - 路径裁剪（trim）
  - 复杂角样式控制（ConcentricRectangleShape）
- 该视图始终在其父视图的 `frame` 内部进行布局与渲染
- 仅支持 iOS 26 及以上系统

***

## 二、角样式系统：EdgeCornerStyle

`ConcentricRectangle` 的核心能力来自其角样式系统 `EdgeCornerStyle`，用于描述单个角的行为方式。

```ts
type EdgeCornerStyle =
  | {
      style: "fixed"
      radius: number
    }
  | {
      style: "concentric"
      minimum: number
    }
  | "concentric"
```

***

### 1. 固定圆角模式（fixed）

```ts
{
  style: "fixed"
  radius: number
}
```

用于创建传统固定半径圆角矩形。

参数说明：

| 参数       | 说明            |
| -------- | ------------- |
| `radius` | 固定圆角半径，单位为 pt |

该模式适合传统静态卡片、按钮等场景。

***

### 2. 同心递进圆角模式（concentric）

```ts
{
  style: "concentric"
  minimum: number
}
```

用于创建随尺寸递进变化的“同心圆角效果”。

参数说明：

| 参数        | 说明                       |
| --------- | ------------------------ |
| `minimum` | 最小内层圆角半径，系统会根据实际尺寸自动向外递进 |

该模式适用于：

- 玻璃按钮
- 动态尺寸卡片
- 层级叠加组件
- 动态动画遮罩

***

### 3. 简写模式

```ts
"concentric"
```

等价于：

```ts
{
  style: "concentric"
  minimum: 系统默认最小值
}
```

适用于无需手动控制最小值的快速使用场景。

***

## 三、ConcentricRectangleShape（角分布规则）

`ConcentricRectangleShape` 用于描述 **每个角是否统一控制，或分别控制**。
该类型支持 7 种结构组合模式。

***

### 1. 全角统一模式（最常用）

```ts
{
  corners: EdgeCornerStyle
  isUniform?: boolean
}
```

参数说明：

| 参数          | 说明                |
| ----------- | ----------------- |
| `corners`   | 应用于全部角的样式         |
| `isUniform` | 是否强制完全一致，默认 false |

示例：

```tsx
<ConcentricRectangle
  corners={{
    style: "concentric",
    minimum: 8
  }}
  fill="red"
/>
```

***

### 2. 四个角完全独立定义

```ts
{
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 不规则异形卡片
- 特殊边角 UI
- 半圆角容器

***

### 3. 底部统一角

```ts
{
  uniformBottomCorners?: EdgeCornerStyle
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 上直角，下圆角卡片
- 底部弹出面板背景

***

### 4. 顶部统一角

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 顶部弹窗
- 顶部玻璃标题栏

***

### 5. 顶部与底部统一组合

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  uniformBottomCorners?: EdgeCornerStyle
}
```

***

### 6. 左侧统一角

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

***

### 7. 左右统一组合

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  uniformTrailingCorners?: EdgeCornerStyle
}
```

***

## 四、通用 Shape 属性（ShapeProps）

```ts
type ShapeProps = {
  trim?: {
    from: number
    to: number
  }

  fill?: ShapeStyle | DynamicShapeStyle

  stroke?: ShapeStyle | DynamicShapeStyle | {
    shapeStyle: ShapeStyle | DynamicShapeStyle
    strokeStyle: StrokeStyle
  }
}
```

***

### 1. trim（路径裁剪）

```ts
trim={{
  from: 0.0,
  to: 0.5
}}
```

用于路径绘制动画、环形裁剪、渐进描边等效果。

***

### 2. fill（填充）

```ts
fill="red"
fill="ultraThinMaterial"
```

支持：

- 纯色
- 动态材质
- 渐变样式

***

### 3. stroke（描边）

```ts
stroke="blue"

stroke={{
  shapeStyle: "blue",
  strokeStyle: {
    lineWidth: 2
  }
}}
```

***

## 五、ConcentricRectangle 在 View Modifiers 中的使用

### 1. 作为 clipShape 使用

```ts
clipShape?: Shape | "concentricRect" | ({
  type: "concentricRect"
} & ConcentricRectangleShape)
```

示例：

```tsx
<VStack
  clipShape={{
    type: "concentricRect",
    corners: {
      style: "concentric",
      minimum: 10
    }
  }}
/>
```

用于：

- 裁剪真实内容显示区域
- 玻璃过渡遮罩
- 动态蒙版

***

### 2. 作为 background 使用

```ts
background?: ShapeStyle | DynamicShapeStyle | {
  style: ShapeStyle | DynamicShapeStyle
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
} | VirtualNode | {
  content: VirtualNode
  alignment: Alignment
}
```

示例：

```tsx
<VStack
  background={{
    style: "ultraThinMaterial",
    shape: {
      type: "concentricRect",
      corners: "concentric"
    }
  }}
/>
```

***

### 3. 作为 contentShape 使用（命中测试区域）

```ts
contentShape?: Shape | {
  kind: ContentShapeKinds
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
}
```

用于控制点击、悬停、拖拽等交互命中区域。

***

## 六、完整示例解析

示例代码：

```tsx
<ZStack
  frame={{
    width: 300,
    height: 200
  }}
  containerShape={{
    type: "rect",
    cornerRadius: 32
  }}
>
  <ConcentricRectangle
    corners={{
      style: "concentric",
      minimum: 8
    }}
    fill="red"
  />
</ZStack>
```

该示例实现了：

- 外部容器为固定圆角矩形
- 内部使用同心递进圆角矩形
- 内外形成层级差异与视觉纵深感
- 红色填充用于强调 ConcentricRectangle 的实际形态

***

## 七、设计与实现注意事项

1. `minimum` 不应超过实际高度或宽度的一半
2. 同心圆角更适合与：

   - `glass`
   - `material`
   - `blur`
   - `opacity`
     等视觉效果配合使用
3. 作为 `contentShape` 使用时，仅影响点击区域，不影响视觉裁剪
4. 作为 `clipShape` 使用时，会真实裁剪子视图渲染内容



---
url: /zh/guide/Views/Controls/ColorPicker/index.md
---

# 颜色选择器

`ColorPicker` 组件提供了一个系统颜色选择器 UI，允许用户选择颜色，并通过 `onChanged` 事件将选择的颜色传递回应用。该组件支持以下格式的颜色：

- 关键字颜色（例如：`green`, `red`, `blue` 等）
- 十六进制颜色字符串（例如：`#FF5733` 或 `#333`）
- CSS rgba 字符串（例如：`rgba(255,0,0,1)`）

***

## `ColorPickerProps`

`ColorPickerProps` 是 `ColorPicker` 组件的属性类型，它可以通过以下两种方式定义：

### 1. 使用 `title` 属性

- **`title`** (`string`): 为颜色选择器提供一个标题，描述颜色选择器的用途或提供指导信息。

### 2. 使用 `children` 属性

- **`children`** (`VirtualNode | undefined | null | (VirtualNode | undefined | null)[]` | `VirtualNode`): 提供一个自定义视图来描述所选颜色的用途。系统的颜色选择器 UI 会根据此视图的文本来设置标题。如果不使用 `children`，则可以仅使用 `title`。

### 其他属性

- **`value`** (`Color`): 当前选定的颜色值。可以是关键字颜色、十六进制颜色字符串或 RGBA 字符串。

- **`onChanged`** (`(value: Color) => void`): 颜色变化时的回调函数。当用户选择颜色时会调用此回调，并传递新的颜色值。

- **`supportsOpacity`** (`boolean`, 可选): 如果设置为 `true`，则允许调整选定颜色的透明度。默认为 `true`。

### 示例代码

```tsx
import { ColorPicker, useState } from 'scripting'

const MyComponent = () => {
  const [color, setColor] = useState<Color>('#FF5733')

  return (
    <ColorPicker
      title="Pick a Color"
      value={color}
      onChanged={setColor}
    />
  )
}
```

### 说明

在上面的示例中：

- `ColorPicker` 组件的 `title` 被设置为 `"Pick a Color"`，提示用户选择颜色。
- 初始颜色值是 `#FF5733`。
- `onChanged` 回调会在颜色更改时触发，更新 `color` 状态。

### 可选的透明度支持

如果你希望支持调整颜色的透明度，可以通过设置 `supportsOpacity` 属性来启用此功能：

```tsx
<ColorPicker
  title="Pick a Color"
  value={color}
  onChanged={setColor}
  supportsOpacity={true}
/>
```

## `Color` 类型

`Color` 类型用于定义颜色的各种格式，包括：

- **关键字颜色**: 如 `"red"`, `"green"`, `"blue"` 等。
- **十六进制字符串**: 如 `"#FF5733"`。
- **CSS rgba 字符串**: 如 `rgba(255, 0, 0, 0.5)`。

### 示例

```tsx
const color: Color = 'rgba(255, 0, 0, 0.5)'
```



---
url: /zh/guide/Views/Controls/ColorPicker/index_example.md
---

# 示例

```tsx
import { Color, ColorPicker, Navigation, NavigationStack, Script, Text, useState, VStack } from "scripting"

function Example() {
  const [value, setValue] = useState<Color>('blue')

  return <NavigationStack>
    <VStack
      navigationTitle={"Color Picker"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <ColorPicker
        value={value}
        onChanged={setValue}
      >
        <Text>Current color: {value}</Text>
      </ColorPicker>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Controls/ContentUnavailableView/index.md
---

# 内容不可用视图

`ContentUnavailableView` 是一个 UI 组件，用于在应用内容不可用时向用户展示一个视图。它通常会显示标题、可选的描述内容以及操作区，用以清晰地告知用户内容缺失或尚未准备好。此组件适用于如列表等场景，当没有数据展示时，提供明确的提示。

## 属性

### 通用属性

您可以为 `ContentUnavailableView` 组件传递两种结构的属性：

1. **基于字符串的属性：**
   - `title` (string): 显示的主标题，通常描述不可用的内容。
   - `systemImage` (string): 一个系统图标，用来直观表示内容不可用。这个图标有助于用户理解当前的状态。
   - `description` (string, 可选): 一个简短的文本描述，进一步说明不可用内容。如果不需要，可以省略。

2. **基于 `VirtualNode` 的属性：**
   - `label` (VirtualNode): 一个虚拟节点，通常是 `Text` 或其他 UI 组件，用来描述不可用内容的标签。
   - `description` (VirtualNode | null, 可选): 一个虚拟节点，通常是 `Text` 组件，用于提供更详细的不可用内容描述。如果不需要描述，可以将其设置为 `null`。
   - `actions` (虚拟节点数组 | null, 可选): 一个可选的操作按钮或链接列表。这些操作可以是按钮、链接或其他组件，也可以设置为 `null`，如果没有操作需求。

## 示例用法

### 1. 使用字符串的简单示例

```tsx
function View({documents}: {documents: {name: string}[]}) {
  return (
    <NavigationStack>
      <List
        overlay={
          documents.length > 0
            ? undefined
            : <ContentUnavailableView
                title="暂无文档"
                systemImage="tray.fill"
              />
        }
      >
        {documents.map(item => (
          <Text>{item.name}</Text>
        ))}
      </List>
    </NavigationStack>
  )
}
```

在此示例中，当文档列表为空时，`ContentUnavailableView` 会显示一个标题“暂无文档”以及一个系统图标 `"tray.fill"`。

### 2. 使用 `VirtualNode` 的高级示例

```tsx
function View({documents}: {documents: {name: string}[]}) {
  return (
    <NavigationStack>
      <List
        overlay={
          documents.length > 0
            ? undefined
            : <ContentUnavailableView
                label={<Text>暂无可用文档</Text>}
                description={<Text>请稍后检查，文档将会在更新后显示。</Text>}
                actions={[<Button onClick={handleRefresh}>刷新</Button>]}
              />
        }
      >
        {documents.map(item => (
          <Text>{item.name}</Text>
        ))}
      </List>
    </NavigationStack>
  )
}
```

在这个例子中，`ContentUnavailableView` 使用虚拟节点作为标签和描述，此外，还添加了一个刷新按钮作为操作。

## 注意事项

- 您可以根据需要选择使用基于字符串的属性或基于虚拟节点的属性，后者适用于更动态的内容展示。
- 该组件灵活，能够在列表、堆栈和其他复杂布局中使用。

## API 详情

- **`title`** 和 **`systemImage`**: 提供一种简单的方式来显示不可用内容，使用字符串标题和系统图标。
- **`label`** 和 **`description`**: 使用虚拟节点可以更灵活地定制标签和描述内容。
- **`actions`**: 可选操作，允许您添加按钮或链接，引导用户执行操作，如刷新内容或跳转到其他页面。

该组件非常适合用在内容可能暂时不可用的场景，能够清晰、一致地向用户展示提示信息。



---
url: /zh/guide/Views/Controls/ContentUnavailableView/index_example.md
---

# 示例

```tsx
import { useState, List, ContentUnavailableView, Button, Text, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [list, setList] = useState<string[]>([])

  return <NavigationStack>
    <List
      navigationTitle={"ContentUnavailableView"}
      navigationBarTitleDisplayMode={"inline"}
      overlay={
        list.length ? undefined
          : <ContentUnavailableView
            title="No data"
            systemImage="tray.fill"
          />
      }
      toolbar={{
        bottomBar: [
          <Button
            title="Add"
            action={() => {
              setList(list => {
                let newList = [
                  (Math.random() * 1000 | 0).toString(),

                  ...list
                ]
                return newList
              })
            }}
          />,
          <Button
            title="Clear"
            action={() => {
              setList([])
            }}
          />
        ]
      }}
    >
      {list.map(name => <Text>{name}</Text>)}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Controls/DatePicker/index.md
---

# 日期、时间选择器

`DatePicker` 是一个用于选择日期（以及可选的时间）的 UI 组件，支持通过多种显示方式（如日历、滚轮、文本等）进行交互。它允许用户根据自己的需求选择特定的日期，并根据组件配置决定是否包括时间选择。此组件特别适合需要日期和时间输入的场景，例如选择事件的开始日期或任务的截止日期。

## 参数

### `DatePickerProps` 类型

- **`title`** (必选)：`string`

  设置日期选择器的标题，通常用于描述选择的目的，例如“选择日期”。

- **`children`** (可选)：`(VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode`

  用于渲染自定义的子视图内容。如果没有自定义内容，则无需传递此属性。

- **`value`** (必选)：`number`

  表示当前选定日期的时间戳（毫秒数）。该值会传递给 `onChanged` 事件处理器。

- **`onChanged`** (必选)：`(value: number) => void`

  当日期值发生变化时调用的回调函数，参数是新的时间戳。

- **`startDate`** (可选)：`number`

  设置可选日期范围的起始日期时间戳。用户只能选择该日期之后的日期。

- **`endDate`** (可选)：`number`

  设置可选日期范围的结束日期时间戳。用户只能选择该日期之前的日期。

- **`displayedComponents`** (可选)：`DatePickerComponents[]`

  一个可选的数组，指定用户能够查看和编辑的日期组件。默认值是 `['hourAndMinute', 'date']`，表示同时显示日期和时间（小时和分钟）。如果需要显示秒数（仅在 watchOS 可用），可以选择 `['hourMinuteAndSecond']`。

### `DatePickerComponents` 类型

该类型定义了日期选择器中可能显示的组件：

- **`date`**：显示日、月和年，基于当前区域设置。
- **`hourAndMinute`**：显示小时和分钟，基于当前区域设置。
- **`hourMinuteAndSecond`**：仅在 watchOS 上可用，显示小时、分钟和秒数，基于当前区域设置。

### `DatePickerStyle` 类型

定义了 `DatePicker` 组件的样式类型。支持以下选项：

- **`automatic`**：默认样式，自动选择合适的显示方式。
- **`compact`**：紧凑样式，以文本格式显示各个日期组件。
- **`graphical`**：图形样式，显示一个可互动的日历或时钟。
- **`wheel`**：滚轮样式，每个日期组件显示为一个可以滚动的列。
- **`field`**：仅在 macOS 上可用，显示为可编辑的文本字段。
- **`stepperField`**：仅在 macOS 上可用，显示为可编辑的文本字段，旁边带有步进器，可增加或减少选中的日期组件。

## 示例代码

以下是 `DatePicker` 组件的示例使用代码：

```tsx
<DatePicker
  title="选择日期和时间"
  value={new Date().getTime()}
  onChanged={(newDate) => console.log('新日期:', newDate)}
  startDate={new Date('2024-01-01').getTime()}
  endDate={new Date('2024-12-31').getTime()}
  displayedComponents={['date', 'hourAndMinute']}
  datePickerStyle="wheel"
/>
```

## 用法说明

`DatePicker` 组件可以通过 `displayedComponents` 属性控制显示的内容。默认情况下，它会显示日期和时间（小时和分钟），但您可以根据需求定制其显示组件。例如，在 `watchOS` 设备上，您可以选择显示小时、分钟和秒数。

选择器的外观和交互方式可以通过 `datePickerStyle` 属性进一步定制。不同的样式提供不同的用户体验，您可以根据平台和用户需求选择最合适的样式。

## 注意事项

- `startDate` 和 `endDate` 用于限定用户可选择的日期范围，确保用户只能选择有效的日期。
- `displayedComponents` 属性的设置需要根据您的需求进行调整。如果不需要时间选择，您可以仅显示日期组件。
- `DatePicker` 支持在不同平台上提供不同的体验（例如，`stepperField` 仅在 macOS 上可用），请确保根据平台调整样式选项。



---
url: /zh/guide/Views/Controls/DatePicker/index_example.md
---

# 示例

```tsx
import { DatePicker, DatePickerComponents, DatePickerStyle, HStack, Image, List, Navigation, NavigationStack, Picker, Script, Section, Spacer, Text, Toggle, useMemo, useState, } from "scripting"

const oneDay = 1000 * 60 * 60 * 24

 function Example() {
  const [date, setDate] = useState(() => Date.now())
  const [startDateEnabled, setStartDateEnabled] = useState(false)
  const [endDateEnabled, setEndDateEnabled] = useState(false)
  const startDate = useMemo(() => Date.now() - oneDay * 7, [])
  const endDate = useMemo(() => Date.now() + oneDay * 7, [])
  const components = useMemo<DatePickerComponents[]>(() => [
    'date',
    'hourAndMinute'
  ], [])
  const [displayedComponents, setDisplayedComponents] = useState<DatePickerComponents[]>([
    'date', 'hourAndMinute'
  ])
  const datePickerStyles = useMemo<DatePickerStyle[]>(() => [
    'compact',
    'graphical',
    'wheel',
  ], [])
  const [selectedStyle, setSelectedStyle] = useState<DatePickerStyle>('graphical')

  return <NavigationStack>
    <List
      navigationTitle={"DatePicker"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"Use startDate"}
          value={startDateEnabled}
          onChanged={setStartDateEnabled}
        />

        <Toggle
          title={"Use endDate"}
          value={endDateEnabled}
          onChanged={setEndDateEnabled}
        />
        {components.map(name =>
          <HStack
            contentShape={'rect'}
            onTapGesture={() => {
              if (displayedComponents.includes(name)) {
                if (displayedComponents.length > 1) {
                  setDisplayedComponents(displayedComponents.filter(e => e !== name))
                }
              } else {
                setDisplayedComponents([name, ...displayedComponents])
              }
            }}
          >
            <Text>Display: {name}</Text>
            <Spacer />
            {displayedComponents.includes(name)
              ? <Image
                systemName={"checkmark"}
                foregroundStyle={"systemBlue"}
              />
              : undefined}
          </HStack>
        )}

        <Picker
          title={"DatePicker Style"}
          value={selectedStyle}
          onChanged={setSelectedStyle as any}
          pickerStyle={'menu'}
        >
          {datePickerStyles.map(style =>
            <Text tag={style}>{style}</Text>
          )}
        </Picker>
      </Section>

      <DatePicker
        title={"DatePicker"}
        value={date}
        onChanged={setDate}
        startDate={startDateEnabled ? startDate : undefined}
        endDate={endDateEnabled ? endDate : undefined}
        displayedComponents={displayedComponents}
        datePickerStyle={selectedStyle}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Controls/Gauge/index.md
---

# 仪表盘

`Gauge` 组件是一个用于显示当前值与指定容量之间关系的视图，类似于汽车上的油表。`Gauge` 组件可以根据配置，显示当前值、显示范围以及描述该量表目的的标签。适用于展示有限容量内的当前值，如进度、水平或数量。

## 属性

### `value` (必选)

- **类型**：`number`
- **描述**：要在量表中显示的当前值。该值应当在 `min` 和 `max` 属性指定的范围内。

### `label` (必选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述量表的目的或意义。例如，可以使用此属性显示量表的描述性文字，如“电池电量”或“温度”等。

### `min` (可选)

- **类型**：`number`
- **描述**：量表的最小有效值，默认为 `0`。表示量表的下限。

### `max` (可选)

- **类型**：`number`
- **描述**：量表的最大有效值，默认为 `1`。表示量表的上限。

### `currentValueLabel` (可选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述当前量表值。例如，可以在量表旁边显示当前值的文本标签。

### `minValueLabel` (可选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述量表的下限。例如，可以在量表的最小值位置显示“0”或“最小”标签。

### `maxValueLabel` (可选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述量表的上限。例如，可以在量表的最大值位置显示“100”或“最大”标签。

### `gaugeStyle` (可选)

- **类型**：`GaugeStyle`
- **描述**：量表的显示风格。此属性可以控制量表的外观样式，有以下几种可选值：
  - **`automatic`**：当前上下文中量表的默认样式。
  - **`accessoryCircular`**：显示一个开放的圆环，环上有一个标记，指示量表的当前值。
  - **`accessoryCircularCapacity`**：显示一个闭合的圆环，部分填充，表示量表的当前值。
  - **`circular`**：**仅适用于 watchOS**，显示一个开放的圆环，环上有一个标记，指示量表的当前值。
  - **`linearCapacity`**：显示一个条形图，随着量表的当前值增加，从左到右填充。
  - **`accessoryLinear`**：显示一个条形图，条形上有一个标记，指示量表的当前值。
  - **`accessoryLinearCapacity`**：显示一个条形图，随着量表的当前值增加，从左到右填充。
  - **`linear`**：**仅适用于 watchOS**，显示一个条形图，条形上有一个标记，指示量表的当前值。

## 示例代码

```tsx
<Gauge
  value={0.7}
  label={<Text>Battery Level</Text>}
  min={0}
  max={1}
  currentValueLabel={<Text>70%</Text>}
  minValueLabel={<Text>0%</Text>}
  maxValueLabel={<Text>100%</Text>}
  gaugeStyle="accessoryCircular"
/>
```

## 使用场景

`Gauge` 组件非常适合以下几种场景：

- 显示进度条（如任务进度、下载进度等）。
- 展示设备状态（如电池电量、信号强度等）。
- 显示性能指标（如温度、湿度、CPU 使用率等）。

通过自定义 `label` 和 `currentValueLabel` 等属性，`Gauge` 组件可以灵活适配不同的显示需求，帮助用户清晰了解当前状态。

## 注意事项

- `value` 属性的值应位于 `min` 和 `max` 之间，否则会导致显示异常。
- 如果未传递 `min` 和 `max` 属性，量表会默认显示在 `[0, 1]` 范围内。
- 使用不同的 `gaugeStyle` 可以显著改变量表的外观。根据设备和使用场景选择适当的样式，以提高用户体验。



---
url: /zh/guide/Views/Controls/Gauge/index_example.md
---

# 示例

```tsx
import { Gauge, List, Navigation, NavigationStack, Script, Section, Text } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Gauge"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>accessoryCircular</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>0 100</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryCircular"}
          tint={"systemGreen"}
        />
      </Section>

      <Section
        header={
          <Text>accessoryCircularCapacity</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryCircularCapacity"}
        />
      </Section>

      <Section
        header={
          <Text>linearCapacity</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"linearCapacity"}
        />
      </Section>

      <Section
        header={
          <Text>accessoryLinear</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryLinear"}
        />
      </Section>
      <Section
        header={
          <Text>accessoryLinearCapacity</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryLinearCapacity"}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Controls/Picker/index.md
---

# 选择器

`Picker` 组件用于从一组互斥的选项中进行选择。它支持不同的显示样式，并允许用户选择单个值。可以通过设置 `value` 和 `onChanged` 属性来控制选项的值和改变事件。

## 类型定义

- `PickerValue`: 选择值的类型，支持 `number` 或 `string`。
- `PickerProps<T extends PickerValue>`: `Picker` 组件的属性类型，其中：
  - `value`: 当前选中的值，可以是 `number` 或 `string`，可选。
  - `onChanged`: 当选择的值发生变化时调用的函数，参数为选中的值（`T`）。
  - `children`: 选项视图，每个子元素都必须使用 `tag` 属性来标记其值，可以是一个 `JSX.Element` 或多个 `JSX.Element` 的数组。
  - `title`: 字符串类型，表示选择项的描述标题，仅在某些情况下使用。
  - `systemImage`: 系统图标的名称，仅在某些情况下使用。
  - `label`: 用于描述选择项的 `JSX.Element` 视图，仅在某些情况下使用。

## 组件功能

`Picker` 组件通过设置 `value` 和 `onChanged` 来管理用户的选择。`value` 是当前选择的值，`onChanged` 是一个回调函数，当用户更改选择时被调用。`children` 提供了选项的视图，允许使用多种不同的布局来展示选项。每个 `children` 元素必须使用 `tag` 属性来标记其值，例如 `<Text tag={1}>Option 1</Text>`。

## Picker 样式

`Picker` 组件支持以下几种样式，用于调整组件的呈现方式：

- `automatic`: 默认样式，基于 `Picker` 上下文自动决定样式。
- `inline`: 将每个选项与当前容器中的其他视图并排显示。
- `menu`: 以菜单形式展示选项，通常通过按钮点击展开，或者在更大菜单中作为子菜单。
- `navigationLink`: 通过导航链接形式呈现，点击后会展示一个 `List` 样式的选择器视图。
- `palette`: 将选项呈现为一行紧凑的元素。
- `segmented`: 将选项以分段控制样式显示。
- `wheel`: 通过可滚动的轮盘展示选项，显示当前选择项和若干邻近选项。

## 示例

以下是如何使用 `Picker` 组件的示例：

### 示例 1：数字类型的 Picker

```tsx
import { Picker, Text, useState } from 'scripting'

const MyPicker = () => {
  const [selectedValue, setSelectedValue] = useState<number>(1)

  return (
    <Picker
      value={selectedValue}
      onChanged={(newValue) => setSelectedValue(newValue)}
      pickerStyle="inline"
    >
      <Text tag={1}>Option 1</Text>
      <Text tag={2}>Option 2</Text>
      <Text tag={3}>Option 3</Text>
    </Picker>
  )
}
```

### 示例 2：字符串类型的 Picker

```tsx
import { Picker, Text, useState } from 'scripting'

const MyPicker = () => {
  const [selectedValue, setSelectedValue] = useState<string>("Option 1")

  return (
    <Picker
      value={selectedValue}
      onChanged={(newValue) => setSelectedValue(newValue)}
      pickerStyle="segmented"
    >
      <Text tag="Option 1">Option 1</Text>
      <Text tag="Option 2">Option 2</Text>
      <Text tag="Option 3">Option 3</Text>
    </Picker>
  )
}
```

### 示例 3：带标题和系统图标的 Picker

```tsx
import { Picker, Text, useState } from 'scripting'

const MyPicker = () => {
  const [selectedValue, setSelectedValue] = useState<string>("Option 1")

  return (
    <Picker
      value={selectedValue}
      onChanged={(newValue) => setSelectedValue(newValue)}
      pickerStyle="menu"
      title="Choose an option"
      systemImage="star"
    >
      <Text tag="Option 1">Option 1</Text>
      <Text tag="Option 2">Option 2</Text>
      <Text tag="Option 3">Option 3</Text>
    </Picker>
  )
}
```

## `Picker` 组件的常用场景

1. **表单选择项**：可以用于表单中的单选项，帮助用户从一组预定义的选项中做出选择。
2. **设置界面**：在应用设置中，`Picker` 可以用于选择颜色、主题、语言等选项。
3. **导航选项**：在更复杂的界面中，`Picker` 还可以作为多层菜单的选择工具。

## 注意事项

- 每个 `Picker` 的 `children` 元素必须使用 `tag` 属性来标记其对应的值，例如 `<Text tag={1}>Option 1</Text>`。
- `value` 和 `onChanged` 必须配合使用，确保在用户更改选择时能够正确响应。
- `pickerStyle` 提供了多种样式，选择适合的样式可以提升用户体验。

### 相关 API

- `JSX.Element`: 用于定义视图元素的基本结构，`Picker` 组件的 `children` 属性依赖此类型。
- `useState`: 用于管理选中值的状态。



---
url: /zh/guide/Views/Controls/Picker/index_example.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Picker, PickerStyle, Script, Section, Text, useMemo, useState, } from "scripting"

function Example() {
  const [value, setValue] = useState<number>(0)
  const options = useMemo<PickerStyle[]>(() => [
    'automatic',
    'inline',
    'menu',
    'navigationLink',
    'palette',
    'segmented',
    'wheel'
  ], [])
  const users = useMemo<string[]>(() => [
    "Jobs", "Elon", "Zack", "Joe"
  ], [])

  return <NavigationStack>
    <List
      navigationTitle={"Picker"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {options.map((style) =>
        <Section
          header={
            <Text>Picker: {style}</Text>}
        >
          <Picker
            title={"Picker: " + style}
            pickerStyle={style}
            value={value}
            onChanged={setValue}
          >
            {users.map((user, index) =>
              <Text
                tag={index}
              >{user}</Text>
            )}
          </Picker>
        </Section>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Controls/ProgressView/index.md
---

# 进度视图

`ProgressView` 是一个用于表示任务或操作进度的 UI 组件。它可以显示确定性（百分比完成）和不确定性（正在进行或未进行）的进度状态。此外，它还提供了可自定义的进度视图样式，包括线性和圆形表示。

你可以使用 `ProgressView` 来显示各种任务的进度，例如下载文件、完成某个过程或等待某个事件。该组件还可以显示附加的细节，如任务描述和当前进度。

## 使用方法

### 组件声明

`ProgressView` 组件接受两种可能的属性集，具体取决于你想表示的是基于时间的区间还是一般的进度任务。这些属性通过 `ProgressViewProps` 类型定义，可能是以下之一：

- `TimerIntervalProgressViewProps`
- `NormalProgressViewProps`

你可以通过绑定 `value` 和 `total` 属性来表示进度，从而创建一个确定性进度视图。此外，组件还支持通过 `progressViewStyle` 属性来自定义样式。

### 示例：基于时间区间的进度视图

```tsx
<ProgressView
  timerFrom={startTimestamp}
  timerTo={endTimestamp}
  countsDown={true}
  label={<Text>任务进行中</Text>}
  currentValueLabel={<Text>50% 完成</Text>}
/>
```

### 示例：普通进度视图

```tsx
<ProgressView
  value={0.5}
  total={1.0}
  title="加载中"
  label={<Text>文件下载中</Text>}
  currentValueLabel={<Text>50% 完成</Text>}
/>
```

## 属性

### `TimerIntervalProgressViewProps`

- **`timerFrom`** (`number`):\
  任务进度区间的起始时间戳（以毫秒为单位）。此值用于计算进度视图中已过去的时间。

- **`timerTo`** (`number`):\
  任务进度区间的结束时间戳（以毫秒为单位）。此值表示进度视图的结束点。

- **`countsDown`** (`boolean`, 可选，默认值: `true`):\
  如果设置为 `true`，进度视图会从 `timerFrom` 倒计时至 `timerTo`。如果设置为 `false`，则表示进度会从 `timerFrom` 增长至 `timerTo`。

- **`label`** (`VirtualNode`, 可选):\
  一个虚拟节点，用于提供任务的描述或附加信息。这可以是一个文本标签或其他类型的视图。

- **`currentValueLabel`** (`VirtualNode`, 可选):\
  一个虚拟节点，描述任务的当前进度值。例如，这可以显示当前的完成百分比。

### `NormalProgressViewProps`

- **`value`** (`number`, 可选):\
  任务当前的进度值，范围为 `0.0` 到 `total` 之间，表示任务完成的百分比。如果为 `nil`，则视图为不确定性进度。

- **`total`** (`number`, 可选，默认值: `1.0`):\
  完成任务所需的总进度值。当 `value` 等于 `total` 时，任务完成。默认值为 `1.0`。

- **`title`** (`string`, 可选):\
  正在进行的任务的标题或名称。

- **`label`** (`VirtualNode`, 可选):\
  描述任务进度的虚拟节点，类似于 `TimerIntervalProgressViewProps` 中的 `label` 属性。

- **`currentValueLabel`** (`VirtualNode`, 可选):\
  显示当前进度值的虚拟节点，类似于 `TimerIntervalProgressViewProps` 中的 `currentValueLabel` 属性。

### `CommonViewProps`

- **`progressViewStyle`** (`ProgressViewStyle`, 可选):\
  用于此视图的进度视图样式。可用样式包括：
  - **`automatic`**: 根据当前上下文自动选择的默认样式。
  - **`circular`**: 使用圆形进度条样式，表示活动的部分完成。在 macOS 之外的平台，圆形样式可能会显示为不确定性指示器。
  - **`linear`**: 使用水平条形样式来显示任务的进度。

### `ProgressViewStyle`

- **`linear`**: 使用水平条形来表示进度。
- **`circular`**: 使用圆形进度条来表示任务的部分完成。在 macOS 之外的平台，通常用于不确定性进度。
- **`automatic`**: 默认样式，自动根据上下文选择进度视图样式。

## 注意事项

- `ProgressView` 会根据提供的 `TimerIntervalProgressViewProps` 或 `NormalProgressViewProps` 中的值自动调整显示方式。
- 如果同时提供了 `value` 和 `total`，则视为确定性进度。如果其中任意一个为 `nil`，则视为不确定性进度。
- 你可以通过 `label` 和 `currentValueLabel` 属性自定义 UI，传递任何类型的视图，包括文本、图片或自定义组件。
- `progressViewStyle` 属性用于自定义进度视图的视觉样式。默认情况下，使用 `automatic` 样式，但你可以根据需要选择 `linear` 或 `circular`。

## 示例

### 确定性进度（包含 value 和 total）

```tsx
<ProgressView
  value={0.75}
  total={1.0}
  title="任务进度"
  label={<Text>任务已完成 75%</Text>}
  currentValueLabel={<Text>75%</Text>}
  progressViewStyle="linear"
/>
```

### 不确定性进度（没有 value）

```tsx
<ProgressView
  title="加载中"
  label={<Text>正在加载文件...</Text>}
  progressViewStyle="circular"
/>
```

## 结论

`ProgressView` 是一个灵活且易于使用的 UI 组件，支持确定性和不确定性进度状态。它允许通过线性或圆形进度指示器展示进度，并且支持自定义任务细节和视觉样式。使用 `ProgressView`，你可以在各种场景中有效地展示任务的进度。



---
url: /zh/guide/Views/Controls/ProgressView/index_example.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, ProgressView, Script, Section, Text, useState, } from "scripting"

function Example() {
  const [timerFrom] = useState(() => Date.now())
  const timerTo = timerFrom + 1000 * 60

  return <NavigationStack>
    <List
      navigationTitle={"ProgressView"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>circular</Text>
        }
      >
        <ProgressView
          progressViewStyle={'circular'}
        />
      </Section>

      <Section
        header={
          <Text>linear</Text>
        }
      >
        <ProgressView
          progressViewStyle={'linear'}
          total={100}
          value={50}
          label={<Text>Progress 50%</Text>}
          currentValueLabel={<Text>50</Text>}
        />
      </Section>

      <Section
        header={
          <Text>TimerInterval</Text>
        }
      >
        <ProgressView
          progressViewStyle={'linear'}
          timerFrom={timerFrom}
          timerTo={timerTo}
          countsDown={false}
          label={<Text>Workout</Text>}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Controls/Slider/index.md
---

# 滑块控件

`Slider` 组件允许用户从一个有限的线性范围内选择一个值。可以通过设置最小值、最大值、步长和当前值来配置滑动条，支持自定义标签用于描述最小值、最大值及滑动条本身。这个组件还支持处理值的变化和编辑状态的回调。

## SliderProps 类型

`SliderProps` 是 `Slider` 组件的属性类型，包含以下字段：

- **min** (`number`):
  - 设置滑动条的最小值。
  - **必选**。

- **max** (`number`):
  - 设置滑动条的最大值。
  - **必选**。

- **step** (`number`):
  - 设置滑动条上每次有效值之间的间隔。
  - **可选**，默认为 `1`。

- **value** (`number`):
  - 设置当前选中的值。
  - **必选**，必须在 `min` 和 `max` 之间。

- **onChanged** (`(value: number) => void`):
  - 一个回调函数，用于监听滑动条的值变化。
  - **必选**，每次值变化时会被调用。

- **onEditingChanged** (`(value: boolean) => void`):
  - 一个可选回调函数，当滑动条的编辑状态发生变化时会被调用。
  - `value` 为 `true` 时表示滑动条正在被编辑，`false` 表示编辑已结束。

- **label** (`VirtualNode`):
  - 一个可选视图，用于描述滑动条的目的。即使某些滑动条样式不会显示该标签，系统仍然会用于可访问性目的（例如，VoiceOver）。
  - **可选**。

- **minValueLabel** (`VirtualNode`):
  - 一个可选视图，用于描述滑动条的最小值。
  - **可选**，仅在 `SliderWithRangeValueLabelProps` 模式下使用。

- **maxValueLabel** (`VirtualNode`):
  - 一个可选视图，用于描述滑动条的最大值。
  - **可选**，仅在 `SliderWithRangeValueLabelProps` 模式下使用。

## SliderWithRangeValueLabelProps 类型

`SliderWithRangeValueLabelProps` 是用于描述滑动条的附加信息的属性类型。它包括：

- **label** (`VirtualNode`):
  - 用于描述滑动条目的标签。

- **minValueLabel** (`VirtualNode`):
  - 用于描述最小值的标签。

- **maxValueLabel** (`VirtualNode`):
  - 用于描述最大值的标签。

## 使用示例

以下是一个使用 `Slider` 组件的简单示例：

```tsx
import { Slider } from 'scripting'

const ExampleSlider = () => {
  const [value, setValue] = useState(50)

  const handleChange = (newValue: number) => {
    setValue(newValue)
  }

  return (
    <Slider
      min={0}
      max={100}
      value={value}
      onChanged={handleChange}
      label={<Text>调整音量</Text>}
      minValueLabel={<Text>0</Text>}
      maxValueLabel={<Text>100</Text>}
    />
  )
}
```

在此示例中，`Slider` 组件配置了一个从 `0` 到 `100` 的滑动条，默认值为 `50`。标签和最小、最大值标签分别描述了滑动条的目的和范围。

## 注意事项

- `Slider` 组件的 `min` 和 `max` 必须设置为数值，且 `value` 必须在这个范围内。
- 当用户调整滑动条时，`onChanged` 回调会触发，传入新的值。
- 如果使用 `SliderWithRangeValueLabelProps`，则必须为 `minValueLabel` 和 `maxValueLabel` 提供合适的视图元素。

## 小结

`Slider` 组件是一个功能强大的 UI 控件，适用于需要用户选择数值的场景。通过灵活的属性和回调，可以实现许多自定义行为，尤其是在需要提供最小、最大值说明或标签的场景中。



---
url: /zh/guide/Views/Controls/Slider/index_example.md
---

# 示例

```tsx
import { useState, Slider, Text, VStack, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [value, setValue] = useState(15)

  return <NavigationStack>
    <VStack
      navigationTitle={"Slider"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Slider
        min={0}
        max={100}
        value={value}
        onChanged={setValue}
        label={<Text>{value}</Text>}
        minValueLabel={<Text>0</Text>}
        maxValueLabel={<Text>100</Text>}
      />
      <Text>Current value: {value}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Controls/Stepper/index.md
---

# 步进器

`Stepper` 是一个用于执行递增和递减操作的控件。它允许用户通过点击“+”或“-”按钮来增加或减少数值。该组件也支持触发编辑状态变化的回调函数。

## 属性

### 1. `title`（可选，字符串）

- **描述**：指定步进器的标题，通常用于说明步进器的目的。
- **类型**：`string`
- **示例**：
  ```tsx
  <Stepper 
    title="Adjust Volume" 
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement} 
  />
  ```

### 2. `children`（可选，虚拟节点）

- **描述**：用于描述步进器的目的的视图内容。可以使用多个子视图来构建控件的外观。此属性和 `title` 属性为互斥关系，只能选择其一。
- **类型**：`(VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode`
- **示例**：
  ```tsx
  <Stepper
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement}
  >
    <Text>Adjust Volume</Text>
  </Stepper>
  ```

### 3. `onIncrement`（必选，回调函数）

- **描述**：当用户点击或触摸“+”按钮时，执行此函数。
- **类型**：`() => void`
- **示例**：
  ```tsx
  const handleIncrement = () => {
    console.log("Incremented");
  }

  <Stepper 
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement} 
  />
  ```

### 4. `onDecrement`（必选，回调函数）

- **描述**：当用户点击或触摸“-”按钮时，执行此函数。
- **类型**：`() => void`
- **示例**：
  ```tsx
  const handleDecrement = () => {
    console.log("Decremented")
  }

  <Stepper onIncrement={handleIncrement} onDecrement={handleDecrement} />
  ```

### 5. `onEditingChanged`（可选，回调函数）

- **描述**：当编辑开始和结束时调用的函数。例如，在 iOS 上，用户长按步进器的增减按钮时，会触发 `onEditingChanged` 回调函数，表示编辑状态的变化。
- **类型**：`(value: boolean) => void`
- **示例**：
  ```tsx
  const handleEditingChanged = (isEditing: boolean) => {
    console.log("Editing started:", isEditing)
  }

  <Stepper 
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement} 
    onEditingChanged={handleEditingChanged} 
  />
  ```

## 示例代码

以下是一个完整的示例，展示了如何使用 `Stepper` 组件：

```tsx
const handleIncrement = () => {
  console.log("Volume increased")
}

const handleDecrement = () => {
  console.log("Volume decreased")
}

const handleEditingChanged = (isEditing: boolean) => {
  console.log("Editing started:", isEditing)
}

<Stepper
  title="Volume Control"
  onIncrement={handleIncrement}
  onDecrement={handleDecrement}
  onEditingChanged={handleEditingChanged}
/>
```

## 注意事项

- `title` 和 `children` 属性是互斥的。只能使用一个来描述步进器的目的。
- `onEditingChanged` 回调函数是可选的，只在支持编辑状态的情况下触发，例如长按按钮时。

## 小结

`Stepper` 控件提供了一个简单的接口来实现递增和递减操作，支持在用户交互时触发回调。通过配置 `title` 或 `children` 属性来指定控件的目的，并且可以使用 `onIncrement` 和 `onDecrement` 函数定义按钮点击后的行为。



---
url: /zh/guide/Views/Controls/Stepper/index_example.md
---

# 示例

```tsx
import { useState, useMemo, Color, Stepper, Text, VStack, RoundedRectangle, HStack, Spacer, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [value, setValue] = useState(0)
  const colors = useMemo<Color[]>(() => ['blue', 'red', 'green', 'purple'], [])
  const color = colors[value]

  function incrementStep() {
    if (value + 1 >= colors.length) {
      setValue(0)
    } else {
      setValue(value + 1)
    }
  }

  function decrementStep() {
    if (value - 1 < 0) {
      setValue(colors.length - 1)
    } else {
      setValue(value - 1)
    }
  }

  return <NavigationStack>
    <VStack
      navigationTitle={"Stepper"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Stepper
        title={"Stepper"}
        onIncrement={incrementStep}
        onDecrement={decrementStep}
      />
      <HStack>
        <Text>Value: {value}</Text>
        <Spacer />
        <RoundedRectangle
          fill={color}
          cornerRadius={4}
          frame={{
            width: 120,
            height: 30
          }}
        />
      </HStack>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Controls/Toggle/index.md
---

# 切换开关

`Toggle` 组件是 Scripting 应用中的一种视图控件，允许用户在“开启”和“关闭”状态之间切换。它支持多种配置选项，以适应不同的使用场景，包括用户交互处理器、自动化的意图支持以及用于显示的自定义选项。

***

## ToggleProps

`ToggleProps` 类型定义了 `Toggle` 组件的配置选项。

### 属性

#### **value**

- **类型**: `boolean`
- **描述**: 指示当前切换状态是“开启”(`true`)还是“关闭”(`false`)。
- **是否必需**: 是

***

#### **onChanged**

- **类型**: `(value: boolean) => void`
- **描述**: 当切换状态更改时调用的处理函数。它接收新的状态值（`true` 或 `false`）作为参数。
- **是否必需**: 是（如果未提供 `intent`）。

***

#### **intent**

- **类型**: `AppIntent<any>`
- **描述**: 当切换状态更改时执行的 `AppIntent`。仅适用于 `Widget` 或 `LiveActivity` 上下文。
- **是否必需**: 是（如果未提供 `onChanged`）。

***

#### **title**

- **类型**: `string`
- **描述**: 描述此切换目的的一段简短字符串。
- **可选**: 是，与 `children` 互斥。

***

#### **systemImage**

- **类型**: `string`
- **描述**: 显示在切换旁边的图像资源名称，通常用于增强描述。
- **可选**: 是，仅当提供了 `title` 时可用。

***

#### **children**

- **类型**: `(VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode`
- **描述**: 描述切换目的的自定义视图，提供比 `title` 更灵活的替代方案。
- **可选**: 是，与 `title` 互斥。

***

## ToggleStyle

定义 `Toggle` 的外观和行为。可以通过 `CommonViewProps` 中的 `toggleStyle` 属性进行配置。

### 选项

- **`'automatic'`**: 根据上下文自动选择最合适的样式。
- **`'switch'`**: 将切换显示为传统的开关。
- **`'button'`**: 将切换显示为按钮。

***

## CommonViewProps

`CommonViewProps` 提供了用于自定义 `Toggle` 的附加选项。

### 属性

#### **toggleStyle**

- **类型**: `'automatic' | 'switch' | 'button'`
- **描述**: 指定切换的外观和行为。如果未设置，则默认为 `'automatic'`。
- **可选**: 是

***

## 使用示例

### 示例 1: 带状态更改处理器的基础切换

```tsx
import { Toggle } from 'scripting'

function MyComponent() {
  const [isEnabled, setIsEnabled] = useState(false)

  return (
    <Toggle 
      value={isEnabled} 
      onChanged={newValue => setIsEnabled(newValue)} 
      title="启用通知" 
      systemImage="bell"
    />
  )
}
```

***

### 示例 2: 带有 AppIntent 的切换

```tsx
import { Toggle, } from 'scripting'
import { SomeToggleIntent } from "./app_intents"

function MyWidget() {
  const checked = getCheckedState()
  return (
    <Toggle 
        value={checked} 
        intent={SomeToggleIntent(checked)} 
        title="执行操作" 
        systemImage="action"
    />
  )
}
```

有关 `AppIntent` 的更多信息，请参阅 `Interactive Widget and LiveActivity` 文档。

***

### 示例 3: 带有自定义视图的切换

```tsx
import { Toggle, View } from 'scripting'

function MyComponent() {
  const [isEnabled, setIsEnabled] = useState(false)

  return (
    <Toggle 
      value={isEnabled} 
      onChanged={newValue => setIsEnabled(newValue)}
    >
      <View>
        <Text>启用功能</Text>
        <Image imageUrl="https://example.com/feature-icon.png" />
      </View>
    </Toggle>
  )
}
```

***

### 示例 4: 带有 `toggleStyle` 的切换

```tsx
import { Toggle } from 'scripting'

function StyledToggle() {
  const [isActive, setIsActive] = useState(false)

  return (
    <Toggle 
      value={isActive} 
      onChanged={newValue => setIsActive(newValue)} 
      title="样式切换" 
      toggleStyle="button"
    />
  )
}
```

***

通过本指南，开发者可以充分利用 `Toggle` 组件的功能，轻松创建动态且交互性强的 UI 体验，提升 Scripting 应用的开发效率。



---
url: /zh/guide/Views/Controls/Toggle/index_example.md
---

# 示例

```tsx
import { useState, VStack, Toggle, Text, Navigation, Script, NavigationStack } from "scripting"

function Example() {
  const [on, setOn] = useState(false)

  return <NavigationStack>
    <VStack
      navigationTitle={"Toggle"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Toggle
        title={"Toggle Switch"}
        value={on}
        onChanged={setOn}
      />
      <Text>Current: {on ? 'on' : 'off'}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Dialog/index.md
---

# 对话框

`Dialog` 模块提供了一组用于展示对话框的快捷方法，包括提示框（Alert）、确认框（Confirm）、输入框（Prompt）和操作表（Action Sheet）。可用于在脚本执行过程中与用户进行交互。

***

## 模块：`Dialog`

***

### ▸ `Dialog.alert(options: { message: string, title?: string, buttonLabel?: string }): Promise<void>`

显示一个简单的提示框，包含一段信息和一个确认按钮。用户点击按钮后，Promise 会被 resolve。

#### 参数说明

- `message` (`string`)：提示的主要内容，**必填**。
- `title?` (`string`)：对话框标题，可选。
- `buttonLabel?` (`string`)：按钮文本，默认为 `"OK"`。

#### 返回值

- `Promise<void>`：用户点击按钮后 resolve。

#### 示例

```ts
await Dialog.alert({
  title: '提示',
  message: '操作已成功完成。',
  buttonLabel: '知道了'
})
```

***

### ▸ `Dialog.confirm(options: { message: string, title?: string, cancelLabel?: string, confirmLabel?: string }): Promise<boolean>`

显示一个确认框，包含“确认”和“取消”两个按钮。返回值表示用户是否确认。

#### 参数说明

- `message` (`string`)：确认信息内容，**必填**。
- `title?` (`string`)：标题，可选。
- `cancelLabel?` (`string`)：取消按钮文本，默认值为 `"Cancel"`。
- `confirmLabel?` (`string`)：确认按钮文本，默认值为 `"OK"`。

#### 返回值

- `Promise<boolean>`：用户点击确认返回 `true`，点击取消返回 `false`。

#### 示例

```ts
const confirmed = await Dialog.confirm({
  title: '删除文件',
  message: '确定要删除这个文件吗？',
  cancelLabel: '取消',
  confirmLabel: '删除'
})

if (confirmed) {
  // 执行删除操作
}
```

***

### ▸ `Dialog.prompt(options: {...}): Promise<string | null>`

显示一个输入框对话界面，允许用户输入文字。返回用户输入的字符串，或在取消时返回 `null`。

#### 参数说明

- `title` (`string`)：输入框标题，**必填**。
- `message?` (`string`)：辅助说明信息。
- `defaultValue?` (`string`)：默认输入值。
- `obscureText?` (`boolean`)：是否隐藏输入内容（如密码）。
- `selectAll?` (`boolean`)：是否自动选中全部默认内容。
- `placeholder?` (`string`)：输入框的占位提示文本。
- `cancelLabel?` (`string`)：取消按钮文本。
- `confirmLabel?` (`string`)：确认按钮文本。
- `keyboardType?` (`KeyboardType`)：输入键盘类型（如数字、邮箱等）。

#### 返回值

- `Promise<string | null>`：用户输入的文本，或取消时为 `null`。

#### 示例

```ts
const name = await Dialog.prompt({
  title: '请输入姓名',
  placeholder: '例如：李雷',
  defaultValue: '张三',
  confirmLabel: '提交',
  cancelLabel: '取消'
})

if (name != null) {
  console.log(`你好，${name}`)
}
```

***

### ▸ `Dialog.actionSheet(options: {...}): Promise<number | null>`

展示一个操作表（Action Sheet），可包含多个选项按钮。点击某个按钮返回该按钮的索引，点击取消返回 `null`。

#### 参数说明

- `title` (`string`)：标题，**必填**。
- `message?` (`string`)：提示信息，可选。
- `cancelButton?` (`boolean`)：是否显示取消按钮，默认值为 `true`。
- `actions` (`{ label: string, destructive?: boolean }[]`)：操作项数组，`destructive` 表示是否为破坏性操作（红色高亮）。

#### 返回值

- `Promise<number | null>`：返回所点击操作的索引，或用户取消时返回 `null`。

#### 示例

```ts
const index = await Dialog.actionSheet({
  title: '是否删除此图片？',
  actions: [
    { label: '删除', destructive: true },
    { label: '保留' }
  ]
})

if (index === 0) {
  // 用户选择删除
} else if (index === 1) {
  // 用户选择保留
} else {
  // 用户点击了取消
}
```

***

## 方法概览

| 方法名           | 用途         | 返回值类型                      |   |
| ------------- | ---------- | -------------------------- | - |
| `alert`       | 显示提示框      | `Promise<void>`            |   |
| `confirm`     | 显示确认框      | `Promise<boolean>`         |   |
| `prompt`      | 显示文字输入框    | `Promise<string  \| null>` |   |
| `actionSheet` | 显示多个选项的操作表 | `Promise<number  \| null>` |   |



---
url: /zh/guide/Views/Dialog/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Dialog"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Button
        title={"Dialog.alert"}
        action={async () => {
          await Dialog.alert({
            message: "This is message",
            title: "Alert",
          })
          console.log("Alert dismissed")
        }}
      />

      <Button
        title={"Dialog.prompt"}
        action={async () => {
          const result = await Dialog.prompt({
            title: "Rename script",
            placeholder: "Enter script name",
          })

          Dialog.alert({
            message: result == null
              ? "You cancel the prompt"
              : "The new script name is: " + result
          })
        }}
      />

      <Button
        title={"Dialog.actionSheet"}
        action={async () => {
          const selectedIndex = await Dialog.actionSheet({
            title: "Are you sure to delete this script?",
            message: "This operation cannot be undone.",
            cancelButton: true,
            actions: [
              {
                label: "Delete",
                destructive: true,
              }
            ]
          })

          if (selectedIndex === 0) {
            Dialog.alert({
              message: "The script is deleted."
            })
          }
        }}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Displaying text/index.md
---

# 显示文本

`Text` 组件用于在 Scripting 应用中显示一行或多行只读文本。它支持纯文本、富文本（Markdown）以及丰富的文本样式。

***

## **类型定义**

### `TextProps`

定义了可传递给 `Text` 组件的属性。`TextProps` 类型有三种可能的结构：

1. **纯文本属性**
   - `children`（可选）：
     - 类型：`null | string | number | boolean | Array<string | number | boolean | undefined | null>`
     - 描述：以纯文本形式渲染的内容，可以是单个值或值的数组。
   - 示例：
     ```tsx
     <Text>简单的纯文本</Text>
     ```

2. **Markdown 文本属性**
   - `attributedString`（可选）：
     - 类型：`string`
     - 描述：指定 Markdown 格式的文本内容。
   - 示例：
     ```tsx
     <Text attributedString="**加粗** _斜体_ [链接](https://example.com)" />
     ```

3. **富文本属性**
   - `styledText`（可选）：
     - 类型：`StyledText`
     - 描述：指定具有自定义样式和属性的富文本内容。
   - 示例：
     ```tsx
     const richText: StyledText = {
       font: "title",
       bold: true,
       underlineStyle: "single",
       underlineColor: "#0000FF",
       content: "丰富样式的文本"
     }
     <Text styledText={richText} />
     ```

***

### `UnderlineStyle`

定义了富文本可用的下划线样式：

- `"byWord"`：逐字下划线。
- `"double"`：双线下划线。
- `"patternDash"`：虚线下划线。
- `"patternDashDot"`：点划线下划线。
- `"patternDashDotDot"`：双点划线下划线。
- `"patternDot"`：点状下划线。
- `"single"`：单线下划线。
- `"thick"`：加粗下划线。

***

### `StyledText`

定义了富文本样式的结构：

- `font`（可选）：指定字体名称，例如：`"title"`、`"body"`。
- `fontDesign`（可选）：自定义字体设计，例如：`"serif"`、`"monospaced"`。
- `fontWeight`（可选）：调整字体粗细，例如：`"light"`、`"bold"`。
- `italic`（可选）：添加斜体样式，类型：`boolean`。
- `bold`（可选）：添加加粗样式，类型：`boolean`。
- `baselineOffset`（可选）：调整文本基线位置，类型：`number`。
- `kerning`（可选）：调整字符间距，类型：`number`。
- `monospaced`（可选）：使用等宽字体，类型：`boolean`。
- `monospacedDigit`（可选）：确保数字字符宽度一致，类型：`boolean`。
- `underlineColor`（可选）：下划线颜色，类型：`Color`。
- `underlineStyle`（可选）：下划线样式，类型：`UnderlineStyle`。
- `strokeColor`（可选）：文本描边颜色，类型：`Color`。
- `strokeWidth`（可选）：文本描边宽度，类型：`number`。
- `strikethroughColor`（可选）：删除线颜色，类型：`Color`。
- `strikethroughStyle`（可选）：删除线样式，类型：`UnderlineStyle`。
- `foregroundColor`（可选）：文本颜色，类型：`Color`。
- `backgroundColor`（可选）：文本背景颜色，类型：`Color`。
- `content`（必填）：指定文本内容，可以是字符串或字符串与 `StyledText` 对象的数组。
- `link`（可选）：为文本添加超链接，类型：`string`。
- `onTapGesture`（可选）：文本被点击时执行的函数，类型：`() => void`。

***

## **`Text` 组件**

### **描述**

一个视图组件，用于显示一行或多行只读文本。内容可以通过 `TextProps` 中的属性进行样式化。

### **示例用法**

1. **纯文本**
   ```tsx
   <Text font="title">
     你好，世界！
   </Text>
   ```

2. **Markdown 文本**
   ```tsx
   <Text attributedString="这是 **加粗**、_斜体_ 和一个 [链接](https://example.com)。" />
   ```

3. **富文本**
   ```tsx
   const richText: StyledText = {
     font: "body",
     bold: true,
     underlineStyle: "single",
     underlineColor: "#00FF00",
     foregroundColor: "#FF0000",
     content: [
       "部分 1，",
       {
         content: "样式",
         italic: true,
         strokeColor: "#0000FF",
         strokeWidth: 2
       },
       "，部分 2"
     ]
   }

   <Text styledText={richText} />
   ```

***

## 注意事项

- **默认字体**：如果未指定 `font` 属性，将使用系统默认字体。
- **性能**：对于动态或频繁更新的内容，确保 `styledText` 对象是不可变的，以避免不必要的重新渲染。
- **点击手势**：在 `StyledText` 中使用 `onTapGesture` 属性为文本添加交互功能。



---
url: /zh/guide/Views/Displaying text/index_example.md
---

# 示例

```tsx
import { Label, List, Markdown, Navigation, NavigationStack, Script, Section, Text, VStack } from "scripting"

function View() {
  return <NavigationStack>
    <List>
      <Section title={"Text"}>
        <VStack>
          <Text
            font={"title"}
            foregroundStyle={"systemRed"}
          >
            Title
          </Text>
          <Text
            font={"body"}
            foregroundStyle={"systemBlue"}
          >Hello Scripting!</Text>
          <Text
            foregroundStyle={"systemGreen"}
            font={"footnote"}
            italic
          >
            This is a footnote.
          </Text>
        </VStack>
      </Section>

      <Section title="AttributedString">
        <Text
          attributedString={`This is regular text.
* This is **bold** text, this is *italic* text, and this is ***bold, italic*** text.
~~A strikethrough example~~
\`Monospaced works too\`
Visit Apple: [click here](https://apple.com)`}
        />
      </Section>

      <Section title={"Label"}>
        <Label
          title={"Hello world"}
          systemImage={"globe"}
        />
      </Section>

      <Section title={"Markdown"}>
        <Markdown
          content={`
# Scripting App
Run your *ideas* quickly **with** scripts.
      `}
        />
      </Section>

      <Section title={"RichText"}>
        <Text
          font={16}
          styledText={{
            content: [
              "I agree the ",
              {
                content: "Terms",
                foregroundColor: "systemOrange",
                underlineColor: "systemBlue",
                bold: true,
                onTapGesture: () => {
                  Dialog.alert({
                    message: "OK!"
                  })
                }
              }
            ]
          }}
        />
      </Section>

    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Editor.md
---

# 编辑器

一个强大的代码编辑器，既可以通过编程方式控制，也可以嵌入自定义视图中展示。编辑器支持语法高亮、读写访问以及完整的生命周期管理，主要通过 `EditorController` 类和 `Editor` 组件来实现。

***

## EditorController

### 概述

`EditorController` 用于管理一个编辑器实例。你可以配置初始内容、监听用户修改、展示或隐藏编辑器，并在不再使用时释放资源。

### 构造函数

用于创建一个新的编辑器控制器实例。

**参数说明**：

- `content`（可选）：编辑器的初始文本内容。
- `ext`（可选）：文件扩展名，用于指定语法高亮语言。支持的类型包括 `tsx`、`ts`、`js`、`jsx`、`txt`、`md`、`css`、`html` 和 `json`。
- `readOnly`（可选）：是否启用只读模式，默认为 `false`。

***

### 属性说明

#### `ext`

只读属性，表示初始化时提供的文件扩展名，用于决定使用哪种语法高亮。

#### `content`

一个字符串，表示当前编辑器的文本内容。可以直接修改该值以更新编辑器内容。

#### `onContentChanged`

可选回调函数，在用户修改内容后大约 **100 毫秒** 被调用。该函数不会在每次输入时立即触发，适合用于防抖、自动保存等逻辑。

***

### 方法说明

#### `present(options?)`

以模态方式展示编辑器。

**参数说明**：

- `navigationTitle`（可选）：设置编辑器的顶部标题。
- `scriptName`（可选）：用于覆盖默认的 `Script.name`，默认为 `"Temporary Script"`。
- `fullscreen`（可选）：是否全屏显示编辑器，默认为 `false`。

**返回值**：返回一个 `Promise`，在编辑器被关闭时完成。

***

#### `dismiss()`

关闭当前展示的编辑器界面。注意，这不会销毁控制器实例，因此可以稍后再次调用 `present()`。

**返回值**：返回一个 `Promise`，在编辑器关闭后完成。

***

#### `dispose()`

释放控制器占用的资源。**必须在不再使用控制器时调用此方法**，以防止内存泄漏。一旦调用该方法，控制器将无法再次使用。

***

## Editor 组件

`Editor` 是一个 React 风格的组件，用于在 UI 中内联渲染编辑器。通常与 `EditorController` 实例搭配使用。

**属性说明**：

- `controller`：编辑器控制器实例，用于管理内容和状态。
- `scriptName`（可选）：用于指定当前编辑器的脚本名称。
- `showAccessoryView` (可选): 当键盘可见时是否显示附件视图。这对于显示“左移”、“右移”、“删除”、“关闭键盘”等按钮非常有用。默认为 false。当编辑器在屏幕上完全可见时（例如，当编辑器是屏幕上唯一的视图时），建议将其设置为 true。

***

### 示例代码

```tsx
function MyEditor() {
  const controller = useMemo(() => {
    return new EditorController({
      content: `const text = "Hello, World!"`,
      ext: "ts",
      readOnly: false,
    })
  }, [])
  
  useEffect(() => {
    return () => {
      // 组件卸载时释放资源
      controller.dispose()
    }
  }, [controller])

  return (
    <Editor
      controller={controller}
      scriptName="My Script"
      showAccessoryView
    />
  )
}
```



---
url: /zh/guide/Views/EnvironmentValuesReader.md
---

`EnvironmentValuesReader` 是 Scripting 提供的一个组件，用于读取 SwiftUI 风格的环境值（Environment Values）。
它允许脚本在视图层级中访问当前环境的上下文信息，例如颜色模式、尺寸类别、是否正在搜索、是否被呈现、编辑模式等。

该组件的定位与 SwiftUI 中的 `@Environment` 类似，但设计上更加明确：
**你必须指定要读取的 environment keys，系统仅在渲染时读取这些值并传入回调函数。**

***

# EnvironmentValues 类型

```ts
type EnvironmentValues = {
    colorScheme: ColorScheme;
    colorSchemeContrast: ColorSchemeContrast;
    displayScale: number;
    horizontalSizeClass: UserInterfaceSizeClass | null;
    verticalSizeClass: UserInterfaceSizeClass | null;
    dismiss: () => void;
    dismissSearch: () => void;
    editMode: EditMode | null;
    widgetRenderingMode: WidgetRenderingMode;
    showsWidgetContainerBackground: boolean;
    isSearching: boolean;
    isPresented: boolean;
    activityFamily: "small" | "medium";
    tabViewBottomAccessoryPlacement: 'expanded' | 'inline';
};
```

以下为每个字段的说明：

***

## 字段说明

### 1. colorScheme

类型：`ColorScheme`
说明：当前系统的颜色模式，例如 `light` 或 `dark`。

***

### 2. colorSchemeContrast

类型：`ColorSchemeContrast`
说明：颜色对比度模式，例如 `standard`、`increased`。

***

### 3. displayScale

类型：`number`
说明：设备屏幕的像素缩放比例，例如 **2.0**, **3.0**。

***

### 4. horizontalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：横向尺寸类别，可用于响应式布局。
可能值：`compact` / `regular`。

***

### 5. verticalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：纵向尺寸类别，行为同上。

***

### 6. dismiss

类型：`() => void`
说明：用于关闭当前呈现的界面，等价于 SwiftUI 的 `dismiss()`。

***

### 7. dismissSearch

类型：`() => void`
说明：关闭当前的搜索 UI（如果 `searchable` 处于激活状态）。

***

### 8. editMode

类型：`EditMode | null`
说明：当前视图是否处于编辑模式（例如 List 的编辑状态）。

***

### 9. widgetRenderingMode

类型：`WidgetRenderingMode`
说明：Widget 渲染模式，例如 `fullColor`、`accented` 等。

***

### 10. showsWidgetContainerBackground

类型：`boolean`
说明：指示 widget 是否显示系统容器背景。

***

### 11. isSearching

类型：`boolean`
说明：当前 view 是否处于搜索状态（来自 `searchable`）。

***

### 12. isPresented

类型：`boolean`
说明：当前 view 是否已呈现，和 `onAppear` 回调不同，不像 `onAppear` 会多次触发。

***

### 13. activityFamily

类型：`"small" | "medium"`
说明：当前LiveActivity的尺寸，同 SwiftUI 中的 `activityFamily`，用于根据些大小渲染 LiveActivity UI。

***

### 14. tabViewBottomAccessoryPlacement

类型：`'expanded' | 'inline'`
说明：当前 TabView 的底部辅助栏的显示方式，同 SwiftUI 中的 `tabViewBottomAccessoryPlacement`。

# EnvironmentValuesReader 组件

```ts
type EnvironmentValuesReaderProps = {
    /**
     * The keys to read from the environment values.
     */
    keys: Array<keyof EnvironmentValues>;
    /**
     * The callback function to render the children, it will be called with the environment values.
     */
    children: (values: EnvironmentValues) => VirtualNode;
};
```

***

# Props 说明

## keys

类型：`Array<keyof EnvironmentValues>`
说明：指定需要读取的 environment key 列表。

只有指定的 key 才会被 read 并传入 children。

***

## children(values)

类型：`(values: EnvironmentValues) => VirtualNode`
说明：用于渲染子节点的回调。
系统会收集你请求的 environment key，并将其值合并成一个对象传入。

***

# 组件定义

```ts
declare const EnvironmentValuesReader: FunctionComponent<EnvironmentValuesReaderProps>;
```

***

# 使用示例

## 示例：读取 colorScheme 和 displayScale

```tsx
import { EnvironmentValuesReader, Text, VStack } from "scripting"

function View() {
  return <EnvironmentValuesReader
    keys={["colorScheme", "displayScale"]}
  >
    {(env) => {
      return <VStack>
        <Text>Color Scheme: {env.colorScheme}</Text>
        <Text>Scale: {env.displayScale}</Text>
      </VStack>
    }}
  </EnvironmentValuesReader>
}
```

***

## 示例：读取 dismiss

```tsx
<EnvironmentValuesReader keys={["dismiss"]}>
  {(env) => {
    return <Button
      title="Close"
      action={() => env.dismiss()}
    />
  }}
</EnvironmentValuesReader>
```

***

## 示例：根据 sizeClass 动态布局

```tsx
<EnvironmentValuesReader keys={["horizontalSizeClass"]}>
  {(env) => {
    const compact = env.horizontalSizeClass === "compact"
    return compact ? <Text>Compact Layout</Text> : <Text>Regular Layout</Text>
  }}
</EnvironmentValuesReader>
```

***

# 使用注意事项

1. **必须显式指定 keys**，否则不会读取任何 environment 值。
2. 每次所指定的 environment key 发生变化时，`children()` 会重新渲染。
3. `dismiss` 和 `dismissSearch` 是实际可调用的操作，与 SwiftUI 一致。
4. environment 的来源来自父视图树，包括 `Navigation`, `searchable`, `editMode`, `Widget` 等组件。
5. 未在 keys 中声明的字段不会出现在 values 对象中。
6. 不用于替代全局状态，适用于读取系统环境或父组件传递的上下文信息。



---
url: /zh/guide/Views/GeometryReader.md
---

`GeometryReader` 是 Scripting 中与 SwiftUI 等效的几何布局读取组件。
它能够在视图构建阶段提供当前容器的尺寸、边距、安全区域和角落内边距等信息，使开发者可以根据环境动态布局内容。

当你需要根据父容器的大小进行自适应布局（响应式布局）时，`GeometryReader` 是非常重要的工具。

***

# GeometryProxy

当 `GeometryReader` 构建其子内容时，会将一个 `GeometryProxy` 实例传递给 `children` 回调。开发者可以使用此对象访问与当前容器相关的布局信息。

```ts
interface GeometryProxy {
  readonly size: Size;
  readonly safeAreaInsets: {
      leading: number;
      top: number;
      trailing: number;
      bottom: number;
  };
  /**
   * Requires iOS 26.0+.
   */
  readonly containerCornerInsets: {
      bottomLeading: Size;
      bottomTrailing: Size;
      topLeading: Size;
      topTrailing: Size;
  } | null;
}
```

***

# GeometryProxy 属性说明

## 1. size

```ts
readonly size: Size
```

当前容器在布局时的实际尺寸。

### Size 结构

```ts
type Size = {
  width: number
  height: number
}
```

### 示例

```tsx
proxy.size.width
proxy.size.height
```

用于动态计算子视图布局，例如宽高比、自适应排版等。

***

## 2. safeAreaInsets

```ts
readonly safeAreaInsets: {
  leading: number
  top: number
  trailing: number
  bottom: number
}
```

当前视图所处环境中的安全区域内边距，包括顶部、底部、左右侧的避让区域。
通常用于避免内容被刘海、Home Indicator 等遮挡。

### 示例用途：

- 内容距离屏幕底部安全区域以上对齐
- 自定义导航栏、工具栏时避免被遮挡
- 实现与设备 UI 边界一致的响应式布局

***

## 3. containerCornerInsets（iOS 26.0+）

```ts
readonly containerCornerInsets: {
  bottomLeading: Size
  bottomTrailing: Size
  topLeading: Size
  topTrailing: Size
} | null
```

该属性仅在 **iOS 26+** 提供，并在设备或容器具有物理圆角偏移时报告每个角落的内边距。

### 用途

- 为圆角窗口、Stage Manager 或分屏环境适配布局
- 在容器圆角内做精确的 UI 对齐

如果平台不支持，则为 `null`。

***

# GeometryReader

```ts
type GeometryReaderProps = {
  children: (proxy: GeometryProxy) => VirtualNode;
};
declare const GeometryReader: FunctionComponent<GeometryReaderProps>;
```

## Props 说明

| 属性名      | 类型                                      | 必须 | 说明                                     |
| -------- | --------------------------------------- | -- | -------------------------------------- |
| children | `(proxy: GeometryProxy) => VirtualNode` | 是  | 构建内容的回调函数，传入 `GeometryProxy` 用于读取布局信息。 |

***

# 工作机制

1. GeometryReader 占据父布局中的位置，并在布局阶段获取当前容器的尺寸与安全区域信息。
2. 将 `GeometryProxy` 注入给 `children(proxy)` 回调。
3. 回调返回的内容将根据读取的信息动态布局。

与 SwiftUI 一样，`GeometryReader` 默认会扩展到可用空间。

***

# 示例：居中布局

```tsx
import { GeometryReader, Text, VStack } from "scripting"

function View() {
  return <GeometryReader>
    {(proxy) => {
      return <VStack
        frame={{
          width: proxy.size.width,
          height: proxy.size.height,
          alignment: "center"
        }}
      >
        <Text>Hello Geometry</Text>
        <Text>
          width: {proxy.size.width}
        </Text>
        <Text>
          height: {proxy.size.height}
        </Text>
      </VStack>
    }}
  </GeometryReader>
}
```

***

# 示例：根据安全区域调整布局

```tsx
<GeometryReader>
  {(proxy) => {
    return <VStack
      padding={{
        top: proxy.safeAreaInsets.top,
        bottom: proxy.safeAreaInsets.bottom
      }}
    >
      <Text>Content inside safe area.</Text>
    </VStack>
  }}
</GeometryReader>
```

***

# 示例（iOS 26+）：读取 containerCornerInsets

```tsx
<GeometryReader>
  {(proxy) => {
    const corners = proxy.containerCornerInsets
    return <Text>
      {corners == null
        ? "Corner insets not available"
        : `Top Leading Corner: ${corners.topLeading.width}, ${corners.topLeading.height}`
      }
    </Text>
  }}
</GeometryReader>
```

***

# 使用建议

- 在需要响应容器尺寸时使用 GeometryReader，例如图片缩放、动态布局、等比布局。
- 避免将大量复杂布局放入 GeometryReader 内，可能影响性能（同 SwiftUI）。



---
url: /zh/guide/Views/Gestures.md
---

# 手势

Scripting 提供了与 SwiftUI 类似的完整手势系统，可为任意视图（如 `<VStack>`、`<HStack>`、`<Text>` 等）添加点击、长按、拖动、缩放、旋转等交互行为。
开发者既可以使用简化的 `onTapGesture` / `onLongPressGesture` / `onDragGesture` 等直接属性，也可以使用新的 `Gesture` 类接口和 `gesture` 修饰符，以获得更灵活的组合方式。

***

## 一、直接手势属性（简化用法）

这些属性提供最直接的交互绑定方式，适合快速使用场景。

***

### 1. `onTapGesture`

在识别到点击手势时执行指定操作。

#### 类型

```ts
onTapGesture?: (() => void) | {
  count: number
  perform: () => void
}
```

#### 参数

| 参数        | 类型           | 默认值 | 说明                |
| --------- | ------------ | --- | ----------------- |
| `count`   | `number`     | `1` | 点击次数（1 为单击，2 为双击） |
| `perform` | `() => void` | —   | 识别到点击后执行的操作       |

#### 示例

```tsx
// 单击触发
<VStack onTapGesture={() => console.log('点击了')} />

// 双击触发
<HStack
  onTapGesture={{
    count: 2,
    perform: () => console.log('双击了')
  }}
/>
```

***

### 2. `onLongPressGesture`

在识别到长按手势时执行操作，可监听按压状态。

#### 类型

```ts
onLongPressGesture?: (() => void) | {
  minDuration?: number
  maxDuration?: number
  perform: () => void
  onPressingChanged?: (state: boolean) => void
}
```

#### 参数

| 参数                  | 类型                         | 默认值     | 说明             |
| ------------------- | -------------------------- | ------- | -------------- |
| `minDuration`       | `number`                   | `500`   | 触发长按所需最短时间（毫秒） |
| `maxDuration`       | `number`                   | `10000` | 长按的最长持续时间（毫秒）  |
| `perform`           | `() => void`               | —       | 长按触发时执行的操作     |
| `onPressingChanged` | `(state: boolean) => void` | —       | 按下或松开时的状态回调    |

#### 示例

```tsx
// 基本用法
<VStack onLongPressGesture={() => console.log('长按触发')} />

// 自定义参数
<HStack
  onLongPressGesture={{
    minDuration: 800,
    maxDuration: 3000,
    perform: () => console.log('长按成功'),
    onPressingChanged: isPressing =>
      console.log(isPressing ? '正在按压' : '已松开')
  }}
/>
```

***

### 3. `onDragGesture`

为视图添加拖动交互，支持实时位置变化与拖动结束事件。

#### 类型

```ts
onDragGesture?: {
  minDistance?: number
  coordinateSpace?: 'local' | 'global'
  onChanged?: (details: DragGestureDetails) => void
  onEnded?: (details: DragGestureDetails) => void
}
```

#### 参数

| 参数                | 类型                                      | 默认值       | 说明           |
| ----------------- | --------------------------------------- | --------- | ------------ |
| `minDistance`     | `number`                                | `10`      | 触发拖动的最小距离（点） |
| `coordinateSpace` | `'local' \| 'global'`                   | `'local'` | 坐标系类型        |
| `onChanged`       | `(details: DragGestureDetails) => void` | —         | 拖动过程中回调      |
| `onEnded`         | `(details: DragGestureDetails) => void` | —         | 拖动结束时回调      |

#### `DragGestureDetails` 类型

```ts
type DragGestureDetails = {
  time: number
  location: Point
  startLocation: Point
  translation: Size
  velocity: Size
  predictedEndLocation: Point
  predictedEndTranslation: Size
}
```

| 字段                        | 说明                  |
| ------------------------- | ------------------- |
| `time`                    | 当前事件时间戳（毫秒）         |
| `location`                | 当前触摸位置 `{x, y}`     |
| `startLocation`           | 拖动起始位置              |
| `translation`             | 从开始拖动至当前的偏移量        |
| `velocity`                | 当前速度（points/second） |
| `predictedEndLocation`    | 预测结束位置              |
| `predictedEndTranslation` | 预测总偏移量              |

#### 示例

```tsx
<VStack
  onDragGesture={{
    minDistance: 5,
    coordinateSpace: 'global',
    onChanged: details => {
      console.log('当前坐标:', details.location)
      console.log('偏移量:', details.translation)
    },
    onEnded: details => {
      console.log('预测结束位置:', details.predictedEndLocation)
    }
  }}
/>
```

***

## 二、Gesture 类接口（高级用法）

若需要更复杂的组合或同时识别多个手势，可使用 `Gesture` 类与 `gesture` 修饰符。

所有手势均返回一个 `GestureInfo` 实例，通过 `.onChanged()` 与 `.onEnded()` 注册事件。

***

### 1. GestureInfo 类

```ts
class GestureInfo<Options, Value> {
  type: string
  options: Options
  onChanged(callback: (value: Value) => void): this
  onEnded(callback: (value: Value) => void): this
}
```

| 方法                     | 说明                  |
| ---------------------- | ------------------- |
| `.onChanged(callback)` | 手势状态变化时调用（如拖动中、缩放中） |
| `.onEnded(callback)`   | 手势结束时调用             |

#### 示例

```tsx
<Text
  gesture={
    TapGesture()
      .onEnded(() => console.log('点击结束'))
  }
/>
```

***

### 2. TapGesture（点击手势）

```ts
declare function TapGesture(count?: number): GestureInfo<number | undefined, void>
```

| 参数      | 类型       | 默认值 | 说明   |
| ------- | -------- | --- | ---- |
| `count` | `number` | `1` | 点击次数 |

#### 示例

```tsx
<Text
  gesture={
    TapGesture(2)
      .onEnded(() => console.log('双击了'))
  }
/>
```

***

### 3. LongPressGesture（长按手势）

```ts
declare function LongPressGesture(options?: LongPressGestureOptions): GestureInfo<LongPressGestureOptions, boolean>

type LongPressGestureOptions = {
  minDuration?: number
  maxDuration?: number
}
```

| 参数            | 默认值   | 说明               |
| ------------- | ----- | ---------------- |
| `minDuration` | 500   | 触发所需的最短时间（毫秒）    |
| `maxDuration` | 10000 | 手指移动前的最长持续时间（毫秒） |

#### 示例

```tsx
<Text
  gesture={
    LongPressGesture({ minDuration: 800 })
      .onChanged(() => console.log('正在长按'))
      .onEnded(() => console.log('长按完成'))
  }
/>
```

***

### 4. DragGesture（拖动手势）

```ts
declare function DragGesture(options?: DragGestureOptions): GestureInfo<DragGestureOptions, DragGestureDetails>

type DragGestureOptions = {
  minDistance?: number
  coordinateSpace?: 'local' | 'global'
}
```

#### 示例

```tsx
<VStack
  gesture={
    DragGesture({ coordinateSpace: 'global' })
      .onChanged(d => console.log('偏移', d.translation))
      .onEnded(d => console.log('速度', d.velocity))
  }
/>
```

***

### 5. MagnifyGesture（缩放手势）

```ts
declare function MagnifyGesture(minScaleDelta?: number | null): GestureInfo<number | null | undefined, MagnifyGestureValue>

type MagnifyGestureValue = {
  time: Date
  magnification: number
  startAnchor: Point
  startLocation: Point
  velocity: number
}
```

#### 示例

```tsx
<Text
  gesture={
    MagnifyGesture(0.05)
      .onChanged(v => console.log('缩放倍率', v.magnification))
      .onEnded(() => console.log('缩放结束'))
  }
/>
```

***

### 6. RotateGesture（旋转手势）

```ts
declare function RotateGesture(minAngleDelta?: Angle | null): GestureInfo<Angle | null | undefined, RotateGestureValue>

type RotateGestureValue = {
  rotation: AngleValue
  velocity: AngleValue
  startAnchor: Point
  time: Date
}

type AngleValue = {
  radians: number
  degrees: number
  magnitude: number
  animatableData: number
}
```

#### 示例

```tsx
<ZStack
  gesture={
    RotateGesture()
      .onChanged(v => console.log('旋转角度', v.rotation.degrees))
      .onEnded(() => console.log('旋转完成'))
  }
/>
```

***

## 三、手势修饰符（Gesture Modifiers）

以下属性可添加在任何视图上，用于控制手势识别行为。

```ts
type GesturesProps = {
  gesture?: GestureProps
  simultaneousGesture?: GestureProps
  highPriorityGesture?: GestureProps
  defersSystemGestures?: EdgeSet
}
```

***

### 1. `gesture`

为视图添加一个手势。

```tsx
<Text
  gesture={
    TapGesture()
      .onEnded(() => console.log('点击'))
  }
/>
```

***

### 2. `highPriorityGesture`

使该手势的识别优先于同视图上的其他手势。

```tsx
<Text
  highPriorityGesture={
    TapGesture(2)
      .onEnded(() => console.log('双击优先'))
  }
/>
```

***

### 3. `simultaneousGesture`

允许多个手势同时识别。

```tsx
<Text
  simultaneousGesture={
    LongPressGesture()
      .onEnded(() => console.log('长按'))
  }
  gesture={
    TapGesture()
      .onEnded(() => console.log('点击'))
  }
/>
```

***

### 4. `defersSystemGestures`

设置屏幕边缘的优先权，使自定义手势优先于系统手势（如返回手势）。

```tsx
<VStack defersSystemGestures="all">
  <Text>边缘手势优先</Text>
</VStack>
```

| 值              | 说明           |
| -------------- | ------------ |
| `'top'`        | 顶部边缘         |
| `'leading'`    | 左边缘（RTL 时为右） |
| `'trailing'`   | 右边缘          |
| `'bottom'`     | 底部边缘         |
| `'horizontal'` | 左右两侧         |
| `'vertical'`   | 上下两侧         |
| `'all'`        | 所有边缘         |

***

## 四、GestureMask（手势优先级控制）

定义当添加多个手势时的优先策略。

```ts
type GestureMask = "all" | "gesture" | "subviews" | "none"
```

| 值            | 说明              |
| ------------ | --------------- |
| `"all"`      | 启用所有手势（默认）      |
| `"gesture"`  | 仅启用当前手势，禁用子视图手势 |
| `"subviews"` | 启用子视图手势，禁用当前手势  |
| `"none"`     | 禁用所有手势          |

#### 示例

```tsx
<VStack
  gesture={{
    gesture: TapGesture().onEnded(() => console.log('Tapped')),
    mask: 'gesture'
  }}
>
  <Text>Tap me</Text>
</VStack>
```

***

## 五、总结对比表

| 手势类型 | 描述      | 对应类函数              | 直接属性                 | 常用回调                          |
| ---- | ------- | ------------------ | -------------------- | ----------------------------- |
| 点击   | 检测单击或多击 | `TapGesture`       | `onTapGesture`       | `.onEnded()`                  |
| 长按   | 检测持续按压  | `LongPressGesture` | `onLongPressGesture` | `.onChanged()` / `.onEnded()` |
| 拖动   | 检测移动轨迹  | `DragGesture`      | `onDragGesture`      | `.onChanged()` / `.onEnded()` |
| 缩放   | 双指缩放    | `MagnifyGesture`   | —                    | `.onChanged()` / `.onEnded()` |
| 旋转   | 双指旋转    | `RotateGesture`    | —                    | `.onChanged()` / `.onEnded()` |



---
url: /zh/guide/Views/Image/index.md
---

# 图像

`Image` 组件用于展示图片，支持来自多种来源的图像，包括系统图标、网络图片、本地文件以及 `UIImage` 对象。同时，它还支持根据浅色 / 深色模式动态切换图片资源，并提供多个视图修饰符用于自定义图像的行为和外观。

***

## **类型定义**

### `ImageResizable`

定义图片的缩放方式：

- **`boolean` 类型**：

  - `true`: 启用默认缩放行为。
  - `false`: 禁用缩放。

- **`object` 类型**：

  - **`capInsets`** _(可选)_: `EdgeInsets`
    设置图片拉伸的边距，用于控制哪些区域被拉伸，哪些保持不变。

  - **`resizingMode`** _(可选)_: `ImageResizingMode`
    设置图片的拉伸模式，例如缩放（stretch）或平铺（tile）。

### `ImageScale`

设置图像在视图中的相对大小：

- `'large'`：较大尺寸
- `'medium'`：中等尺寸
- `'small'`：较小尺寸

### `DynamicImageSource<T>`

用于根据系统的浅色或深色模式动态切换图片资源：

```ts
type DynamicImageSource<T> = {
  dark: T
  light: T
}
```

可用于以下字段：

- `imageUrl`: 网络图片
- `filePath`: 本地图片
- `image`: `UIImage` 对象

***

## **图片来源参数类型**

### `SystemImageProps`

- **`systemName`** _(string, 必填)_
  系统图标名称。可在 [SF Symbols 官网](https://developer.apple.com/design/resources/#sf-symbols) 或 [SF Symbols Browser App](https://apps.apple.com/cn/app/sf-symbols-reference/id1491161336?l=en-GB) 中查看所有图标。

- **`variableValue`** _(number, 可选)_
  一个介于 `0.0` 到 `1.0` 之间的值，用于动态调整支持变量图标的外观。若图标不支持变量值，此项无效。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

### `NetworkImageProps`

- **`imageUrl`** _(string | DynamicImageSource\<string>, 必填)_
  图片的网络 URL 地址。支持使用 `DynamicImageSource` 实现浅色/深色模式下切换图片。

- **`placeholder`** _(VirtualNode, 可选)_
  图片加载完成前显示的占位视图。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

### `FileImageProps`

- **`filePath`** _(string | DynamicImageSource\<string>, 必填)_
  本地图片文件的路径。支持使用 `DynamicImageSource` 动态切换。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

### `UIImageProps`

- **`image`** _(UIImage | DynamicImageSource\<UIImage>, 必填)_
  一个 `UIImage` 对象。支持动态切换 `UIImage` 对象以适应浅色/深色模式。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

***

## **通用视图修饰符（CommonViewProps）**

- **`scaleToFit`** _(boolean, 可选)_
  缩放图像以适配容器大小。

- **`scaleToFill`** _(boolean, 可选)_
  缩放图像以填满容器。

- **`aspectRatio`** _(object, 可选)_
  设置图像宽高比例：

  - **`value`** _(number 或 null, 可选)_：宽高比。为 null 时保持原始比例。
  - **`contentMode`** _(ContentMode, 必填)_：设置是适配（fit）还是填充（fill）。

- **`imageScale`** _(ImageScale, 可选)_
  设置图像缩放等级。可选值：`'large'`、`'medium'`、`'small'`

- **`foregroundStyle`** _(ShapeStyle | DynamicShapeStyle | object, 可选)_
  设置前景样式，可用于系统图标等：

  - **`primary`**：主前景颜色或样式
  - **`secondary`**：辅助前景样式
  - **`tertiary`** _(可选)_：第三前景样式

***

### 图像渲染行为（ImageRenderingBehaviorProps）

| 属性                            | 类型                                      | 默认值          | 说明                                           |
| ----------------------------- | --------------------------------------- | ------------ | -------------------------------------------- |
| `resizable`                   | `boolean \| object`                     | `false`      | 控制图像是否自适应尺寸（详见下方）                            |
| `renderingMode`               | `'original' \| 'template'`              | `'original'` | 设置图像渲染模式，`template` 可使用 `foregroundColor` 着色 |
| `interpolation`               | `'none' \| 'low' \| 'medium' \| 'high'` | `'medium'`   | 设置图像缩放时的插值质量                                 |
| `antialiased`                 | `boolean`                               | `false`      | 是否开启抗锯齿边缘渲染                                  |
| `widgetAccentedRenderingMode` | `WidgetAccentedRenderingMode`           | -            | 控制在 Widget 的强调模式下的图像渲染方式（仅 Widget 有效）        |

***

## **使用示例**

1. **根据浅色/深色模式切换网络图片**

```tsx
<Image
  imageUrl={{
    light: "https://example.com/image-light.png",
    dark: "https://example.com/image-dark.png"
  }}
  placeholder={<Text>加载中...</Text>}
/>
```

2. **本地图片动态切换**

```tsx
<Image
  filePath={{
    light: Path.join(Script.directory, "light.jpg"),
    dark: Path.join(Script.directory, "dark.jpg")
  }}
  resizable={true}
/>
```

3. **UIImage 动态切换**

```tsx
const lightImage = UIImage.fromFile('/path/light.png')
const darkImage = UIImage.fromFile('/path/dark.png')

<Image image={{ light: lightImage, dark: darkImage }} />
```

4. **系统图标，设置缩放和宽高比**

```tsx
<Image
  systemName="square.and.arrow.up.circle"
  scaleToFit={true}
  aspectRatio={{ value: 1.0, contentMode: "fit" }}
  imageScale="medium"
  foregroundStyle={{
    primary: "blue",
    secondary: "gray",
  }}
/>
```

***

## 注意事项

- 通过 `DynamicImageSource` 可以实现根据系统外观自动切换图片资源，适配浅色/深色主题。
- 可以组合使用 `scaleToFit`、`scaleToFill`、`aspectRatio` 等修饰符，灵活控制布局。
- `foregroundStyle` 可用于精细控制图标或图形的配色样式。
- 使用网络图片时请确保 URL 可访问；使用本地路径时确保文件存在。



---
url: /zh/guide/Views/Image/index_example.md
---

# 示例

```tsx
import { Button, Image, List, Markdown, Navigation, NavigationStack, ProgressView, QRImage, Script, Section, Text, VStack } from "scripting"

function View() {
  const dismiss = Navigation.useDismiss()
  const url = "https://github.com"

  return <NavigationStack>
    <List
      navigationTitle={"Image"}
      toolbar={{
        topBarLeading: <Button
          title={"Close"}
          action={dismiss}
        />
      }}
    >

      <Section title={"Network Image"}>
        <Image
          imageUrl={'https://developer.apple.com/assets/elements/icons/swiftui/swiftui-96x96_2x.png'}
          resizable
          scaleToFit
          placeholder={<ProgressView
            progressViewStyle={'circular'}
          />}
        />
      </Section>

      <Section title={"SF Symbol"}>
        <Image
          systemName={"phone"}
          resizable
          scaleToFit
          frame={{
            width: 32,
            height: 32,
          }}
          foregroundStyle={"systemGreen"}
        />
      </Section>

      <Section title={"Local Image"}>
        <Markdown
          content={`\`\`\`tsx
<Image
  filePath={Path.join(Script.directory, "test.jpg")}
/>
\`\`\``}
        />
      </Section>

      <Section title={"QR Code Image"}>
        <VStack>
          <Text>URL: {url}</Text>
          <QRImage
            data={url}
          />
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/FlowLayout.md
---

# 流式布局组件(FlowLayout)

`FlowLayout` 是一种流式布局组件，用于按照水平方向依次排列子视图，当空间不足时会自动换行至下一行。适用于展示一组大小不一的元素，如标签、按钮、图标列表等。

***

## 导入方式

```ts
import { FlowLayout } from "scripting"
```

***

## 属性（Props）

### `spacing?: number`

元素之间的间距（水平与垂直间距），单位为像素。

- 默认值：`8`
- 类型：`number`

用于设置每个子元素之间的间距，若不指定则使用默认间距。

### `children?: VirtualNode | (VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[]`

要显示的子元素集合。

- 支持单个子节点或多个节点
- `undefined` 和 `null` 类型的子元素会被忽略
- 可传入嵌套数组（常见于使用 `map` 渲染）

***

## 示例

### 基本用法

```ts
import { FlowLayout, Text } from "scripting"

export default function Example() {
  return (
    <FlowLayout spacing={12}>
      <Text>标签一</Text>
      <Text>标签二</Text>
      <Text>标签三</Text>
      <Text>标签四</Text>
    </FlowLayout>
  )
}
```

### 搭配数组渲染

```ts
const tags = ["Apple", "Orange", "Banana", "Pear", "Grape"]

export default function TagsExample() {
  return (
    <FlowLayout spacing={6}>
      {tags.map(tag => <Text>{tag}</Text>)}
    </FlowLayout>
  )
}
```

### 使用默认间距

```ts
<FlowLayout>
  <Text>A</Text>
  <Text>B</Text>
  <Text>C</Text>
</FlowLayout>
```

***

## 使用场景示例

适用于以下布局需求：

- 标签集合展示（Tag Cloud）
- 动态宽度按钮组
- 图标/头像流式排列
- 自适应内容容器



---
url: /zh/guide/Views/Layout/Grid/index.md
---

# 网格布局（Grid）

**Scripting 应用**中的 `Grid` 组件提供了一个灵活的容器，用于将子视图排列为二维网格布局。它支持自定义对齐、间距以及嵌套子组件，从而创建美观的布局。

***

### `Grid` 组件

一个容器视图，用于将其他视图排列为二维布局。

### 导入路径

```ts
import { Grid, GridRow } from 'scripting'
```

***

### 类型：`GridProps`

| 属性                  | 类型                                                                                            | 默认值      | 描述                                                                        |
| ------------------- | --------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------- |
| `alignment`         | `Alignment`                                                                                   | `center` | 子视图在每个网格单元格中的对齐方式。可选值包括 `leading`（靠左对齐）、`center`（居中对齐）或 `trailing`（靠右对齐）。 |
| `horizontalSpacing` | `number`                                                                                      | 平台默认值    | 每个单元格之间的水平距离（以点为单位）。如果未设置，则为平台定义的默认值。                                     |
| `verticalSpacing`   | `number`                                                                                      | 平台默认值    | 每个单元格之间的垂直距离（以点为单位）。如果未设置，则为平台定义的默认值。                                     |
| `children`          | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | N/A      | 要在网格中排列的子组件或节点。                                                           |

***

### `GridRow` 组件

`Grid` 的子组件，表示网格布局中的水平行。使用 `GridRow` 可水平分组并对齐网格中的子视图。

***

### 类型：`GridRowProps`

| 属性          | 类型                                                                                            | 默认值      | 描述                                                           |
| ----------- | --------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------ |
| `alignment` | `VerticalAlignment`                                                                           | `center` | 将内容在行内垂直对齐。可选值包括 `top`（顶部对齐）、`center`（居中对齐）或 `bottom`（底部对齐）。 |
| `children`  | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | N/A      | 要在行内水平排列的子组件或节点。                                             |

***

## 使用示例

以下示例展示了如何使用 `Grid` 和 `GridRow` 组件创建包含行、文本、图像和分隔符的布局。

```tsx
<Grid
  alignment="center"
  horizontalSpacing={10}
  verticalSpacing={15}
>
  <GridRow alignment="center">
    <Text>Hello</Text>
    <Image systemName="globe" />
  </GridRow>
  <Divider />
  <GridRow alignment="bottom">
    <Image systemName="hand.wave" />
    <Text>World</Text>
  </GridRow>
</Grid>
```

**输出布局**

- **第一行：** 包含一个 `Text` 元素（“Hello”）和一个显示 `globe` 图标的 `Image`，垂直居中对齐。
- **分隔符：** 分隔两行。
- **第二行：** 包含一个显示 `wave` 图标的 `Image` 和一个 `Text` 元素（“World”），垂直底部对齐。

***

### 属性详细说明

1. **Grid: Alignment（对齐）**
   - 设置每个单元格内内容的对齐方式。
   - 可选值：
     - `leading`：内容对齐到单元格的起始位置。
     - `center`：内容居中对齐（默认值）。
     - `trailing`：内容对齐到单元格的结束位置。
   - 示例：
     ```tsx
     <Grid alignment="leading">
       <GridRow>
         <Text>Aligned to start</Text>
       </GridRow>
     </Grid>
     ```

2. **GridRow: Alignment（行对齐）**
   - 设置每行内容的垂直对齐方式。
   - 可选值：
     - `top`：内容对齐到行顶部。
     - `center`：内容垂直居中（默认值）。
     - `bottom`：内容对齐到行底部。
   - 示例：
     ```tsx
     <Grid>
       <GridRow alignment="top">
         <Text>Top-aligned</Text>
       </GridRow>
       <GridRow alignment="bottom">
         <Text>Bottom-aligned</Text>
       </GridRow>
     </Grid>
     ```

3. **水平和垂直间距**
   - 自定义单元格和行之间的间距。
   - 示例：
     ```tsx
     <Grid horizontalSpacing={5} verticalSpacing={20}>
       <GridRow>
         <Text>Item 1</Text>
         <Text>Item 2</Text>
       </GridRow>
     </Grid>
     ```

4. **Children（子组件）**
   - 接受任意组合的 `VirtualNode` 组件，包括 `Text`、`Image`、`GridRow` 和自定义组件。
   - 支持嵌套数组或空值，以便灵活创建动态布局。

***

## 嵌套组件

`Grid` 和 `GridRow` 组件可与其他支持的 UI 元素无缝结合使用：

- **`Divider`：** 在行之间添加视觉分隔。
- **`Text`、`Image` 和自定义组件：** 可将任意支持的 UI 组件作为 `GridRow` 的子元素。

***

## 图像示例

以下示例展示了输出布局的图像：

![Grid 示例](https://docs-assets.developer.apple.com/published/f20954fd2b30390306220984d444d0cf/Grid-2-iOS@2x.png)

此布局对应前述示例，显示了两行内容及一个分隔符。

***

## 注意事项

- **默认间距：** 水平和垂直间距值针对 iOS 进行了优化，但可根据具体设计需求进行自定义。
- **对齐选项：** 将 `Grid` 的单元格对齐与 `GridRow` 的垂直对齐结合使用，实现精确的布局控制。
- **动态布局：** `Grid` 和 `GridRow` 的灵活性使其适用于具有可变内容的响应式设计。

欢迎尝试使用不同的子组件和间距配置，创建适合您 UI 的定制设计！



---
url: /zh/guide/Views/Layout/Grid/index_example.md
---

# 示例

```tsx
import { Divider, ForEach, Grid, GridRow, Image, List, Navigation, NavigationStack, Rectangle, Script, Section, Text, Toggle, useState, VStack } from "scripting"

function Example() {
  const [gridCellUnsizedAxes, setGridCellUnsizedAxes] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"Grid"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>Grid</Text>
        }
      >
        <Grid>
          <GridRow>
            <Text>Hello</Text>
            <Image systemName={"globe"} />
          </GridRow>
          <GridRow>
            <Image systemName={"hand.wave"} />
            <Text>World</Text>
          </GridRow>
        </Grid>
      </Section>

      <Section
        header={<Text>Grid Divider</Text>}
      >
        <VStack>
          <Toggle
            title={"gridCellUnsizedAxes"}
            value={gridCellUnsizedAxes}
            onChanged={setGridCellUnsizedAxes}
          />
          <Grid>
            <GridRow>
              <Text>Hello</Text>
              <Image systemName={"globe"} />
            </GridRow>
            <Divider
              gridCellUnsizedAxes={gridCellUnsizedAxes
                ? 'horizontal'
                : undefined}
            />
            <GridRow>
              <Image systemName={"hand.wave"} />
              <Text>World</Text>
            </GridRow>
          </Grid>
        </VStack>
      </Section>

      <Section
        header={
          <Text>Column count, cell spacing, alignment</Text>
        }
      >
        <Grid
          alignment={"bottom"}
          verticalSpacing={1}
          horizontalSpacing={1}
        >
          <GridRow>
            <Text>Row 1</Text>
            <ForEach
              count={2}
              itemBuilder={index =>
                <Rectangle
                  fill={"red"}
                  key={index.toString()}
                />
              }
            />
          </GridRow>
          <GridRow>
            <Text>Row 2</Text>
            <ForEach
              count={5}
              itemBuilder={index =>
                <Rectangle
                  fill={"green"}
                  key={index.toString()}
                />
              }
            />
          </GridRow>
          <GridRow>
            <Text>Row 3</Text>
            <ForEach
              count={5}
              itemBuilder={index =>
                <Rectangle
                  fill={"blue"}
                  key={index.toString()}
                />
              }
            />
          </GridRow>
        </Grid>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/HStack/index.md
---

# 水平布局（HStack）

在Scripting应用中，`HStack` 组件提供了一种方便的方法，用于以灵活的对齐和间距选项水平排列视图。此组件是创建需要子视图并排布局的关键工具。

***

## `HStackProps`

### 属性

1. **`alignment`** (可选)
   - **类型**: `VerticalAlignment`
   - **描述**: 指定堆栈中子视图的垂直对齐方式。每个子视图都会根据相同的垂直屏幕坐标对齐。
   - **默认值**: `"center"`
   - **可选值**:
     - `"top"`: 将子视图对齐到顶部边缘。
     - `"center"`: 将子视图对齐到垂直中心。
     - `"bottom"`: 将子视图对齐到底部边缘。
     - `"firstTextBaseline"`: 根据文本的第一个基线对齐子视图。
     - `"lastTextBaseline"`: 根据文本的最后一个基线对齐子视图。
   - **示例**:
     ```tsx
     <HStack alignment="top">
       <Text>Item 1</Text>
       <Text>Item 2</Text>
     </HStack>
     ```

2. **`spacing`** (可选)
   - **类型**: `number`
   - **描述**: 指定相邻子视图之间的间距。如果未提供，堆栈将自动使用默认间距。
   - **默认值**: `undefined`（使用默认间距）
   - **示例**:
     ```tsx
     <HStack spacing={15}>
       <Text>Item 1</Text>
       <Text>Item 2</Text>
     </HStack>
     ```

3. **`children`** (可选)
   - **类型**:
     ```ts
     (VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode | undefined
     ```
   - **描述**: 指定要排列在堆栈中的子视图。可以接受单个子视图、多个子视图或嵌套数组的子视图。
   - **示例**:
     ```tsx
     <HStack>
       <Text>Item 1</Text>
       <Text>Item 2</Text>
       <Text>Item 3</Text>
     </HStack>
     ```

***

## `VerticalAlignment`

`VerticalAlignment` 是一个枚举类型，用于指定子视图在 `HStack` 中的垂直对齐方式。

### 可选值：

- **`"top"`**: 将子视图对齐到顶部边缘。
- **`"center"`**: 将子视图对齐到垂直中心轴。
- **`"bottom"`**: 将子视图对齐到底部边缘。
- **`"firstTextBaseline"`**: 根据文本内容的第一个基线对齐子视图。
- **`"lastTextBaseline"`**: 根据文本内容的最后一个基线对齐子视图。

***

## **`HStack` 组件**

### 描述

`HStack` 组件是一个布局容器，用于将其子视图排列成一条水平线。它提供了垂直对齐选项以及指定子视图之间间距的功能。

### 语法

```tsx
<HStack alignment="center" spacing={10}>
  {children}
</HStack>
```

### 示例 1：基础水平堆栈

```tsx
function Example1() {
  return (
    <HStack>
      <Text>Item 1</Text>
      <Text>Item 2</Text>
      <Text>Item 3</Text>
    </HStack>
  )
}
```

### 示例 2：自定义间距和对齐方式

```tsx
function Example2() {
  return (
    <HStack alignment="bottom" spacing={20}>
      <Text>Aligned Bottom</Text>
      <Text>With Spacing</Text>
    </HStack>
  )
}
```

### 示例 3：复杂的子视图

```tsx
function Example3() {
  return (
    <HStack spacing={10}>
      {[1, 2, 3].map((item) => (
        <Text key={item.toString()}>Item {item}</Text>
      ))}
    </HStack>
  )
}
```

### 注意事项:

- 确保传递给 `HStack` 的所有子组件都是有效的 `VirtualNode` 元素。
- 对于更复杂的布局，可以将 `HStack` 与其他组件如 `VStack` 或 `Spacer` 结合使用。

### 参见：

- `VStack` 用于垂直堆叠视图。
- `Spacer` 用于在堆栈中创建灵活的间距。
- `Text` 用于渲染文本内容。

***

### 图示

以下图示显示了在 `HStack` 中垂直对齐的效果：

![垂直对齐](https://docs-assets.developer.apple.com/published/a63aa800a94319cd283176a8b21bb7af/VerticalAlignment-1-iOS@2x.png)



---
url: /zh/guide/Views/Layout/HStack/index_example.md
---

# 示例

```tsx
import { HStack, Navigation, NavigationStack, Script, Text } from "scripting"

function Example() {
  const list = [0, 1, 2, 3, 4]

  return <NavigationStack>
    <HStack
      navigationTitle={"HStack"}
      alignment={"top"}
      spacing={10}
    >
      {list.map((_, index) =>
        <Text>Item{index + 1}</Text>
      )}
    </HStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/LazyHGrid/index.md
---

# 惰性水平网格布局（LazyHGrid）

`LazyHGrid` 组件是 **Scripting** 应用用户界面库的一部分。它通过可自定义的大小和对齐选项将其子元素排列在网格布局中，仅根据需要创建和显示项目，从而为大型或动态数据集提供了性能优化。

***

## LazyHGrid

### 类型: `FunctionComponent<LazyHGridProps>`

`LazyHGrid` 将其子元素排列在一个水平扩展的网格中。与普通网格不同，它以懒加载方式加载和显示项目，仅在项目即将出现在屏幕上时创建它们。这使其非常适合处理包含大量或动态内容的网格。

***

## LazyHGridProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                    |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | --------------------------------------------------------------------- |
| `rows`        | `GridItem[]`                                                                                  | **必需**            | 定义网格中行的配置，包括其大小和对齐方式。                                                 |
| `alignment`   | `VerticalAlignment`                                                                           | `undefined`       | 控制网格在其父视图中的垂直对齐方式。                                                    |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 网格与其父视图中下一个项目之间的距离。                                                   |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图会固定在父滚动视图的边界内。                                                 |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在网格中显示的内容。接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## GridItem

定义网格中单行的属性。

| 属性          | 类型          | 默认值               | 描述                                |
| ----------- | ----------- | ----------------- | --------------------------------- |
| `alignment` | `Alignment` | `undefined`       | 指定在此行中放置每个子视图时使用的对齐方式。            |
| `spacing`   | `number`    | `undefined`（默认间距） | 此行与下一行之间的间距。                      |
| `size`      | `GridSize`  | **必需**            | 定义行的大小。可以是固定大小，也可以是基于内容的灵活/自适应大小。 |

***

## GridSize

定义网格布局中行或列的大小。

| 类型         | 属性                                           | 描述                                |
| ---------- | -------------------------------------------- | --------------------------------- |
| `number`   | _无_                                          | 行或列的固定大小。                         |
| `adaptive` | `min: number`, `max?: number \|'infinity'`   | 指定一个灵活大小，根据内容进行调整，带有最小值和可选的最大值限制。 |
| `flexible` | `min?: number`, `max?: number \| 'infinity'` | 指定一个动态调整的灵活大小，可以使用可选的最小值和最大值约束。   |

***

## PinnedScrollViews

定义网格中哪些视图会固定在父滚动视图的边界内：

- `'sectionHeaders'`：仅固定节标题
- `'sectionFooters'`：仅固定节页脚
- `'sectionHeadersAndFooters'`：同时固定节标题和页脚

***

## 示例用法

```tsx
import { LazyHGrid, Text } from 'scripting'

const Example = () => {
  const rows = [
    { size: 50 },
    { size: { type: 'adaptive', min: 30, max: 80 } },
    { size: { type: 'flexible', min: 20, max: 'infinity' } }
  ]
  
  return (
    <ScrollView
      axes="horizontal"
    >
      <LazyHGrid 
        rows={rows} 
        alignment="center" 
        spacing={12} 
      >
        <Text>项目 1</Text>
        <Text>项目 2</Text>
        <Text>项目 3</Text>
      </LazyHGrid>
    </ScrollView>
  )
}
```

### 说明：

- 定义了三个具有不同大小的行：
  - 一个大小为 50 的固定行
  - 一个最小大小为 30，最大大小为 80 的自适应行
  - 一个最小大小为 20，无最大大小的灵活行
- 网格在其父视图中垂直居中排列，项目之间的间距为 12 点

***

## 注意事项

- `LazyHGrid` 非常适合处理包含大量或动态内容的水平扩展网格布局
- 使用 `GridSize` 定义基于可用空间的灵活或自适应布局
- `pinnedViews` 属性确保关键视图（如标题或页脚）在滚动过程中始终可见

此 API 为基于网格的水平布局提供了灵活性和性能优化。



---
url: /zh/guide/Views/Layout/LazyHGrid/index_example.md
---

# 示例

```tsx
import { Color, LazyHGrid, Navigation, NavigationStack, RoundedRectangle, Script, ScrollView, Text, useMemo, VStack } from "scripting"

function Example() {
  const colors = useMemo(() => {
    const colors: {
      name: string
      value: Color
    }[] = []

    const numToHex = (n: number) => {
      return n === 0 ? '00' : n.toString(16)
    }

    for (let r = 0x00; r <= 0xff; r += 0x11) {
      for (let g = 0x00; g <= 0xff; g += 0x11) {
        for (let b = 0x00; b <= 0xff; b += 0x11) {
          const name = `${numToHex(r)}${numToHex(g)}${numToHex(b)}`
          const value: Color = `#${name}`
          colors.push({
            name,
            value
          })
        }
      }
    }

    return colors
  }, [])

  return <NavigationStack>
    <ScrollView
      navigationTitle={"LazyHGrid"}
      navigationBarTitleDisplayMode={"inline"}
      axes={"horizontal"}
    >
      <LazyHGrid
        spacing={2}
        rows={[
          { size: 100 },
          { size: 100 },
          { size: 100 },
          { size: 100 },
        ]}
      >
        {colors.map((color) =>
          <VStack>
            <Text>
              {color.name}
            </Text>
            <RoundedRectangle
              fill={color.value}
              cornerRadius={4}
              frame={{
                width: 50,
                height: 50
              }}
            />
          </VStack>
        )}
      </LazyHGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/LazyHStack/index.md
---

# 惰性水平布局（LazyHStack）

`LazyHStack` 组件是 **Scripting** 应用程序用户界面库的一部分。它将其子元素排列在水平堆栈中，仅在需要时创建和显示元素，从而提高了处理大型数据集时的性能。

## LazyHStack

## 类型：`FunctionComponent<LazyHStackProps>`

`LazyHStack` 将其子元素按横向排列在一条线上。与普通的水平堆栈不同，它会懒加载和显示视图，仅在它们即将出现在屏幕上时才创建。这使其非常适合处理大型或动态数据的场景。

***

## LazyHStackProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                     |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | ---------------------------------------------------------------------- |
| `alignment`   | `VerticalAlignment`                                                                           | `undefined`       | 决定子元素在堆栈中的垂直对齐方式。所有子视图共享相同的垂直屏幕坐标。                                     |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 邻近子视图之间的间距。如果设置为 `undefined`，堆栈将使用默认的间距值。                              |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图在滚动过程中固定在滚动视图的边界内。                                              |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在堆栈中显示的内容。可接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## PinnedScrollViews

`PinnedScrollViews` 类型定义了哪些子视图可以在滚动时固定在滚动视图的边界内：

- `'sectionHeaders'`：仅固定节头部。
- `'sectionFooters'`：仅固定节尾部。
- `'sectionHeadersAndFooters'`：同时固定节头部和尾部。

***

## 使用示例

```tsx
import { LazyHStack, Text, ScrollView, Section } from 'scripting'

const Example = () => {
  return (
    <ScrollView
      axes="horizontal"
    >
      <LazyHStack
        alignment="center"
        spacing={10}
        pinnedViews="sectionHeaders"
      >
        {list.map(item =>
          <Section
            key={item.id}
            header={
              <Text>{item.title}</Text>
            }
          >
            <ItemView
              item={item}
            />
          </Section>
        )}
      </LazyHStack>
    </ScrollView>
  )
}
```

### 说明：

- 堆栈以 `10` 点的间距水平排列 `Section` 视图。
- `alignment` 属性使项目在堆栈中垂直居中。
- `pinnedViews` 属性确保节头部在滚动视图滚动时固定在顶部。

***

## 注意事项

- 懒加载通过仅在视图可见时创建视图来提高性能。
- 使用 `spacing` 调整项目之间的距离，使用 `alignment` 控制垂直对齐方式。
- `pinnedViews` 属性特别适用于类似表格的布局，其中头部或尾部需要在滚动时保持可见。

此 API 使您能够高效地处理水平增长的内容，同时提供布局和滚动行为的自定义选项。



---
url: /zh/guide/Views/Layout/LazyHStack/index_example.md
---

# 示例

```tsx
import { ForEach, LazyHStack, Navigation, NavigationStack, Script, ScrollView, Text, VStack } from "scripting"

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"LazyHStack"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <ScrollView
        axes={"horizontal"}
      >
        <LazyHStack
          alignment={"top"}
          spacing={10}
        >
          <ForEach
            count={100}
            itemBuilder={index =>
              <Text
                padding
                background={"systemIndigo"}
                key={index.toString()}
              >Column {index}</Text>
            }
          />
        </LazyHStack>
      </ScrollView>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/LazyVGrid/index.md
---

# 惰性垂直网格布局（LazyVGrid）

`LazyVGrid` 组件是 **Scripting** 应用的用户界面库的一部分。它通过可自定义的大小和对齐选项将其子元素排列在网格布局中。组件仅根据需要创建和显示项目，从而为处理大型或动态数据集提供了性能优化。

***

## LazyVGrid

### 类型: `FunctionComponent<LazyVGridProps>`

`LazyVGrid` 将其子元素排列在一个垂直扩展的网格中。与普通网格不同，它以懒加载方式加载和显示项目，仅在项目即将出现在屏幕上时创建它们。这使其非常适合处理包含大量或动态内容的网格。

***

## LazyVGridProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                    |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | --------------------------------------------------------------------- |
| `columns`     | `GridItem[]`                                                                                  | **必需**            | 定义网格中列的配置，包括其大小和对齐方式。                                                 |
| `alignment`   | `HorizontalAlignment`                                                                         | `undefined`       | 控制网格在其父视图中的水平对齐方式。                                                    |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 相邻网格项之间的距离。如果设置为 `undefined`，网格将使用默认间距值。                              |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图会固定在父滚动视图的边界内。                                                 |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在网格中显示的内容。接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## GridItem

定义网格中单列的属性。

| 属性          | 类型          | 默认值               | 描述                                |
| ----------- | ----------- | ----------------- | --------------------------------- |
| `alignment` | `Alignment` | `undefined`       | 指定在此列中放置每个子视图时使用的对齐方式。            |
| `spacing`   | `number`    | `undefined`（默认间距） | 此列与下一列之间的间距。                      |
| `size`      | `GridSize`  | **必需**            | 定义列的大小。可以是固定大小，也可以是基于内容的灵活/自适应大小。 |

***

## GridSize

定义网格布局中行或列的大小。

| 类型         | 属性                                           | 描述                                |
| ---------- | -------------------------------------------- | --------------------------------- |
| `number`   | _无_                                          | 行或列的固定大小。                         |
| `adaptive` | `min: number`, `max?: number \| 'infinity'`  | 指定一个灵活大小，根据内容进行调整，带有最小值和可选的最大值限制。 |
| `flexible` | `min?: number`, `max?: number \| 'infinity'` | 指定一个动态调整的灵活大小，可以使用可选的最小值和最大值约束。   |

***

## PinnedScrollViews

定义网格中哪些视图会固定在父滚动视图的边界内：

- `'sectionHeaders'`：仅固定节标题
- `'sectionFooters'`：仅固定节页脚
- `'sectionHeadersAndFooters'`：同时固定节标题和页脚

***

## 示例用法

```tsx
import { LazyVGrid, Text } from 'scripting'

const Example = () => {
  const columns = [
    { size: 50 },
    { size: { type: 'adaptive', min: 40, max: 100 } },
    { size: { type: 'flexible', min: 30, max: 'infinity' } }
  ]

  return (
    <ScrollView>
      <LazyVGrid
        columns={columns}
        alignment="leading"
        spacing={16}
      >
        <Text>项目 1</Text>
        <Text>项目 2</Text>
        <Text>项目 3</Text>
      </LazyVGrid>
    </ScrollView>
  )
}
```

### 说明：

- 定义了三个具有不同大小的列：
  - 一个大小为 50 的固定列
  - 一个最小大小为 40，最大大小为 100 的自适应列
  - 一个最小大小为 30，无最大大小的灵活列
- 网格与其父视图的起始边对齐，项目之间的间距为 16 点

***

## 注意事项

- `LazyVGrid` 非常适合处理包含大量或动态内容的垂直扩展网格布局
- 使用 `GridSize` 定义基于可用空间的灵活或自适应布局
- `pinnedViews` 属性确保关键视图（如标题或页脚）在滚动过程中始终可见

此 API 为基于网格的垂直布局提供了灵活性和性能优化。



---
url: /zh/guide/Views/Layout/LazyVGrid/index_example.md
---

# 示例

```tsx
import { Color, LazyVGrid, Navigation, NavigationStack, RoundedRectangle, Script, ScrollView, Text, useMemo, VStack } from "scripting"

function Example() {
  const colors = useMemo(() => {
    const colors: {
      name: string
      value: Color
    }[] = []

    const numToHex = (n: number) => {
      return n === 0 ? '00' : n.toString(16)
    }

    for (let r = 0x00; r <= 0xff; r += 0x11) {
      for (let g = 0x00; g <= 0xff; g += 0x11) {
        for (let b = 0x00; b <= 0xff; b += 0x11) {
          const name = `${numToHex(r)}${numToHex(g)}${numToHex(b)}`
          const value: Color = `#${name}`
          colors.push({
            name,
            value
          })
        }
      }
    }

    return colors
  }, [])

  return <NavigationStack>
    <ScrollView
      navigationTitle={"LazyVGrid"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <LazyVGrid
        spacing={2}
        columns={[
          { size: 100 },
          { size: 100 },
          { size: 100 },
          { size: 100 },
        ]}
      >
        {colors.map((color) =>
          <VStack>
            <Text>
              {color.name}
            </Text>
            <RoundedRectangle
              fill={color.value}
              cornerRadius={4}
              frame={{
                width: 50,
                height: 50
              }}
            />
          </VStack>
        )}
      </LazyVGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/LazyVStack/index.md
---

# 惰性垂直布局（LazyVStack）

`LazyVStack` 组件是 **Scripting** 应用用户界面库的一部分。它将子元素排列在垂直堆叠中，仅根据需要创建和显示项目，从而为大型数据集提供了性能优化。

***

## LazyVStack

### 类型: `FunctionComponent<LazyVStackProps>`

`LazyVStack` 将其子元素排列成一个垂直扩展的线性布局。与普通垂直堆叠不同，它仅在视图即将出现在屏幕上时懒加载和显示内容。这使其非常适合处理列表或动态生成的大量内容。

***

## LazyVStackProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                    |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | --------------------------------------------------------------------- |
| `alignment`   | `HorizontalAlignment`                                                                         | `undefined`       | 确定子元素在堆叠中如何水平对齐。所有子视图共享相同的水平屏幕坐标。                                     |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 相邻子视图之间的距离。如果设置为 `undefined`，堆叠将使用默认间距值。                              |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图在滚动期间固定在滚动视图的边界内。                                              |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在堆叠中显示的内容。接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## PinnedScrollViews

`PinnedScrollViews` 类型定义了哪些类型的子视图可以在滚动期间固定在滚动视图的边界内：

- `'sectionHeaders'`：仅固定节标题
- `'sectionFooters'`：仅固定节页脚
- `'sectionHeadersAndFooters'`：同时固定节标题和页脚

***

## 示例用法

```tsx
import { LazyVStack, Text, ScrollView, Section } from 'scripting'

const Example = () => {
  return (
    <ScrollView>
      <LazyVStack alignment="leading" spacing={12} pinnedViews="sectionHeaders">
        {list.map(item => 
          <Section
            key={item.id}
            header={
              <Text>{item.title}</Text>
            }
          >
            <ItemView
              item={item}
            />
          </Section>
        )}
      </LazyVStack>
    </ScrollView>
  )
}
```

### 说明：

- 堆叠以 `12` 点的间距将 `Section` 视图垂直排列
- `alignment` 属性将项目对齐到堆叠的起始边
- `pinnedViews` 属性确保节标题在滚动视图顶部保持固定状态

***

## 注意事项

- 懒加载确保仅在视图变得可见时创建视图，从而提高大型内容的性能
- 使用 `spacing` 控制项目之间的垂直距离，使用 `alignment` 自定义水平对齐
- `pinnedViews` 属性对于具有粘性标题或页脚的表格或列表布局特别有用

此 API 允许您高效管理垂直增长的内容，同时提供布局和滚动行为的定制选项。



---
url: /zh/guide/Views/Layout/LazyVStack/index_example.md
---

# 示例

```tsx
import { HStack, LazyVStack, Navigation, NavigationStack, Script, ScrollView, Section, Spacer, Text, useMemo } from "scripting"

function Example() {
  const groups = useMemo(() => {
    const groups: {
      name: string
      items: number[]
    }[] = []

    for (let i = 1; i < 10; i++) {
      const list: {
        name: string
        items: number[]
      } = {
        name: "Group " + i,
        items: []
      }

      for (let j = 0; j < 10; j++) {
        list.items.push(i * 10 + j)
      }

      groups.push(list)
    }

    return groups
  }, [])

  return <NavigationStack>
    <ScrollView
      navigationTitle={"LazyVStack"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <LazyVStack
        alignment={"leading"}
        spacing={10}
        pinnedViews={"sectionHeaders"}
      >
        {groups.map(group =>
          <Section
            header={
              <HStack
                background={"purple"}
              >
                <Text>{group.name}</Text>
                <Spacer />
              </HStack>
            }
          >
            {group.items.map(item =>
              <Text>Row {item}</Text>
            )}
          </Section>
        )}
      </LazyVStack>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/VStack/index.md
---

# 垂直布局（VStack）

在Scripting 应用程序中，`VStack` 组件是一个布局视图，用于垂直排列其子视图。它提供了灵活的选项，用于调整子视图的对齐方式以及控制它们之间的间距。

***

## **`VStack` 组件**

### **类型声明**

```ts
declare const VStack: FunctionComponent<VStackProps>
```

### **描述**

`VStack` 组件会将其子视图垂直排列，非常适合创建垂直堆叠的布局。您可以根据设计需求，自定义子视图的对齐方式和它们之间的间距。

***

## **属性**

### `alignment` （可选）

- **类型**: `HorizontalAlignment`
- **默认值**: `"center"`
- **描述**: 确定堆栈中子视图的水平对齐方式。对齐方式指定了垂直排列的视图如何在水平方向上相互定位。
- **可接受的值**:
  - `"leading"`：将视图向左对齐。
  - `"center"`：将视图水平居中对齐。
  - `"trailing"`：将视图向右对齐。

#### **示例**

```tsx
<VStack alignment="leading">
  <Text>左对齐</Text>
  <Text>另一个项目</Text>
</VStack>
```

***

### `spacing` （可选）

- **类型**: `number | undefined`
- **默认值**: 如果未指定，则会根据子视图自动计算。
- **描述**: 设置相邻子视图之间的距离（像素）。使用 `undefined` 时，堆栈将自动确定最佳间距。

#### **示例**

```tsx
<VStack spacing={10}>
  <Text>项目 1</Text>
  <Text>项目 2</Text>
</VStack>
```

***

### `children` （可选）

- **类型**:
  ```ts
  (VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode | undefined
  ```
- **描述**: 堆栈中显示的子元素。您可以传递单个元素、元素数组或 `undefined`/`null` 值。`null` 和 `undefined` 值会被忽略，从而支持动态布局。

#### **示例**

```tsx
<VStack>
  <Text>第一个项目</Text>
  <Image systemName="star" />
</VStack>
```

***

## **`HorizontalAlignment` 类型**

水平对齐控制了当视图在 `VStack` 中垂直排列时，如何在水平方向上相互定位。

### **类型声明**

```ts
type HorizontalAlignment = 'leading' | 'center' | 'trailing'
```

### **对齐选项**

- **`leading`**：将所有子视图与堆栈的左边缘对齐。
- **`center`**：将所有子视图水平居中对齐。
- **`trailing`**：将所有子视图与堆栈的右边缘对齐。

### **视觉指南**

以下是三种对齐选项的示例图：

![水平对齐](https://docs-assets.developer.apple.com/published/cb8ad6030a1ebcfee545d02f406500ee/HorizontalAlignment-1-iOS@2x.png)

***

## **使用示例**

```tsx
<VStack alignment="leading" spacing={10}>
  <Image systemName="globe" />
  <Text>左对齐项目</Text>
  <Text>另一个项目</Text>
</VStack>
```

### **解释**

1. **`alignment="leading"`**：将所有子视图左对齐。
2. **`spacing={10}`**：为每个子视图之间添加 10 像素的间距。
3. 包含两个子视图：
   - 一个显示系统图标的 `Image` 视图。
   - 两个显示标签项目的 `Text` 视图。

***

## **最佳实践**

1. 使用 `alignment` 来控制堆叠文本和图标的水平定位，以实现更好的视觉一致性。
2. 利用 `spacing` 创建间距合理、视觉美观的布局。
3. 动态或条件性地传递子元素时，无需担心 `null` 或 `undefined` 值。

通过本指南，您可以自信地使用 `VStack` 组件，在Scripting 应用项目中创建清晰的垂直堆叠布局。



---
url: /zh/guide/Views/Layout/VStack/index_example.md
---

# 示例

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function Example() {
  const list = [0, 1, 2, 3, 4]

  return <NavigationStack>
    <VStack
      navigationTitle={"VStack"}
      alignment={"leading"}
      spacing={10}
    >
      {list.map((_, index) =>
        <Text>Item{index + 1}</Text>
      )}
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Layout/ZStack/index.md
---

# ZStack

`ZStack` 组件在 Scripting 应用中用于将子视图以层叠堆栈的形式排列。它支持通过预定义的对齐指南，在 x 和 y 轴上灵活地对齐这些图层。

***

## `ZStackProps`

`ZStack` 组件接受以下属性：

| 属性          | 类型                                                                                            | 默认值         | 描述                        |
| ----------- | --------------------------------------------------------------------------------------------- | ----------- | ------------------------- |
| `alignment` | `Alignment`（可选）                                                                               | `"center"`  | 决定子视图在 x 轴和 y 轴上的对齐方式。    |
| `children`  | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined` | 要在堆栈中显示的子组件。可以是单个节点或节点数组。 |

***

## `Alignment`

`Alignment` 类型定义了一组常用的对齐方式，用于堆叠视图。这些对齐方式结合了水平和垂直方向的对齐指南。下图展示了这些对齐方式：

![Alignment](https://docs-assets.developer.apple.com/published/09693fd98ab76356519a900fd33d9e7f/Alignment-1-iOS@2x.png)

### 支持的值：

| 值                             | 描述                      |
| ----------------------------- | ----------------------- |
| `"top"`                       | 将视图对齐到堆栈的顶部边缘。          |
| `"center"`                    | 在水平和垂直轴上将视图居中对齐。        |
| `"bottom"`                    | 将视图对齐到堆栈的底部边缘。          |
| `"leading"`                   | 将视图对齐到主边缘（在从左到右布局中为左侧）。 |
| `"trailing"`                  | 将视图对齐到尾边缘（在从左到右布局中为右侧）。 |
| `"bottomLeading"`             | 将视图对齐到左下角。              |
| `"bottomTrailing"`            | 将视图对齐到右下角。              |
| `"centerFirstTextBaseline"`   | 使用第一个文本基线在中心对齐视图。       |
| `"centerLastTextBaseline"`    | 使用最后一个文本基线在中心对齐视图。      |
| `"leadingFirstTextBaseline"`  | 使用第一个文本基线对齐到主边缘。        |
| `"leadingLastTextBaseline"`   | 使用最后一个文本基线对齐到主边缘。       |
| `"topLeading"`                | 将视图对齐到左上角。              |
| `"topTrailing"`               | 将视图对齐到右上角。              |
| `"trailingFirstTextBaseline"` | 使用第一个文本基线对齐到尾边缘。        |
| `"trailingLastTextBaseline"`  | 使用最后一个文本基线对齐到尾边缘。       |

***

## `ZStack` 组件

`ZStack` 是一个函数组件，用于将其子元素以层叠堆栈的形式排列。每个子元素的位置相对于 `alignment` 属性中定义的对齐方式。

### 导入组件

要使用 `ZStack` 组件，请确保从 Scripting 应用的 `scripting` 包中导入它：

```tsx
import { ZStack } from 'scripting'
```

***

## 示例用法

### 1. 基础示例

将子视图对齐到顶部：

```tsx
<ZStack alignment="top">
  <Image systemName="globe" />
  <Text>
    Hello world.
  </Text>
</ZStack>
```

### 2. 高级对齐

使用复杂的对齐方式（如 `bottomLeading`）定位子元素：

```tsx
<ZStack alignment="bottomLeading">
  <Rectangle fill="gray" />
  <Text>
    Bottom Leading Text
  </Text>
</ZStack>
```

### 3. 嵌套 `ZStack` 示例

将 `ZStack` 与其他布局组件结合以实现复杂布局：

```tsx
<ZStack alignment="center">
  <Rectangle fill="blue" />
  <ZStack alignment="topTrailing">
    <Image systemName="star" />
    <Text>
      Nested ZStack
    </Text>
  </ZStack>
</ZStack>
```

***

## 注意事项

- **性能考虑**：避免向 `ZStack` 添加过多的子视图，以免在复杂布局中导致潜在的性能瓶颈。
- **组合布局**：将 `ZStack` 与其他组件（如 `VStack` 和 `HStack`）结合使用，以创建灵活动态的用户界面。



---
url: /zh/guide/Views/Layout/ZStack/index_example.md
---

# 示例

```tsx
import { Button, Circle, Color, List, Navigation, NavigationLink, NavigationStack, Rectangle, Script, Section, Text, VStack, ZStack } from "scripting"

function Example() {
  const colors: Color[] = [
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "purple",
  ]

  return <NavigationStack>
    <List
      navigationTitle={"ZStack"}
    >
      <Section
        header={
          <Text
            textCase={null}
          >ZStack</Text>
        }
      >
        <ZStack>
          {colors.map((color, index) =>
            <Rectangle
              fill={color}
              frame={{
                width: 100,
                height: 100,
              }}
              offset={{
                x: index * 10,
                y: index * 10
              }}
            />
          )}
        </ZStack>
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >background</Text>
        }
      >
        <Text
          background={{
            content: <Rectangle
              fill={"systemBlue"}
              frame={{
                width: 100,
                height: 50,
              }}
            />,
            alignment: "center",
          }}
        >Hello Scripting!</Text>
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >overlay</Text>
        }
      >
        <Circle
          fill={"yellow"}
          frame={{
            width: 100,
            height: 100,
          }}
          overlay={{
            content: <Rectangle
              fill={"blue"}
              frame={{
                width: 50,
                height: 50,
              }}
            />,
            alignment: "center"
          }}
        />
      </Section>

      <Section
        title={"containerBackground (iOS 18.0+)"}
      >
        <Button
          title={"Present"}
          action={() => {
            Navigation.present({
              element: <ContainerBackgroundExample />,
              modalPresentationStyle: "pageSheet"
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

function ContainerBackgroundExample() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"containerBackground"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />,
      }}
    >
      <NavigationLink
        title={"Red Page"}
        destination={
          <VStack
            navigationContainerBackground={"red"}
            frame={{
              maxWidth: 'infinity',
              maxHeight: 'infinity'
            }}
          >
            <Text>A red page</Text>
          </VStack>
        }
      />
      <NavigationLink
        title={"Blue Page"}
        destination={
          <VStack
            navigationContainerBackground={"blue"}
            frame={{
              maxWidth: 'infinity',
              maxHeight: 'infinity'
            }}
          >
            <Text>A blue page</Text>
          </VStack>
        }
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Link.md
---

# 链接

`Link` 组件用于创建可点击的控件，点击后可跳转到指定的 URL。该组件可用于打开网页、App 内自定义 URL Scheme，或其他支持的链接类型。

> **注意**：如果在小组件中使用 `Link`，则会忽略 `widgetURL` 修饰符的设置。

### 属性说明

| 属性名        | 类型                        | 说明                      |
| ---------- | ------------------------- | ----------------------- |
| `url`      | `string`                  | 点击后要跳转的目标链接地址。          |
| `children` | `string` \| `VirtualNode` | 展示在链接中的内容，可以是纯文本或自定义布局。 |

### 示例

```tsx
<Link url={Script.createOpenURLScheme('Script A')}>
  打开脚本 A
</Link>

<Link url="https://example.com">
  <HStack>
    <Image
      systemName="globe"
      width={20}
      height={20}
      padding={{ trailing: 8 }}
    />
    <Text>打开链接</Text>
  </HStack>
</Link>
```

该组件支持使用纯文本作为子内容，也可以使用复杂的布局作为子节点。点击链接后，会根据 URL 类型打开相应的页面（如 Safari、其他 App 或自定义处理程序）。



---
url: /zh/guide/Views/List/DisclosureGroup/index.md
---

# 展开组

`DisclosureGroup` 组件用于将相关内容组织为可展开/折叠的区域。它非常适合在列表中分组展示具有层级结构或可选显示的内容。

本示例展示如何创建一个顶层的 DisclosureGroup，以及如何嵌套子组来构建多层结构。同时结合按钮和切换开关（Toggle）进行交互控制。

***

## 概览

你将学习如何：

- 使用 `DisclosureGroup` 创建可折叠的内容区域
- 绑定展开状态到本地组件状态
- 嵌套多个 DisclosureGroup 以展示层级结构
- 与 `Toggle`、`Text`、`Button` 等其他视图组合使用

***

## 示例代码

### 1. 导入依赖模块

```tsx
import { Button, DisclosureGroup, List, Navigation, NavigationStack, Script, Text, Toggle, useState } from "scripting"
```

### 2. 定义组件状态

通过 `useState` 管理展开状态以及两个切换项的值：

```tsx
const [topExpanded, setTopExpanded] = useState(true)
const [oneIsOn, setOneIsOn] = useState(false)
const [twoIsOn, setTwoIsOn] = useState(true)
```

### 3. 使用 DisclosureGroup 构建界面

该界面包含一个 `List`，位于 `NavigationStack` 中。通过 `Button` 控制顶层 DisclosureGroup 的展开状态。组内包含多个切换项，并嵌套一个子组：

```tsx
return <NavigationStack>
  <List
    navigationTitle={"DislcosureGroup"}
    navigationBarTitleDisplayMode={"inline"}
  >
    <Button
      title={"Toggle expanded"}
      action={() => setTopExpanded(!topExpanded)}
    />
    <DisclosureGroup
      title={"Items"}
      isExpanded={topExpanded}
      onChanged={setTopExpanded}
    >
      <Toggle
        title={"Toggle 1"}
        value={oneIsOn}
        onChanged={setOneIsOn}
      />
      <Toggle
        title={"Toggle 2"}
        value={twoIsOn}
        onChanged={setTwoIsOn}
      />
      <DisclosureGroup
        title={"Sub-items"}
      >
        <Text>Sub-item 1</Text>
      </DisclosureGroup>
    </DisclosureGroup>
  </List>
</NavigationStack>
```

### 4. 展示页面并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键概念

- **DisclosureGroup**：一个可展开的容器视图，用于隐藏或显示内部内容。
- **isExpanded**：用于绑定展开状态，控制 DisclosureGroup 的展开或折叠。
- **onChanged**：当用户点击展开或折叠时触发的回调函数。
- **嵌套支持**：DisclosureGroup 支持嵌套使用，可构建多层内容。
- **组件组合**：可与 `Toggle`、`Text`、`Button` 等组件灵活组合，构建交互界面。

***

## 应用场景

- 将设置项分组管理，提升可读性
- 构建可展开的问答、功能列表或信息面板
- 显示具有层级结构的数据，如文件夹、分类、过滤器等

通过 DisclosureGroup，你可以在滚动列表中以清晰且用户友好的方式组织复杂或可选内容。



---
url: /zh/guide/Views/List/DisclosureGroup/index_example.md
---

# 示例

```tsx
import { Button, DisclosureGroup, List, Navigation, NavigationStack, Script, Text, Toggle, useState } from "scripting"

function Example() {
  const [topExpanded, setTopExpanded] = useState(true)
  const [oneIsOn, setOneIsOn] = useState(false)
  const [twoIsOn, setTwoIsOn] = useState(true)

  return <NavigationStack>
    <List
      navigationTitle={"DislcosureGroup"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Button
        title={"Toggle expanded"}
        action={() => setTopExpanded(!topExpanded)}
      />
      <DisclosureGroup
        title={"Items"}
        isExpanded={topExpanded}
        onChanged={setTopExpanded}
      >
        <Toggle
          title={"Toggle 1"}
          value={oneIsOn}
          onChanged={setOneIsOn}
        />
        <Toggle
          title={"Toggle 2"}
          value={twoIsOn}
          onChanged={setTwoIsOn}
        />

        <DisclosureGroup
          title={"Sub-items"}
        >
          <Text>Sub-item 1</Text>
        </DisclosureGroup>
      </DisclosureGroup>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/List/Display data inside a row/index.md
---

# 在行中显示数据

本示例展示如何使用 `List` 组件，通过自定义的行布局来展示结构化数据。每一行显示一个人的姓名和电话号码，布局清晰，排版整洁，采用了 SwiftUI 风格的堆叠式组件。

## 概览

你将学到如何：

- 定义自定义的行组件（`PersonRowView`）
- 使用 `List` 展示数据集合
- 应用文本样式和系统图标
- 使用 `VStack` 和 `HStack` 进行布局排版

***

## 示例代码

### 1. 导入依赖并定义数据类型

```tsx
import { HStack, Label, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

type Person = {
  name: string
  phoneNumber: string
}
```

### 2. 创建行组件

`PersonRowView` 是用于渲染单行内容的组件。它使用纵向堆叠将姓名与电话号码分隔，并使用适当的字体样式和颜色来区分信息层级。

```tsx
function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}
```

### 3. 在导航堆栈中展示列表

使用 `NavigationStack` 和 `List` 来展示所有的行。你可以设置导航栏标题以说明视图内容。

```tsx
function Example() {
  const staff: Person[] = [
    {
      name: "Juan Chavez",
      phoneNumber: "(408) 555-4301",
    },
    {
      name: "Mei Chen",
      phoneNumber: "(919) 555-2481"
    }
  ]

  return <NavigationStack>
    <List
      navigationTitle={"Display data inside a row"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {staff.map(person =>
        <PersonRowView
          person={person}
        />
      )}
    </List>
  </NavigationStack>
}
```

### 4. 展示界面并退出脚本

使用 `Navigation.present` 弹出该页面视图，并在页面关闭后退出脚本。

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 总结

本示例展示了如何**在行中展示数据**，核心要点包括：

- 使用 `VStack` 和 `HStack` 构建布局结构
- 定义可复用的类型化行组件
- 使用 `List` 渲染结构化的数据集合
- 搭配图标和标签增强可读性和视觉效果

适用于联系人列表、搜索结果、记录信息等多种数据展示场景，支持灵活扩展与样式自定义。



---
url: /zh/guide/Views/List/Display data inside a row/index_example.md
---

# 示例

```tsx
import { HStack, Label, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

type Person = {
  name: string
  phoneNumber: string
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  const staff: Person[] = [
    {
      name: "Juan Chavez",
      phoneNumber: "(408) 555-4301",
    },
    {
      name: "Mei Chen",
      phoneNumber: "(919) 555-2481"
    }
  ]

  return <NavigationStack>
    <List
      navigationTitle={"Display data inside a row"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {staff.map(person =>
        <PersonRowView
          person={person}
        />
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/List/Editable List/index.md
---

# 可编辑列表

本示例展示如何在 Scripting 应用中使用 `List`、`ForEach` 和 `EditButton` 组件构建一个支持 **删除与排序操作** 的可编辑列表。

***

## 概览

你将学习如何：

- 使用 `ForEach` 渲染动态列表项
- 实现列表项的删除和拖动排序功能
- 使用 `EditButton` 启用编辑模式
- 通过 `useState` 管理列表的状态

***

## 示例代码

### 1. 导入所需模块

```tsx
import { Color, EditButton, ForEach, List, Navigation, NavigationStack, Script, Text, useState } from "scripting"
```

### 2. 定义组件状态

使用 `useState` 初始化颜色字符串数组作为列表数据：

```tsx
const [colors, setColors] = useState<Color[]>([
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "purple",
])
```

### 3. 处理删除操作

`onDelete` 方法根据传入的索引数组移除对应的列表项：

```tsx
function onDelete(indices: number[]) {
  setColors(colors.filter((_, index) => !indices.includes(index)))
}
```

### 4. 处理拖动排序操作

`onMove` 方法将被拖动的元素插入至目标位置：

```tsx
function onMove(indices: number[], newOffset: number) {
  const movingItems = indices.map(index => colors[index])
  const newColors = colors.filter((_, index) => !indices.includes(index))
  newColors.splice(newOffset, 0, ...movingItems)
  setColors(newColors)
}
```

### 5. 构建可编辑列表界面

主界面使用 `NavigationStack` 和 `List` 构建，并通过 `toolbar` 添加 `EditButton` 实现编辑模式：

```tsx
return <NavigationStack>
  <List
    navigationTitle={"Editable List"}
    navigationBarTitleDisplayMode={"inline"}
    toolbar={{
      confirmationAction: [
        <EditButton />,
      ]
    }}
  >
    <ForEach
      count={colors.length}
      itemBuilder={index =>
        <Text
          key={colors[index]} // 每项必须提供唯一 key
        >{colors[index]}</Text>
      }
      onDelete={onDelete}
      onMove={onMove}
    />
  </List>
</NavigationStack>
```

### 6. 启动视图并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

- **List**：用于展示可滚动的列表视图。
- **ForEach**：根据指定数量动态渲染子视图。
- **EditButton**：切换列表的编辑模式，支持删除和排序操作。
- **onDelete / onMove**：在用户删除或拖动项时调用的回调函数。
- **useState**：用于追踪和更新当前的列表数据。

***

## 注意事项

- `ForEach` 中的每个子项必须提供唯一的 `key`，以确保视图更新正常。
- 仅在编辑模式下才能进行删除和排序操作，需通过 `EditButton` 启用。

***

## 适用场景

- 可排序的任务列表或待办事项
- 支持编辑的设置项集合
- 根据用户输入动态更新的内容展示

该示例为你创建交互式脚本或工具提供了灵活的列表功能模板。



---
url: /zh/guide/Views/List/Editable List/index_example.md
---

# 示例

```tsx
import { Color, EditButton, ForEach, List, Navigation, NavigationStack, Script, Text, useState } from "scripting"

function Example() {
  const [colors, setColors] = useState<Color[]>([
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "purple",
  ])

  function onDelete(indices: number[]) {
    setColors(colors.filter((_, index) => !indices.includes(index)))
  }

  function onMove(indices: number[], newOffset: number) {
    const movingItems = indices.map(index => colors[index])
    const newColors = colors.filter((_, index) => !indices.includes(index))
    newColors.splice(newOffset, 0, ...movingItems)
    setColors(newColors)
  }

  return <NavigationStack>
    <List
      navigationTitle={"Editable List"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        confirmationAction: [
          <EditButton />,
        ]
      }}
    >
      <ForEach
        count={colors.length}
        itemBuilder={index =>
          <Text
            key={colors[index]} // Must provide a unique key!!!
          >{colors[index]}</Text>
        }
        onDelete={onDelete}
        onMove={onMove}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/List/List interaction/index.md
---

# 列表交互

本示例展示如何在 **Scripting** 应用中通过左右滑动手势为 `List` 列表项添加交互操作。借助 `leadingSwipeActions` 和 `trailingSwipeActions`，你可以实现诸如标记未读、删除、标记重点等常见功能。

***

## 概览

你将学会如何：

- 使用自定义单元格显示消息列表
- 为列表项添加左右滑动手势操作
- 配置滑动行为（例如禁止全滑触发）
- 结合 `Button`、`Label`、`Circle` 等组件构建交互界面

***

## 示例代码

### 1. 定义消息数据类型

```ts
type Message = {
  from: string
  content: string
  isUnread: boolean
}
```

### 2. 创建自定义消息单元格组件

使用 `HStack` 和 `VStack` 展示每条消息的状态指示点、发件人和内容。

```tsx
function MessageCell({
  message
}: {
  message: Message
}) {
  return <HStack>
    <Circle
      fill={message.isUnread ? "systemBlue" : "clear"}
      frame={{
        width: 16,
        height: 16,
      }}
    />
    <VStack alignment={"leading"}>
      <Text font={"headline"}>{message.from}</Text>
      <Text>{message.content}</Text>
    </VStack>
  </HStack>
}
```

### 3. 管理列表状态与操作

```tsx
const [messages, setMessages] = useState<Message[]>(...)

function toggleUnread(message: Message) {
  setMessages(messages.map(item =>
    item !== message ? item : { ...message, isUnread: !item.isUnread }
  ))
}

function deleteMessage(message: Message) {
  setMessages(messages.filter(item => item !== message))
}
```

### 4. 构建带滑动交互的列表视图

```tsx
return <NavigationStack>
  <List
    navigationTitle={"Messages"}
    navigationBarTitleDisplayMode={"inline"}
    listStyle={"inset"}
  >
    {messages.map(message =>
      <MessageCell
        message={message}
        leadingSwipeActions={{
          allowsFullSwipe: false,
          actions: [
            <Button
              action={() => toggleUnread(message)}
              tint={"systemBlue"}
            >
              {message.isUnread
                ? <Label title={"Read"} systemImage={"envelope.open"} />
                : <Label title={"Unread"} systemImage={"envelope.badge"} />
              }
            </Button>
          ]
        }}
        trailingSwipeActions={{
          actions: [
            <Button
              role={"destructive"}
              action={() => deleteMessage(message)}
            >
              <Label title={"Delete"} systemImage={"trash"} />
            </Button>,
            <Button
              action={() => {}}
              tint={"systemOrange"}
            >
              <Label title={"Flag"} systemImage={"flag"} />
            </Button>
          ]
        }}
      />
    )}
  </List>
</NavigationStack>
```

### 5. 展示页面并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键特性

- **leadingSwipeActions**：配置从主视图起始方向滑动（如从左向右）的操作。
- **trailingSwipeActions**：配置从主视图尾部方向滑动（如从右向左）的操作。
- **allowsFullSwipe**：设置为 `false` 时，禁止通过完全滑动直接触发第一个操作按钮。
- **Button 的 role 属性**：使用 `"destructive"` 等角色值，系统会为按钮应用相应的视觉样式（如删除按钮为红色）。
- **tint**：可自定义按钮颜色，以提升识别度与视觉分层。

***

## 适用场景

- **邮件/消息类脚本**：快速标记为已读/未读、删除、归档或加星。
- **任务清单**：滑动完成任务或移除待办事项。
- **自定义工具列表**：根据上下文为每项内容添加快捷操作。

通过滑动操作，可以为列表提供直观、高效的交互方式，提升用户体验与操作效率。



---
url: /zh/guide/Views/List/List interaction/index_example.md
---

# 示例

```tsx
import { Button, Circle, HStack, Label, List, Navigation, NavigationStack, Script, Text, useState, VStack } from "scripting"

type Message = {
  from: string
  content: string
  isUnread: boolean
}

function MessageCell({
  message
}: {
  message: Message
}) {
  return <HStack>
    <Circle
      fill={message.isUnread ? "systemBlue" : "clear"}
      frame={{
        width: 16,
        height: 16,
      }}
    />
    <VStack
      alignment={"leading"}
    >
      <Text font={"headline"}>{message.from}</Text>
      <Text>{message.content}</Text>
    </VStack>
  </HStack>
}

function Example() {
  const [messages, setMessages] = useState<Message[]>(() => [
    {
      from: "Maria Ruiz",
      content: "If you have a list of messages, you can add an action to toggle a message as unread on a swipe from the leading edge, and actions to delete or flag messages on a trailing edge swipe.",
      isUnread: true,
    },
    {
      from: "Mei Chen",
      content: "Actions appear in the order you list them, starting from the swipe’s originating edge. In the example, the Delete action appears closest to the screen’s trailing edge",
      isUnread: true,
    },
    {
      from: "Maria Ruiz",
      content: "By default, the user can perform the first action for a given swipe direction with a full swipe. The user can perform both the toggle unread and delete actions with full swipes. You can opt out of this behavior for an edge by setting the allowsFullSwipe parameter to false.",
      isUnread: false,
    },
    {
      from: "Mei Chen",
      content: "When you set a role for a button using one of the values from the ButtonRole, system styles the button according to its role. In the example above, the delete action appears in red because it has the destructive role. If you want to set a different color, add the tint property to the button",
      isUnread: true,
    }
  ])

  function toggleUnread(message: Message) {
    setMessages(messages.map(item => item !== message ? item : {
      ...message,
      isUnread: !item.isUnread
    }))
  }

  function deleteMessage(message: Message) {
    setMessages(messages.filter(item => item !== message))
  }

  return <NavigationStack>
    <List
      navigationTitle={"Messages"}
      navigationBarTitleDisplayMode={"inline"}
      listStyle={"inset"}
    >
      {messages.map(message =>
        <MessageCell
          message={message}
          leadingSwipeActions={{
            allowsFullSwipe: false,
            actions: [
              <Button
                action={() => toggleUnread(message)}
                tint={"systemBlue"}
              >
                {message.isUnread
                  ? <Label title={"Read"} systemImage={"envelope.open"} />
                  : <Label title={"Unread"} systemImage={"envelope.badge"} />
                }
              </Button>
            ]
          }}
          trailingSwipeActions={{
            actions: [
              <Button
                role={"destructive"}
                action={() => deleteMessage(message)}
              >
                <Label title={"Delete"} systemImage={"trash"} />
              </Button>,
              <Button
                action={() => { }}
                tint={"systemOrange"}
              >
                <Label title={"Flag"} systemImage={"flag"} />
              </Button>
            ]
          }}
        />
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/List/List style/index.md
---

# 列表样式

通过该属性，你可以自定义 `List` 视图在 UI 中的行为和外观。

***

## 属性声明

```tsx
listStyle?: ListStyle;
```

### 描述

`listStyle` 属性定义了列表的视觉样式，允许你从多种预定义样式中选择合适的样式。

***

### 可接受的值

`listStyle` 属性接受以下字符串值：

- **`automatic`**：使用平台的默认列表行为和外观。
- **`bordered`**：以标准边框显示列表。
- **`carousel`**：将列表设置为类似于旋转木马的外观。
- **`elliptical`**：为列表提供椭圆形的样式。
- **`grouped`**：以分组格式显示列表。
- **`inset`**：为列表应用内嵌外观。
- **`insetGroup`**：结合内嵌和分组样式。
- **`plain`**：以简单样式显示列表，不添加额外的装饰。
- **`sidebar`**：将列表呈现为类似侧边栏的外观。

***

### 默认行为

如果未指定 `listStyle`，系统会根据平台选择默认样式。

***

## 使用示例

以下展示了如何在 TypeScript 代码中应用 `listStyle` 属性：

### 示例 1：简单列表样式 (Plain Style)

```tsx
<List
  listStyle="plain"
>
  <Text>项目 1</Text>
  <Text>项目 2</Text>
  <Text>项目 3</Text>
</List>
```

此示例创建了一个简单样式的列表。

***

### 示例 2：分组列表样式 (Grouped Style)

```tsx
<List
  listStyle="grouped"
>
  <Section header={
    <Text>水果</Text>
  }>
    <Text>苹果</Text>
    <Text>香蕉</Text>
  </Section>
  <Section header={
    <Text>蔬菜</Text>
  }>
    <Text>胡萝卜</Text>
    <Text>西兰花</Text>
  </Section>
</List>
```

此示例创建了一个分组样式的列表，每个分组有一个标题。

***

### 示例 3：侧边栏列表样式 (Sidebar Style)

```tsx
<List
  listStyle="sidebar"
>
  <Text>主页</Text>
  <Text>设置</Text>
  <Text>个人资料</Text>
</List>
```

此示例创建了一个类似于侧边栏的列表。

***

## 注意事项

- `listStyle` 属性直接映射到 SwiftUI 的 `listStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过选择合适的 `listStyle`，你可以根据设计需求调整列表的外观，从而为用户提供更符合场景的视觉体验。



---
url: /zh/guide/Views/List/List style/list_style.md
---

# 示例

```tsx
import { List, ListStyle, Navigation, NavigationStack, Picker, Script, Section, Text, useMemo, useState } from "scripting"

function Example() {
  const [listStyle, setListStyle] = useState<ListStyle>("automatic")
  const listStyleOptions = useMemo<ListStyle[]>(() => [
    "automatic",
    "bordered",
    "carousel",
    "elliptical",
    "grouped",
    "inset",
    "insetGroup",
    "plain",
    "sidebar",
  ], [])

  return <NavigationStack>
    <List
      navigationTitle={"List Style"}
      navigationBarTitleDisplayMode={"inline"}
      listStyle={listStyle}
    // listSectionSpacing={5} // apply for all sections
    >
      <Picker
        title={"ListStyle"}
        value={listStyle}
        onChanged={setListStyle as any}
        pickerStyle={"menu"}
      >
        {listStyleOptions.map(listStyle =>
          <Text tag={listStyle}>{listStyle}</Text>
        )}
      </Picker>

      <Section>
        <Text
          badge={10} // Use a badge to convey optional, supplementary information about a view
        >Recents</Text>
        <Text>Favorites</Text>
      </Section>

      <Section
        header={<Text>Colors</Text>}
        listItemTint={"systemBlue"}
      >
        <Text>Red</Text>
        <Text>Blue</Text>
      </Section>

      <Section
        header={<Text>Shapes</Text>}
      >
        <Text>Rectangle</Text>
        <Text>Circle</Text>
      </Section>

      <Section
        header={<Text>Borders</Text>}
        listSectionSpacing={10} // specify on an individual Section
      >
        <Text>Dashed</Text>
        <Text>Solid</Text>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/List/Refresable List/index.md
---

# 可刷新列表

将可滚动视图标记为 **可刷新**，允许用户下拉以触发异步的数据刷新操作。

## 类型

```ts
refreshable?: () => Promise<void>
```

***

## 概述

在如 `<List>` 这样的可滚动视图上使用 `refreshable` 修饰符，可以启用下拉刷新的交互行为。当用户在页面顶部下拉时，框架会调用你提供的异步处理函数。

在处理函数中，你可以执行异步操作（例如请求网络数据或更新本地状态），当该函数返回后，刷新指示器将自动隐藏。

此行为与 SwiftUI 的 [`refreshable`](https://developer.apple.com/documentation/swiftui/view/refreshable%28action:%29) 非常相似。

***

## 使用示例

```tsx
<List
  navigationTitle="可刷新列表"
  navigationBarTitleDisplayMode="inline"
  refreshable={refresh}
/>
```

### 完整示例

```tsx
function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 2000) // 模拟2秒刷新
    })
  }

  return <NavigationStack>
    <List
      navigationTitle="可刷新列表"
      navigationBarTitleDisplayMode="inline"
      refreshable={refresh}
    >
      <Section header={<Text textCase={null}>下拉即可刷新</Text>}>
        {data.map(item =>
          <Text>数字：{item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}
```

***

## 行为说明

- `refreshable` 必须返回一个 `Promise<void>`。只有在该 promise 被解析（`resolve`）后，刷新指示器才会消失。
- 在处理函数内部可以使用 `await` 进行异步操作：

  ```ts
  refreshable={async () => {
    const result = await fetchData()
    setData(result)
  }}
  ```
- 此修饰符 **仅适用于可滚动容器**（如 `<List>`）。
- 在刷新逻辑中应更新相关状态，以反映新的数据。
- 避免长时间运行或无反馈的任务，必须确保 promise 能被及时解析以防止界面卡住。

***

## 使用建议

- 保持刷新逻辑简洁高效。
- 始终在逻辑结束后调用 `resolve`。
- 开发时可使用延迟模拟加载动画：

  ```ts
  await new Promise(resolve => setTimeout(resolve, 1000))
  ```



---
url: /zh/guide/Views/List/Refresable List/refreshable_list.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Script, Section, Text, useState } from "scripting"

function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 1000 * 2)
    })
  }

  return <NavigationStack>
    <List
      navigationTitle={"Refreshable List"}
      navigationBarTitleDisplayMode={"inline"}
      refreshable={refresh}
    >
      <Section header={
        <Text textCase={null}>Pull down to refresh</Text>
      }>
        {data.map(item =>
          <Text>Number: {item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/List/Represent data hierarchy in sections/index.md
---

# 以分区表示数据层级

本示例展示如何在 **Scripting** 应用中使用 `Section` 组件，在 `List` 中清晰地组织层级化数据。通过将相关数据（例如员工列表）按部门分组，并为每个分组设置标题，可以更好地提升信息的可读性与结构性。

***

## 概览

你将学习如何：

- 使用 `List` 和 `Section` 展示结构化数据
- 根据部门将员工信息分组显示
- 创建可复用的行视图组件
- 将公司 → 部门 → 员工的层级数据结构转换为列表界面

***

## 数据模型

示例定义了一个公司层级结构，包含公司、部门和员工三层：

```ts
type Person = {
  name: string
  phoneNumber: string
}

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}
```

### 示例数据

```ts
const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        { name: "Juan Chavez", phoneNumber: "(408) 555-4301" },
        { name: "Mei Chen", phoneNumber: "(919) 555-2481" }
      ]
    },
    {
      name: "Engineering",
      staff: [
        { name: "Bill James", phoneNumber: "(408) 555-4450" },
        { name: "Anne Johnson", phoneNumber: "(417) 555-9311" }
      ]
    }
  ]
}
```

***

## 人员行组件

`PersonRowView` 是一个可复用组件，用于展示员工姓名和电话号码，采用垂直排版并添加辅助样式。

```tsx
function PersonRowView({ person }: { person: Person }) {
  return <VStack alignment={"leading"} spacing={3}>
    <Text font={"headline"} foregroundStyle={"label"}>{person.name}</Text>
    <HStack spacing={3} font={"subheadline"} foregroundStyle={"secondaryLabel"}>
      <Label title={person.phoneNumber} systemImage={"phone"} />
    </HStack>
  </VStack>
}
```

***

## 主视图布局

主界面使用 `NavigationStack` 包裹 `List`，每个部门对应一个 `Section`。部门名称作为区块标题，区块内通过 `PersonRowView` 渲染员工列表。

```tsx
function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Represent data hierarchy in sections"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <Section
          header={<Text>{department.name}</Text>}
        >
          {department.staff.map(person =>
            <PersonRowView person={person} />
          )}
        </Section>
      )}
    </List>
  </NavigationStack>
}
```

***

## 启动入口

脚本展示界面后，在关闭时退出脚本：

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

- **List**：用于构建可滚动的列表容器。
- **Section**：将列表按组分类，每组有标题和子项。
- **NavigationStack**：提供导航上下文与导航栏标题显示。
- **PersonRowView**：可复用组件，统一渲染员工数据格式。

***

## 适用场景

- 按部门、分类、地区等组织联系人或数据条目
- 展示有父子结构的数据，如清单、文件、配置项等
- 实现信息有序分组，提升用户的查阅与交互体验

通过在 `List` 中使用 `Section`，你可以构建清晰、分组合理的层级数据界面，使复杂内容一目了然，适合各类数据展示与信息架构设计。



---
url: /zh/guide/Views/List/Represent data hierarchy in sections/index_example.md
---

# 示例

```tsx
import { HStack, Label, List, Navigation, NavigationStack, Script, Section, Text, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Represent data hierarchy in sections"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <Section
          header={
            <Text>{department.name}</Text>
          }
        >
          {department.staff.map(person =>
            <PersonRowView
              person={person}
            />
          )}
        </Section>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/List/Selectable List.md
---

# 可选择的列表

`List.selection` 用于为 `List` 组件提供**选择状态绑定能力**，用于实现列表的：

- 单选模式（Single Selection）
- 多选模式（Multiple Selection）
- 与编辑模式（`EditButton`）联动的批量选择行为

***

## 一、API 定义

```ts
type ListProps = {
  selection?: Observable<string | null> | Observable<string[]>
  ...
}

declare const List: FunctionComponent<ListProps>
```

***

## 二、selection 类型说明

`selection` 通过 `Observable` 的泛型类型自动区分选择模式：

| 模式 | Observable 类型                | 说明         |
| -- | ---------------------------- | ---------- |
| 单选 | `Observable<string \| null>` | 仅允许选中一个元素  |
| 多选 | `Observable<string[]>`       | 允许同时选中多个元素 |

***

## 三、selection 与 ForEach 的自动绑定规则

当 `List` 绑定 `selection` 时，`ForEach` 的 `data` **必须满足以下规则**：

```ts
ForEach 的 data 数组中，每一个元素都必须包含：

{
  id: string
}
```

系统行为规则如下：

1. `id` 会被自动作为该行的 **唯一选择标识**
2. 当用户点击某一行时：

   - 单选模式：`selected.value` 会被自动设置为该行的 `id`
   - 多选模式：该 `id` 会被自动加入或移出 `selected.value` 数组
3. 不需要手动在 `onTap` 中处理选中逻辑
4. `id` 必须唯一且稳定，否则会导致选择状态错乱或失效

***

## 四、单选模式（Single Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string | null>(null)
```

### 2. 使用示例

```tsx
function View() {
  const selected = useObservable<string | null>(null)

  const options = useObservable<{ id: string }[]>(() =>
    new Array(10).fill(0).map((_, i) => ({ id: i.toString() }))
  )

  return <NavigationStack>
    <List selection={selected}>
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

- `null`：当前没有选中任何项
- `"3"`：当前选中 `id === "3"` 的项

***

## 五、多选模式（Multiple Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string[]>([])
```

### 2. 使用示例

```tsx
function View() {
  const dismiss = Navigation.useDismiss()
  const selected = useObservable<string[]>([])

  const options = useObservable<{ id: string }[]>(() =>
    new Array(30).fill(0).map((_, i) => ({
      id: i.toString() 
    }))
  )

  console.log(selected.value)

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />,
        topBarTrailing: <EditButton />
      }}
      selection={selected}
    >
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

`selected.value` 始终为一个字符串数组，例如：

```ts
["2", "5", "8"]
```

表示当前有 3 项被同时选中。

***

## 六、selection 与 EditButton 的编辑模式行为

当 `List` 绑定了 `selection` 后：

1. `EditButton` 会自动启用选择编辑模式
2. 进入编辑模式后：

   - 单选：点击某一项即切换选中项
   - 多选：支持多项同时勾选
3. 退出编辑模式后：

   - `selected.value` 会被 **自动重置**

     - 单选模式重置为 `null`
     - 多选模式重置为空数组 `[]`

该行为与 SwiftUI 原生编辑模式保持一致。

***

## 七、selection 的程序化控制

除了用户交互以外，也可以通过代码主动修改选中状态。

### 单选模式

```ts
selected.setValue("5")
```

### 多选模式

```ts
selected.setValue(["1", "3", "7"])
```

设置后 UI 会自动同步对应的勾选状态。

***

## 八、selection 与 NavigationStack 的兼容性

`List.selection` 可以安全地在 `NavigationStack` 内使用，不会影响：

- 页面导航行为
- Toolbar 显示
- EditButton 编辑模式
- 页面返回逻辑

标准推荐结构如下：

```tsx
<NavigationStack>
  <List selection={selected}>
    ...
  </List>
</NavigationStack>
```

***

## 九、常见错误说明

### 1. selection 类型错误

错误：

```ts
const selected = useObservable<number | null>(null)
```

正确：

```ts
const selected = useObservable<string | null>(null)
```

目前 `selection` 仅支持 `string` 作为选择标识类型。

***

### 2. 多选模式初始化错误

错误：

```ts
const selected = useObservable<string[]>(null)
```

正确：

```ts
const selected = useObservable<string[]>([])
```

***

### 3. data 未包含 id:string

错误示例：

```tsx
const options = [{ name: "A" }, { name: "B" }]
```

该写法将导致：

- selection 无法正常工作
- 勾选状态丢失
- 列表复用异常

***

## 十、适用场景

`List.selection` 适用于以下场景：

- 单选设置项（主题、语言、偏好）
- 批量删除
- 批量导出
- 批量分享
- 文件管理器
- 通讯录选择
- 任务列表勾选



---
url: /zh/guide/Views/List/Use list for navigations/index.md
---

# 使用列表进行导航

本示例展示如何在 **Scripting** 应用中使用 `List` 创建可导航的分层数据界面。通过 `DisclosureGroup` 将内容按部门分组，并结合 `NavigationLink` 实现点击跳转到人员详情页的功能。

***

## 概览

你将学习如何：

- 使用 `List` 显示部门和员工的目录结构
- 使用 `DisclosureGroup` 创建可展开的分组
- 使用 `NavigationLink` 跳转到详细视图
- 构建可复用的子视图组件来提升代码结构清晰度

***

## 数据结构

本示例使用嵌套结构模拟公司 → 部门 → 员工的信息层级：

```ts
type Person = {
  name: string
  phoneNumber: string
}

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}
```

### 示例数据

```ts
const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        { name: "Juan Chavez", phoneNumber: "(408) 555-4301" },
        { name: "Mei Chen", phoneNumber: "(919) 555-2481" }
      ]
    },
    {
      name: "Engineering",
      staff: [
        { name: "Bill James", phoneNumber: "(408) 555-4450" },
        { name: "Anne Johnson", phoneNumber: "(417) 555-9311" }
      ]
    }
  ]
}
```

***

## 视图组件

### `PersonRowView`

用于显示员工姓名与电话号码的组件，使用垂直堆叠排版。

```tsx
function PersonRowView({ person }: { person: Person }) {
  return <VStack alignment={"leading"} spacing={3}>
    <Text font={"headline"} foregroundStyle={"label"}>{person.name}</Text>
    <HStack spacing={3} font={"subheadline"} foregroundStyle={"secondaryLabel"}>
      <Label title={person.phoneNumber} systemImage={"phone"} />
    </HStack>
  </VStack>
}
```

### `PersonDetailView`

点击员工后跳转的详情页，展示详细信息。

```tsx
function PersonDetailView({ person }: { person: Person }) {
  return <VStack>
    <Text font={"title"} foregroundStyle={"label"}>{person.name}</Text>
    <HStack foregroundStyle={"secondaryLabel"}>
      <Label title={person.phoneNumber} systemImage={"phone"} />
    </HStack>
  </VStack>
}
```

***

## 主界面布局

根视图使用 `NavigationStack` 包裹 `List`，通过 `DisclosureGroup` 对部门分组，组内使用 `NavigationLink` 包裹员工信息，支持点击跳转详情页：

```tsx
function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Staff Directory"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <DisclosureGroup title={department.name}>
          {department.staff.map(person =>
            <NavigationLink
              destination={<PersonDetailView person={person} />}
            >
              <PersonRowView person={person} />
            </NavigationLink>
          )}
        </DisclosureGroup>
      )}
    </List>
  </NavigationStack>
}
```

***

## 启动视图并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

- **List**：用于展示可滚动的列表结构。
- **DisclosureGroup**：支持分组并可展开/折叠内容区域。
- **NavigationLink**：可点击的跳转组件，用于导航到目标视图。
- **NavigationStack**：用于包裹整个导航流程，提供导航上下文。

***

## 应用场景

- 构建组织架构、通讯录等分级导航界面
- 展示具有层级结构的数据，如公司目录、分类商品等
- 提供从列表快速跳转到详细信息的用户体验

本示例提供了一种结构清晰、功能完整的导航模式，适用于构建多级数据浏览和交互式信息展示的脚本页面。



---
url: /zh/guide/Views/List/Use list for navigations/index_example.md
---

# 示例

```tsx
import { DisclosureGroup, HStack, Label, List, Navigation, NavigationLink, NavigationStack, Script, Text, VStack } from "scripting"

type Person = {
  name: string
  phoneNumber: string
}

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Staff Directory"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <DisclosureGroup
          title={department.name}
        >
          {department.staff.map(person =>
            <NavigationLink
              destination={
                <PersonDetailView
                  person={person}
                />
              }
            >
              <PersonRowView
                person={person}
              />
            </NavigationLink>
          )}
        </DisclosureGroup>
      )}
    </List>
  </NavigationStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/LivePhotoView.md
---

# LivePhotoView

LivePhoto 表示一张 **系统级 Live Photo**，它由以下两部分组成：

- 一张高分辨率静态图片
- 一段与图片绑定的短视频（通常为 MOV）

在 Scripting 中，LivePhoto 是一个 **不可直接 new 的系统对象**，通常来源于：

- 照片选择器返回的结果
- 使用本地图片与视频文件动态构建

LivePhoto 的主要用途包括：

- 在界面中实时展示 Live Photo
- 读取并处理其底层资源（图片 / 视频）
- 将其拆解、重建或重新保存到系统相册

***

## LivePhoto 类

### LivePhoto.size

```
readonly size: Size
```

表示 Live Photo 的尺寸信息，对应其 **主图像（静态图片）** 的像素宽高。

该属性常用于：

- UI 布局约束
- 计算缩放比例
- 判断 Live Photo 的原始分辨率

***

### LivePhoto.getAssetResources()

```
getAssetResources(): Promise<{
  data: Data
  assetLocalIdentifier: string
  contentType: UTType
  originalFilename: string
  pixelHeight: number
  pixelWidth: number
}[]>
```

用于获取 Live Photo 的 **底层资源列表**。

一个 Live Photo 通常至少包含以下资源：

- 静态图片资源（JPEG / HEIC）
- 视频资源（QuickTime MOV）

返回数组中每一项代表一个资源，其字段含义如下：

- `data`
  资源的二进制数据，可直接用于写入文件、保存或传输

- `assetLocalIdentifier`
  Photos 框架中该资源的本地唯一标识

- `contentType`
  资源的统一类型标识（UTType），用于区分图片或视频类型

- `originalFilename`
  系统中该资源的原始文件名

- `pixelWidth` / `pixelHeight`
  该资源的实际像素尺寸

典型使用场景包括：

- 手动保存 Live Photo（避免中间临时文件）
- 将 Live Photo 拆解为独立的图片与视频
- 对 Live Photo 进行自定义导出或重建

***

### LivePhoto.from(options)

```
static from(options: {
  imagePath: string
  videoPath: string
  targetSize?: Size | null
  placeholderImage: UIImage | null
  contentMode?: "aspectFit" | "aspectFill"
  onResult: (result: LivePhoto | null, info: {
    error: string | null
    degraded: boolean | null
    cancelled: boolean | null
  }) => void
}): Promise<() => void>
```

用于 **从本地图片文件与视频文件异步构建 Live Photo**。

该方法的特点如下：

- 构建过程是异步的
- `onResult` 可能会被调用多次
- 支持降级结果（低质量预览）
- 支持主动取消请求

#### 参数说明

- `imagePath`
  静态图片文件路径，通常为 JPEG 或 HEIC

- `videoPath`
  与图片对应的视频文件路径，通常为 MOV

- `targetSize`
  指定返回 Live Photo 的目标尺寸
  传入 `null` 表示使用原始尺寸

- `placeholderImage`
  Live Photo 尚未加载完成时用于占位显示的 UIImage

- `contentMode`
  占位图的显示方式

  - `aspectFit`：完整显示，保持比例
  - `aspectFill`：填满区域，可能裁剪

- `onResult(result, info)`
  Live Photo 加载完成或状态更新时触发的回调

#### info 参数说明

- `error`
  构建失败时的错误信息

- `degraded`
  表示当前结果是否为低质量版本

- `cancelled`
  表示请求是否被取消

#### 返回值

该方法返回一个 Promise，成功后解析为一个 **可取消函数**：

```
() => void
```

调用该函数可立即取消 Live Photo 的加载过程。

***

## LivePhotoView 组件

LivePhotoView 是用于 **在界面中展示 Live Photo 的原生视图组件**，行为与系统 Photos App 中的 Live Photo 播放体验一致。

***

### LivePhotoViewProps

```
type LivePhotoViewProps = {
  livePhoto: Observable<LivePhoto | null>
}
```

#### livePhoto

- 类型：`Observable<LivePhoto | null>`
- 必填

该属性用于绑定当前要显示的 Live Photo。

设计为 `Observable` 的原因是：

- Live Photo 通常是异步获取的
- 允许在同一个视图中动态切换 Live Photo
- 便于与选择器、加载逻辑解耦

当 Observable 的值发生变化时，LivePhotoView 会自动更新显示内容。

***

## 使用示例说明

以下示例展示了一个典型使用流程：

- 用户选择一张 Live Photo
- 将 Live Photo 存入 Observable
- LivePhotoView 自动展示并播放该 Live Photo

```tsx
import { LivePhotoView, Button, useObservable } from "scripting"

function Example() {
  const livePhoto = useObservable<LivePhoto | null>(null)

  return <>
    <Button
      title="Set Live Photo"
      action={async () => {
        const lp = await getLivePhotoSomehow()
        livePhoto.setValue(lp)
      }}
    />

    <LivePhotoView
      livePhoto={livePhoto}
      frame={{ idealHeight: 300 }}
    />
  </>
}
```

### 核心流程说明

- 使用 `useObservable<LivePhoto | null>` 创建可观察状态
- 在用户选择 Live Photo 后，通过 `setValue` 更新状态
- LivePhotoView 自动响应状态变化并展示内容

LivePhotoView 不负责：

- Live Photo 的获取
- 权限处理
- 数据保存

它仅专注于 **展示与交互体验**。

***

## 设计原则与注意事项

- LivePhoto 是系统资源对象，生命周期由系统管理
- LivePhotoView 必须绑定 Observable，而不是直接传值
- 同一个 LivePhoto 实例可被多个 LivePhotoView 使用
- Live Photo 的加载与 UI 渲染解耦，推荐始终通过 Observable 驱动

***

## 总结

LivePhoto 相关能力在 Scripting 中主要由两部分组成：

- **LivePhoto 数据模型**
  用于表示、构建和解析系统 Live Photo

- **LivePhotoView 展示组件**
  用于以原生方式展示 Live Photo，并支持动态更新



---
url: /zh/guide/Views/Markdown.md
---

# Markdown

`Markdown` 是一个用于渲染 Markdown 格式文本的视图组件，可在脚本的用户界面中显示富文本内容、代码块、文档说明等。它支持多种显示主题以及代码语法高亮样式，非常适合展示格式化文档、日志、开发说明等信息。

***

## 导入方式

```ts
import { Markdown } from 'scripting'
```

***

## 基本用法

```tsx
<Markdown content="# 你好\n这是一个 **Markdown** 视图。" />
```

***

## 参数说明（Props）

### `content: string` **(必填)**

要显示的 Markdown 格式文本内容。支持标准 Markdown 语法。

```tsx
<Markdown content="## 特性\n- 支持 **加粗**、*斜体* 和 `代码块`。" />
```

***

### `theme?: 'basic' | 'github' | 'docC'`

设置 Markdown 内容的整体主题风格，可选值包括：

- `'basic'`：简洁、通用的默认样式。
- `'github'`：GitHub 风格，适合开发文档或代码说明。
- `'docC'`：仿照 Apple DocC 的文档风格。

```tsx
<Markdown content="**Hello**" theme="docC" />
```

***

### `highlighterTheme?: 'midnight' | 'presentation' | 'sundellsColors' | 'sunset' | 'wwdc17' | 'wwdc18'`

设置 Markdown 中代码块的语法高亮主题。如果未设置，默认不使用高亮主题。

可选值包括：

- `'midnight'`
- `'presentation'`
- `'sundellsColors'`
- `'sunset'`
- `'wwdc17'`
- `'wwdc18'`

````tsx
<Markdown
  content="```js\nconsole.log('Hello')\n```"
  highlighterTheme="wwdc18"
/>
````

***

### `useDefaultHighlighterTheme?: boolean`

是否使用系统默认的语法高亮主题。启用后，系统会根据当前的浅色或深色模式自动切换主题。

> ⚠️ 如果设置了 `highlighterTheme`，此配置将被忽略。

````tsx
<Markdown
  content="```swift\nprint(\"你好\")\n```"
  useDefaultHighlighterTheme={true}
/>
````

***

### `scrollable?: boolean`

默认值：`true`

控制 Markdown 视图是否可滚动。如果希望将其嵌入到其他可滚动容器中，可设置为 `false`。

```tsx
<Markdown content="# 标题" scrollable={false} />
```

***

## 示例

```tsx
<Markdown
  content={`
# 欢迎使用 Scripting

以下是一个简单的示例：

\`\`\`ts
const hello = "world"
console.log(hello)
\`\`\`
  `}
  theme="github"
  highlighterTheme="sunset"
/>
```



---
url: /zh/guide/Views/Menu/index.md
---

# 菜单

Scripting 提供的 `Menu` 是一个交互式菜单组件，用于展示一组操作项或子菜单。该组件可以作为操作容器，也支持嵌套结构，适合在工具栏、上下文菜单或紧凑布局中统一管理多个相关操作。

其行为类似于 SwiftUI 中的 `Menu`，支持纯文本标签和自定义视图标签，并可配置点击时的默认行为。

***

## 用途

使用 `Menu` 可以将多个相关操作整合为一个统一入口，提升界面整洁性与可用性。菜单中可以包含多个 `Button` 组件，也可以嵌套其他 `Menu` 实现多级菜单结构。

***

## 属性定义

```ts
type MenuProps = {
  primaryAction?: () => void
  children?: VirtualNode | (VirtualNode | undefined | null)[]
} & (
  | {
      title: string
      systemImage?: string
    }
  | {
      label: VirtualNode
    }
)
```

### 基础属性

| 属性名             | 类型                | 说明                                 |
| --------------- | ----------------- | ---------------------------------- |
| `primaryAction` | `() => void`（可选）  | 点击菜单本身时触发的主操作，不展开子菜单。适合设置默认行为。     |
| `children`      | `VirtualNode` 或数组 | 菜单的内容，通常是 `Button` 或嵌套的 `Menu` 组件。 |

### 标签配置（二选一）

开发者必须指定以下两种标签方式之一：

#### 方式一：`title` 与可选的 `systemImage`

| 属性名           | 类型           | 说明                      |
| ------------- | ------------ | ----------------------- |
| `title`       | `string`     | 菜单标题，描述菜单的操作内容。         |
| `systemImage` | `string`（可选） | SF Symbols 图标名称，显示在标题旁。 |

#### 方式二：`label` 自定义视图标签

| 属性名     | 类型            | 说明                   |
| ------- | ------------- | -------------------- |
| `label` | `VirtualNode` | 自定义菜单标签视图，可组合图标、文本等。 |

***

## 示例：基础菜单结构

```tsx
<Menu title="操作">
  <Button title="重命名" action={rename} />
  <Button title="删除" action={delete} />
  <Menu title="复制">
    <Button title="复制" action={copy} />
    <Button title="复制格式" action={copyFormatted} />
  </Menu>
</Menu>
```

在此示例中：

- 主菜单为 `"操作"`，包含两个按钮和一个嵌套的 `"复制"` 子菜单；
- 子菜单中继续包含两个按钮。

***

## 示例：使用 `primaryAction` 和图标

```tsx
<Menu
  title="更多"
  systemImage="ellipsis"
  primaryAction={() => console.log("点击菜单")}
>
  <Button title="设置" action={openSettings} />
  <Button title="帮助" action={openHelp} />
</Menu>
```

- 用户点击菜单图标将触发 `primaryAction`；
- 长按或展开菜单时，会展示其 `children` 内容。

***

## 示例：使用自定义标签

```tsx
<Menu
  label={
    <HStack>
      <Image systemName="gear" />
      <Text>选项</Text>
    </HStack>
  }
>
  <Button title="配置" action={configure} />
</Menu>
```

此示例使用 `HStack` 组合图标与文本作为菜单标签，适合在复杂场景下灵活布局。

***

## 开发提示

- `Menu` 常用于 `toolbar`、`contextMenu` 等需要组合多个操作的界面中；
- 可无限嵌套子菜单，构建多层级操作结构；
- 若操作不多且用户期望直接执行某一默认行为，可设置 `primaryAction`；
- 自定义 `label` 可用于图标+文本的混合样式，提升可视性与品牌一致性。



---
url: /zh/guide/Views/Menu/index_example.md
---

# 示例

```tsx
import { Button, Group, List, Menu, Navigation, NavigationStack, Script, ScrollView, Section, Text, VStack } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Menu"}
      navigationBarTitleDisplayMode={"inline"}
    >

      <Section
        header={
          <Text>Menu</Text>
        }
      >
        <Menu
          title={"Open Menu"}
        >
          <Button
            title="Rename"
            action={() => console.log("Rename")}
          />
          <Button
            title="Delete"
            role={"destructive"}
            action={() => console.log("Delete")}
          />
          <Menu title="Copy">
            <Button
              title="Copy"
              action={() => console.log("Copy")}
            />
            <Button
              title="Copy Formated"
              action={() => console.log("Copy fomatted")}
            />
          </Menu>
        </Menu>
      </Section>

      <Section
        header={
          <Text>ContextMenu</Text>
        }
      >
        <Text
          foregroundStyle={"link"}
          contextMenu={{
            menuItems: <Group>
              <Button
                title="Add"
                action={() => {
                  // Add
                }}
              />
              <Button
                title="Delete"
                role="destructive"
                action={() => {
                  // Delete
                }}
              />
            </Group>
          }}
        >Long Press to open context menu</Text>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Modal presentaions/index.md
---

# 模态展示

Scripting App 提供了对 SwiftUI 风格的模态视图展示的支持。开发者可以通过向组件声明特定的属性，实现类似 `sheet`、`popover`、`fullScreenCover`、`alert` 和 `confirmationDialog` 的展示行为。这些展示是响应状态变化的，并支持多种配置项，以满足在不同屏幕尺寸和交互需求下的使用场景。

***

## Alert（警告弹窗）

当条件为真时，展示一个带标题、可选消息和操作按钮的警告弹窗。

```ts
alert?: {
  title: string
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
  actions: VirtualNode
  message?: VirtualNode
}
```

### 字段说明

- **`title`**：弹窗的标题文本。
- **`isPresented`**：控制弹窗是否显示的布尔值。
- **`onChanged`**：当 `isPresented` 状态变化时调用的回调函数。需要在用户关闭弹窗时将其更新为 `false`。
- **`actions`**：表示操作按钮的 `VirtualNode`。
- **`message`**（可选）：用于展示附加信息的 `VirtualNode`。

***

## Confirmation Dialog（确认对话框）

展示一个确认对话框，包含标题、可选消息和操作项。

```ts
confirmationDialog?: {
  title: string
  titleVisibility?: Visibility
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
  actions: VirtualNode
  message?: VirtualNode
}
```

### 字段说明

- **`title`**：对话框的标题。
- **`titleVisibility`**（可选）：标题是否显示，默认值为 `"automatic"`。
- **`isPresented`**：是否显示对话框。
- **`onChanged`**：用于更新 `isPresented` 状态的回调。
- **`actions`**：对话框操作项。
- **`message`**（可选）：附加消息内容。

```ts
type Visibility = "automatic" | "hidden" | "visible"
```

***

## Sheet（底部弹窗）

从底部弹出模态视图，通常用于展示中等重要性的内容。支持传入单个或多个配置项。

```ts
sheet?: ModalPresentation | ModalPresentation[]
```

***

## Full Screen Cover（全屏覆盖视图）

展示一个覆盖全屏的模态视图。可传入多个视图配置。

```ts
fullScreenCover?: ModalPresentation | ModalPresentation[]
```

***

## Popover（弹出菜单）

展示一个带箭头的弹出内容区域，通常用于 iPad 或大屏设备上。可设置适配策略及箭头位置。

```ts
popover?: PopoverPresentation | PopoverPresentation[]
```

### PopoverPresentation 类型定义

```ts
type PopoverPresentation = ModalPresentation & {
  arrowEdge?: Edge
  presentationCompactAdaptation?: PresentationAdaptation | {
    horizontal: PresentationAdaptation
    vertical: PresentationAdaptation
  }
}
```

#### 字段说明

- **`arrowEdge`**（可选）：弹出箭头指向的边，默认是 `"top"`。
- **`presentationCompactAdaptation`**（可选）：在紧凑环境下的展示适配策略。

```ts
type Edge = "top" | "bottom" | "leading" | "trailing"
```

***

## ModalPresentation（通用模态视图结构）

该类型被 `sheet`、`popover` 和 `fullScreenCover` 使用，定义了基础展示结构。

```ts
type ModalPresentation = {
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
  content: VirtualNode
}
```

### 字段说明

- **`isPresented`**：控制是否展示模态视图。
- **`onChanged`**：模态视图关闭或显示时触发的状态更新回调。
- **`content`**：展示内容的 `VirtualNode`。

***

## PresentationAdaptation（展示适配策略）

指定在不同尺寸环境下的视图展示方式。

```ts
type PresentationAdaptation =
  | "automatic"
  | "fullScreenCover"
  | "none"
  | "popover"
  | "sheet"
```

- **`automatic`**：系统自动选择合适的展示方式。
- **`fullScreenCover`**：优先使用全屏覆盖。
- **`popover`**：优先使用弹出菜单形式。
- **`sheet`**：优先使用底部弹窗。
- **`none`**：尽量保持原始展示方式，不做适配。

***

## 示例用法

### 展示 Sheet

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  sheet={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    content: <VStack>
      <Text>Sheet 内容</Text>
      <Button title={"Dismiss"} action={() => setIsPresented(false)} />
    </VStack>
  }}
/>
```

### 展示 Popover

```tsx
<Button
  title={"Show Popover"}
  action={() => setIsPresented(true)}
  popover={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    presentationCompactAdaptation: "popover",
    content: <Text>Popover 内容</Text>,
    arrowEdge: "top",
  }}
/>
```

### 展示 Full Screen Cover

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  fullScreenCover={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    content: <VStack>
      <Text>全屏模态视图</Text>
    </VStack>
  }}
/>
```

### 配置 Sheet 高度

```tsx
sheet={{
  isPresented: isPresented,
  onChanged: setIsPresented,
  content: <VStack
    presentationDetents={[200, "medium", "large"]}
    presentationDragIndicator={"visible"}
  >
    <Text>可拖动调整高度的 Sheet</Text>
  </VStack>
}}
```

### 展示 Alert

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  alert={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    title: "警告",
    message: <Text>一切正常</Text>,
    actions: <Button title={"OK"} action={() => {}} />
  }}
/>
```

### 展示 Confirmation Dialog

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  confirmationDialog={{
    isPresented,
    onChanged: setIsPresented,
    title: "是否删除此图片？",
    actions: <Button title={"删除"} role={"destructive"} action={() => {}} />
  }}
/>
```



---
url: /zh/guide/Views/Modal presentaions/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, useState, VStack } from "scripting"

function SheetExample() {
  const [
    isPresented,
    setIsPresented
  ] = useState(false)

  return <Section
    header={
      <Text>Showing a sheet</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      sheet={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        content: <VStack
          presentationDragIndicator={"visible"}
        >
          <Text
            font={"title"}
            padding={50}
          >
            Sheet content
          </Text>
          <Button
            title={"Dismiss"}
            action={() => setIsPresented(false)}
          />
        </VStack>
      }}
    />
  </Section>
}

function PopoverExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Showing a popover</Text>
    }
  >
    <Button
      title={"Show Popover"}
      action={() => {
        setIsPresented(true)
      }}
      popover={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        presentationCompactAdaptation: "popover",
        content: <Text padding>Popover content</Text>,
        arrowEdge: "top",
      }}
    />
  </Section>
}

function FullScreenCoverExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Showing a full screen cover</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      fullScreenCover={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        content: <VStack
          onTapGesture={() => setIsPresented(false)}
          foregroundStyle={"white"}
          frame={{
            maxHeight: "infinity",
            maxWidth: "infinity",
          }}
          background={"blue"}
          ignoresSafeArea
        >
          <Text>A full-screen modal view.</Text>
          <Text>Tap to dismiss</Text>
        </VStack>
      }}
    />
  </Section>
}

function ConfiguringSheetHeightExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Configuring sheet height</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      sheet={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        content: <VStack
          presentationDragIndicator={"visible"}
          presentationDetents={[
            200, // fixed height
            "medium",
            "large"
          ]}
        >
          <Text
            font={"title"}
            padding={50}
          >
            Drag the indicator to resize the sheet height.
          </Text>
          <Button
            title={"Dismiss"}
            action={() => setIsPresented(false)}
          />
        </VStack>
      }}
    />
  </Section>
}

function PresentAlertExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Present a alert view</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      alert={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        actions: <Button
          title={"OK"}
          action={() => { }}
        />,
        title: "Alert",
        message: <Text>Everything is OK</Text>
      }}
    />
  </Section>
}

function PresentConfirmationDialogExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Present a confirmation dialog</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => {
        setIsPresented(true)
      }}
      confirmationDialog={{
        isPresented,
        onChanged: setIsPresented,
        title: "Do you want to delete this image?",
        actions: <Button
          title={"Delete"}
          role={"destructive"}
          action={() => {
            Dialog.alert({
              message: "The image has been deleted."
            })
          }}
        />
      }}
    />
  </Section>
}

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Modal presentations"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <SheetExample />
      <ConfiguringSheetHeightExample />
      <FullScreenCoverExample />
      <PopoverExample />
      <PresentAlertExample />
      <PresentConfirmationDialogExample />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/NamespaceReader.md
---

# 命名空间读取器（NamespaceReader）

`NamespaceReader` 用于 **创建并管理一个几何动画命名空间（Namespace）**。
该命名空间是实现以下能力的**前提条件**：

- `matchedGeometryEffect`（组件级几何联动动画）
- `matchedTransitionSource`（页面级导航转场动画）
- `navigationTransition`（如 zoom 转场）

可以将 `NamespaceReader` 理解为：

> 一个“动画坐标系提供者”，用于告诉系统：哪些视图属于**同一组几何动画作用域**。

***

## 一、API 角色说明

`NamespaceReader` 并不是一个普通的 UI 组件，而是一个 **命名空间生成器**，用于：

- 创建一个全新的 `NamespaceID`
- 通过 render function 方式暴露给子视图使用
- 作为几何匹配动画系统的“分组边界”

它在 Scripting 中对应 SwiftUI 的：

- `@Namespace`
- `Namespace.ID`

***

## 二、基本使用方式

### 1. 最小用法结构

```tsx
<NamespaceReader>
  {namespace => (
    // 在这个作用域内
    // 使用 namespace 绑定 matchedGeometryEffect 或 matchedTransitionSource
  )}
</NamespaceReader>
```

说明：

- `NamespaceReader` 是一个 **函数式子节点组件**
- 其子节点必须是一个函数
- 该函数的参数 `namespace` 即为当前创建的命名空间实例

***

## 三、Namespace 的本质作用

### 1. 命名空间的真正含义

`namespace` 的本质作用是：

- 把一组“逻辑上可能互相关联的视图”
- 显式地声明为：

  > “它们允许进行几何匹配动画”

如果没有相同的 `namespace`：

- 即使两个视图的 `id` 完全一致
- 依然 **不会产生任何几何动画**

***

### 2. Namespace 的隔离能力

| 情况                       | 是否发生几何匹配 |
| ------------------------ | -------- |
| 相同 `id` + 相同 `namespace` | 会        |
| 相同 `id` + 不同 `namespace` | 不会       |
| 不同 `id` + 相同 `namespace` | 不会       |
| 不同 `id` + 不同 `namespace` | 不会       |

结论：

> **必须同时满足 `id` 与 `namespace` 完全一致，系统才会建立几何匹配关系。**

***

## 四、NamespaceReader 与几何动画系统的关系

### 1. 与 matchedGeometryEffect 的关系

- `matchedGeometryEffect` 依赖 `namespace` 建立“跨视图几何映射”
- `NamespaceReader` 是 `matchedGeometryEffect` 的 **前置条件**
- 没有 `NamespaceReader`：

  - `matchedGeometryEffect` 无法工作

***

### 2. 与 matchedTransitionSource 的关系

- 页面级转场动画依赖 `namespace` 来配对：

  - 转场源视图
  - 目标页面
- `NamespaceReader` 用于：

  - 在源页面生成 namespace
  - 并传递给目标页面作为统一坐标系统

***

## 五、最基础的 NamespaceReader 示例（组件级）

```tsx
const expanded = useObservable(false)

<NamespaceReader>
  {namespace => (
    <VStack>
      {!expanded.value && (
        <Circle
          matchedGeometryEffect={{
            id: "shape",
            namespace
          }}
          onTapGesture={() => {
            expanded.setValue(true)
          }}
        />
      )}

      {expanded.value && (
        <Circle
          frame={{ width: 200, height: 200 }}
          matchedGeometryEffect={{
            id: "shape",
            namespace,
            isSource: false
          }}
        />
      )}
    </VStack>
  )}
</NamespaceReader>
```

该示例中：

- `NamespaceReader` 负责创建动画坐标系
- 两个 `Circle` 因为：

  - `id` 相同
  - `namespace` 相同
    从而建立起几何联动关系

***

## 六、导航转场中的 NamespaceReader 典型结构

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

该结构说明：

- `namespace` 由 `NamespaceReader` 生成
- 同时被：

  - 源视图使用
  - 目标页面使用
- 从而建立完整的页面级共享几何动画

***

## 七、命名空间的生命周期与作用范围

### 1. 生命周期

- `NamespaceReader` 每次创建：

  - 都会生成一个 **全新的 namespace**
- 该 namespace 的生命周期：

  - 仅存在于当前组件树
  - 随组件卸载而销毁

***

### 2. 作用范围

- namespace 只对其 render function 内部的视图生效
- 不可跨越组件树自动共享
- 如果需要跨组件共享：

  - 必须通过 props 显式传递 `namespace`

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- 是否真的使用了 `NamespaceReader`
- 是否正确接收并传递了 `namespace`
- source 与 target 是否引用的是 **同一个 namespace 实例**

***

### 2. 动画偶尔失效、不稳定

常见原因：

- `NamespaceReader` 被条件渲染反复销毁与重建
- 每次重建都会生成新的 namespace
- 导致旧视图与新视图：

  - 实际上不在同一个动画坐标系中

建议：

- 将 `NamespaceReader` 放在 **稳定的父级节点**
- 避免在 `if / ternary` 结构中频繁切换

***

### 3. 多个 NamespaceReader 嵌套导致动画错乱

问题表现：

- id 相同
- 但实际 namespace 不同
- 系统无法建立匹配关系

排查思路：

- 确认 source 与 target 是否真的来自：

  - 同一个 `NamespaceReader` 实例

***

## 九、设计层面的使用建议

1. 一个独立动画区域使用一个 `NamespaceReader`
2. 不要为每一个视图都单独创建 `NamespaceReader`
3. 页面级动画：

   - NamespaceReader 应放在整个页面的根节点
4. 组件级动画：

   - NamespaceReader 应包裹同一个逻辑模块
5. 同一个 namespace 内：

   - 不要复用相同的 `id` 给不相关的视图

***

## 十、适用场景总结

适合使用 `NamespaceReader` 的场景：

- 卡片 → 详情页的共享元素动画
- Tab 指示器几何联动
- 图片放大预览
- 列表项 → 详情内容过渡
- 多视图间的空间连续动画

不需要使用 `NamespaceReader` 的场景：

- 普通 opacity / scale 动画
- 单视图内部的简单过渡
- 不涉及跨视图几何同步的动画



---
url: /zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Collapsed split views.md
---

# 折叠分栏视图

```tsx
import { Navigation, NavigationSplitView, NavigationSplitViewColumn, Script, Text, useState, VStack } from "scripting"

function Example() {
  const [preferredColumn, setPreferredColumn] = useState<NavigationSplitViewColumn>("detail")

  return <NavigationSplitView
    preferredCompactColumn={{
      value: preferredColumn,
      onChanged: (value) => {
        console.log("preferredCompactColumn changed to", value)
        setPreferredColumn(value)
      }
    }}
    sidebar={
      <VStack
        navigationContainerBackground={"yellow"}
        frame={{
          maxWidth: "infinity",
          maxHeight: "infinity",
        }}
      >
        <Text>Yellow</Text>
      </VStack>
    }
  >
    <VStack
      navigationContainerBackground={"blue"}
      frame={{
        maxWidth: "infinity",
        maxHeight: "infinity",
      }}
    >
      <Text>Blue</Text>
    </VStack>
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Control column visibility.md
---

# 控制栏的可见性

```tsx
import { HStack, Label, List, Navigation, NavigationSplitView, NavigationSplitViewVisibility, Script, Text, useState, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

const companies: Company[] = [
  {
    name: "Company A",
    departments: [
      {
        name: "Sales",
        staff: [
          {
            name: "Juan Chavez",
            phoneNumber: "(408) 555-4301",
          },
          {
            name: "Mei Chen",
            phoneNumber: "(919) 555-2481",
          }
        ]
      },
      {
        name: "Engineering",
        staff: [
          {
            name: "Bill James",
            phoneNumber: "(408) 555-4450"
          },
          {
            name: "Anne Johnson",
            phoneNumber: "(417) 555-9311"
          }
        ]
      }
    ]
  },
  {
    name: "Company B",
    departments: [
      {
        name: "Human resources",
        staff: [
          {
            name: "Lily",
            phoneNumber: "(111) 555-5552"
          },
          {
            name: "Ross",
            phoneNumber: "(222) 666-8888"
          }
        ]
      },
      {
        name: "Sales",
        staff: [
          {
            name: "John",
            phoneNumber: "(1) 888-4444"
          }
        ]
      }
    ]
  }
]

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

 function Example() {
  const [columnVisibility, setColumnVisibility] = useState<NavigationSplitViewVisibility>("detailOnly")
  const [selectedPerson, setSelectedPerson] = useState<Person>()

  return <NavigationSplitView
    columnVisibility={{
      value: columnVisibility,
      onChanged: (value) => {
        console.log("columnVisibility changed to", value)
        setColumnVisibility(value)
      },
    }}
    sidebar={
      <List>
        {companyA.departments[0].staff.map(person =>
          <PersonRowView
            person={person}
            contentShape={"rect"}
            onTapGesture={() => {
              setSelectedPerson(person)
            }}
          />
        )}
      </List>
    }
  >
    {selectedPerson != null
      ? <PersonDetailView
        person={selectedPerson}
      />
      : <Text>Please select a person.</Text>
    }
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Three-column.md
---

# 三栏

```tsx
import { HStack, Label, List, Navigation, NavigationSplitView, Script, Section, Text, useState, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

const companies: Company[] = [
  {
    name: "Company A",
    departments: [
      {
        name: "Sales",
        staff: [
          {
            name: "Juan Chavez",
            phoneNumber: "(408) 555-4301",
          },
          {
            name: "Mei Chen",
            phoneNumber: "(919) 555-2481",
          }
        ]
      },
      {
        name: "Engineering",
        staff: [
          {
            name: "Bill James",
            phoneNumber: "(408) 555-4450"
          },
          {
            name: "Anne Johnson",
            phoneNumber: "(417) 555-9311"
          }
        ]
      }
    ]
  },
  {
    name: "Company B",
    departments: [
      {
        name: "Human resources",
        staff: [
          {
            name: "Lily",
            phoneNumber: "(111) 555-5552"
          },
          {
            name: "Ross",
            phoneNumber: "(222) 666-8888"
          }
        ]
      },
      {
        name: "Sales",
        staff: [
          {
            name: "John",
            phoneNumber: "(1) 888-4444"
          }
        ]
      }
    ]
  }
]

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  const [selectedCompany, setSelectedCompany] = useState<Company>()
  const [selectedPerson, setSelectedPerson] = useState<Person>()

  return <NavigationSplitView
    sidebar={
      <List>
        {companies.map(company =>
          <Text
            onTapGesture={() => {
              setSelectedCompany(company)
            }}
          >{company.name}</Text>
        )}
      </List>
    }
    content={
      selectedCompany != null
        ? <List>
          {selectedCompany.departments.map(department =>
            <Section
              header={<Text>{department.name}</Text>}
            >
              {department.staff.map(person =>
                <PersonRowView
                  person={person}
                  contentShape={"rect"}
                  onTapGesture={() => {
                    setSelectedPerson(person)
                  }}
                />
              )}
            </Section>
          )}
        </List>
        : <Text>Select a company</Text>
    }
  >
    {selectedPerson != null
      ? <PersonDetailView
        person={selectedPerson}
      /> :
      <Text>Select a person</Text>}
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Two-column.md
---

# 两栏

```tsx
import { HStack, Label, List, Navigation, NavigationSplitView, Script, Text, useState, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  const [selectedPerson, setSelectedPerson] = useState<Person>()

  return <NavigationSplitView
    sidebar={
      <List>
        {companyA.departments[0].staff.map(person =>
          <PersonRowView
            person={person}
            contentShape={"rect"}
            onTapGesture={() => {
              setSelectedPerson(person)
            }}
          />
        )}
      </List>
    }
  >
    {selectedPerson != null
      ? <PersonDetailView
        person={selectedPerson}
      />
      : <Text>Please select a person.</Text>
    }
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Navigation/NavigationStack/NavigationStack with path.md
---

# NavigationStack 配合 path

`NavigationStack.path` 用于为 `NavigationStack` 提供**可观察的导航路径控制能力**，用于实现：

- 编程式导航（Programmatic Navigation）
- 多级页面堆栈控制
- 页面回退到指定层级或根视图
- 与 `NavigationDestination` 的动态页面映射联动

***

## 一、API 定义

```ts
type NavigationStackProps = {
  path?: Observable<string[]>
  ...
}

declare const NavigationStack: FunctionComponent<NavigationStackProps>
```

***

## 二、path 的类型与含义

```ts
path?: Observable<string[]>
```

`path` 是一个字符串数组的可观察对象，用于表示当前导航栈中的**页面路径序列**。

其语义规则如下：

- 每一个 `string` 表示一个页面标识
- 数组顺序表示页面入栈顺序
- 数组末尾元素表示当前显示的页面
- 数组为空表示回到根页面（Root）

示例说明：

```ts
[]
```

表示当前在根视图

```ts
["a"]
```

表示已导航到页面 `a`

```ts
["a", "b"]
```

表示先进入页面 `a`，再进入页面 `b`

***

## 三、基础使用示例

```tsx
function Page() {
  const path = useObservable<string[]>(["a"])

  return <NavigationStack
    path={path}
  >
    <VStack
      navigationTitle="Navigation Demo"
      navigationDestination={
        <NavigationDestination>
          {(page) =>
            <VStack>
              <Text>
                Current page:
                {page}
              </Text>
              {path.value.length > 1
                && <Button
                  title="Go to Root"
                  action={() => {
                    path.setValue([])
                  }}
                />}
            </VStack>
          }
        </NavigationDestination>
      }
    >
      <Button
        title="Show page a"
        action={() => {
          path.setValue(["a"])
        }}
      />
      <Button
        title="Show page b"
        action={() => {
          path.setValue(["b"])
        }}
      />
      <Button
        title="Show page a then b"
        action={() => {
          path.setValue(["a", "b"])
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 四、path 的工作机制说明

### 1. path 作为导航状态的唯一数据源

当 `NavigationStack` 绑定了 `path` 后：

- 当前页面层级将完全由 `path.value` 决定
- UI 导航状态将与 `path` 保持双向同步
- 不再依赖隐式的 Push / Pop 状态管理

***

### 2. 页面入栈规则

当执行：

```ts
path.setValue(["a"])
```

系统行为：

- 根页面入栈
- 跳转至页面 `a`

当执行：

```ts
path.setValue(["a", "b"])
```

系统行为：

- 先进入页面 `a`
- 再进入页面 `b`
- 当前显示页面为 `b`

***

### 3. 页面出栈与回到根页面

当执行：

```ts
path.setValue([])
```

系统行为：

- 清空整个导航路径
- 立即回到根页面

***

## 五、NavigationDestination 与 path 的关系

`NavigationDestination` 用于根据 `path` 中的当前值动态构建目标页面。

```tsx
<NavigationDestination>
  {(page) => ...}
</NavigationDestination>
```

其中：

- `page` 参数来自 `path.value` 的当前末尾元素
- 当 `path` 发生变化时：

  - `page` 会自动更新
  - 对应的页面内容会重新渲染

示例逻辑：

```ts
["a"]  -> page === "a"
["a","b"] -> page === "b"
```

***

## 六、通过按钮控制 path 进行导航

跳转到页面 `a`：

```ts
path.setValue(["a"])
```

跳转到页面 `b`：

```ts
path.setValue(["b"])
```

连续跳转两个页面：

```ts
path.setValue(["a", "b"])
```

返回根页面：

```ts
path.setValue([])
```

***

## 七、path 与手势返回的同步关系

当用户通过系统返回手势或导航栏返回按钮返回时：

- `path.value` 会自动同步更新
- 显示页面与 `path` 始终保持一致
- 不需要额外监听返回事件进行手动同步

***

## 八、path 的典型使用场景

`NavigationStack.path` 适用于以下场景：

- 深层页面跳转
- 跨页面编程式导航控制
- 统一的路由状态管理
- 脚本控制页面跳转
- 恢复上次浏览路径
- 多步骤流程（向导式界面）

***

## 九、常见错误说明

### 1. path 未初始化为空数组

错误：

```ts
const path = useObservable<string[]>(null)
```

正确：

```ts
const path = useObservable<string[]>([])
```

***

### 2. path 中的值类型错误

错误：

```ts
path.setValue([1, 2])
```

正确：

```ts
path.setValue(["1", "2"])
```

当前 `path` 仅支持 `string[]` 作为路径类型。

***

## 十、与不使用 path 的 NavigationStack 的区别

| 功能      | 不使用 path | 使用 path |
| ------- | -------- | ------- |
| 手动 Push | 支持       | 不建议     |
| 编程式跳转   | 不支持      | 支持      |
| 多层跳转    | 受限       | 完全支持    |
| 状态恢复    | 困难       | 简单      |
| 路由统一管理  | 不可控      | 完全可控    |



---
url: /zh/guide/Views/Navigation/NavigationStack/Use with NavigationLink.md
---

# 与 NavigationLink 一起使用

```tsx
import { Color, List, Navigation, NavigationLink, NavigationStack, Script, Text, VStack } from "scripting"

function NavigationDetailView({
  color
}: {
  color: Color
}) {

  return <VStack
    navigationContainerBackground={color}
    frame={{
      maxWidth: "infinity",
      maxHeight: "infinity"
    }}
  >
    <Text>{color}</Text>
  </VStack>
}


function Example() {
  const colors: Color[] = [
    "red", "green", "blue", "orange", "purple"
  ]

  return <NavigationStack>
    <List
      navigationTitle={"NavigationStack with links"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {colors.map(color =>
        <NavigationLink
          destination={
            <NavigationDetailView
              color={color}
            />
          }
        >
          <Text>Navigation to {color} view</Text>
        </NavigationLink>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Navigation/NavigationStack/Use with navigationDestination.md
---

# 与 navigationDestination 一起使用

```tsx
import { useState, Color, NavigationStack, List, Text, HStack, Spacer, Image, VStack, Navigation, Script } from "scripting"

function NavigationDetailView({
  color
}: {
  color: Color
}) {

  return <VStack
    navigationContainerBackground={color}
    frame={{
      maxWidth: "infinity",
      maxHeight: "infinity"
    }}
  >
    <Text>{color}</Text>
  </VStack>
}

function Example() {
  const colors: Color[] = [
    "red", "green", "blue", "orange", "purple"
  ]
  const [selectedColor, setSelectedColor] = useState<Color | null>()

  return <NavigationStack>
    <List
      navigationTitle={"With Navigation Destination"}
      navigationDestination={{
        isPresented: selectedColor != null,
        onChanged: value => {
          if (!value) {
            setSelectedColor(null)
          }
        },
        content: selectedColor != null
          ? <NavigationDetailView
            color={selectedColor}
          />
          : <Text>Select a color</Text>
      }}
    >
      {colors.map(color =>
        <HStack
          contentShape={"rect"}
          onTapGesture={() => {
            setSelectedColor(color)
          }}
        >
          <Text>Navigation to {color} view</Text>
          <Spacer />
          <Image
            systemName={"chevron.right"}
            foregroundStyle={"secondaryLabel"}
          />
        </HStack>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Navigation/TabView/TabView with badge.md
---

# 带徽章的 TabView

```tsx
import { Label, Navigation, Script, TabView, Text, useState } from "scripting"

function Example() {
  const [tabIndex, setTabIndex] = useState(0)

  return <TabView
    tabIndex={tabIndex}
    onTabIndexChanged={setTabIndex}
  >
    <ReceivedView
      tag={0}
      tabItem={
        <Label
          title={"Received"}
          systemImage={"tray.and.arrow.down.fill"}
        />
      }
      badge={2}
    />
    <SendView
      tag={1}
      tabItem={
        <Label
          title={"Send"}
          systemImage={"tray.and.arrow.up.fill"}
        />
      }
    />
    <AccountView
      tag={2}
      badge={"!"}
      tabItem={
        <Label
          title={"Account"}
          systemImage={"person.crop.circle.fill"}
        />
      }
    />
  </TabView>
}

function ReceivedView() {
  return <Text>Received view</Text>
}

function SendView() {
  return <Text>Send view</Text>
}

function AccountView() {
  return <Text>Account view</Text>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Navigation/TabView/TabView with multiple scrolling pages.md
---

# 包含多个可滚动页面的 TabView

```tsx
import { Color, Navigation, NavigationStack, Script, TabView, Text, VStack } from "scripting"

function Example() {
  const colors: Color[] = [
    "red",
    "green",
    "blue",
    "purple"
  ]

  return <NavigationStack>
    <VStack
      navigationTitle={"TabView"}
    >
      <TabView
        tabViewStyle={"page"}
        frame={{
          height: 200
        }}
      >
        {colors.map(color =>
          <ColorView
            color={color}
          />
        )}
      </TabView>
    </VStack>
  </NavigationStack>
}

function ColorView({
  color,
}: {
  color: Color
}) {
  return <VStack
    frame={{
      maxWidth: "infinity",
      maxHeight: "infinity"
    }}
    background={color}
  >
    <Text>{color}</Text>
  </VStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Navigation/TabView/TabView.md
---

Scripting 提供了与最新 iOS TabView 体系一致的 API：
通过 `TabView`、`Tab`、`TabSection` 组织界面结构，使应用能够在 iOS 18+ 环境下完整支持多标签视图、侧边栏标签、可定制布局等。

相比旧版本依赖 `tabItem` 修饰符的方式，新的结构更加灵活、分组更清晰，并能与 TabViewCustomization 等新特性无缝配合。

***

# 一、基础结构：TabView + Tab

在最基本的形式中，`TabView` 作为容器，内部包含多个 `Tab`。
每个 `Tab` 定义：

- 标签标题
- 图标
- 标识值（value）
- 角色（如 search）
- 对应的内容视图

示例：

```tsx
function RootView() {
  const selection = useObservable<number>(0)

  return (
    <TabView selection={selection}>
      <Tab
        title="首页"
        systemImage="house.fill"
        value={0}
      >
        <HomeView />
      </Tab>

      <Tab
        title="搜索"
        systemImage="magnifyingglass"
        value={1}
        role="search"
      >
        <SearchView />
      </Tab>

      <Tab
        title="设置"
        systemImage="gearshape.fill"
        value={2}
      >
        <SettingsView />
      </Tab>
    </TabView>
  )
}
```

要点：

- `selection` 通过 Observable 控制当前激活的标签
- `value` 必须与 `selection` 的泛型类型匹配（string 或 number）
- Search Tab 可使用 `role="search"` 与搜索相关行为联动

***

# 二、使用 TabSection 组织分组标签

当 Tab 数量较多、需要按功能分类、需要在侧边栏中显示复杂结构时，可以使用 `TabSection`。

结构关系为：

```
TabView
 ├─ TabSection
 │   ├─ Tab
 │   ├─ Tab
 │   └─ ...
 ├─ TabSection
 │   ├─ Tab
 │   └─ ...
```

## 1. 使用 title 作为分组标题

```tsx
<TabView selection={selection}>
  <TabSection title="收件箱">
    <Tab title="收件箱" systemImage="tray.fill" value="inbox">
      <InboxView />
    </Tab>
    <Tab title="已发送" systemImage="paperplane.fill" value="sent">
      <SentView />
    </Tab>
  </TabSection>

  <TabSection title="标签">
    <Tab title="重要" systemImage="star.fill" value="important">
      <ImportantView />
    </Tab>
  </TabSection>
</TabView>
```

## 2. 使用 header 作为自定义组头

如需显示图标、说明文字或复合内容，可用 `header`：

```tsx
<TabSection
  header={
    <HStack spacing={8}>
      <Image systemName="folder.fill" />
      <VStack>
        <Text fontWeight="bold">项目</Text>
        <Text fontSize={12} foregroundColor="secondary">
          最近打开的项目
        </Text>
      </VStack>
    </HStack>
  }
>
  <Tab title="项目 A" systemImage="doc.fill" value="projectA">
    <ProjectAView />
  </Tab>
</TabSection>
```

***

# 三、TabSection 的高级能力：布局、操作区、拖拽与可见性

`TabSection` 提供了丰富的分组级配置，让 Tab 分组的呈现方式更加灵活。

## 1. tabPlacement（标签位置策略）

支持：

- `automatic`
- `pinned`
- `sidebarOnly`

例如将某组仅显示在侧边栏：

```tsx
<TabSection title="标签" tabPlacement="sidebarOnly">
  <Tab title="重要" systemImage="star.fill" value="important">
    <ImportantView />
  </Tab>
</TabSection>
```

## 2. sectionActions（分组操作区）

为某一组提供额外操作按钮：

```tsx
<TabSection
  title="列表"
  sectionActions={
    <Button title="添加" systemImage="plus" action={addItem} />
  }
>
  ...
</TabSection>
```

## 3. 分组可见性与可定制行为

通过：

- `defaultVisibility`
- `customizationID`
- `customizationBehavior`
- `draggable`
- `dropDestination`

可以为每个分组提供：

- 默认显示策略
- 是否允许用户自定义排序或隐藏
- 是否可以拖动
- 外部拖拽数据的处理

例如：

```tsx
<TabSection
  title="文件"
  customizationID="file-section"
  customizationBehavior="reorderable"
  draggable="file-section"
  dropDestination={items => handleDrop(items)}
>
  ...
</TabSection>
```

***

# 四、TabView 级别的高级配置

TabView 本身提供了一系列属性，可用于构建高级 UI（iOS 18～26）。

包括：

- `tabBarMinimizeBehavior`
- `tabViewBottomAccessory`
- `tabViewSearchActivation`
- `tabViewCustomization`
- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

以下为每项能力的说明。

***

## 1. tabBarMinimizeBehavior（iOS 26.0+）

控制 TabBar 是否根据滚动方向自动最小化：

- `automatic`
- `never`
- `onScrollDown`
- `onScrollUp`

示例：

```tsx
<TabView
  selection={selection}
  tabBarMinimizeBehavior="onScrollDown"
>
  ...
</TabView>
```

***

## 2. tabViewBottomAccessory（iOS 26.0+）

为 TabView 添加底部附加视图，例如提示栏：

```tsx
<TabView
  selection={selection}
  tabViewBottomAccessory={
    <HStack>
      <Text>左右滑动切换标签</Text>
      <Spacer />
      <Button title="知道了" action={dismiss} />
    </HStack>
  }
>
  ...
</TabView>
```

***

## 3. tabViewSearchActivation（iOS 26.0+）

控制搜索 Tab 的激活方式：

- `automatic`
- `searchTabSelection`

与 `role="search"` 搭配使用：

```tsx
<TabView
  selection={selection}
  tabViewSearchActivation="searchTabSelection"
>
  ...
</TabView>
```

***

## 4. 侧边栏附属视图（iOS 18.0+）

包括：

- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

示例：

```tsx
<TabView
  selection={selection}
  tabViewSidebarHeader={<UserHeader />}
  tabViewSidebarFooter={<SettingsButton />}
  tabViewSidebarBottomBar={<UpgradeButton />}
>
  ...
</TabView>
```

***

# 五、TabViewCustomization：标签页可定制化体系（重点补充）

`TabViewCustomization` 是一个可序列化的状态对象，用于存储和恢复用户对 Tab 布局的自定义行为，包括：

- Tab 分组顺序
- 分组内部的 Tab 排序
- Tab 可见性（在 TabBar 与 Sidebar 中分别独立管理）
- 重置各种设置
- 持久化与恢复

它通常放在 TabView 根视图中，通过：

```tsx
tabViewCustomization={customizationState}
```

来注入。

## 1. 创建与加载 TabViewCustomization

创建方式通常是：

```tsx
const customization = useObservable<TabViewCustomization >(() => {
  const data = Storage.get('tab_customization')
  if (data) {
    return TabViewCustomization.fromData(data) ?? new TabViewCustomization()
  }
  return new TabViewCustomization()
})

useEffect(() => {
  const listener = (newValue: TabViewCustomization) => {
    const data = newValue.toData()
    if (data) {
      Storage.set('tab_customization', data)
    }
  }
  customization.subscribe(listener)
  return () => {
    customization.unsubscribe(listener)
  }
}, [])
```

如需创建一个新的空自定义对象，可使用：

```tsx
const customizationState = useObservable(() => new TabViewCustomization())
```

## 2. 保存自定义内容

你可以将用户调整后的 Tab 布局序列化保存：

```tsx
const data = customization.value?.toData()
Storage.set('tab_customization', data)
```

`toData()` 会将内部状态转换为可存储的 `Data` 对象。

## 3. 获取并操作分组（Section）

```ts
getSection(id: string): TabViewCustomizationSection | null
```

`TabSection` 通常带有 `customizationID`，这样就可以获取特定分组并操作它：

```tsx
const section = customization.value?.getSection('file-section')

section?.tabOrder        // 一个包含 tab ID 顺序的数组，或 null
section?.resetTabOrder() // 重置排序
```

场景示例：

- 用户将“文件”分组中的 Tab 重新排序
- 用户将某些 Tab 移动到“更多”区域
- 应用需要根据用户排序更新 UI

## 4. 获取并操作单个 Tab

```ts
getTab(id: string): TabViewCustomizationTab | null
```

可通过 Tab 的 `customizationID` 获取并调整其可见性：

```tsx
const tab = customization.value?.getTab('important-tab')

tab?.tabBarVisibility         // Visibility 类型
tab.sidebarVisibility = 'hidden'
```

适用场景：

- 控制 Tab 在 TabBar 或 Sidebar 中是否显示
- 用户可通过自定义界面操作 Tab 可见性
- 程序自动隐藏某些 Tab

## 5. 全局重置

```ts
resetSectionOrder(): void
resetVisibility(): void
```

通常用于：

- 点击“恢复默认布局”按钮
- 版本更新后清理已有布局逻辑

示例：

```tsx
<Button
  title="恢复默认"
  action={() => {
    customization.value?.resetSectionOrder()
    customization.value?.resetVisibility()
  }}
/>
```

***

# 六、与旧的 tabItem 写法的关系

此文档采用全新的结构化写法：

- TabView
- Tab
- TabSection
- TabViewCustomization

旧的 `tabItem` 写法仍可用于简单场景以及兼容iOS 17，但与侧边栏、Tab 分组、自定义布局等高级能力不兼容。
在复杂应用中，建议全面迁移到新的组件体系。



---
url: /zh/guide/Views/Present views/Dismissing a presented view/index.md
---

# 关闭一个视图

此示例演示了如何使用 `Navigation.useDismiss` 钩子**以编程方式关闭已呈现的视图**。当你希望在用户交互（如点击按钮或文本标签）后关闭自定义视图时，这个方法非常有用。

***

## 目的

你将学会：

- 通过 `Navigation.useDismiss` 获取关闭视图的函数
- 调用该函数以关闭当前已呈现的视图
- 使用 `Script.exit` 安全退出脚本，以避免内存泄漏

***

## 示例代码

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {
  // 获取上下文中的 `dismiss` 函数
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle={"关闭视图"}
    >
      <Text
        foregroundStyle={'link'}
        onTapGesture={() => {
          dismiss()
        }}
      >点击关闭视图</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  // 避免内存泄漏
  Script.exit()
}

run()
```

***

## 关键概念

### `Navigation.useDismiss()`

该钩子返回当前视图上下文中的 `dismiss` 函数。调用它会关闭通过 `Navigation.present()` 呈现的视图。

### 使用场景

- 手动关闭一个已呈现的 UI 视图
- 用于表单提交、取消或导航控制逻辑中

### 示例用法

在示例中，渲染了一个可点击的 `Text`：

```tsx
<Text
  foregroundStyle={'link'}
  onTapGesture={() => {
    dismiss()
  }}
>
  点击关闭视图
</Text>
```

点击该文本会触发 `dismiss()`，从而关闭视图。

***

## 最佳实践

- 在 `Navigation.present()` 执行完成后，始终调用 `Script.exit()` 以避免内存泄漏
- 将视图包装在 `NavigationStack` 中，以支持标题栏和导航行为
- 确保 `useDismiss` 只在通过 `Navigation.present()` 呈现的组件树中使用

***

## 运行效果

此脚本会呈现一个简单视图，视图中包含一个链接样式的文本“**点击关闭视图**”。当用户点击该文本时，视图将被关闭。



---
url: /zh/guide/Views/Present views/Dismissing a presented view/index_example.md
---

# 示例

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {
  // Access the `dismiss` function of the context.
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle={"Dismiss a view"}
    >
      <Text
        foregroundStyle={'link'}
        onTapGesture={() => {
          dismiss()
        }}
      >Tap and dismiss</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Present views/Present a simple view/index.md
---

# 展示一个简单视图

本示例展示了如何使用 `Navigation.present` 在 Scripting 中展示一个基本的 UI 页面，同时演示了如何使用 `NavigationStack` 和 `navigationTitle` 设置导航标题。

***

## 示例功能

你将学习如何：

- 使用 `Navigation.present` 展示一个自定义页面
- 使用 `NavigationStack` 和 `VStack` 构建页面结构
- 设置导航栏标题（`navigationTitle`）

***

## 示例代码

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {

  return <NavigationStack>
    <VStack
      navigationTitle={"Present a simple view"}
    >
      <Text>Hello Scripting!</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

### `Navigation.present(options)`

该方法用于展示一个完整页面的 UI 视图。它接收一个 `element` 参数，该参数是要展示的根组件。

```ts
await Navigation.present({
  element: <View />
})
```

### `NavigationStack`

导航堆栈容器组件，支持页面标题、导航栏按钮等功能。它必须作为页面结构的最外层容器使用，以启用导航行为。

### `VStack`

垂直方向布局容器，用于将子视图从上到下堆叠排列。在本例中，它包含一个 `Text` 组件。

### `navigationTitle`

在 `VStack` 上设置该属性可以设置页面的导航栏标题。

***

## 页面效果

该示例会展示一个标题为 **“Present a simple view”** 的页面，并在中央显示文本 **“Hello Scripting!”**。

***

## 注意事项

- 如果你的页面需要导航栏、标题、返回按钮等功能，请务必使用 `NavigationStack` 包裹视图。
- `Navigation.present` 弹出页面后，需在其完成后调用 `Script.exit()` 来确保资源正确释放，避免内存泄漏。



---
url: /zh/guide/Views/Present views/Present a simple view/index_example.md
---

# 示例

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {

  return <NavigationStack>
    <VStack
      navigationTitle={"Present a simple view"}
    >
      <Text>Hello Scripting!</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/SVG.md
---

# SVG

`SVG` 是一个用于显示 SVG 矢量图像的视图组件，支持从以下三种来源加载 SVG 内容：

- **网络图片 URL**
- **本地文件路径**
- **内联 SVG 代码**

SVG 图像在显示时会作为位图进行渲染（不再支持矢量绘制）。你可以选择以模板图像的方式渲染，从而实现着色功能。

***

## 使用方式

```tsx
import { SVG } from 'scripting'
```

***

## Props（属性）

### 图像来源（3选1，必须指定一个）

| 属性         | 类型                                     | 说明                 |
| ---------- | -------------------------------------- | ------------------ |
| `url`      | `string \| DynamicImageSource<string>` | 从网络 URL 加载 SVG 图像  |
| `filePath` | `string \| DynamicImageSource<string>` | 从本地文件路径加载 SVG 图像   |
| `code`     | `string \| DynamicImageSource<string>` | 使用内联 SVG 字符串代码渲染图像 |

注意：以上三个属性**互斥**，只能设置其中一个。

***

### 图像渲染行为（ImageRenderingBehaviorProps）

| 属性                            | 类型                                      | 默认值          | 说明                                           |
| ----------------------------- | --------------------------------------- | ------------ | -------------------------------------------- |
| `resizable`                   | `boolean \| object`                     | `false`      | 控制图像是否自适应尺寸（详见下方）                            |
| `renderingMode`               | `'original' \| 'template'`              | `'original'` | 设置图像渲染模式，`template` 可使用 `foregroundColor` 着色 |
| `interpolation`               | `'none' \| 'low' \| 'medium' \| 'high'` | `'medium'`   | 设置图像缩放时的插值质量                                 |
| `antialiased`                 | `boolean`                               | `false`      | 是否开启抗锯齿边缘渲染                                  |
| `widgetAccentedRenderingMode` | `WidgetAccentedRenderingMode`           | -            | 控制在 Widget 的强调模式下的图像渲染方式（仅 Widget 有效）        |

***

### `resizable` 属性详细说明

| 类型                            | 含义                          |
| ----------------------------- | --------------------------- |
| `true`                        | 使用默认拉伸模式使图像适应容器大小           |
| `false`                       | 不对图像进行缩放                    |
| `{ capInsets, resizingMode }` | 设置切片边距和缩放模式（用于九宫格图像或复杂缩放需求） |

***

## 示例

### 从本地文件加载 SVG 并作为模板图像渲染

```tsx
<SVG
  filePath="/path/to/local/image.svg"
  resizable
  frame={{ width: 50, height: 50 }}
  renderingMode="template"
  foregroundColor="red"
/>
```

***

### 使用内联 SVG 代码渲染图像

```tsx
<SVG
  code={`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
    <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
  </svg>`}
  frame={{ width: 100, height: 100 }}
/>
```

***

## 注意事项

- `SVG` 图像现在统一以**位图方式渲染**，不再支持 `vectorDrawing` 属性。
- 若希望对图像进行着色，可设置 `renderingMode="template"` 并搭配 `foregroundColor`。
- 所有图像来源字段（`url`、`filePath`、`code`）只能设置一个，不能同时使用。



---
url: /zh/guide/Views/Scroll views/index.md
---

# 可滚动视图

`ScrollView` 组件用于在可滚动区域中显示其内容。当用户执行滚动手势时，可视区域会随之更新。你可以通过 `axes` 属性控制滚动方向，支持垂直、水平或双向滚动。

## 类型定义

```ts
type ScrollViewProps = {
  axes?: AxisSet
  children?: VirtualNode | VirtualNode[] | (VirtualNode | undefined | null)[]
}
```

## 基本说明

- 滚动方向由 `axes` 属性控制。
- 内容通过 `children` 指定，通常使用如 `<VStack>`、`<HStack>` 等布局容器。
- 不支持缩放操作。

## 默认行为

- 默认滚动方向为 **垂直**。
- 滚动指示器根据平台默认行为自动显示，除非通过 modifier 显式设置。

## 示例

```tsx
<ScrollView>
  <VStack>
    {new Array(100).fill('').map((_, index) => (
      <Text>Row {index}</Text>
    ))}
  </VStack>
</ScrollView>
```

***

## ScrollView 修饰符说明

你可以使用以下视图修饰符配置滚动行为：

***

### `scrollIndicator`

控制滚动指示器的显示方式。

#### 类型定义

```ts
scrollIndicator?: ScrollScrollIndicatorVisibility | {
  visibility: ScrollScrollIndicatorVisibility
  axes: AxisSet
}
```

#### `ScrollScrollIndicatorVisibility` 可选值：

- `"automatic"`：遵循系统默认行为。
- `"visible"`：显示指示器，可能会自动隐藏。
- `"hidden"`：隐藏指示器，除非被系统强制显示。
- `"never"`：从不显示指示器。

#### 示例

```tsx
<ScrollView scrollIndicator="never">
  <VStack>{/* 内容 */}</VStack>
</ScrollView>
```

设置特定方向的指示器：

```tsx
<ScrollView
  scrollIndicator={{
    visibility: "hidden",
    axes: "vertical"
  }}
>
  <VStack>{/* 内容 */}</VStack>
</ScrollView>
```

***

### `scrollDisabled`

完全禁用滚动行为。

#### 类型定义

```ts
scrollDisabled?: boolean
```

#### 示例

```tsx
<ScrollView scrollDisabled>
  <Text>该滚动视图已被锁定。</Text>
</ScrollView>
```

***

### `scrollClipDisabled`

控制是否允许内容超出滚动视图边界显示。

#### 类型定义

```ts
scrollClipDisabled?: boolean
```

#### 示例

```tsx
<ScrollView scrollClipDisabled>
  {/* 内容可能会超出滚动区域边界 */}
</ScrollView>
```

***

### `scrollDismissesKeyboard`

指定滚动行为对软件键盘的影响。

#### 类型定义

```ts
scrollDismissesKeyboard?: ScrollDismissesKeyboardMode
```

#### 可选值

- `"automatic"`：根据上下文决定默认行为。
- `"immediately"`：滚动开始时立即关闭键盘。
- `"interactively"`：允许用户拖动关闭键盘。
- `"never"`：滚动不会影响键盘。

#### 示例

```tsx
<ScrollView scrollDismissesKeyboard="interactively">
  {/* 含有输入框的内容 */}
</ScrollView>
```

***

### `defaultScrollAnchor`

设置初始显示的内容锚点，或内容变化时保持该锚点对齐。

#### 类型定义

```ts
defaultScrollAnchor?: KeywordPoint | Point
```

#### `KeywordPoint` 关键词

如 `"top"`、`"bottom"`、`"leading"`、`"trailing"`、`"center"`、`"topLeading"`、`"bottomTrailing"` 等。

#### 示例

```tsx
<ScrollView defaultScrollAnchor="bottom">
  <VStack>
    {/* 新增内容会保持底部对齐 */}
  </VStack>
</ScrollView>
```

***

### `AxisSet`

定义滚动方向。

#### 类型定义

```ts
type AxisSet = 'vertical' | 'horizontal' | 'all'
```

#### 示例

```tsx
<ScrollView axes="horizontal">
  <HStack>{/* 横向滚动内容 */}</HStack>
</ScrollView>
```

***

### `scrollTargetLayout`

用于标记滚动区域中的主要布局容器，便于对齐与滚动控制。

#### 类型定义

```ts
scrollTargetLayout?: boolean
```

#### 示例

```tsx
<ScrollView axes="horizontal">
  <LazyHStack scrollTargetLayout>
    {items.map(item => <Text>{item.title}</Text>)}
  </LazyHStack>
</ScrollView>
```

***

### `scrollTargetBehavior`

定义滚动时如何对齐内容。

#### 类型定义

```ts
scrollTargetBehavior?: ScrollTargetBehavior
```

```ts
type ScrollTargetBehavior =
  | "paging"
  | "viewAligned"
  | "viewAlignedLimitAutomatic"
  | "viewAlignedLimitAlways"
  | "viewAlignedLimitNever"
  | "viewAlignedLimitAlwaysByFew"
  | "viewAlignedLimitAlwaysByOne"
```

#### 模式说明

- `"paging"`：分页滚动，以容器尺寸为单位。
- `"viewAligned"`：滚动时按视图边界对齐。
- `"viewAlignedLimitAutomatic"`：在紧凑横向环境下限制滚动数量，其他情况放开。
- `"viewAlignedLimitAlways"`：始终限制每次滚动的项目数量。
- `"viewAlignedLimitNever"`：不限制滚动范围。
- `"viewAlignedLimitAlwaysByFew"` _(仅 iOS 18.0+)_：每次滚动少量视图。
- `"viewAlignedLimitAlwaysByOne"` _(仅 iOS 18.0+)_：每次滚动一个视图。

#### 描述

用于配置内容滚动对齐策略，适用于横向滚动的列表、分页等场景。

***

### `scrollContentBackground`

指定滚动区域的默认背景是否显示。

#### 类型定义

```ts
scrollContentBackground?: Visibility
```

#### 可选值

- `"automatic"`：根据上下文自动决定是否显示背景。
- `"hidden"`：隐藏默认背景，可实现透明或自定义背景。
- `"visible"`：强制显示默认背景，即使已有自定义背景。

#### 示例

```tsx
<List scrollContentBackground="hidden">
  <Text>这里没有默认背景</Text>
</List>
```

***

## 总结

| 修饰符 / 属性                  | 说明                                      |
| ------------------------- | --------------------------------------- |
| `axes`                    | 设置滚动方向（`vertical`、`horizontal` 或 `all`） |
| `scrollIndicator`         | 控制滚动指示器的显示及滚动方向                         |
| `scrollDisabled`          | 设置为 `true` 时禁用滚动行为                      |
| `scrollClipDisabled`      | 允许内容超出滚动区域边界可见                          |
| `scrollDismissesKeyboard` | 滚动时控制是否关闭软件键盘                           |
| `defaultScrollAnchor`     | 设置初始锚点或内容变化时的锚点                         |
| `scrollTargetLayout`      | 标记布局容器为滚动对齐的目标区域                        |
| `scrollTargetBehavior`    | 设置内容滚动对齐方式（分页、视图对齐等）                    |
| `scrollContentBackground` | 控制是否显示默认背景（透明、自定义背景场景常用）                |



---
url: /zh/guide/Views/Scroll views/index_example.md
---

# 示例

```tsx
import { Color, ForEach, HStack, KeywordPoint, Navigation, NavigationStack, Picker, RoundedRectangle, Script, ScrollView, Text, useState, VStack } from "scripting"

function Example() {
  const colors: Color[] = [
    "systemRed",
    "systemOrange",
    "systemYellow",
    "systemGreen",
    "systemBlue",
    "systemPurple",
    "systemIndigo",
    "systemPink",
  ]
  const [scrollAnchor, setScrollAnchor] = useState<KeywordPoint>("bottom")

  return <NavigationStack>
    <ScrollView
      navigationTitle={"ScrollView"}
      defaultScrollAnchor={scrollAnchor}
      navigationBarTitleDisplayMode={"inline"}
      key={scrollAnchor}
    >
      <VStack
        spacing={16}
        padding
      >
        <Picker
          title={"Default Scroll Anchor"}
          value={scrollAnchor}
          onChanged={setScrollAnchor as any}
          pickerStyle={"menu"}
        >
          <Text tag={"top"}>Top</Text>
          <Text tag={"center"}>Center</Text>
          <Text tag={"bottom"}>Bottom</Text>
        </Picker>

        <ScrollView
          axes={"horizontal"}
          frame={{
            height: 64
          }}
        >
          <HStack spacing={8}>
            <ForEach
              count={15}
              itemBuilder={index =>
                <RoundedRectangle
                  key={index.toString()}
                  fill={"systemIndigo"}
                  cornerRadius={6}
                  frame={{
                    width: 64,
                    height: 64,
                  }}
                  overlay={
                    <Text>{index}</Text>
                  }
                />
              }
            />
          </HStack>
        </ScrollView>

        <ForEach
          count={colors.length}
          itemBuilder={index => {
            const color = colors[index]
            return <RoundedRectangle
              key={color}
              fill={color}
              cornerRadius={16}
              frame={{
                height: 100
              }}
            />
          }}
        />
      </VStack>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()


```



---
url: /zh/guide/Views/ScrollViewReader.md
---

**ScrollViewReader** 组件，用于在脚本中获得对可滚动内容的编程化控制能力，使开发者能够在运行时滚动至任意视图位置，包括列表项、文本节点等。

ScrollViewReader 与 SwiftUI 的行为保持一致：
开发者通过一个回调函数获得一个 `ScrollViewProxy` 实例，并可以在任意时机调用 `scrollTo(id)` 控制滚动视图的位置。

***

# ScrollViewProxy

`ScrollViewProxy` 是提供滚动控制的代理对象，由 `ScrollViewReader` 在渲染期间自动注入。

```ts
interface ScrollViewProxy {
    scrollTo: (id: string | number, anchor?: KeywordPoint | Point) => void;
}
```

## 方法

### scrollTo(id, anchor?)

滚动到某个具有指定 `id` 的元素。
该 `id` 必须在可滚动内容内存在，并通过 `key` 配置。

#### 参数说明

| 参数     | 类型             | 必须       | 说明 |                                         |
| ------ | -------------- | -------- | -- | --------------------------------------- |
| id     | `string`       | `number` | 是  | 要滚动到的目标元素的唯一标识符。通常对应 `<View key="xxx">` |
| anchor | `KeywordPoint` | `Point`  | 否  | 滚动目标在可视区域中的对齐方式。可为字符串关键字或坐标点。           |

### KeywordPoint 类型

属于字符串关键字，常用：

- `'top'`
- `'center'`
- `'bottom'`

### Point 类型

用于精确控制滚动位置：

```ts
type Point = {
  x: number
  y: number
}
```

***

# ScrollViewReader

ScrollViewReader 用于包裹可滚动内容，并提供一个 `scrollViewProxy` 以控制内部滚动。

```ts
type ScrollViewReaderProps = {
    children: (scrollViewProxy: ScrollViewProxy) => VirtualNode
};
declare const ScrollViewReader: FunctionComponent<ScrollViewReaderProps>
```

## Props 说明

| 名称       | 类型                                        | 必须 | 说明                                          |
| -------- | ----------------------------------------- | -- | ------------------------------------------- |
| children | `(proxy: ScrollViewProxy) => VirtualNode` | 是  | 回调函数，将滚动代理传给开发者，并返回 ScrollView、List 等可滚动视图。 |

***

# 使用说明

1. **ScrollViewReader 必须包裹 List、ScrollView 等可滚动组件**。
2. **回调中的 proxy 只在视图构建阶段提供一次**，开发者可利用 `useRef` 保存。
3. 支持在动画中使用，例如 `withAnimation`。
4. 锚点可选，不传则使用默认对齐方式。
5. 所有 ScrollView 内部节点都可以使用 `key` 来作为 `scrollTo` 的目标。

***

# 基础示例

下面是一个完整的使用示例，包括滚动到指定元素以及使用动画的方式。

```tsx
import {
  Button,
  Navigation,
  NavigationStack,
  Script,
  Text,
  List,
  ScrollViewReader,
  ScrollView,
  VStack,
  useRef,
  ScrollViewProxy,
  withAnimation
} from "scripting"

function Item({ index }: { index: number }) {
  return <Text>
    Item - {index}
  </Text>
}

function View() {
  const dismiss = Navigation.useDismiss()
  const proxyRef = useRef<ScrollViewProxy>()

  return <NavigationStack>
    <VStack navigationTitle="ScrollViewReader">

      <ScrollViewReader>
        {(proxy) => {
          // 记录 proxy 实例，供按钮点击时使用
          proxyRef.current = proxy

          return <List>
            {new Array(100).fill(0).map((_, index) =>
              <Item
                key={index}
                index={index}
              />
            )}
            <Text key="bottom">
              Bottom
            </Text>
          </List>
        }}
      </ScrollViewReader>

      <Button
        title="跳转"
        action={() => {
          if (proxyRef.current == null) {
            console.log("no proxy found")
            return
          }

          const index = Math.random() * 100 | 0

          withAnimation(() => {
            proxyRef.current?.scrollTo(index, "bottom")
            // proxyRef.current?.scrollTo("bottom", "bottom")
          })
        }}
      />

    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```

***

# 关于 ID（key）匹配的说明

`scrollTo(id)` 依赖于内部节点的 `key` 属性。
以下配置都可作为滚动目标：

```tsx
<Text key="bottom">Bottom</Text>
```

`key` 与 SwiftUI 的 `.id()` 行为保持一致。

***

# 动画支持

ScrollViewReader 支持结合 `withAnimation` 来进行平滑滚动。例如：

```tsx
withAnimation(() => {
  proxy.scrollTo("target", "center")
})
```

在动画块中触发滚动，将获得平滑过渡。

***

# 注意事项

1. **必须在 ScrollViewReader 回调中记录 proxy**，否则外部无法访问。
2. **必须确保目标元素存在并有唯一 id**，否则无法滚到目标位置。
3. **不支持在 ScrollViewReader 外部渲染可滚动组件**。
4. **滚动行为与 SwiftUI 基本一致**，包括 anchor 对齐方式。



---
url: /zh/guide/Views/Search/index.md
---

# 搜索

Scripting 支持与 SwiftUI 类似的搜索功能。你可以为列表等滚动视图添加搜索栏，控制搜索栏的显示位置、状态，监听输入变化，并动态显示搜索建议。

***

## `searchable`

为视图添加搜索栏，并将搜索文本与状态绑定。

### 类型

```ts
searchable?: {
  value: string
  onChanged: (value: string) => void
  placement?: SearchFieldPlacement
  prompt?: string
  presented?: {
    value: boolean
    onChanged: (value: boolean) => void
  }
}
```

### 参数说明

- `value`: 当前搜索输入的文本（受控状态）。
- `onChanged`: 每当用户输入发生变化时调用，传入新的搜索内容。
- `placement`: 控制搜索栏的显示位置（可选）。
- `prompt`: 搜索栏中的提示占位文本（可选）。
- `presented`: 控制搜索栏是否处于激活状态，可以主动打开或关闭搜索界面（可选）。

### 示例

```tsx
function SearchExample() {
  const [query, setQuery] = useState("")
  const [showSearch, setShowSearch] = useState(false)

  return (
    <List
      searchable={{
        value: query,
        onChanged: setQuery,
        placement: "navigationBarDrawer",
        prompt: "搜索项目",
        presented: {
          value: showSearch,
          onChanged: setShowSearch,
        }
      }}
    >
      <Text>当前搜索内容：{query}</Text>
    </List>
  )
}
```

### `SearchFieldPlacement` 可选值

| 值                                       | 描述                           |
| --------------------------------------- | ---------------------------- |
| `'automatic'`                           | 系统自动决定搜索栏位置（默认）。             |
| `'navigationBarDrawer'`                 | 在导航栏下方作为抽屉式显示。               |
| `'navigationBarDrawerAlwaysDisplay'`    | 始终显示抽屉搜索栏。                   |
| `'navigationBarDrawerAutomaticDisplay'` | 根据需要自动显示抽屉搜索栏。               |
| `'toolbar'`                             | 显示在工具栏中。                     |
| `'sidebar'`                             | 显示在侧边栏（适用于 iPad 或 macOS 风格）。 |

***

## `searchSuggestions`

设置搜索建议的内容区域，在用户输入时显示一组建议项。

### 类型

```ts
searchSuggestions?: VirtualNode
```

### 示例

```tsx
const suggestions = useMemo(() => [
  {
    label: "🍎 Apple",
    value: "Apple"
  },
  {
    label: "🍌 Bananer",
    value: "Bananer"
  }
], [])
const filteredSuggestions = useMemo(() => {
  if (!/\S+/.test(query)) {
    return suggestions
  }
  const q = query.toLowerCase()
  return suggestions.filter(s =>
    s.label.toLowerCase().includes(q) ||
    s.value.toLowerCase().includes(q))
}, [query, suggestions])

<List
  searchable={{
    value: query,
    onChanged: setQuery
  }}
  searchSuggestions={
    <>
      {filteredSuggestions.map(s =>
        <Text
          searchCompletion={s.value}
        >{s.label}</Text>
      )}
    </>
  }
/>
```

***

## `searchSuggestionsVisibility`

控制搜索建议的显示位置和是否可见。

### 类型

```ts
searchSuggestionsVisibility?: {
  visibility: 'visible' | 'hidden'
  placements: SearchSuggestionsPlacementSet
}
```

### `SearchSuggestionsPlacementSet` 可选值

| 值           | 描述                |
| ----------- | ----------------- |
| `'content'` | 在主内容区域中显示建议项。     |
| `'menu'`    | 在弹出菜单或下拉列表中显示建议项。 |
| `'all'`     | 同时适用于所有可用位置。      |

### 示例

```tsx
<List
  searchSuggestionsVisibility={{
    visibility: 'visible',
    placements: 'menu'
  }}
/>
```

***

## `searchCompletion`

将某个视图（如 `<Text>`）标记为可点击的搜索建议项，并指定点击后填入搜索框的值。

### 类型

```ts
searchCompletion?: string
```

### 示例

```tsx
<Text searchCompletion="Mango">🥭 芒果</Text>
```

当用户点击该建议项后，搜索栏将自动填入 `"Mango"`。

***

## 小结

| 修饰符                           | 功能说明               |
| ----------------------------- | ------------------ |
| `searchable`                  | 添加搜索栏，绑定搜索状态与行为。   |
| `searchSuggestions`           | 提供搜索建议项列表。         |
| `searchSuggestionsVisibility` | 控制建议项的显示位置和是否可见。   |
| `searchCompletion`            | 设置建议项点击后自动填入搜索栏的值。 |



---
url: /zh/guide/Views/Search/index_example.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Script, Text, useMemo, useState } from "scripting"

function Example() {
  const [searchText, setSearchText] = useState("")
  const languages = useMemo(() => [
    "Java",
    "Objective-C",
    "Swift",
    "Python",
    "JavaScript",
    "C++",
    "Ruby",
    "Lua"
  ], [])

  const filteredLanguages = useMemo(() => {
    if (searchText.length === 0) {
      return languages
    }

    const text = searchText.toLowerCase()

    return languages.filter(language =>
      language.toLowerCase().includes(text)
    )
  }, [searchText, languages])

  return <NavigationStack>
    <List
      navigationTitle={"Searchable List"}
      navigationBarTitleDisplayMode={"inline"}
      searchable={{
        value: searchText,
        onChanged: setSearchText,
      }}
    >
      {filteredLanguages.map(language =>
        <Text>{language}</Text>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Shapes/index.md
---

# 形状

Scripting 提供了一套形状组件，用于绘制可缩放的矢量图形元素，包括矩形、圆形、椭圆、胶囊形、圆角矩形等。这些图形支持填充、描边、裁剪路径和尺寸控制，可广泛应用于信息展示、装饰背景、自定义进度视图等界面场景。

***

## 通用属性：`ShapeProps`

所有形状组件均支持以下属性，用于控制外观：

```ts
type ShapeProps = {
  trim?: {
    from: number
    to: number
  }
  fill?: ShapeStyle | DynamicShapeStyle
  stroke?: ShapeStyle | DynamicShapeStyle | {
    shapeStyle: ShapeStyle | DynamicShapeStyle
    strokeStyle: StrokeStyle
  }
  strokeLineWidth?: number // 已废弃
}
```

### 属性说明

| 属性名               | 类型                                 | 说明                                             |
| ----------------- | ---------------------------------- | ---------------------------------------------- |
| `trim`            | `{ from: number; to: number }`     | 裁剪图形路径，仅绘制部分路径。`from` 与 `to` 为 0～1 的小数。        |
| `fill`            | `ShapeStyle` 或 `DynamicShapeStyle` | 设置填充颜色或渐变。                                     |
| `stroke`          | 同 `fill`，或带 `strokeStyle` 的对象      | 设置描边颜色或渐变，支持自定义描边样式。                           |
| `strokeLineWidth` | `number`（已废弃）                      | 设置描边宽度。建议使用 `stroke.strokeStyle.lineWidth` 替代。 |

***

## 描边样式：`StrokeStyle`

你可以通过 `strokeStyle` 对象来自定义描边的线条细节：

```ts
type StrokeStyle = {
  lineWidth?: number
  lineCap?: 'butt' | 'round' | 'square'
  lineJoin?: 'bevel' | 'miter' | 'round'
  mitterLimit?: number
  dash?: number[]
  dashPhase?: number
}
```

### 描边样式参数说明

| 参数名           | 说明                                                   |
| ------------- | ---------------------------------------------------- |
| `lineWidth`   | 描边线条的宽度（单位：pt）。                                      |
| `lineCap`     | 线条端点样式，可选 `"butt"`（平头）、`"round"`（圆头）、`"square"`（方头）。 |
| `lineJoin`    | 拐角连接样式，可选 `"miter"`、`"round"`、`"bevel"`。             |
| `mitterLimit` | miter 样式拐角的最小限制（用于防止尖角过长）。                           |
| `dash`        | 虚线样式数组，定义实线和空白的交替长度。                                 |
| `dashPhase`   | 从虚线图案中的哪个位置开始绘制（偏移量）。                                |

***

## 支持的形状组件

### `Rectangle` 矩形

```tsx
<Rectangle
  fill="orange"
  stroke={{
    shapeStyle: "red",
    strokeStyle: {
      lineWidth: 3,
      lineJoin: "round"
    }
  }}
  frame={{ width: 100, height: 100 }}
/>
```

***

### `RoundedRectangle` 圆角矩形

```tsx
<RoundedRectangle
  fill="blue"
  cornerRadius={16}
  frame={{ width: 100, height: 100 }}
/>
```

支持统一圆角半径或尺寸：

```ts
type RoundedRectangleProps = ShapeProps & (
  | { cornerRadius: number }
  | { cornerSize: { width: number, height: number } }
) & {
  style?: RoundedCornerStyle // 默认为 continuous
}
```

***

### `UnevenRoundedRectangle` 不规则圆角矩形

支持为每个角设置不同的圆角半径：

```tsx
<UnevenRoundedRectangle
  fill="brown"
  topLeadingRadius={16}
  topTrailingRadius={0}
  bottomLeadingRadius={0}
  bottomTrailingRadius={16}
  frame={{ width: 100, height: 50 }}
/>
```

***

### `Circle` 圆形

```tsx
<Circle
  stroke="purple"
  strokeLineWidth={4}
  frame={{ width: 100, height: 100 }}
/>
```

***

### `Capsule` 胶囊形

```tsx
<Capsule
  fill="systemIndigo"
  frame={{ width: 100, height: 40 }}
/>
```

***

### `Ellipse` 椭圆

```tsx
<Ellipse
  fill="green"
  frame={{ width: 40, height: 100 }}
/>
```

***

## 使用建议

- 使用 `fill` 和 `stroke` 可分别设置填充与描边样式，支持纯色与渐变；
- 若需自定义描边样式（如虚线、线头、线角），应使用 `stroke.strokeStyle`；
- `strokeLineWidth` 已废弃，建议统一使用 `strokeStyle.lineWidth`；
- `trim` 属性可用于实现动画绘图、进度展示等场景；
- 所有形状组件均支持 `frame`、`padding`、`background` 等布局修饰符，适合与其他组件组合使用。



---
url: /zh/guide/Views/Shapes/index_example.md
---

# 示例

```tsx
import { Capsule, Circle, Ellipse, List, Navigation, NavigationStack, Rectangle, RoundedRectangle, Script, Section, Text, UnevenRoundedRectangle, } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Shapes"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>Rectangle</Text>
        }
      >
        <Rectangle
          fill={"orange"}
          stroke={{
            shapeStyle: "red",
            strokeStyle: {
              lineWidth: 3,
            }
          }}
          frame={{
            width: 100,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>RoundedRectangle</Text>
        }
      >
        <RoundedRectangle
          fill={"blue"}
          cornerRadius={16}
          frame={{
            width: 100,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>Circle</Text>
        }
      >
        <Circle
          stroke={{
            shapeStyle: "purple",
            strokeStyle: {
              lineWidth: 4,
            }
          }}
          frame={{
            width: 100,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>Capsule</Text>
        }
      >
        <Capsule
          fill={"systemIndigo"}
          frame={{
            width: 100,
            height: 40,
          }}
        />
      </Section>

      <Section
        header={
          <Text>Ellipse</Text>
        }
      >
        <Ellipse
          fill={"green"}
          frame={{
            width: 40,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>UnevenRoundedRectangle</Text>
        }
      >
        <UnevenRoundedRectangle
          fill={"brown"}
          topLeadingRadius={16}
          topTrailingRadius={0}
          bottomLeadingRadius={0}
          bottomTrailingRadius={16}
          frame={{
            width: 100,
            height: 50,
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Text input/Keyboard.md
---

# 键盘

`Keyboard` API 与 `useKeyboardVisible` 钩子一起，可以在 Scripting 应用中与软件键盘交互。您可以检查键盘是否可见、隐藏键盘、监听键盘的可见性变化，并在函数组件中以响应式方式访问当前可见状态。

***

## 概述

`Keyboard` API 的功能包括：

1. 检查键盘当前是否可见。
2. 以编程方式隐藏键盘。
3. 监听键盘可见性变化。
4. 使用 `useKeyboardVisible` 钩子以响应式方式跟踪键盘的可见性。

***

## 模块：`Keyboard`

### 属性

- **`visible: boolean`**\
  一个只读属性，指示键盘当前是否可见。
  - `true`：键盘可见。
  - `false`：键盘隐藏。

***

### 方法

#### `Keyboard.hide(): void`

隐藏当前可见的键盘。

- **用法**：
  - 如果键盘已隐藏，此方法不会执行任何操作。
  - 通常用于以编程方式关闭键盘。

***

#### `Keyboard.addVisibilityListener(listener: (visible: boolean) => void): void`

添加一个监听器函数，当键盘的可见性发生变化时触发。

- **参数**：
  - `listener: (visible: boolean) => void`：一个回调函数，接收 `visible` 参数：
    - `true`：键盘变为可见。
    - `false`：键盘变为隐藏。

- **用法**：
  - 使用此方法在键盘出现或消失时执行自定义逻辑。

***

#### `Keyboard.removeVisibilityListener(listener: (visible: boolean) => void): void`

移除之前添加的可见性监听器。

- **参数**：
  - `listener: (visible: boolean) => void`：要移除的回调函数。必须与通过 `addVisibilityListener` 添加的函数一致。

***

## 钩子：`useKeyboardVisible`

### `useKeyboardVisible(): boolean`

一个钩子，用于访问当前键盘的可见状态。该钩子提供了一种响应式方式来跟踪键盘是否可见。

- **返回值**：
  - `true`：键盘当前可见。
  - `false`：键盘当前隐藏。

- **用法**：
  - 此钩子非常适合函数组件，根据键盘的可见状态有条件地渲染 UI 元素或执行逻辑。

***

## 示例用法

### 使用 `Keyboard.visible` 检查键盘可见性

```ts
if (Keyboard.visible) {
  console.log("键盘可见。")
} else {
  console.log("键盘隐藏。")
}
```

***

### 隐藏键盘

```ts
Keyboard.hide()
console.log("键盘已通过编程方式隐藏。")
```

***

### 添加和移除可见性监听器

```ts
// 定义监听器
function handleKeyboardVisibility(visible: boolean) {
  if (visible) {
    console.log("键盘现在可见。")
  } else {
    console.log("键盘现在隐藏。")
  }
}

// 添加监听器
Keyboard.addVisibilityListener(handleKeyboardVisibility)

// 移除监听器
Keyboard.removeVisibilityListener(handleKeyboardVisibility)
console.log("键盘可见性监听器已移除。")
```

***

### 在函数组件中使用 `useKeyboardVisible`

```tsx
import { useKeyboardVisible, VStack, Text } from 'scripting'

function KeyboardStatus() {
  const isKeyboardVisible = useKeyboardVisible()

  return (
    <VStack>
      {isKeyboardVisible ? (
        <Text>The keyboard is currently visible.</Text>
      ) : (
        <Text>The keyboard is currently hidden.</Text>
      )}
    </VStack>
  )
}
```

***

## 注意事项

1. **响应式状态与钩子**：在函数组件中使用 `useKeyboardVisible` 钩子，以简洁和响应式的方式跟踪键盘的可见性。
2. **静态状态与 `Keyboard.visible`**：使用 `Keyboard.visible` 属性进行快速的非响应式检查。
3. **事件监听器**：根据需要使用 `addVisibilityListener` 添加多个可见性监听器，并确保在不需要时移除它们以防止内存泄漏。
4. **以编程方式关闭键盘**：`Keyboard.hide()` 方法在提交表单或点击输入框外部以关闭键盘等场景中非常有用。



---
url: /zh/guide/Views/Text input/SecureField/index.md
---

# 安全文本输入框（SecureField）

`SecureField` 是 Scripting 提供的安全文本输入框组件，用于输入密码或其他敏感信息。用户输入内容会被自动隐藏，不以明文显示，其行为与 SwiftUI 中的 `SecureField` 一致。

该组件适用于登录、注册、PIN 验证等需要保护用户隐私的场景。

***

## 属性定义

```ts
type SecureFieldProps = (
  | { title: string }
  | { label: VirtualNode }
) & {
  value: string
  onChanged: (value: string) => void
  prompt?: string
  autofocus?: boolean
  onFocus?: () => void
  onBlur?: () => void
}
```

### 属性说明

| 属性          | 类型                        | 说明                           |
| ----------- | ------------------------- | ---------------------------- |
| `title`     | `string`                  | 输入框的文本标签（与 `label` 二选一）。     |
| `label`     | `VirtualNode`             | 自定义标签视图节点（与 `title` 二选一）。    |
| `value`     | `string`                  | 当前输入的内容，需使用状态绑定更新。           |
| `onChanged` | `(value: string) => void` | 当输入内容发生变化时触发的回调函数。           |
| `prompt`    | `string`（可选）              | 输入框为空时显示的提示占位文字。             |
| `autofocus` | `boolean`（可选）             | 是否在渲染后自动聚焦该输入框，默认值为 `false`。 |
| `onFocus`   | `() => void`（可选）          | 输入框获取焦点时触发的回调。               |
| `onBlur`    | `() => void`（可选）          | 输入框失去焦点时触发的回调。               |

***

## 示例

```tsx
import { useState, VStack, SecureField } from "scripting"

function LoginForm() {
  const [password, setPassword] = useState("")

  return <VStack padding>
    <SecureField
      title="密码"
      value={password}
      onChanged={setPassword}
      prompt="请输入密码"
    />
  </VStack>
}
```

### 行为说明

- 输入内容将以安全方式隐藏，不会以明文显示；
- 可通过 `prompt` 提示用户输入；
- 绑定的状态变量（如 `password`）可用于后续认证逻辑。

***

## 注意事项

- `title` 与 `label` 必须二选一使用；
- 除了内容会被隐藏，其他行为与 `TextField` 基本一致；
- 支持自动聚焦和焦点事件监听，可用于配合用户交互逻辑；
- 非常适用于登录、注册、设置等需要密码输入的界面。



---
url: /zh/guide/Views/Text input/SecureField/index_example.md
---

# 示例

```tsx
import { useState, SecureField, VStack, Text, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [password, setPassword] = useState('')

  return <NavigationStack>
    <VStack
      navigationTitle={"SecureField"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <SecureField
        title={"Password"}
        value={password}
        onChanged={setPassword}
        prompt={"Enter password"}
      />
      <Text>Password: {password}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/Text input/TextField/index.md
---

# 文本输入框（TextField）

Scripting 提供了与 SwiftUI 中 `TextField` 相似的文本输入框组件，支持声明式绑定、提示文字、焦点控制、滚动方向和行数限制等功能。

`TextField` 适用于用户信息填写、搜索、消息输入等各种输入场景，可灵活设置为单行或多行滚动输入。

***

## 属性定义

```ts
type TextFieldProps = (
  | { title: string }
  | { label: VirtualNode }
) & {
  value: string
  onChanged: (value: string) => void
  prompt?: string
  axis?: Axis
  autofocus?: boolean
  onFocus?: () => void
  onBlur?: () => void
}
```

### 属性说明

| 属性          | 类型                                 | 说明                                 |
| ----------- | ---------------------------------- | ---------------------------------- |
| `title`     | `string`                           | 作为输入框标签显示的标题字符串（与 `label` 二选一）。    |
| `label`     | `VirtualNode`                      | 自定义标签节点（与 `title` 二选一）。            |
| `value`     | `string`                           | 当前输入框内容，需使用状态绑定更新。                 |
| `onChanged` | `(value: string) => void`          | 输入内容变更时的回调函数。                      |
| `prompt`    | `string`（可选）                       | 输入框中的提示文本，占位提示用途。                  |
| `axis`      | `"horizontal"` \| `"vertical"`（可选） | 当内容溢出时的滚动方向。多行输入需设置为 `"vertical"`。 |
| `autofocus` | `boolean`（可选）                      | 是否自动聚焦该输入框。默认为 `false`。            |
| `onFocus`   | `() => void`（可选）                   | 输入框获得焦点时触发的回调。                     |
| `onBlur`    | `() => void`（可选）                   | 输入框失去焦点时触发的回调。                     |

***

## 示例一：可垂直滚动的多行输入框

```tsx
import { useState, VStack, TextField } from "scripting"

function ScrollableTextInput() {
  const [text, setText] = useState("")

  return <VStack padding>
    <TextField
      title="留言"
      value={text}
      onChanged={setText}
      prompt="请输入留言"
      axis="vertical"
      lineLimit={{ min: 3, max: 8 }}
    />
  </VStack>
}
```

### 行为说明：

- 输入框会自动扩展至 3～8 行的高度；
- 超过 8 行后内容将支持垂直滚动；
- 输入为空时显示 `prompt` 占位提示文字。

***

## 示例二：基础的单行输入框

```tsx
import { useState, VStack, TextField, Text } from "scripting"

function UsernameInput() {
  const [username, setUsername] = useState("")

  return <VStack padding>
    <TextField
      title="用户名"
      value={username}
      onChanged={setUsername}
      prompt="请输入用户名"
    />
    <Text>当前用户名：{username}</Text>
  </VStack>
}
```

***

## 使用说明

- `title` 和 `label` 必须二选一，不可同时设置；
- 设置 `axis="vertical"` 并结合 `lineLimit` 可启用多行输入及滚动行为；
- 可使用 `autofocus`、`onFocus`、`onBlur` 管理输入框的焦点交互；
- 搭配 `useState` 可实现实时响应的表单输入功能。



---
url: /zh/guide/Views/Text input/TextField/index_example.md
---

# 示例

```tsx
import { useState, TextField, VStack, Text, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [username, setUsername] = useState('')

  return <NavigationStack>
    <VStack
      navigationTitle={"TextField"}
    >
      <TextField
        title={"Username"}
        value={username}
        onChanged={setUsername}
        prompt={"Enter username"}
      />
      <Text>Username: {username}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /zh/guide/Views/Time-based label views.md
---

# 时间标签视图

Scripting 提供了一组便捷的时间标签组件，封装了 SwiftUI 中 `Text` 的时间样式。这些组件支持在小组件和视图中显示实时更新的日期与时间格式，适用于加载动态数据、显示相对时间、计时器等多种应用场景。

***

## `DateLabel`

用于以不同格式展示一个时间戳。即使组件未运行，也可在小组件中显示持续更新的时间相关信息。

### 属性定义

```ts
type DateLabelProps = {
  timestamp: number
  style: 'date' | 'time' | 'timer' | 'relative' | 'offset'
}
```

- `timestamp`: 要显示的时间点，单位为毫秒（UNIX 时间戳）。

- `style`: 显示样式，可选值包括:
  - `"date"`: 以日期形式显示，例如 `"June 3, 2019"`
  - `"time"`: 仅显示时间，例如 `"11:23PM"`
  - `"timer"`: 以计时器形式实时更新，例如 `"2:32"`、`"36:59:01"`
  - `"relative"`: 以相对当前时间的形式显示，例如 `"2 hours, 23 minutes"`
  - `"offset"`: 显示相对当前时间的偏移，例如 `+2 hours`、`-3 months`

### 示例

```tsx
<DateLabel
  timestamp={Date.now()}
  style="date"
/>

<DateLabel
  timestamp={Date.now()}
  style="relative"
/>
```

***

## `DateRangeLabel`

用于显示两个时间点之间的本地化时间范围。

### 属性定义

```ts
type DateRangeLabelProps = {
  from: number
  to: number
}
```

| 属性     | 说明           |
| ------ | ------------ |
| `from` | 起始时间戳，单位为毫秒。 |
| `to`   | 结束时间戳，单位为毫秒。 |

### 示例

```tsx
<DateRangeLabel
  from={Date.now()}
  to={Date.now() + 1000 * 60}
/>
```

***

## `DateIntervalLabel`

用于显示两个时间点之间的时间区间，常用于表示日程或事件的开始与结束时间。

### 属性定义

```ts
type DateIntervalLabelProps = {
  from: number
  to: number
}
```

### 示例

```tsx
let fromDate = new Date()
fromDate.setHours(9)
fromDate.setMinutes(30)

let toDate = new Date()
toDate.setHours(15)
toDate.setMinutes(30)

<DateIntervalLabel
  from={fromDate.getTime()}
  to={toDate.getTime()}
/>
```

> 输出示例：`9:30 AM – 3:30 PM`

***

## `TimerIntervalLabel`

用于在指定的时间区间内显示一个实时运行的计时器，可设置是否倒计时、是否在特定时间暂停等。

### 属性定义

```ts
type TimerIntervalLabelProps = {
  from: number
  to: number
  pauseTime?: number
  countsDown?: boolean
  showsHours?: boolean
}
```

| 属性           | 说明                                      |
| ------------ | --------------------------------------- |
| `from`       | 计时器开始的时间戳（毫秒）。                          |
| `to`         | 计时器结束的时间戳（毫秒）。                          |
| `pauseTime`  | （可选）计时器在该时间点暂停。默认为 `undefined`，表示不暂停。   |
| `countsDown` | （可选）是否倒计时。默认为 `true`。                   |
| `showsHours` | （可选）当剩余时间超过 60 分钟时，是否显示小时部分。默认为 `true`。 |

### 示例

```tsx
<TimerIntervalLabel
  from={Date.now()}
  to={Date.now() + 1000 * 60 * 12}
  pauseTime={Date.now() + 1000 * 60 * 10}
/>
```

该示例表示一个从 12 分钟开始倒计时的计时器，在倒计至 10 分钟时暂停。



---
url: /zh/guide/Views/Toolbars/index.md
---

# 工具栏

`toolbar` 属性用于为导航栏、底部工具栏或键盘附加区域添加自定义操作项。该机制参考了 SwiftUI 中的工具栏 API，允许开发者以声明式方式将按钮、控制组等元素精确地放置在界面的特定位置。

这套系统适用于提供主操作、上下文操作或增强文本输入时的交互体验。

***

## 定义

```ts
toolbar?: ToolBarProps
```

### ToolBarProps 类型定义

```ts
type ToolBarProps = {
  bottomBar?: VirtualNode | VirtualNode[]
  cancellationAction?: VirtualNode | VirtualNode[]
  confirmationAction?: VirtualNode | VirtualNode[]
  destructiveAction?: VirtualNode | VirtualNode[]
  keyboard?: VirtualNode | VirtualNode[]
  navigation?: VirtualNode | VirtualNode[]
  primaryAction?: VirtualNode | VirtualNode[]
  principal?: VirtualNode | VirtualNode[]
  topBarLeading?: VirtualNode | VirtualNode[]
  topBarTrailing?: VirtualNode | VirtualNode[]
}
```

***

## 放置位置说明

`ToolBarProps` 的每个字段都对应一个界面区域，可传入单个或多个 `VirtualNode` 元素进行展示。

- **`automatic`**（隐式）：由系统自动判断最佳放置位置（未在类型中显式声明）。
- **`bottomBar`**：放置于底部工具栏。
- **`cancellationAction`**：表示“取消”操作，通常用于模态界面中。
- **`confirmationAction`**：表示“确认”操作，通常用于模态界面中。
- **`destructiveAction`**：表示破坏性操作，系统可能使用红色等强调样式。
- **`keyboard`**：当键盘弹出时显示在键盘附加区域。
- **`navigation`**：用于导航行为（如返回或关闭）。
- **`primaryAction`**：表示当前上下文中的主要操作。
- **`principal`**：放置在导航栏中间区域。
- **`topBarLeading`**：放置于导航栏的前导位置（通常是左侧）。
- **`topBarTrailing`**：放置于导航栏的尾部位置（通常是右侧）。

***

## 示例

```tsx
<VStack
  navigationTitle={"Toolbars"}
  navigationBarTitleDisplayMode={"inline"}
  toolbar={{
    topBarTrailing: [
      <Button
        title={"选择"}
        action={() => {}}
      />,
      <ControlGroup
        label={
          <Button
            title={"添加"}
            systemImage={"plus"}
            action={() => {}}
          />
        }
        controlGroupStyle={"palette"}
      >
        <Button
          title={"新建"}
          systemImage={"plus"}
          action={() => {}}
        />
        <Button
          title={"导入"}
          systemImage={"square.and.arrow.down"}
          action={() => {}}
        />
      </ControlGroup>
    ],
    bottomBar: [
      <Button
        title={"新建子分类"}
        action={() => {}}
      />,
      <Button
        title={"添加分类"}
        action={() => {}}
      />
    ],
    keyboard: <HStack padding>
      <Spacer />
      <Button
        title={"完成"}
        action={() => {
          Keyboard.hide()
        }}
      />
    </HStack>
  }}
>
  <TextField
    title={"文本输入框"}
    value={text}
    onChanged={setText}
    textFieldStyle={"roundedBorder"}
    prompt={"点击输入框以显示键盘工具栏"}
  />
</VStack>
```

此示例展示了：

- 在顶部导航栏右侧添加了一个“选择”按钮和一个带“新建”“导入”按钮的控制组。
- 在底部工具栏添加了两个分类相关操作按钮。
- 在键盘区域右侧添加了一个“完成”按钮，可点击关闭键盘。

***

## 注意事项

- 所有工具栏项支持响应状态变化，UI 会自动刷新。
- `keyboard` 区域的内容仅在输入框聚焦、键盘弹出时显示。
- 推荐使用 `ControlGroup` 来组织功能相关的按钮，提升可读性和操作一致性。



---
url: /zh/guide/Views/Toolbars/index_example.md
---

# 示例

```tsx
import { Button, ControlGroup, HStack, Navigation, NavigationStack, Script, Spacer, TextField, useState, VStack } from "scripting"

function Example() {
  const [text, setText] = useState("")

  return <NavigationStack>
    <VStack
      navigationTitle={"Toolbars"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        topBarTrailing: [
          <Button
            title={"Select"}
            action={() => { }}
          />,
          <ControlGroup
            label={
              <Button
                title={"Add"}
                systemImage={"plus"}
                action={() => { }}
              />
            }
            controlGroupStyle={"palette"}
          >
            <Button
              title={"New"}
              systemImage={"plus"}
              action={() => { }}
            />
            <Button
              title={"Import"}
              systemImage={"square.and.arrow.down"}
              action={() => { }}
            />
          </ControlGroup>
        ],
        bottomBar: [
          <Button
            title={"New Sub Category"}
            action={() => { }}
          />,
          <Button
            title={"Add category"}
            action={() => { }}
          />
        ],
        keyboard: <HStack
          padding
        >
          <Spacer />
          <Button
            title={"Done"}
            action={() => {
              Keyboard.hide()
            }}
          />
        </HStack>
      }}
      padding
    >
      <TextField
        title={"TextField"}
        value={text}
        onChanged={setText}
        textFieldStyle={"roundedBorder"}
        prompt={"Focus to show the keyboard toolbar"}
      />
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/VideoPreviewView.md
---

# 视频预览视图（VideoPreviewView）

`VideoPreviewView` 用于实时展示 `VideoRecorder` 当前相机会话的预览画面（camera preview）。
它是 UI 层组件，不负责录制控制逻辑；录制的准备、开始、暂停、恢复与停止由 `VideoRecorder` 负责。

`VideoPreviewView` 的核心职责是：将录制器内部的预览输出渲染到界面中，并支持通过通用 View props（如 `frame`、`aspectRatio` 等）进行布局。

***

## 组件定义

```ts
type VideoPreviewViewProps = {
  recorder: VideoRecorder
}

declare const VideoPreviewView: FunctionComponent<VideoPreviewViewProps>
```

***

## Props 说明

### recorder

```ts
recorder: VideoRecorder
```

绑定的 `VideoRecorder` 实例。`VideoPreviewView` 会从该实例获取预览画面来源。

#### 行为约定

- 当 `recorder.prepare()` 成功后，预览画面可用并开始更新。
- 当 `recorder.dispose()` 被调用后，预览画面停止并释放底层资源。
- `VideoPreviewView` 不会自动调用 `prepare()` 或自动开始录制。

***

## 与 VideoRecorder 状态的关系

`VideoPreviewView` 的显示效果通常与 `VideoRecorder.state` 对应如下（具体表现可能受系统行为影响）：

| Recorder 状态 | 预览表现           |
| ----------- | -------------- |
| `idle`      | 尚未准备，可能为空画面    |
| `preparing` | 正在准备中，画面可能尚不可用 |
| `ready`     | 预览可用           |
| `recording` | 正常实时预览         |
| `paused`    | 通常停留在暂停时的最后一帧  |
| `finishing` | 停止更新或逐步停止      |
| `finished`  | 不再更新           |
| `failed`    | 不可用            |

***

## 推荐用法与生命周期管理

建议将 `VideoRecorder` 作为页面级对象创建，并在页面卸载时调用 `dispose()` 释放资源。
同时，使用 `onStateChanged` 监听状态，以驱动 UI 文案、按钮可用性、错误提示等。

要点：

- `VideoRecorder` 建议通过 `useMemo` 创建，避免每次渲染重复构造。
- 在 `useEffect` 中绑定 `onStateChanged`，并在 cleanup 中调用 `dispose()`。
- 录制前必须 `await recorder.prepare()`。

***

## 完整示例

```tsx
function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()
  const recorder = useMemo(() => {
    return new VideoRecorder({
      camera: {
        position: "front",
      },
      frameRate: 30,
      audioEnabled: true,
      orientation: "portrait",
      sessionPreset: "hd1280x720",
      videoCodec: "hevc"
    })
  }, [])
  const [state, setState] = useState<VideoRecorderState>("idle")

  useEffect(() => {
    recorder.onStateChanged = (state, details) => {
      setState(state)

      if (state === "failed") {
        Dialog.alert(details!)
      }
    }

    return () => {
      recorder.dispose()
    }
  }, [])

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <Text>State: {state}</Text>

      <Button
        title="Start"
        action={async () => {
          await recorder.prepare()
          recorder.startRecording(
            Path.join(
              FileManager.documentsDirectory,
              "test.mov"
            )
          )
        }}
      />

      <Button
        title="Pause"
        action={() => {
          recorder.pauseRecording()
        }}
      />

      <Button
        title="Resume"
        action={() => {
          recorder.resumeRecording()
        }}
      />

      <Button
        title="Stop"
        action={async () => {
          await recorder.stopRecording()
        }}
      />

      <VideoPreviewView
        recorder={recorder}
        frame={{
          width: 300
        }}
        aspectRatio={{
          value: 3 / 4,
          contentMode: "fill"
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 布局与渲染建议

### 使用 frame 控制尺寸

`VideoPreviewView` 支持通过通用的 `frame` 属性约束宽高。例如：

- 仅指定 `width`：配合 `aspectRatio` 确定最终高度
- 指定 `width` + `height`：强制固定大小（可能导致裁剪或拉伸，取决于 aspect ratio 与 content mode）

### 使用 aspectRatio 控制比例与填充策略

示例：

```tsx
<VideoPreviewView
  recorder={recorder}
  aspectRatio={{ value: 3 / 4, contentMode: "fill" }}
/>
```

- `value`：宽高比
- `contentMode: "fill"`：按比例填充并裁剪
- 若你希望完整显示画面且允许留边，可使用 `contentMode: "fit"`（如果你们的通用 props 支持该值）

***

## 常见注意事项

### 必须 prepare 才能稳定显示预览

`VideoPreviewView` 绑定 `recorder` 并不意味着会自动启动会话。若未 `prepare()`：

- 预览可能为空
- 或短时间内不可用
- 不建议依赖隐式行为

最佳实践：在 Start 按钮中 `await recorder.prepare()` 后再 `startRecording()`，如示例所示。

### 释放资源

- 页面关闭或不再需要预览时，务必调用 `recorder.dispose()`。
- 建议使用 `useEffect` cleanup 释放，避免相机占用导致后续页面无法打开摄像头或耗电。

### 错误处理

当 `state === "failed"` 时，建议：

- 立即提示 `details`（如示例 `Dialog.alert(details!)`）
- 同时在 UI 上禁用录制按钮，或提供重试逻辑（例如 `await recorder.reset()` 后再 `prepare()`）

***

## 组件职责边界

- `VideoRecorder`：负责录制控制与状态机（prepare/start/pause/resume/stop/reset/dispose）
- `VideoPreviewView`：负责画面显示与 UI 布局（通过 `frame` / `aspectRatio` 等通用属性）



---
url: /zh/guide/Views/View groupings/ControlGroup.md
---

# 控件组

```tsx
import { Button, ControlGroup, ControlGroupStyle, Label, List, Navigation, NavigationStack, Picker, Script, Text, useMemo, useState } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [style, setStyle] = useState<ControlGroupStyle>("palette")
  const styles = useMemo<ControlGroupStyle[]>(() => [
    'automatic',
    'compactMenu',
    'menu',
    'navigation',
    'palette'
  ], [])

  return <NavigationStack>
    <List
      navigationTitle={"ControlGroup"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />,
        confirmationAction: [
          <ControlGroup
            label={
              <Label
                title={"Plus"}
                systemImage={"plus"}
              />
            }
            controlGroupStyle={style}
          >
            <Button
              title={"Edit"}
              systemImage={"pencil"}
              action={() => { }}
            />
            <Button
              title={"Delete"}
              systemImage={"trash"}
              role={"destructive"}
              action={() => { }}
            />
          </ControlGroup>
        ]
      }}
    >
      <Picker
        title={"Control Group Style"}
        value={style}
        onChanged={setStyle as any}
      >
        {styles.map(style =>
          <Text tag={style}>{style}</Text>
        )}
      </Picker>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/View groupings/ForEach/index.md
---

`ForEach` 是 Scripting 中用于渲染可变数量子视图的组件，用于构建动态列表、可编辑列表，以及支持系统级的删除与移动行为。其设计参考 SwiftUI 的 `ForEach`，并与 Scripting 的 `Observable` 状态管理系统深度集成。

组件支持两种模式：

1. **旧版模式（已不推荐使用）**：`count + itemBuilder`
2. **推荐的现代模式**：`data: Observable<T[]> + builder`

***

# 1. 类型定义

## ForEachDeprecatedProps（已不推荐）

```ts
type ForEachDeprecatedProps = {
  count: number;
  itemBuilder: (index: number) => VirtualNode;
  onDelete?: (indices: number[]) => void;
  onMove?: (indices: number[], newOffset: number) => void;
};
```

### 参数说明

#### count: number

要渲染的元素数量，`itemBuilder` 将从 0 到 `count - 1` 依次构建每个子视图。

#### itemBuilder(index)

基于索引构建一个 `VirtualNode`。

#### onDelete(indices)

注册删除行为。
当 ForEach 放置在 `List` 中时，如果提供 `onDelete`，将启用系统级的滑动删除交互。
回调触发时，`List` 中对应的行已被移除，你必须在回调中同步删除数据源中的对应项目。

#### onMove(indices, newOffset)

注册移动行为，用于支持编辑状态下的拖动排序。
如希望禁用移动能力，可传入 `null`。

***

# 2. ForEachProps（推荐使用）

```ts
type ForEachProps<T extends { id: string }> =
  | ForEachDeprecatedProps
  | {
      data: Observable<T[]>;
      builder: (item: T, index: number) => VirtualNode;
      editActions?: "delete" | "move" | "all" | null;
    };
```

### 参数说明

#### data: Observable\<T\[]>

一个可观察数组，数组元素必须包含唯一的 `id: string` 字段。

使用 `Observable` 的好处：

- 当数组变动（增删改）时，会自动触发 SwiftUI 刷新
- 可以保留动画
- 更接近 SwiftUI 中 `ForEach($items)` 的使用体验
- 支持与 `List`、`NavigationStack` 等组件无缝联动

#### builder(item, index)

用于基于当前数组的每个元素构建对应的 VirtualNode。

**注意：必须为返回的子节点提供唯一的 key（通常使用 item.id）。**

#### editActions: "delete" | "move" | "all" | null

控制 ForEach 的可编辑能力：

| 值          | 含义            |
| ---------- | ------------- |
| `"delete"` | 仅启用删除         |
| `"move"`   | 仅启用移动（拖动排序）   |
| `"all"`    | 同时启用删除与移动     |
| `null`     | 不提供任何编辑能力（默认） |

当 `ForEach` 位于 `List` 内部时，编辑能力会自动映射到系统提供的交互方式。

***

# 3. ForEachComponent 接口

```ts
interface ForEachComponent {
  <T extends { id: string }>(props: ForEachProps<T>): VirtualNode;
}
```

`ForEach` 是一个泛型组件，接受带有 `id` 的任意数据类型。

***

# 4. 系统级删除交互示例

当 `ForEach` 放在 `List` 内部，并使用 `data + builder` 模式时，系统会自动启用 swipe-to-delete，只需正确提供 `id` 和编辑能力。

### 示例代码

```tsx
function View() {
  const fruits = useObservable(() =>
    ["Apple", "Bananer", "Papaya", "Mango"].map((name, index) => ({
      id: index.toString(),
      name,
    }))
  );

  return (
    <NavigationStack>
      <List
        navigationTitle="Fruits"
        toolbar={{
          topBarTrailing: <EditButton />,
        }}>
        <ForEach data={fruits} builder={(item, index) => <Text key={item.id}>{item.name}</Text>} />
      </List>
    </NavigationStack>
  );
}
```

***

# 5. 使用建议与最佳实践

### 1. 推荐使用 `data: Observable<T[]>` 方案

新版 API 更接近 SwiftUI 行为，拥有更好的性能与类型推断支持，且未来将接入更多 SwiftUI-style 的能力。

### 2. 每个元素必须拥有 `id: string`

这是确保 Diff 和动画正确工作的基础。

### 3. 必须为 builder 返回的节点提供 `key={item.id}`

否则可能导致:

- 动画不生效
- 列表渲染混乱
- 删除或移动行为出错

### 4. 若需要与编辑按钮联动，必须放置于 `List` 中

并设置 toolbar：

```tsx
toolbar={{
  topBarTrailing: <EditButton />
}}
```



---
url: /zh/guide/Views/View groupings/ForEach/iterating.md
---

# 示例

```tsx
import { Button, Font, ForEach, List, Navigation, NavigationStack, Script, Section, Text, useObservable, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  const namedFonts = useObservable(() => {
    return [
      "largeTitle",
      "title",
      "headline",
      "body",
      "caption"
    ].map(e => ({
      id: e,
      name: e as Font
    }))
  })

  return <NavigationStack>
    <List
      navigationTitle={"Iterating"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        header={
          <Text
            textCase={null}
          >ForEach</Text>
        }
      >
        <ForEach
          data={namedFonts}
          builder={(namedFont) => {
            return <Text
              key={namedFont.id}
              font={namedFont.name}
            >{namedFont.name}</Text>
          }}
        />
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >Iterating in code block</Text>
        }
      >
        <VStack>
          {namedFonts.value.map(namedFont =>
            <Text
              font={namedFont.name}
            >{namedFont.name}</Text>
          )}
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/View groupings/Form.md
---

# 表单

```tsx
import { Button, Form, Navigation, NavigationStack, Picker, Script, Section, Text, Toggle, useState } from "scripting"

type NotifyMeAboutType = "directMessages" | "mentions" | "anything"
type ProfileImageSize = "large" | "medium" | "small"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [notifyMeAbout, setNotifyMeAbout] = useState<NotifyMeAboutType>("directMessages")
  const [playNotificationSounds, setPlayNotificationSounds] = useState(true)
  const [profileImageSize, setprofileImageSize] = useState<ProfileImageSize>("medium")
  const [sendReadReceipts, setSendReadReceipts] = useState(false)

  return <NavigationStack>
    <Form
      navigationTitle={"Form"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        header={<Text>Notifications</Text>}
      >
        <Picker
          title={"Notify Me About"}
          value={notifyMeAbout}
          onChanged={setNotifyMeAbout as any}
        >
          <Text
            tag={"directMessages"}
          >Direct Messages</Text>
          <Text
            tag={"mentions"}
          >Mentions</Text>
          <Text
            tag={"anything"}
          >Anything</Text>
        </Picker>

        <Toggle
          title={"Play notification sounds"}
          value={playNotificationSounds}
          onChanged={setPlayNotificationSounds}
        />
        <Toggle
          title={"Send read receipts"}
          value={sendReadReceipts}
          onChanged={setSendReadReceipts}
        />
      </Section>

      <Section
        header={<Text>User Profiles</Text>}
      >
        <Picker
          title={"Profile Image Size"}
          value={profileImageSize}
          onChanged={setprofileImageSize as any}
        >
          <Text
            tag={"large"}
          >Large</Text>
          <Text
            tag={"medium"}
          >Medium</Text>
          <Text
            tag={"small"}
          >Small</Text>
        </Picker>

        <Button
          title={"Clear Image Cache"}
          action={() => { }}
        />
      </Section>
    </Form>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/View groupings/Group.md
---

# Group

```tsx
import { Button, Group, List, Navigation, NavigationStack, Script, Section, Text, VStack } from "scripting"

function Example() {
  const dimiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Group"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dimiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Apply the headline font to all Text views</Text>
        }
      >
        <Group
          font={"headline"}
        >
          <Text>Scripting</Text>
          <Text>TypeScript</Text>
          <Text>TSX</Text>
        </Group>
      </Section>

      <Section
        footer={
          <Text>Group some views as a view</Text>
        }
      >
        <VStack>
          <Group
            foregroundStyle={"red"}
          >
            <Text>1</Text>
            <Text>2</Text>
            <Text>3</Text>
            <Text>4</Text>
            <Text>5</Text>
            <Text>6</Text>
            <Text>7</Text>
          </Group>
          <Text>8</Text>
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/View groupings/GroupBox.md
---

# GroupBox

```tsx
import { Button, GroupBox, Label, Navigation, NavigationStack, Script, ScrollView, Text, Toggle, useState, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [userAgreed, setUserAgreed] = useState(false)
  const agreementText = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."

  return <NavigationStack>
    <VStack
      navigationTitle={"GroupBox"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <GroupBox
        label={
          <Label
            title={"End-User Agreement"}
            systemImage={"building.columns"}
          />
        }
      >
        <ScrollView
          frame={{
            height: 100,
          }}
        >
          <Text>{agreementText}</Text>
        </ScrollView>
        <Toggle
          value={userAgreed}
          onChanged={setUserAgreed}
        >
          <Text>I agree to the above terms</Text>
        </Toggle>
      </GroupBox>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/View groupings/Section.md
---

# Section

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, useState } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [isExpanded, setIsExpanded] = useState(true)

  return <NavigationStack>
    <List
      navigationTitle={"Section"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />,
      }}
    >
      <Section>
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>

      <Section
        header={<Text>Section with header</Text>}
      >
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>

      <Section
        footer={<Text>Section with footer</Text>}
      >
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>

      <Section
        header={
          <Text
            onTapGesture={() => setIsExpanded(!isExpanded)}
          >Collapsable Section</Text>
        }
        isExpanded={isExpanded}
        onChanged={setIsExpanded}
      >
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Views/WebView.md
---

# 网页视图

```tsx
import { Button, HStack, Image, List, Navigation, NavigationStack, Script, Section, Text, TextField, useMemo, useState, VStack, WebView } from "scripting"

function WebViewControllerExample() {
  const [logs, setLogs] = useState<{
    content: string
    error: boolean
  }[]>([])

  function addLog(content: string, error = false) {
    setLogs(logs => [...logs, { content, error }])
  }

  async function runCode() {
    setLogs([])
    const controller = new WebViewController()

    addLog("WebViewController created.")
    addLog("Start loading...")

    if (await controller.loadURL("https://github.com")) {
      addLog("Website is loaded.")
      addLog("Calling controller.evaluateJavaScript...")
      const title = await controller.evaluateJavaScript<string>("document.title")

      if (title != null) {
        addLog(`Title: ${title}`)
      } else {
        addLog("Failed to get the title.", true)
      }
    } else {
      addLog("Failed to load the website.", true)
    }

    controller.dispose()
    addLog("The controller is disposed.")
  }

  return <Section
    header={
      <Text>WebView controller</Text>
    }
  >
    <VStack
      frame={{
        maxWidth: "infinity"
      }}
      alignment={"leading"}
    >
      <Text font={"headline"}>This example will follow these steps:</Text>
      <VStack
        padding={{
          leading: 16
        }}
        spacing={16}
        foregroundStyle={"secondaryLabel"}
        alignment={"leading"}
      >
        <Text>Create a WebViewController instane</Text>
        <Text>Load https://github.com</Text>
        <Text>Call evaluateJavaScript and get the title of the website</Text>
      </VStack>
      <HStack
        alignment={"center"}
        frame={{
          maxWidth: "infinity"
        }}
      >
        <Button
          title={"Run"}
          action={runCode}
        />
      </HStack>

      <VStack
        alignment={"leading"}
        spacing={8}
      >
        {logs.map(log =>
          <Text
            font={"caption"}
            monospaced
            padding={{
              leading: 16
            }}
            foregroundStyle={log.error ? "systemRed" : "systemGreen"}
          >{log.content}</Text>
        )}
      </VStack>
    </VStack>
  </Section>
}

function PresentWebViewExample() {

  function run() {
    const controller = new WebViewController()
    controller.loadURL("https://github.com")

    controller.present({
      fullscreen: true,
      navigationTitle: "Github"
    }).then(() => {
      console.log("WebView is dismissed")
      controller.dispose()
    })
  }

  return <Section
    header={
      <Text>Present a WebView as a independent page</Text>
    }
  >
    <Button
      title={"Present"}
      action={run}
    />
  </Section>
}

function EmbedAWebViewExample() {
  const controller = useMemo(() => new WebViewController(), [])
  const [url, setUrl] = useState("")

  return <Section
    header={
      <Text>Embed a WebView</Text>
    }
  >
    <VStack>
      <HStack>
        <Button action={() => {
          controller.goBack()
        }}>
          <Image
            systemName={"arrow.left"}
          />
        </Button>
        <Button action={() => {
          controller.goForward()
        }}>
          <Image
            systemName={"arrow.right"}
          />
        </Button>
        <Button action={() => {
          controller.reload()
        }}>
          <Image
            systemName={"arrow.clockwise"}
          />
        </Button>
        <TextField
          title={"Website URL"}
          textFieldStyle={"roundedBorder"}
          value={url}
          onChanged={setUrl}
          keyboardType={"URL"}
          textInputAutocapitalization={"never"}
          frame={{
            maxWidth: "infinity"
          }}
        />
        <Button
          action={() => controller.loadURL(url)}
        >
          <Image
            systemName={"arrow.right.circle"}
          />
        </Button>
      </HStack>
      <WebView
        controller={controller}
        frame={{
          height: 400
        }}
      />
    </VStack>
  </Section>
}

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"WebView"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <WebViewControllerExample />
      <PresentWebViewExample />
      <EmbedAWebViewExample />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /zh/guide/Widget/AccessoryWidgetBackground.md
---

# AccessoryWidgetBackground

一个自适应的背景视图，根据小组件当前的环境提供系统标准外观。

## 概述

`AccessoryWidgetBackground` 组件适用于配件类小组件（Accessory Widgets），如锁屏小组件或待机模式（StandBy）小组件。它会自动根据系统环境（如浅色/深色模式、透明度、系统主题）应用合适的背景样式，确保小组件与系统视觉风格一致。

通常你可以将此视图作为背景层，配合 `ZStack` 等布局使用，将自定义内容覆盖其上方，从而获得既美观又系统一致的外观。

## 示例

```tsx
import { AccessoryWidgetBackground, Text, ZStack } from "scripting"

function AccessoryView() {
  return (
    <ZStack>
      <AccessoryWidgetBackground />
      <Text font="caption">Weather</Text>
    </ZStack>
  )
}
```

在此示例中，`AccessoryWidgetBackground` 提供了系统适配的背景，`Text` 文本则显示在其上方。此布局非常适合锁屏小组件，确保内容在各种系统外观下保持清晰可读。

## 使用建议

- 通常应将 `AccessoryWidgetBackground` 放在 `ZStack` 的底层，以作为背景视图。
- 不建议对该组件直接设置颜色或样式，它会根据系统环境自动调整。
- 可与其他 SwiftUI 风格的组件结合使用，构建与原生系统一致的小组件外观。

## 兼容性

此组件主要用于配件类小组件，在普通视图中使用可能不会有任何视觉效果。建议仅在小组件开发中使用，以获得最佳系统一致性体验。



---
url: /zh/guide/Widget/Animation for Widget and LiveActivity.md
---

# 在小组件和灵动岛中使用动画

这些API让你在小组件中播放动图或者使用位移和旋转动画。

## `AnimatedFrames` 组件

### 描述

`AnimatedFrames` 组件允许你通过提供的子视图来展示帧动画。这些子视图将按顺序循环显示，形成动画效果。你可以自定义动画的持续时间。

### 属性

- **`duration`**: `DurationInSeconds`\
  动画的持续时间，单位为秒。

- **`children`**: `VirtualNode[]`\
  一组视图，作为动画的每一帧。每个子视图在动画过程中依次显示。

### 示例

```tsx
<AnimatedFrames duration={4}>
  <Circle fill="red" frame={{width: 20, height: 20}} />
  <Circle fill="red" frame={{width: 25, height: 25}} />
  <Circle fill="red" frame={{width: 30, height: 30}} />
  <Circle fill="red" frame={{width: 35, height: 35}} />
</AnimatedFrames>
```

***

## `AnimatedGif` 组件

### 描述

`AnimatedGif` 组件用于在小组件中渲染一个 GIF 动图。你可以提供 GIF 文件的路径，并可选地设置动画的持续时间。

### 属性

- **`path`**: `string`\
  GIF 文件的路径。

- **`duration`**: `DurationInSeconds` _(可选)_\
  动画的持续时间，单位为秒。如果未提供，使用默认持续时间。

### 示例

```tsx
<AnimatedGif
  path={Path.join(Script.directory, "test.gif")}
  duration={4}
/>
```

***

## `SwingAnimation` 类型

### 描述

`SwingAnimation` 类型定义了视图在水平和垂直方向上的摇摆动画配置。

### 属性

- **`duration`**: `DurationInSeconds`\
  动画的持续时间，单位为秒。

- **`distance`**: `number`\
  视图在给定轴向上摇摆的距离。

***

## `ClockHandRotationEffectPeriod` 类型

### 描述

`ClockHandRotationEffectPeriod` 类型用于定义时钟指针旋转效果的周期。你可以使用预定义值如 `"hourHand"`、`"minuteHand"` 或 `"secondHand"`，也可以提供自定义的持续时间。

***

## `AnimatedImage` 组件

### 描述

`AnimatedImage` 组件用于在小组件中渲染一个动画图像。你可以使用 `SFSymbol` 或 `UIImage` 作为动画帧，并自定义动画的持续时间和内容模式（适应或填充）。

### 属性

- **`systemImages`**: `(string | { name: string; variableValue: number })[]` _(可选)_\
  一个包含 `SFSymbol` 名称和变量值的数组，用于显示作为动画帧的符号图像。

- **`images`**: `UIImage[]` _(可选)_\
  一个 `UIImage` 数组，用于显示作为动画帧的图像。

- **`contentMode`**: `ContentMode` _(可选)_\
  图像在父容器中的显示方式。默认为 `"fit"`。\
  可选值：`"fit"`、`"fill"`。

- **`duration`**: `DurationInSeconds`\
  动画的持续时间，单位为秒。

### 示例 (使用 `SFSymbol`)

```tsx
<AnimatedImage
  duration={6}
  systemImages={[
    {name: "chart.bar.fill", variableValue: 0},
    {name: "chart.bar.fill", variableValue: 0.3},
    {name: "chart.bar.fill", variableValue: 0.6},
    {name: "chart.bar.fill", variableValue: 1},
  ]}
  contentMode="fit"
/>
```

### 示例 (使用 `UIImage`)

```tsx
const image1 = Path.join(Script.directory, "image1.png")
const image2 = Path.join(Script.directory, "image2.png")

<AnimatedImage
  duration={4}
  images={[
    UIImage.fromFile(image1),
    UIImage.fromFile(image2),
  ]}
  contentMode="fill"
/>
```

***

## `CommonViewProps` 类型

### 描述

此类型定义了支持动画效果的视图的公共属性，包括摇摆动画和时钟指针旋转效果。

### 属性

- **`swingAnimation`**: `{ x?: SwingAnimation, y?: SwingAnimation }` _(可选)_\
  定义了视图在 X 轴和 Y 轴上的摇摆动画配置。每个轴向都可以有单独的动画设置：
  - **`x`**: 水平轴的动画配置。
  - **`y`**: 垂直轴的动画配置。

- **`clockHandRotationEffect`**: `ClockHandRotationEffectPeriod | { anchor: KeywordPoint | Point, period: ClockHandRotationEffectPeriod }` _(可选)_\
  定义模拟时钟指针的旋转效果。可以指定锚点（可选）和周期（例如，`"hourHand"`、`"minuteHand"`、`"secondHand"`），或者提供自定义的旋转持续时间。

### 示例 (摇摆动画)

```tsx
<Circle
  fill="systemRed"
  frame={{width: 50, height: 50}}
  swingAnimation={{
    x: {duration: 4, distance: 250},
    y: {duration: 2, distance: 50},
  }}
/>
```

### 示例 (时钟指针旋转效果)

```tsx
<Circle
  fill="systemBlue"
  frame={{width: 50, height: 50}}
  clockHandRotationEffect="minuteHand"
/>
```



---
url: /zh/guide/Widget/Tinted Mode Adaptation Guide.md
---

# 小组件染色模式适配指南

iOS 18 引入了一种新的小组件渲染模式，称为 **accented 模式（强调色模式）**，它会使用系统定义的强调色对小组件的内容进行统一染色。为支持该行为，**Scripting** app 提供了三个视图修饰符：

- `widgetAccentable`
- `widgetAccentedRenderingMode`
- `widgetBackground`

这些修饰符让你可以精确控制小组件中哪些部分参与系统的染色逻辑，从而创建更具层次感和适配性的界面。

***

## `widgetAccentable`

### 说明

将视图及其所有子视图标记为 **accented group（强调组）** 的一部分。当小组件处于 **accented 渲染模式** 时，系统会分别为强调组与默认组应用不同的色调。染色过程仿照模板图像的方式 —— 系统会忽略你设置的颜色，仅使用视图的 alpha（透明度）进行渲染。

这个修饰符有助于在 tinted 小组件中实现清晰的层次分离效果。

### 用法示例

```tsx
<VStack>
  <Text
    widgetAccentable
    font="caption"
  >
    MON
  </Text>
  <Text font="title">
    6
  </Text>
</VStack>
```

说明：

- 第一个 `Text` 使用了 `widgetAccentable`，将被系统染色为强调色；
- 第二个 `Text` 属于默认组，通常被染为较浅的颜色。

***

## `widgetAccentedRenderingMode`（用于 `Image` 组件）

### 说明

控制 `Image` 在 **accented 模式** 下的渲染方式。可用于调整图像在染色模式下的外观处理。

### 可用模式

- `'accented'`：将图像加入强调组，使用强调色渲染。
- `'accentedDesaturated'`：将图像亮度转为 alpha 后使用强调色染色。
- `'desaturated'`：将图像亮度转为 alpha 后使用默认组色调染色。
- `'fullColor'`：保留图像原始颜色，不进行染色（仅适用于 iOS 系统图像）。

### 用法示例

```tsx
<Image
  filePath="/path/to/image.png"
  widgetAccentedRenderingMode="fullColor"
/>
```

该设置可确保图像保留完整颜色，适合用于品牌 Logo 或需要保持清晰度的图像内容。

***

## `widgetBackground`

### 说明

`widgetBackground` 修饰符用于在小组件中设置背景样式，**并自动适配 iOS 18 的 accented 模式**。当小组件处于 accented 模式时，该背景会**自动隐藏**，避免被系统强制染色为白色。

iOS 18 会忽略背景颜色，除非设置透明度（alpha）。使用 `widgetBackground` 可以放心地定义装饰性背景，而不必担心其在染色模式下显示异常。

### 支持格式

#### 纯色背景

```tsx
<Text widgetBackground="systemGray5">
  Hello
</Text>
```

#### 浅色/深色模式适配背景

```tsx
<Text
  widgetBackground={{
    light: "white",
    dark: "black"
  }}
>
  模式感知背景
</Text>
```

#### 带形状的背景

```tsx
<Text
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12,
      style: "continuous"
    }
  }}
>
  圆角背景
</Text>
```

> 提示：可用形状包括 `'rect'`、`'circle'`、`'capsule'`、`'ellipse'`、`'buttonBorder'`、`'containerRelative'`，也支持自定义圆角矩形。

### 特性说明

- 在 **accented 模式** 下，背景会被自动隐藏；
- 在 **默认或全彩模式** 下，背景正常显示；
- 与 `widgetAccentable` 配合使用，可实现分层布局，保持视觉清晰度。

***

## 系统行为说明（适用于 iOS 18+）

- 在 **accented 模式** 中，**所有颜色（包括背景）都会被忽略**，除非设置了 `alpha < 1`。例如纯色背景会被渲染为白色。
- 通过 **设置 alpha 值** 可实现视觉层级，例如 `alpha = 1` 会获得强烈染色效果，而 `alpha = 0.3` 更加柔和。
- **不要依赖具体颜色值** 来控制样式，在 accented 模式下颜色会被系统统一替换，应通过分组和透明度控制样式。
- **推荐使用 `widgetBackground` 代替 `background`**，以确保背景在 accented 模式下能够被正确隐藏。

***

## 示例

```tsx
<VStack
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12
    }
  }}
  spacing={4}
>
  <Image
    filePath="/path/to/icons/calendar.png"
    widgetAccentedRenderingMode="accentedDesaturated"
  />
  <Text widgetAccentable font="caption">
    MON
  </Text>
  <Text font="title">
    6
  </Text>
</VStack>
```

该布局：

- 设置了一个圆角灰色背景，仅在非 accented 模式下显示；
- 图标和星期标签加入了 **强调组**；
- 日期数字保留在 **默认组**；
- 即便系统进行染色，也能保持清晰的分层效果。

***

## 使用技巧

- 使用 `widgetAccentable` 精确标记需要染色的内容，避免误将整个小组件标记为强调组；
- 对于品牌图标等需要保留原色的图像，使用 `widgetAccentedRenderingMode="fullColor"`；
- 使用 `widgetBackground` 替代 `background`，以确保背景能在强调模式下正确处理；
- 为背景或视图设置透明度（如 `alpha < 1`）可保留层次感，避免全部被染为纯白。



---
url: /zh/guide/Widget/Widget API.md
---

# 小组件 API

`Widget` 类提供了一组静态方法和属性，用于在 Scripting app 中创建、预览和刷新主屏幕小组件。通过此 API，可以渲染小组件 UI，访问用户配置参数，并控制小组件的刷新策略。

***

## 类：`Widget`

此类为静态类，不能实例化，所有成员均为静态。

***

### 静态属性

#### `Widget.family: WidgetFamily`

获取用户当前配置的小组件尺寸类型（即小组件的 family）。
常见取值包括：

- `"systemSmall"` – 小尺寸组件
- `"systemMedium"` – 中尺寸组件
- `"systemLarge"` – 大尺寸组件
- `"accessoryRectangular"` – 锁屏矩形组件
- `"accessoryCircular"` – 锁屏圆形组件

> **类型：** `WidgetFamily`

***

#### `Widget.displaySize: WidgetDisplaySize`

获取当前小组件的显示尺寸（单位为点）。根据小组件的 family 和设备分辨率决定具体大小。

> **类型：** `{ width: number; height: number }`

***

#### `Widget.parameter: string`

如果用户在主屏幕小组件中设置了 `参数` 字段，并通过点击该小组件打开并运行脚本，可以通过该属性访问该参数的值。
适用于根据不同用户配置动态渲染不同的小组件内容。

> **类型：** `string`

***

### 静态方法

#### `Widget.present(element: VirtualNode, reloadPolicy?: WidgetReloadPolicy): void`

用于在小组件上渲染 UI。传入一个 React 风格的 JSX 节点（即 VirtualNode）作为渲染内容。可选地传入刷新策略以控制 WidgetKit 请求新时间线的时机。

##### 参数说明

- `element` (`VirtualNode`) – 小组件 UI 的 JSX 树。
- `reloadPolicy` (`WidgetReloadPolicy`，可选) – 控制 WidgetKit 请求新时间线的策略，默认为 `atEnd`。

##### 示例

```tsx
function WidgetView() {
  return <VStack>
    <Image
      systemName="globe"
      resizable
      scaleToFit
      frame={{
        width: 28,
        height: 28
      }}
    />
    <Text>Hello Scripting!</Text>
  </VStack>
}

Widget.present(<WidgetView />, {
  policy: "after",
  date: new Date(Date.now() + 1000 * 60 * 5) // 5分钟后刷新
})
```

> **返回值：** `void`

***

#### `Widget.preview(options?: PreviewOptions): Promise<void>`

用于在 `index.tsx` 中预览小组件效果。可以为小组件配置不同参数选项，模拟其在不同参数下的外观。
此方法仅支持在 `index.tsx` 中调用，在 `widget.tsx` 或 `intent.tsx` 中不可用。

##### 参数说明

- `options`（可选）– 预览配置项。

```ts
interface PreviewOptions {
  family?: WidgetFamily
  parameters?: {
    options: Record<string, string> // 参数名到 JSON 字符串的映射
    default: string                 // 默认使用的参数键
  }
}
```

##### 示例

```tsx
const options = {
  "Param 1": JSON.stringify({ color: "red" }),
  "Param 2": JSON.stringify({ color: "blue" }),
}

await Widget.preview({
  family: "systemSmall",
  parameters: {
    options,
    default: "Param 1"
  }
})
console.log("Widget preview dismissed")
```

> **返回值：** `Promise<void>`
> 如果参数设置不正确，将抛出异常。

***

#### `Widget.reloadAll(): void`

请求 WidgetKit 重新加载所有由 Scripting 创建的小组件时间线。
在小组件依赖的数据变化时调用此方法可以立即触发刷新。

> **返回值：** `void`

***

## 相关类型

### `WidgetFamily`

表示小组件的尺寸类型：

```ts
type WidgetFamily =
  | "systemSmall"
  | "systemMedium"
  | "systemLarge"
  | "accessoryCircular"
  | "accessoryRectangular"
```

***

### `WidgetDisplaySize`

表示小组件当前的显示尺寸（单位：点）：

```ts
interface WidgetDisplaySize {
  width: number
  height: number
}
```

***

### `WidgetReloadPolicy`

定义小组件的刷新策略：

```ts
type WidgetReloadPolicy =
  | { policy: "atEnd" } // 时间线结束后刷新（默认）
  | { policy: "after", date: Date } // 指定时间之后刷新
```

***

## 使用说明

- `Widget.present` 应在 `widget.tsx` 中调用，用于定义和显示小组件实际内容。
- `Widget.preview` 仅用于 `index.tsx` 中测试和预览小组件，不会被系统实际渲染。
- 使用 `Widget.parameter` 时，若参数为结构化数据（如对象），需使用 `JSON.parse()` 解析。
- 脚本结束后应调用 `Script.exit()` 以确保小组件正常退出。

***

如需导出为 Markdown 文档或用于帮助中心，请告诉我，我可以为你生成格式化版本。



---
url: /zh/guide/Widget/Widget Background in Tinted Mode.md
---

# 小组件色调模式背景

`widgetBackground` 是一个专用于**小组件**的视图修饰符，用于在不同的渲染模式下设置背景样式，特别是为适配 **iOS 18 的 tinted（强调色）模式**而设计。

## 功能说明

在 **tinted 模式**下，iOS 会将所有视图颜色（包括背景）渲染为白色，除非该视图使用了 `widgetAccentable` 标记。这可能会导致背景显示异常或视觉效果失真。

使用 `widgetBackground` 可以避免这种问题：

- **在 accented 模式下自动隐藏背景**，避免被系统渲染为纯白色；
- **在默认模式或全彩模式下正常显示背景**。

这样可以确保你的小组件在不同系统渲染环境下都具有良好的视觉一致性。

***

## 支持的背景设置方式

`widgetBackground` 支持以下几种格式：

### 1. **纯色背景（ShapeStyle）**

使用简单颜色作为背景：

```tsx
<Text widgetBackground="systemBlue">
  Hello
</Text>
```

***

### 2. **动态背景（DynamicShapeStyle）**

根据系统的浅色/深色模式动态切换背景样式：

```tsx
<Text
  widgetBackground={{
    light: "white",
    dark: "black"
  }}
>
  模式感知背景
</Text>
```

***

### 3. **带形状的背景样式**

使用指定的\*\*形状（Shape）\*\*配合填充样式，实现结构化的背景设计：

```tsx
<Text
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12,
      style: "continuous"
    }
  }}
>
  圆角背景
</Text>
```

支持的形状包括：

- 预设形状：`'rect'`、`'circle'`、`'capsule'`、`'ellipse'`、`'buttonBorder'`、`'containerRelative'`
- 自定义圆角矩形：支持统一圆角、椭圆角尺寸、每个角独立设定

***

## 在 accented 模式下的行为

- **在 iOS 的 accented（tinted）模式下**：背景会被自动隐藏，以避免出现纯白色遮盖问题；
- **在默认或全彩渲染模式下**：背景将按设定正常显示。

此行为可有效避免系统渲染方式对 UI 布局和层级的干扰。

***

## 使用建议

- 仅在小组件中使用 `widgetBackground`，以避免在普通视图中出现不必要的隐藏行为；
- 不要使用背景传达重要信息，因为在 accented 模式下它可能会被隐藏；
- 搭配 `widgetAccentable` 使用，以精确控制哪些内容应参与系统色彩渲染，哪些内容应独立呈现。



---
url: /zh/guide/Widget/Widget Quick Start.md
---

# 小组件快速入门

**Scripting** 是一款支持使用 TypeScript 和类 React 的 TSX 语法来创建 iOS 主屏幕小组件的应用。你可以在 `widget.tsx` 文件中使用受 SwiftUI 启发的组件定义小组件的界面。

***

## 1. 快速开始

### 第一步：创建脚本项目

1. 打开 **Scripting** 应用。
2. 创建一个新的脚本项目，并为你的小组件命名。

### 第二步：添加 `widget.tsx` 文件

1. 在项目中创建一个名为 `widget.tsx` 的文件。
2. 使用函数组件定义小组件的界面。
3. 从 `scripting` 包中导入所需组件和 API。

#### 示例：

```tsx
// widget.tsx
import { VStack, Text, Widget } from 'scripting'

function MyWidgetView() {
  return (
    <VStack>
      <Text>Hello world</Text>
    </VStack>
  )
}

Widget.present(<MyWidgetView />)
```

调用 `Widget.present()` 将该组件渲染为主屏幕小组件。

***

## 2. 获取小组件上下文

你可以通过 `Widget` API 提供的以下属性来适配布局和内容：

| 属性                   | 描述                                      |
| -------------------- | --------------------------------------- |
| `Widget.displaySize` | 小组件在运行时的实际像素尺寸。                         |
| `Widget.family`      | 小组件类型：`'small'`、`'medium'` 或 `'large'`。 |
| `Widget.parameter`   | 用户在主屏幕小组件设置中配置的自定义参数。                   |

使用这些属性可以根据小组件的尺寸或用户偏好动态调整内容和布局。

***

## 3. 添加到主屏幕

1. 将 **Scripting** 小组件添加到 iOS 主屏幕。
2. 长按该小组件并点击 **编辑小组件**。
3. 选择你创建的脚本，并根据需要配置 **参数**。

配置完成后，`widget.tsx` 中定义的组件将直接显示在主屏幕上。

***

## 4. 视图构建方式

使用受 SwiftUI 启发的内置组件（如 `VStack`、`HStack`、`Text`、`Image` 等）构建小组件界面。你也可以将逻辑与视图分离到多个文件中进行组织，通过模块导入使用。

***

## 5. 开发限制与最佳实践

### 小组件中 Hooks 不生效

虽然可以在代码中使用 `useState`、`useEffect` 等 React Hooks，但在小组件中这些 **不会生效**，因为小组件是 **一次性渲染** 的，没有持续的交互生命周期。避免依赖任何动态状态逻辑。

### 内存限制

iOS 对小组件有约 **30MB** 的内存限制。为了不超出限制：

- 避免渲染过多嵌套视图。
- 减少图像资源使用。
- 避免内存泄漏或长时间引用的数据。

如果渲染失败或显示空白，通常是内存问题导致的。

### 小组件上下文立即销毁

调用 `Widget.present(...)` 后，当前执行上下文会被 **立即销毁**，因此：

- 所有数据准备应在调用前完成。
- 避免在 `Widget.present` 之后编写逻辑，因为这些代码不会执行。
- 将小组件函数视为一次性 UI 渲染器。

***

## 6. 交互支持

尽管小组件大多是静态的，但可以通过 AppIntent 实现 **基础交互功能**：

- 使用 `<Button>` 或 `<Toggle>` 等组件触发 AppIntent。
- 更多详情可参考 **Interactive Widget 和 LiveActivity** 文档。

***

## 7. 视图兼容性

**并非所有 SwiftUI 视图都支持在小组件中使用。** 某些布局容器与特效不被支持。请参考 Apple 官方文档：[WidgetKit 中支持的 SwiftUI 视图](https://developer.apple.com/documentation/widgetkit/swiftui-views)。

***

## 8. 小组件预览限制

Scripting 应用内的小组件预览仅是 **近似效果**，与 iOS 主屏幕上的实际渲染在以下方面可能略有差异：

- 文字对齐
- 小组件尺寸
- 小组件圆角
- 布局行为

要确保布局准确，请 **始终在主屏幕上测试小组件**。

***

## 9. 刷新小组件

### 通用刷新方法

- 调用 `Widget.reloadAll()` 可立即刷新所有小组件（包括用户和开发者小组件）。
- 可在 AppIntent 或 `index.tsx` 中调用。
- 也可以使用 Scripting 应用中的 **刷新小组件** 按钮快速测试开发时的变更。

这有助于快速迭代布局或逻辑。

### 新增：用户小组件与开发者小组件

Scripting 支持两种类型的小组件（kind）：

| 类型                       | 说明                         |
| ------------------------ | -------------------------- |
| **User Widgets（用户小组件）**  | 用于普通用户在主屏幕上添加和使用的正式小组件。    |
| **Test Widgets（开发者小组件）** | 用于开发者在开发阶段进行调试和预览的测试版本小组件。 |

这两类小组件使用不同的 `kind`，互不影响，便于在开发时安全地进行刷新与测试。

### 新增刷新方法

| 方法                           | 描述                                                   |
| ---------------------------- | ---------------------------------------------------- |
| `Widget.reloadUserWidgets()` | 仅刷新 **用户小组件（User Widgets）**，不影响开发者测试用的 Test Widgets。 |
| `Widget.reloadTestWidgets()` | 仅刷新 **开发者小组件（Test Widgets）**，不会影响用户主屏幕上的正式小组件。       |

这两个方法的设计目的是为了隔离开发和用户使用场景。当你在开发阶段修改 `widget.tsx` 并调用 `Widget.reloadTestWidgets()` 时，只会刷新测试用的小组件，而用户的正式小组件不会受到任何干扰。

#### 示例：

```tsx
// 在开发环境中刷新测试小组件
await Widget.reloadTestWidgets()

// 在发布前刷新所有用户小组件
await Widget.reloadUserWidgets()
```

#### 使用建议：

- 开发阶段：推荐使用 **`Widget.reloadTestWidgets()`**。
- 发布或用户脚本更新后：推荐使用 **`Widget.reloadUserWidgets()`** 或 **`Widget.reloadAll()`**。

***

## 10. 文档与支持

- 查看 **Views 文档** 获取所有可用组件和修饰器的完整列表。
- 参考 **API 文档** 获取更高级的功能集成（如 Calendar、FileManager、AVPlayer 等）。

***

## 11. 使用 `Widget.preview` 进行开发预览

开发过程中，你可以使用 `Widget.preview()` 方法在 `index.tsx` 中预览小组件的布局效果和参数配置，无需返回主屏幕进行测试。

### 方法：`Widget.preview(options)`

该方法可在应用内模拟不同参数和尺寸的小组件展示，适用于 **开发调试阶段**，只能在 **`index.tsx` 环境中调用**（不能在 `widget.tsx` 或 `intent.tsx` 中使用）。

### 参数说明

| 属性                   | 类型                       | 描述                               |                 |                                  |
| -------------------- | ------------------------ | -------------------------------- | --------------- | -------------------------------- |
| `family`             | `'systemSmall'`          | `'systemMedium'`                 | `'systemLarge'` | 可选。预览的小组件尺寸，默认为 `'systemSmall'`。 |
| `parameters.options` | `Record<string, string>` | 参数选项的字典，键为参数名，值为可 JSON 解析的字符串内容。 |                 |                                  |
| `parameters.default` | `string`                 | 指定默认使用的参数名。                      |                 |                                  |

### 示例

```tsx
const options = {
  "Param 1": JSON.stringify({
    color: "red"
  }),
  "Param 2": JSON.stringify({
    color: "blue"
  }),
}

await Widget.preview({
  family: "systemSmall",
  parameters: {
    options,
    default: "Param 1"
  }
})
console.log("Widget preview dismissed")
```

该方法可用于测试小组件在不同输入参数下的视觉表现，例如颜色、内容或配置状态等。

### 注意事项

- 该方法 **必须在 `index.tsx` 中调用**，适用于测试脚本或开发工具页面。
- 如果参数格式不正确，将会抛出错误。
- 预览效果仍受 [第 8 节 小组件预览限制](#8-小组件预览限制) 所述的限制影响，建议最终在主屏幕测试确认。



---
url: /zh/index.md
---

# Scripting

iOS 自动化工具

> by thomfang

[开始](/zh/guide/Quick Start) | [下载](https://apps.apple.com/app/apple-store/id6479691128)

## Features

- /home/custom.svg **高度自定义**: <div>· 封装大量原生API（如日历、通知、蓝牙...）<br>· 支持自定义小组件、控制中心小组件、灵动岛、自定义键盘、快捷指令、共享菜单...</div>
- /home/ai.svg **AI 集成**: <div>· 使用自己的API Key与各AI服务聊天<br>· 可调用自己的脚本工具、本地知识库、生成代码并运行，完成各种复杂任务</div>
- /home/search.svg **优秀的开发体验**: <div>· 提供 VS Code 开发脚手架，支持手机实时预览<br>· 内置多语言编辑器，尤其强化 TypeScript，支持自动补全、语法高亮与检查</div>



---
url: /zh/privacy/policy.md
---

# 隐私政策

## 简介

欢迎使用 Scripting！您的隐私对我们非常重要。此《隐私政策》将解释在您使用我们的应用时，我们如何处理您的数据。

## 无数据收集

Scripting App 不会收集或存储任何个人数据。所有在应用中产生的活动和数据都仅保留在您的设备上。

## 自愿沟通

如果您选择通过电子邮件与我们联系，我们可能会接收并存储您提供的信息，例如您的姓名、电子邮件地址以及任何消息内容。这些信息仅用于回复您的询问，不会与第三方共享。

## 第三方集成

Scripting App 可能会与第三方服务进行交互，例如您的设备上的 Shortcuts app 或其他集成。通过这些集成共享的任何数据都完全由这些服务管理，我们不会对此进行收集。

当您使用第三方模型集成功能时，提供的 API Key 将存储在设备本地，仅用于向 AI 模型发送和接收有关您任务的请求。Scripting App 不会收集、传输或将 API Key 用于任何其他目的。

## 健康数据与 HealthKit

Scripting 提供了可选的接口，用于访问 Apple 的 HealthKit 框架，允许您编写的脚本在设备上读取和写入您的健康数据。我们尊重您的隐私，并已设计此功能以确保：

### 不存储或分析

Scripting 不会收集、传输、分析或存储您的任何 HealthKit 数据。所有健康相关操作均在您的设备内本地完成。

### 用户控制与同意

对健康数据的访问完全由您控制。每当脚本请求读取或写入 HealthKit 示例数据时，iOS 会提示您授权或拒绝。您始终拥有完全控制权，并可在系统“设置”中随时撤销访问权限。

### 仅限脚本访问

授予的 HealthKit 权限仅限于您在 Scripting 中运行的脚本。应用本身及其开发者无法在脚本之外访问您的健康数据。

### 透明度

任何使用 HealthKit API 的脚本都必须明确声明所需的数据类型。您可以在授权前查看这些请求，以确保您确切了解所涉及的健康指标。

## 数据安全

由于 Scripting App 不会收集或存储数据，因此不存在未经授权访问您的个人信息的风险。通过电子邮件自愿分享的任何数据将受到谨慎处理并安全存储。

## 隐私政策变更

我们可能会不时更新此《隐私政策》。任何更改都会发布在本页面上，并相应更新“最后更新”日期。

## 联系我们

如果您对本《隐私政策》有任何疑问或顾虑，请通过以下方式与我们联系：

电子邮件： [tilfon@live.com](mailto:tilfon@live.com)



---
url: /zh/privacy/service.md
---

# 服务条款与EULA

## 总则

欢迎使用 Scripting 应用！在使用本应用之前，请仔细阅读本协议内容。本协议适用于所有使用本应用的用户，包括免费用户和 Scripting Pro 用户。

## 软件许可协议（EULA）

- **许可范围:** 您被授予一项非独占、不可转让的许可，仅用于个人用途。

- **知识产权:** 本应用的所有内容、设计及代码均为开发者所有，受法律保护。

- **禁止行为:** 您不得反向工程、修改或分发本应用。

- **终止条款:** 如您违反协议内容，我们保留终止您使用本应用的权利。

## 服务条款

- **服务描述:** 本应用提供脚本开发环境、高级功能（如自定义主题、代码模板等）。

- **订阅计划:**
  - **一次性购买:** 解锁所有功能，终身有效。

  - **月度与年度订阅:** 自动续订服务。

- **购买与确认:** 您可以通过您的 iTunes 账户确认购买 Scripting Pro 订阅。付款将在您确认购买后从您的 iTunes 账户中扣除。

- **取消订阅:** 您可以随时通过访问设备的 iTunes 账户设置来取消订阅。如果您希望停止自动续订，需在当前订阅周期结束的至少 24 小时之前取消订阅。如果未在此时间内取消，订阅将在到期后自动续订。

- **续订与费用:** 在当前订阅周期结束的 24 小时内，系统会自动续订，并从您的 iTunes 账户中扣除相应费用。续订费用与初始订阅费用相同，除非您已更改订阅计划。

- **免费订阅的注意事项:** 免费试用期结束后，订阅将自动续订为付费计划，费用将从您的 iTunes 账户中扣除。如果您在试用期内未取消订阅，则默认视为您接受订阅条款。

- **第三方模型集成:** Scripting App 充当外部 AI 模型的桥梁，完全依赖用户提供的 API Key 与这些服务（例如 OpenAI GPT）进行交互。所有与 AI 相关的交互均符合第三方模型提供商的使用条款。

- **隐私政策:** 详情请参阅我们的[隐私政策](/zh/privacy/policy.md)。

## 责任限制

本应用按“现状”提供，开发者不对因使用本应用而产生的任何直接或间接损失负责。

## 争议解决与适用法律

- **适用法律:** 本协议适用您所在地区的法律。

- **争议解决:** 双方应本着友好协商的原则解决争议，协商不成时依法处理。

## 联系我们

如有疑问，请通过以下方式联系我们：

邮箱：[tilfon@live.com](mailto:tilfon@live.com)

网站: scripting.fun



---
url: /v2/zh/guide/AppIntent.md
---

# AppIntent

`AppIntentManager` 用于在 **Scripting** 中注册并管理 `AppIntent`，它是 Widget、Live Activity、ControlWidget 等控件执行脚本逻辑的核心机制。
所有的 `AppIntent` **必须** 定义在 `app_intents.tsx` 文件中，且在执行时其运行环境 `Script.env` 为 `"app_intents"`。

通过 `AppIntentManager` 注册的意图可以被 Widget / Live Activity / ControlWidget 中的 **Button** 与 **Toggle** 控件调用，以在用户交互时触发对应的脚本逻辑。

***

## 一、类型定义

### `AppIntent<T>`

表示一个具体的应用意图实例。

| 字段名        | 类型                  | 描述                                       |
| ---------- | ------------------- | ---------------------------------------- |
| `script`   | `string`            | 脚本路径，由系统内部生成。                            |
| `name`     | `string`            | 意图名称，唯一标识该 AppIntent。                    |
| `protocol` | `AppIntentProtocol` | 该意图实现的协议类型（如普通、音频播放、音频录制、Live Activity）。 |
| `params`   | `T`                 | 意图执行时的参数。                                |

***

### `AppIntentFactory<T>`

表示一个 **工厂函数**，用于通过参数创建 `AppIntent` 实例。

```ts
type AppIntentFactory<T> = (params: T) => AppIntent<T>
```

***

### `AppIntentPerform<T>`

表示一个执行函数，用于在意图被触发时执行实际逻辑。

```ts
type AppIntentPerform<T> = (params: T) => Promise<void>
```

***

### `AppIntentProtocol`

`AppIntentProtocol` 是枚举类型，用于指定意图的协议（行为类别）。

| 枚举成员                       | 描述                                                                                                                                       |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `AppIntent` (0)            | 普通 AppIntent。用于执行一般操作的意图。                                                                                                                |
| `AudioPlaybackIntent` (1)  | 播放、暂停或修改音频播放状态的意图。                                                                                                                       |
| `AudioRecordingIntent` (2) | （iOS 18.0+）启动、停止或修改音频录制状态的意图。**注意**：在 iOS/iPadOS 中，当使用 `AudioRecordingIntent` 协议时，必须在开始录音时启动一个 **Live Activity** 并在录音持续时保持活跃，否则音频录制将会停止。 |
| `LiveActivityIntent` (3)   | 启动、暂停或修改 Live Activity 的意图。                                                                                                              |

***

## 二、AppIntentManager 类

### `AppIntentManager.register<T>(options): AppIntentFactory<T>`

注册一个新的 `AppIntent`。
通过指定 `name`、`protocol` 和 `perform` 函数来注册，当控件（Button/Toggle）被触发时，系统会自动调用 `perform` 函数执行逻辑。

```ts
static register<T = undefined>(options: {
  name: string;
  protocol: AppIntentProtocol;
  perform: AppIntentPerform<T>;
}): AppIntentFactory<T>
```

#### 参数：

| 参数名        | 类型                    | 描述                                    |
| ---------- | --------------------- | ------------------------------------- |
| `name`     | `string`              | AppIntent 的名称，需唯一，用于标识该意图。            |
| `protocol` | `AppIntentProtocol`   | AppIntent 的协议类型。                      |
| `perform`  | `AppIntentPerform<T>` | 当控件触发该意图时执行的异步函数，参数为控件传递过来的 `params`。 |

#### 返回值：

- **`AppIntentFactory<T>`**：返回一个工厂函数，可通过传入参数创建 `AppIntent` 实例。

#### 示例：

```tsx
/// app_intents.tsx
export const ToggleDoorIntent = AppIntentManager.register({
  name: "ToggleDoorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async ({ id, newState }: { id: string; newState: boolean }) => {
    // 自定义逻辑：切换门的状态
    await setDoorState(id, newState)
    // 通知控件刷新状态（如 ControlWidgetToggle）
    ControlWidget.reloadToggles()
  }
})
```

在控件文件中（如 `control_widget_toggle.tsx`）：

```tsx
ControlWidget.present(
  <ControlWidgetToggle
    intent={ToggleDoorIntent({ id: "door1", newState: !currentState })}
    label={{
      title: "Door 1",
      systemImage: currentState ? "door.garage.opened" : "door.garage.closed"
    }}
    activeValueLabel={{ title: "The door is opened" }}
    inactiveValueLabel={{ title: "The door is closed" }}
  />
)
```

在小组件中使用（如 `widget.tsx`）:

```tsx
<Toggle
  title="Door 1"
  value={currentState}
  intent={ToggleDoorIntent({ id: "door1", newState: !currentState })}
/>
```

***

## 三、执行时环境

所有通过 `AppIntentManager` 定义的 AppIntent 在执行时，`Script.env` 会自动为 `"app_intents"`。
这意味着在 `perform` 函数中可以安全地使用适合 `"app_intents"` 环境的 API（如访问网络、更新 Live Activity 状态、触发控件刷新等）。

***

## 四、最佳实践

1. **集中管理**：所有 AppIntent 必须定义在 `app_intents.tsx` 文件中，避免分散。
2. **类型安全**：在 `perform` 和控件参数中定义严格的参数类型 `T`，以确保开发时的自动补全与类型检查。
3. **协议匹配**：根据控件行为选择合适的 `AppIntentProtocol`，例如：

   - 普通操作 → `AppIntent`
   - 控制音频播放 → `AudioPlaybackIntent`
   - 控制音频录制 → `AudioRecordingIntent`（iOS 18+ 且需保持 Live Activity）
   - 启动/暂停 Live Activity → `LiveActivityIntent`
4. **状态刷新**：执行完 `perform` 后，如需更新 UI 状态（例如切换门锁开关），请调用 `ControlWidget.reloadButtons()` 、 `ControlWidget.reloadToggles()` 或 `Widget.reloadAll()`。



---
url: /v2/zh/guide/Assistant/Assistant Conversation APIs.md
---

# 智能助手会话 API

Conversation API 用于**启动、控制和展示一个由系统托管的 Assistant 对话会话**。
该会话对应一个**完整的聊天页面（Chat Page）**，由 Scripting App 统一管理 UI、状态和模型交互。

与 `requestStreaming` / `requestStructuredData` 的区别在于：

- Conversation API 面向**交互式聊天体验**
- 系统负责消息发送、流式输出、Provider 切换、UI 渲染
- 开发者只需关注“何时开始 / 何时结束 / 是否展示”

***

## 会话生命周期概览

一个典型的会话生命周期如下：

1. `startConversation` —— 创建会话（可选自动开始）
2. `present` —— 展示 Assistant 聊天页面
3. 用户与 Assistant 进行交互
4. `dismiss` —— 临时关闭聊天页面（会话仍存在）
5. `present` —— 再次展示会话
6. `stopConversation` —— 结束会话并释放资源

重要约束：

- **同一时间只能存在一个活动会话**
- 若已有会话在运行，再次调用 `startConversation` 会抛出错误
- 调用 `stopConversation` 会自动触发 `dismiss`

***

## startConversation

### API 定义

```ts
function startConversation(options: {
  message: string
  images?: UIImage[]
  autoStart?: boolean
  systemPrompt?: string
  modelId?: string
  provider?: Provider
}): Promise<void>
```

***

### 参数说明

#### options.message

- 类型：`string`
- 必填
- 会话的**初始用户消息**
- 相当于聊天页面中的第一条用户输入

***

#### options.images（可选）

- 类型：`UIImage[]`
- 会与 `message` 一起作为首条用户消息发送
- 适用于：

  - 图片分析
  - 拍照 / 截图后直接发起对话

***

#### options.autoStart（可选）

- 类型：`boolean`
- 默认值：`false`

行为说明：

- `true`：

  - 创建会话后立即开始生成回复
- `false`：

  - 仅创建会话，不自动发送
  - 通常配合 `present` 使用，由用户点击发送

***

#### options.systemPrompt（可选）

- 类型：`string`

说明：

- 若未提供：

  - 使用 Scripting Assistant 内置 system prompt
  - Assistant Tools 可用
- 若提供：

  - 完全替换默认 system prompt
  - **Assistant Tools 将不可用**

适用场景：

- 构建高度定制的聊天角色
- 禁用工具调用，仅使用纯模型能力

***

#### options.modelId（可选）

- 类型：`string`
- 指定本次会话使用的模型
- 用户仍可在聊天页面中手动切换模型（若 UI 允许）

***

#### options.provider（可选）

- 类型：`Provider`
- 指定默认 Provider
- 用户可在聊天页面中更改 Provider（若 UI 允许）

***

### 返回值

```ts
Promise<void>
```

- 会话创建成功即 resolve
- 若已有会话存在，将 reject

***

## present

### API 定义

```ts
function present(): Promise<void>
```

***

### 行为说明

- 展示当前会话对应的 Assistant 聊天页面
- 若页面已展示，调用不会产生额外效果
- 可在以下场景调用：

  - `startConversation` 之后首次展示
  - `dismiss` 后重新展示同一会话

***

### 返回值

```ts
Promise<void>
```

- 当聊天页面被用户关闭时 resolve

***

## dismiss

### API 定义

```ts
function dismiss(): Promise<void>
```

***

### 行为说明

- 关闭 Assistant 聊天页面
- **不会终止会话**
- 会话状态、历史消息仍保留

适用场景：

- 临时让出界面空间
- 页面跳转或多任务切换

***

### 返回值

```ts
Promise<void>
```

- 页面成功关闭后 resolve

***

## stopConversation

### API 定义

```ts
function stopConversation(): Promise<void>
```

***

### 行为说明

- 彻底终止当前会话
- 自动调用 `dismiss`
- 清理会话状态与资源
- 结束后可再次调用 `startConversation` 创建新会话

***

### 返回值

```ts
Promise<void>
```

***

## 会话状态相关常量

### Assistant.isAvailable

```ts
const isAvailable: boolean
```

- 表示当前用户是否**具备使用 Assistant 的权限**
- 若为 `false`：

  - 所有 Conversation API 均不可用

***

### Assistant.isPresented

```ts
const isPresented: boolean
```

- 表示 Assistant 聊天页面当前是否处于展示状态

***

### Assistant.hasActiveConversation

```ts
const hasActiveConversation: boolean
```

- 表示当前是否存在一个活动会话
- 常用于防止重复调用 `startConversation`

***

## 使用示例

### 示例一：最常见的使用方式

```ts
await Assistant.startConversation({
  message: "帮我总结这篇文章的要点",
  autoStart: true
})

await Assistant.present()
```

***

### 示例二：创建会话但不自动发送

```ts
await Assistant.startConversation({
  message: "我们来讨论一下系统架构设计",
  autoStart: false
})

await Assistant.present()
// 由用户在 UI 中手动点击发送
```

***

### 示例三：暂时关闭，再次展示

```ts
await Assistant.startConversation({
  message: "分析这张图片",
  images: [image],
  autoStart: true
})

await Assistant.present()

// 用户关闭页面
await Assistant.dismiss()

// 稍后再次展示同一会话
await Assistant.present()
```

***

### 示例四：结束当前会话并重新开始

```ts
if (Assistant.hasActiveConversation) {
  await Assistant.stopConversation()
}

await Assistant.startConversation({
  message: "开始一个新的话题",
  autoStart: true
})

await Assistant.present()
```

***

## 使用建议与最佳实践

- 将 Conversation API 视为“**托管聊天界面**”
- 不要在同一业务流中混用 Conversation API 与 `requestStreaming`
- 在调用 `startConversation` 前检查 `hasActiveConversation`
- 若仅需要数据或一次性输出，应使用：

  - `requestStructuredData`
  - `requestStreaming`
- 若用户需要持续交互体验，应使用 Conversation API

***

## 设计边界说明

- Conversation API 不适合无 UI 场景
- 不适合后台自动化任务
- 不适合需要完全控制 Prompt / Token / 输出格式的场景



---
url: /v2/zh/guide/Assistant/Assistant Quick Start.md
---

# 快速了解智能助手

Scripting 的 Assistant API 提供了三类能力，分别面向 **数据处理**、**流式输出** 和 **交互式聊天** 三种不同使用场景。
在使用之前，建议先明确你的需求属于哪一类。

***

## Assistant API 分类总览

| API 分类 | 主要方法                                                             | 适用场景                   |
| ------ | ---------------------------------------------------------------- | ---------------------- |
| 结构化数据  | `requestStructuredData`                                          | 从文本 / 图片中提取结构化 JSON 数据 |
| 流式生成   | `requestStreaming`                                               | 实时展示 AI 输出内容           |
| 会话聊天   | `startConversation` / `present` / `dismiss` / `stopConversation` | 托管式聊天体验                |

***

## requestStructuredData

**用途**
用于请求**严格符合 JSON Schema 的结构化结果**。

**适合场景**

- 解析票据、发票、账单
- 从自然语言中提取字段
- 生成配置、规则、表单数据
- 需要直接用于程序逻辑的数据

**特点**

- 返回值稳定、可预测
- 不适合长文本或展示型输出
- 适合后台或无 UI 场景

**一句话总结**

> 需要“数据”，用 `requestStructuredData`

***

## requestStreaming

**用途**
用于获取**流式输出**，在模型生成过程中持续接收内容。

**适合场景**

- 聊天气泡逐字显示
- 长文本生成（文章、说明、分析）
- 需要低延迟反馈的 UI

**特点**

- 支持文本、推理、用量等多种 Chunk
- 可边生成边渲染
- 不保证输出结构

**一句话总结**

> 需要“过程”和“实时展示”，用 `requestStreaming`

***

## Conversation API（会话聊天）

**相关方法**

- `startConversation`
- `present`
- `dismiss`
- `stopConversation`

**用途**
用于创建并展示一个**系统托管的 Assistant 聊天页面**。

**适合场景**

- 类 ChatGPT 的交互体验
- 用户需要多轮对话
- 希望系统管理 UI、Provider 切换、消息状态

**特点**

- 内置完整聊天 UI
- 自动处理流式输出
- 同一时间仅支持一个会话

**一句话总结**

> 需要“完整聊天体验”，用 Conversation API

***

## 如何选择合适的 API

### 常见选择指南

- **我要解析一张账单 →** `requestStructuredData`
- **我要展示 AI 写文章的过程 →** `requestStreaming`
- **我要打开一个聊天页面让用户和 AI 对话 →** Conversation API
- **我不需要 UI，只要结果 →** `requestStructuredData` 或 `requestStreaming`
- **我希望系统帮我处理聊天 UI →** Conversation API

***

## 简单示例

### 结构化数据

```ts
const data = await Assistant.requestStructuredData(...)
```

***

### 流式输出

```ts
const stream = await Assistant.requestStreaming(...)
for await (const chunk of stream) {
  // handle chunk
}
```

***

### 聊天会话

```ts
await Assistant.startConversation({ message: "你好", autoStart: true })
await Assistant.present()
```

***

## 使用建议

- 不要在同一业务流程中混用 Conversation API 和 `requestStreaming`
- 有明确数据结构需求时，优先选择 `requestStructuredData`
- 展示型输出和交互体验优先考虑 `requestStreaming` 或 Conversation API

***

## 下一步

如果你需要更深入的内容，可以继续阅读：

- `requestStructuredData` 详细文档
- `requestStreaming` 详细文档
- Conversation API 生命周期说明



---
url: /v2/zh/guide/Assistant/requestStreaming.md
---

# 请求流式数据

`requestStreaming` 用于向 Assistant 请求**流式输出（Streaming Response）**。
与一次性返回完整结果不同，该 API 会在模型生成内容的过程中**持续返回数据片段（Chunk）**，调用方可以边接收边处理，从而实现：

- 实时展示 AI 输出（打字机效果）
- 流式日志 / 分段结果处理
- 长文本生成的低延迟体验
- 在生成过程中提前终止或切换 UI 状态

该 API 返回的是一个 **`ReadableStream<StreamChunk>`**，你可以通过 `for await ... of` 逐块读取。

***

## API 定义

```ts
function requestStreaming(options: {
  systemPrompt?: string | null
  messages: MessageItem | MessageItem[]
  provider?: Provider
  modelId?: string
}): Promise<ReadableStream<StreamChunk>>
```

***

## 参数说明

### options.systemPrompt（可选）

- 类型：`string | null`
- 指定本次请求使用的 system prompt
- 若未提供：

  - 使用 Assistant 内置的默认 system prompt
- 若显式传入：

  - 将**完全替换默认 system prompt**
  - Assistant Tools 将**不可用**

适用场景：

- 构建专用角色（如代码审查、翻译、摘要）
- 严格约束模型行为或输出风格

***

### options.messages

- 类型：`MessageItem | MessageItem[]`
- 必填
- 用于描述对话上下文的消息列表

#### MessageItem 结构

```ts
type MessageItem = {
  role: "user" | "assistant"
  content: MessageContent | MessageContent[]
}
```

- `role`

  - `"user"`：用户输入
  - `"assistant"`：历史 Assistant 输出（用于上下文补全）

***

### MessageContent 类型

#### 文本内容

```ts
type MessageTextContent =
  | string
  | { type: "text"; content: string }
```

***

#### 图片内容

```ts
type MessageImageContent = {
  type: "image"
  content: string // data:image/...;base64,...
}
```

***

#### 文档内容

```ts
type MessageDocumentContent = {
  type: "document"
  content: {
    mediaType: string
    data: string // base64
  }
}
```

***

### options.provider（可选）

- 类型：`Provider`
- 指定使用的 AI Provider
- 若未指定：

  - 使用 Assistant 当前配置的默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 若未指定，使用 Provider 默认模型

***

## 返回值

```ts
Promise<ReadableStream<StreamChunk>>
```

该 Promise resolve 后，你将获得一个可异步迭代的流对象。

***

## StreamChunk 类型说明

`requestStreaming` 的流中会返回以下三类 Chunk。

***

### StreamTextChunk（文本输出）

```ts
type StreamTextChunk = {
  type: "text"
  content: string
}
```

- 表示 Assistant 生成的**可展示文本**
- 多个 chunk 拼接后构成完整回复

***

### StreamReasoningChunk（推理输出）

```ts
type StreamReasoningChunk = {
  type: "reasoning"
  content: string
}
```

- 表示模型的**中间推理过程**
- 是否返回、返回粒度取决于 Provider / Model

***

### StreamUsageChunk（用量信息）

```ts
type StreamUsageChunk = {
  type: "usage"
  content: {
    totalCost: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    inputTokens: number
    outputTokens: number
  }
}
```

说明：

- 通常在流的**末尾**返回一次
- 不同 Provider 支持的字段略有差异
- `totalCost` 可能为 `null`（例如 Provider 未提供费用信息）

***

## 使用示例

### 示例一：最基本的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: {
    role: "user",
    content: "给我讲一个简短的科幻故事"
  },
  provider: "openai"
})

let text = ""

for await (const chunk of stream) {
  if (chunk.type === "text") {
    text += chunk.content
    console.log(chunk.content)
  }
}
```

***

### 示例二：区分文本、推理和用量

```ts
const stream = await Assistant.requestStreaming({
  systemPrompt: "你是一个严谨的技术写作助手",
  messages: [
    {
      role: "user",
      content: "解释什么是 HTTP/3"
    }
  ]
})

let answer = ""
let reasoningLog = null
let usage = null

for await (const chunk of stream) {
  switch (chunk.type) {
    case "text":
      answer += chunk.content
      break

    case "reasoning":
      reasoningLog = (reasoningLog ?? "") + chunk.content
      break

    case "usage":
      usage = chunk.content
      break
  }
}

console.log(answer)
console.log(usage)
```

***

### 示例三：包含图片与文档的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: [
    {
      role: "user",
      content: [
        {
          type: "text",
          content: "请分析这份文档的核心内容"
        },
        {
          type: "document",
          content: {
            mediaType: "application/pdf",
            data: "JVBERi0xLjQKJcfs..."
          }
        }
      ]
    }
  ],
  provider: "anthropic"
})

for await (const chunk of stream) {
  if (chunk.type === "text") {
    console.log(chunk.content)
  }
}
```

***

## 使用建议与注意事项

- 流式结果**必须按顺序消费**，不可并发读取
- UI 场景下建议：

  - 文本 chunk 实时渲染
  - reasoning chunk 仅用于调试
  - usage chunk 延迟处理
- 若中途不再需要结果，应主动中止读取，避免无意义消耗
- 并非所有 Provider / Model 都会返回 reasoning 或 usage
- 不同 Provider 的 chunk 粒度不同，不应假设单次 chunk 是完整句子



---
url: /v2/zh/guide/Assistant/requestStructuredData.md
---

# 请求结构化数据

`requestStructuredData` 用于向 Assistant 请求**严格符合指定 JSON Schema 的结构化 JSON 数据**。
该 API 适合在你需要**可预测、可直接用于程序逻辑**的数据结果时使用，而不是自由文本。

典型使用场景包括：

- 从自然语言中提取结构化字段
- 解析发票、收据、账单、票据
- 生成配置对象、规则数据
- 在不同 AI Provider / Model 之间获得一致的数据结构

***

## 支持的 JSON Schema 类型

Scripting 提供了一套轻量级、跨模型可用的 Schema 描述方式，由三种基础类型组成。

### Primitive（基础类型）

```ts
type JSONSchemaPrimitive = {
  type: "string" | "number" | "boolean"
  required?: boolean
  description: string
}
```

***

### Object（对象类型）

```ts
type JSONSchemaObject = {
  type: "object"
  properties: Record<string, JSONSchemaType>
  required?: boolean
  description: string
}
```

***

### Array（数组类型）

```ts
type JSONSchemaArray = {
  type: "array"
  items: JSONSchemaType
  required?: boolean
  description: string
}
```

***

## API 定义

### 不包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

### 包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  images: string[],
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

## 参数说明

### prompt

- 类型：`string`
- 必填
- 向模型说明**需要解析或生成什么结构化数据**
- 强烈建议在 prompt 中明确：

  - 时间格式（如 ISO-8601）
  - 金额是否为纯数字
  - 缺失字段的处理规则

***

### images（可选）

- 类型：`string[]`
- 每一项必须是 Data URI，例如：

```text
data:image/png;base64,iVBORw0KGgoAAAANS...
```

- 并非所有 Provider / Model 都支持图片输入
- 图片数量过多可能导致请求失败

***

### schema

- 类型：`JSONSchemaArray | JSONSchemaObject`
- 必填
- 定义模型**唯一允许返回的 JSON 结构**
- 每一个字段都应提供清晰的 `description`，这是保证结果稳定的关键

***

### options.provider

- 类型：`Provider`
- 可选，未指定时使用 Assistant 当前默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 未指定时使用 Provider 默认模型

***

## 返回值

```ts
Promise<R>
```

- `R` 为调用方声明的泛型类型
- 返回结果应严格符合 Schema 描述
- 若模型无法生成合法结构，Promise 将被 reject

***

## 使用示例

### 示例一：解析票据 / 收据，提取消费项目、时间和金额

该示例演示如何将一段票据文本解析为结构化数据，包括：

- 整体消费时间（`purchasedAt`）
- 币种（`currency`）
- 消费项目列表（`items`）

  - 项目名称
  - 项目时间（若无则为空）
  - 金额
- 合计金额（`total`）

```ts
type ReceiptItem = {
  name: string
  time: string
  amount: number
}

type ReceiptParsed = {
  purchasedAt: string
  currency: string
  items: ReceiptItem[]
  total: number
}

const receiptText = `
Star Coffee
2026-01-08 14:23
Latte (Large)   $5.50
Blueberry Muffin $3.20
Tax             $0.79
Total           $9.49
`

const parsed = await Assistant.requestStructuredData<ReceiptParsed>(
  [
    "请分析以下票据文本，并提取结构化信息：",
    "- purchasedAt：整体消费时间，使用 ISO-8601 格式，若无法判断则返回空字符串",
    "- currency：币种代码（如 USD / EUR / CNY），若无法判断则返回空字符串",
    "- items：仅包含实际消费项目，不包含税费、合计等行",
    "  - name：项目名称",
    "  - time：项目级时间，若无则返回空字符串",
    "  - amount：数值类型的金额",
    "- total：合计金额，若无则返回 -1",
    "",
    "票据内容：",
    receiptText
  ].join("\n"),
  {
    type: "object",
    description: "票据解析结果",
    properties: {
      purchasedAt: {
        type: "string",
        description: "整体消费时间（ISO-8601），若无则为空字符串"
      },
      currency: {
        type: "string",
        description: "币种代码，若无法判断则为空字符串"
      },
      items: {
        type: "array",
        description: "消费项目列表（不包含税费、合计等）",
        items: {
          type: "object",
          description: "单个消费项目",
          properties: {
            name: {
              type: "string",
              description: "项目名称"
            },
            time: {
              type: "string",
              description: "项目时间（ISO-8601），若无则为空字符串"
            },
            amount: {
              type: "number",
              description: "项目金额"
            }
          }
        }
      },
      total: {
        type: "number",
        description: "合计金额，若不存在则为 -1"
      }
    }
  },
  {
    provider: "openai"
  }
)

// 建议在业务层将空字符串 / -1 归一化为 null
console.log(parsed)
```

***

### 示例二：生成数组结构

```ts
type Expense = {
  name: string
  amount: number
}

const expenses = await Assistant.requestStructuredData<Expense[]>(
  "列出三项常见的日常支出及其大致金额",
  {
    type: "array",
    description: "支出列表",
    items: {
      type: "object",
      description: "单项支出",
      properties: {
        name: {
          type: "string",
          description: "支出名称"
        },
        amount: {
          type: "number",
          description: "金额"
        }
      }
    }
  },
  {
    provider: "gemini"
  }
)
```

***

### 示例三：结合图片生成结构化结果

```ts
type ImageSummary = {
  description: string
  containsText: boolean
}

const summary = await Assistant.requestStructuredData<ImageSummary>(
  "分析这张图片的主要内容",
  ["data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD..."],
  {
    type: "object",
    description: "图片分析结果",
    properties: {
      description: {
        type: "string",
        description: "图片内容描述"
      },
      containsText: {
        type: "boolean",
        description: "是否包含可识别文本"
      }
    }
  },
  {
    provider: "openai"
  }
)
```

***

## 使用建议与注意事项

- 当返回结果用于业务逻辑时，优先使用 `requestStructuredData`
- Schema 描述越明确，结果越稳定
- 复杂业务规则不要放在 Schema 中，应由业务代码处理



---
url: /v2/zh/guide/AssistantTool.md
---

# 智能助手工具

Assistant Tool 是 Scripting 应用中为智能助手（Assistant）提供系统功能扩展的机制。通过定义和实现 Assistant Tool，开发者可以为 Assistant 提供设备能力访问、文件读写操作、数据分析处理等辅助功能，提升 Assistant 的智能性和实用性。

本文以一个示例工具「Request Current Location」为基础，介绍 Assistant Tool 的完整实现流程，包括工具创建、配置文件说明、执行逻辑实现以及各类函数的详细说明。

***

## 一、工具创建流程

1. 打开任意脚本项目，在文件管理界面点击“添加 Assistant Tool”按钮。

2. 在弹出的配置窗口中填写Assistant Tool 相关的信息。

3. 点击“保存”后，系统会自动在脚本中生成两个文件：

- `assistant_tool.json`：描述工具的元数据和参数信息。
- `assistant_tool.tsx`：实现工具的执行逻辑。

***

## 二、配置文件 assistant\_tool.json

该文件用于声明工具的基本信息和行为配置。以下是示例内容及字段说明：

```json
{
  "displayName": "Request Current Location",
  "id": "request_current_location",
  "description": "This tool allows you to request the one-time delivery of the latitude and longitude of the user’s current location.",
  "icon": "location.fill",
  "color": "systemBlue",
  "parameters": [],
  "requireApproval": true,
  "autoApprove": true,
  "scriptEditorOnly": false
}
```

### 字段说明：

| 字段                 | 类型      | 说明                  |
| ------------------ | ------- | ------------------- |
| `displayName`      | string  | 工具在界面中显示的名称         |
| `id`               | string  | 工具唯一标识符，不能重复        |
| `description`      | string  | 工具功能描述              |
| `icon`             | string  | 使用的 SF Symbols 图标名  |
| `color`            | string  | 工具主色调               |
| `parameters`       | array   | 工具需要的参数（为空表示无输入）    |
| `requireApproval`  | boolean | 是否需要用户批准            |
| `autoApprove`      | boolean | 是否支持 Assistant 自动批准 |
| `scriptEditorOnly` | boolean | 工具是否仅能在脚本编辑器中使用     |

***

## 三、执行逻辑 assistant\_tool.tsx 实现示例

```tsx
type RequestCurrentLocationParams = {}

const locationApprovalRequest: AssistantToolApprovalRequestFn<RequestCurrentLocationParams> = async (
  params,
) => {
  return {
    message: "The assistant wants to request your current location.",
    primaryButtonLabel: "Allow"
  }
}

const requestCurrentLocation: AssistantToolExecuteWithApprovalFn<RequestCurrentLocationParams> = async (
  params,
  {
    primaryConfirmed,
    secondaryConfirmed,
  }
) => {
  try {
    const location = await Location.requestCurrent()
    if (location) {
      return {
        success: true,
        message: [
          "The user's current location info:",
          `<latitude>${location.latitude}</latitude>`,
          `<longitude>${location.longitude}</longitude>`
        ].join("\n")
      }
    }
    return {
      success: false,
      message: "Failed to request user's current location, ask user to check the device's location permission."
    }
  } catch {
    return {
      success: false,
      message: "Failed to request user's current location, ask user to check the device's location permission."
    }
  }
}

const testRequestLocationApprovalFn = AssistantTool.registerApprovalRequest(
  locationApprovalRequest
)

const testRequestLocationExecuteFn = AssistantTool.registerExecuteToolWithApproval(
  requestCurrentLocation
)

// 可在脚本编辑器中运行以下测试代码：
testRequestLocationApprovalFn({})
testRequestLocationExecuteFn({}, {
  primaryConfirmed: true,
  secondaryConfirmed: false
})
```

***

## 四、AssistantTool 注册函数详解

### 1. `registerApprovalRequest`

注册一个函数，在执行工具前向用户请求批准。

```ts
function registerApprovalRequest<P>(
  requestFn: AssistantToolApprovalRequestFn<P>
): AssistantToolApprovalRequestTestFn<P>
```

**参数说明**：

- `requestFn(params, scriptEditorProvider?)`：返回提示信息，包括 message、按钮文本等。
- `params`：工具执行时的输入参数。
- `scriptEditorProvider`：仅在工具设置为仅限脚本编辑器使用时可用，提供脚本文件访问能力。

**返回值说明**：

返回的测试函数可用于在脚本编辑器中模拟触发批准请求。

***

### 2. `registerExecuteToolWithApproval`

注册一个需要用户批准的执行函数。

```ts
function registerExecuteToolWithApproval<P>(
  executeFn: AssistantToolExecuteWithApprovalFn<P>
): AssistantToolExecuteWithApprovalTestFn<P>
```

**参数说明**：

- `params`：工具执行时的输入参数。
- `userAction`：用户在批准提示中选择的操作：

```ts
type UserActionForApprovalRequest = {
  primaryConfirmed: boolean
  secondaryConfirmed: boolean
}
```

- `scriptEditorProvider`：同上。

**返回值说明**：

返回一个对象：

```ts
{
  success: boolean
  message: string
}
```

- `success`: 是否执行成功。
- `message`: 返回给Assistant的执行成功或失败的信息。

***

### 3. `registerExecuteTool`

注册一个不需要用户批准的工具逻辑。

```ts
function registerExecuteTool<P>(
  executeFn: AssistantToolExecuteFn<P>
): AssistantToolExecuteTestFn<P>
```

**适用场景**：如操作无敏感性、不涉及设备权限时，可使用此方式。

***

### 4. 测试函数使用

每个注册函数会返回对应的测试函数，可在脚本中运行：

```ts
testApprovalRequestFn({ ...params })
testExecuteFn({ ...params }, {
  primaryConfirmed: true,
  secondaryConfirmed: false,
})
testExecuteToolFn({ ...params })
```

***

## 五、脚本编辑器接口说明（ScriptEditorProvider）

当工具设置为 `scriptEditorOnly: true` 时，系统提供 `ScriptEditorProvider` 接口，允许访问脚本项目的文件系统与语法信息。

接口能力包括：

- 文件读写（读取、更新、写入、插入、替换）
- 差异比较（openDiffEditor）
- 语法检查结果（getLintErrors）
- 获取项目中所有文件/文件夹列表

适用于如格式化脚本、批量修改内容等编辑类工具。

***

## 六、执行与用户体验流程

1. Assistant 在会话中判断是否需要调用某个工具。
2. 如果工具设置为需要批准，系统弹出批准对话框：
   - 显示由 `registerApprovalRequest` 返回的提示信息。
   - 用户点击“允许”后执行工具逻辑。
3. 执行结果通过 `message` 字段返回给 Assistant，并可呈现给用户。

***

## 七、无需批准的工具实现方式

当不需要显示批准提示时，可直接使用 `registerExecuteTool` 注册逻辑函数：

```ts
AssistantTool.registerExecuteTool<MyParams>(async (params) => {
  // 执行逻辑
  return {
    success: true,
    message: "Tool executed successfully."
  }
})
```

将 `assistant_tool.json` 中的 `requireApproval` 字段设置为 `false` 即可。

***

## 八、小结

Assistant Tool 是 Scripting 应用提供的可扩展能力模块，支持用户授权、文件操作、系统调用等多种场景。开发流程主要包括：

1. 在脚本项目中创建工具；
2. 配置工具元信息；
3. 实现逻辑函数并注册；
4. 使用测试函数验证行为；
5. 在 Assistant 会话中自动或主动触发执行。



---
url: /v2/zh/guide/Changelog/2.4.3/Animation and Transition.md
---

# 动画和过渡

Scripting 通过 `Observable` / `useObservable`、`Animation`、`Transition`、`withAnimation` 以及视图的 `animation` / `transition` 属性，基本对齐了 SwiftUI 的动画能力，包括：

- **属性动画**：数值、颜色、布局等属性随状态变化平滑过渡
- **过渡动画**：视图插入 / 移除时的进出效果（如淡入淡出、滑入滑出、翻转）
- **显式动画**：通过 `withAnimation` 包裹一段「状态更新代码」统一加动画

## Animation 类

`Animation` 用来描述「属性变化的时间曲线与节奏」，类似 SwiftUI 的 `Animation`。

### 工厂方法（创建动画）

#### `Animation.default()`

```ts
static default(): Animation
```

- 创建一个默认动画（通常是系统预设的 ease-in-out 曲线）
- 无需配置，适合「只想要一个普通的过渡效果」的场景

示例：

```tsx
<Text animation={{
  animation: Animation.default(),
  value: value
}}>默认动画</Text>
```

***

#### `Animation.linear(duration?)`

```ts
static linear(duration?: DurationInSeconds | null): Animation
```

- 匀速动画，整段时间内速度保持恒定
- `duration`：动画持续时间（秒），可选，不传时使用默认时长

适合：进度条数值增长、颜色线性变化等。

***

#### `Animation.easeIn(duration?)`

```ts
static easeIn(duration?: DurationInSeconds | null): Animation
```

- 开始慢、后面加速
- 适合：元素「加速进入」的感觉

***

#### `Animation.easeOut(duration?)`

```ts
static easeOut(duration?: DurationInSeconds | null): Animation
```

- 开始快、结尾慢
- 适合：元素「减速停止」的感觉，如卡片滑入后停在目标位置

***

#### `Animation.bouncy(options?)`

```ts
static bouncy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 带回弹效果的动画
- 参数：

  - `duration`：总时长（秒）
  - `extraBounce`：额外弹性，越大越明显

适合：按钮点击放大回弹、卡片弹出等「有趣」的动效。

***

#### `Animation.smooth(options?)`

```ts
static smooth(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 相对柔和、过渡自然的动画
- 与 `bouncy` 相比，弹性感更弱，更偏「丝滑」

***

#### `Animation.snappy(options?)`

```ts
static snappy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 动作「干脆利落」，响应速度快
- 常见于触控反馈、选中高亮等瞬间反馈场景

***

#### `Animation.spring(options?)`

```ts
static spring(options?: {
  blendDuration?: number
} & ({
  duration?: DurationInSeconds
  bounce?: number
  response?: never
  dampingFraction?: never
} | {
  response?: number
  dampingFraction?: number
  duration?: never
  bounce?: never
})): Animation
```

支持两种配置方式（注意互斥）：

1. **基于时长的弹簧动画**

   - `duration`: 动画持续时间
   - `bounce`: 弹性大小

2. **物理参数模式**

   - `response`: 响应速度（值越小反馈越快）
   - `dampingFraction`: 阻尼系数（0\~1，越大越「稳」，越小越「弹」）

额外参数：

- `blendDuration`：动画混合时长，用于多动画衔接场景（可选）

示例：

```tsx
// 简单弹簧
const anim1 = Animation.spring({
  duration: 0.4,
  bounce: 0.3
})

// 高级弹簧
const anim2 = Animation.spring({
  response: 0.25,
  dampingFraction: 0.7
})
```

***

#### `Animation.interactiveSpring(options?)`

```ts
static interactiveSpring(options?: {
  response?: number
  dampingFraction?: number
  blendDuration?: number
}): Animation
```

- 面向「交互驱动」的弹簧动画，例如拖拽结束后的回弹
- 参数与 `spring` 的物理参数模式类似，语义更偏向手势交互

***

#### 0 `Animation.interpolatingSpring(options?)`

```ts
static interpolatingSpring(options?: {
  mass?: number
  stiffness: number
  damping: number
  initialVelocity?: number
} | {
  duration?: DurationInSeconds
  bounce?: number
  initialVelocity?: number
  mass?: never
  stiffness?: never
  damping?: never
}): Animation
```

两种配置方式（互斥）：

1. **物理参数模式**

   - `mass`: 质量
   - `stiffness`: 刚度
   - `damping`: 阻尼
   - `initialVelocity`: 初速度（可选）

2. **时长 + 弹性模式**

   - `duration`: 动画时长
   - `bounce`: 弹性
   - `initialVelocity`: 初速度（可选）

适合对动态效果「非常在意手感」的高级场景。

***

### 修改已有动画（链式 API）

#### `delay(time)`

```ts
delay(time: DurationInSeconds): Animation
```

- 使动画延迟 `time` 秒后再开始
- 返回一个新的 `Animation` 实例（原动画不变）

示例：

```tsx
const [animValue, setAnimValue] = useState(0)
const anim = Animation
  .spring({ duration: 0.4, bounce: 0.3 })
  .delay(0.2)

<Text animation={{
  animation: anim,
  value: animValue
}>延迟弹簧</Text>
```

***

#### `repeatCount(count, autoreverses?)`

```ts
repeatCount(count: number, autoreverses?: boolean): Animation
```

- 重复执行动画 `count` 次
- `autoreverses`（默认 `true`）：是否来回反向播放

示例：

```tsx
const pulse = Animation
  .easeIn(0.6)
  .repeatCount(3, true)

<Text animation={{
  animation: pulse,
  value: value
}}>闪烁三次</Text>
```

***

#### `repeatForever(autoreverses?)`

```ts
repeatForever(autoreverses?: boolean): Animation
```

- 无限次重复动画
- 适合加载动画、呼吸灯效果等

***

### Animation 实战示例

#### 示例 1：基本大小动画

```tsx
import { VStack, Button, Rectangle, useObservable, Animation, withAnimation } from "scripting"

export function Demo() {
  const size = useObservable(80)

  return <VStack spacing={16}>
    <Rectangle
      frame={{ width: size.value, height: size.value }}
      backgroundColor="blue"
      animation={{
        animation: Animation.spring({ duration: 0.3, bounce: 0.2 }),
        value: size.value
      }}
    />

    <Button
      title="Toggle Size"
      action={() => {
        withAnimation(() => {
          size.setValue(size.value === 80 ? 140 : 80)
        })
      }}
    />
  </VStack>
}
```

***

## Transition 类（视图过渡）

`Transition` 描述的是**视图插入与移除**时的「进场 / 退场效果」，对应 SwiftUI 的 `AnyTransition`。

> 注意：只有当视图在 JSX 中「存在与否」发生变化（如 `{visible.value && <Text ... />}`）时，`transition` 才会生效。

### 实例方法

#### `animation(animation?)`

```ts
animation(animation?: Animation): Transition
```

- 为当前过渡指定（或覆盖）使用的 `Animation`
- 不传时使用默认动画

示例：

```tsx
const t = Transition
  .move("bottom")
  .animation(Animation.spring({ duration: 0.4 }))
```

***

#### `combined(other)`

```ts
combined(other: Transition): Transition
```

- 组合两个过渡效果，类似 SwiftUI 的 `.combined`
- 如：向下滑入 + 淡入

示例：

```tsx
const t = Transition
  .move("bottom")
  .combined(Transition.opacity())
```

在视图中使用：

```tsx
<Text transition={t}>组合过渡</Text>
```

***

### 静态方法（构造不同类型的过渡）

#### `Transition.identity()`

```ts
static identity(): Transition
```

- 「没有任何过渡」，视图插入 / 移除时不会做动画
- 通常用于禁用某些分支的过渡效果

***

#### `Transition.move(edge)`

```ts
static move(edge: Edge): Transition
```

- 从某个边缘移入 / 移出
- `edge` 通常是 `"leading" | "trailing" | "top" | "bottom"` 等（和 SwiftUI 对齐）

示例：

```tsx
<Text transition={Transition.move("leading")}>
  从左侧滑入 / 滑出
</Text>
```

***

#### `Transition.offset(position?)`

```ts
static offset(position?: Point): Transition
```

- 通过偏移实现过渡
- `position`: `{ x: number, y: number }`，默认 `{ x: 0, y: 0 }`

例如：

```tsx
<Text
  transition={Transition.offset({ x: 0, y: 40 })}
>
  从下方位移进出
</Text>
```

***

#### `Transition.pushFrom(edge)`

```ts
static pushFrom(edge: Edge): Transition
```

- 类似导航 push 的效果，从某个边缘推入并把旧内容推走
- 适合做「页面切换」类效果

***

#### `Transition.opacity()`

```ts
static opacity(): Transition
```

- 单纯的淡入 / 淡出
- 与 `Animation` 搭配可以控制淡入淡出的节奏

***

#### `Transition.scale(scale?, anchor?)`

```ts
static scale(
  scale?: number,
  anchor?: Point | KeywordPoint
): Transition
```

- 缩放过渡
- `scale`：缩放比（默认 1）
- `anchor`：缩放基准点，支持：

  - `Point`：如 `{ x: 0.5, y: 0.5 }`
  - `KeywordPoint`：如 `"center"`、`"top"`, `"bottom"` 等（具体值与 Scripting 内部对齐）

示例：

```tsx
<Text
  transition={Transition.scale(0.8, "center")}
>
  缩放进出
</Text>
```

***

#### `Transition.slide()`

```ts
static slide(): Transition
```

- 类似 SwiftUI 的 `.slide`，通常是从一侧滑入 / 滑出（具体方向由系统决定）
- 常用于列表项、简单出现 / 消失效果

***

#### `Transition.fade(duration?)`

```ts
static fade(duration?: DurationInSeconds): Transition
```

- 带时长配置的淡入 / 淡出
- 与 `Transition.opacity()` 类似，但可以直接指定过渡时间

***

#### Flip 系列（翻转过渡）

```ts
static flipFromLeft(duration?: DurationInSeconds): Transition
static flipFromBottom(duration?: DurationInSeconds): Transition
static flipFromRight(duration?: DurationInSeconds): Transition
static flipFromTop(duration?: DurationInSeconds): Transition
```

- 类似卡片翻转的 3D 过渡

示例：

```tsx
<Text
  transition={Transition.flipFromLeft(0.4)}
>
  左侧翻入 / 翻出
</Text>
```

***

#### 0 `Transition.asymmetric(insertion, removal)`

```ts
static asymmetric(
  insertion: Transition,
  removal: Transition
): Transition
```

- 插入和移除使用不同的过渡效果
- 典型用法：进入时从下方滑入，离开时淡出

示例：

```tsx
const appear = Transition
  .move("bottom")
  .combined(Transition.opacity())

const disappear = Transition.opacity()

const t = Transition.asymmetric(appear, disappear)

<Text transition={t}>不对称过渡</Text>
```

***

### Transition 实战示例

#### 示例：多种过渡效果对比

```tsx
const visible = useObservable(true)

return <VStack spacing={12}>
  {visible.value &&
    <Text
      transition={Transition.slide().combined(Transition.opacity())}
    >
      Slide + Fade
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.move("leading")}
    >
      Move leading
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.scale()}
    >
      Scale
    </Text>
  }

  <Button
    title="Toggle"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## withAnimation：显式动画入口

`withAnimation` 用来「显式」地将一段状态更新包裹在动画上下文中，类似 SwiftUI 的 `withAnimation`。
它返回 `Promise<void>`，方便在异步逻辑中等待动画完成。

### 重载签名

```ts
function withAnimation(body: () => void): Promise<void>
function withAnimation(animation: Animation, body: () => void): Promise<void>
function withAnimation(
  animation: Animation,
  completionCriteria: "logicallyComplete" | "removed",
  body: () => void
): Promise<void>
```

- 第一个重载：使用默认动画
- 第二个重载：指定动画曲线 / 弹性等
- 第三个重载：额外指定**完成条件**：

  - `"logicallyComplete"`：动画在时间轴上播放完成时视为完成（典型属性动画）
  - `"removed"`：通常用于涉及过渡的场景，等待相关视图被移出 / 动画结束后再继续逻辑（具体行为依赖底层 SwiftUI）

> 实际等待的精确时机由内部动画系统决定，一般可理解为「该动画相关的视图不再处于动画中」。

***

### 基本用法

#### 默认动画

```tsx
const size = useObservable(100)

<Button
  title="Toggle"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value === 100 ? 200 : 100)
    })
  }}
/>
```

***

#### 指定动画

```tsx
const visible = useObservable(true)

<Button
  title="Toggle Panel"
  action={() => {
    withAnimation(
      Animation.spring({ duration: 0.3, bounce: 0.2 }),
      () => {
        visible.setValue(!visible.value)
      }
    )
  }}
/>
```

***

#### 在异步函数中等待动画结束

```ts
async function hideThenRunTask() {
  await withAnimation(Animation.easeOut(0.25), () => {
    visible.setValue(false)
  })

  // 此处可以认为相关动画已经结束，再继续耗时任务或导航
  await doSomethingHeavy()
}
```

***

## 视图上的 animation / transition 属性

在 Scripting 的视图组件上，可以通过 props 的形式配置动画相关行为：

- `animation?: Animation`（属性动画）
- `transition?: Transition`（插入 / 移除过渡）

### 属性动画（animation）

属性动画的核心逻辑：

- 当某个视图依赖的 `Observable` 的 `value` 发生变化时
- 如果该视图设置了 `animation={...}` 或更新发生在 `withAnimation` 中
- 则 SwiftUI 会对这些属性差异进行插值，从原值平滑过渡到新值

示例：

```tsx
const size = useObservable(80)

<Rectangle
  frame={{
    width: size.value,
    height:size.value
  }}
  backgroundColor="green"
  animation={{
    animation: Animation.spring({ duration: 0.3, bounce: 0.25 }),
    value: size.value
  }}
/>
```

配合 `withAnimation`：

```tsx
<Button
  title="Grow"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value + 20)
    })
  }}
/>
```

***

### 过渡动画（transition）

过渡动画只在「视图从无到有 / 从有到无」时生效。

关键点：

- 通常通过条件渲染控制：

  ```tsx
  {visible.value && <Text transition={...}>Hello</Text>}
  ```

- 状态变化本身需要动画上下文（`withAnimation` 或默认动画）

- `Transition.animation(...)` 可为过渡指定特定 `Animation`

示例：条件面板的进出过渡

```tsx
const visible = useObservable(false)

<VStack>
  {visible.value &&
    <Text
      transition={Transition
        .move("bottom")
        .combined(Transition.opacity())
        .animation(Animation.spring({ duration: 0.35, bounce: 0.3 }))
      }
    >
      Panel
    </Text>
  }

  <Button
    title="Toggle Panel"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## 综合示例：列表增删带过渡与属性动画

```tsx
import {
  VStack,
  HStack,
  Text,
  Button,
  useObservable,
  Animation,
  Transition
} from "scripting"

type Item = { id: string; title: string }

export function AnimatedList() {
  const items = useObservable<Item[]>([
    { id: "1", title: "First" },
    { id: "2", title: "Second" }
  ])

  function addItem() {
    withAnimation(Animation.spring({ duration: 0.3 }), () => {
      const next = items.value.length + 1
      items.setValue([
        ...items.value,
        { id: String(next), title: `Item ${next}` }
      ])
    })
  }

  function removeLast() {
    if (items.value.length === 0) return
    withAnimation(Animation.easeOut(0.25), () => {
      items.setValue(items.value.slice(0, -1))
    })
  }

  return <VStack spacing={12}>
    {items.value.map(item =>
      <HStack
        key={item.id}
        transition={Transition
          .move("trailing")
          .combined(Transition.opacity())
        }
      >
        <Text>{item.title}</Text>
      </HStack>
    )}

    <HStack spacing={12}>
      <Button title="Add" action={addItem} />
      <Button title="Remove Last" action={removeLast} />
    </HStack>
  </VStack>
}
```

这个示例中：

- 使用 `Observable<Item[]>` 作为列表数据源
- `transition` 负责列表项插入 / 删除时的滑动 + 淡入淡出
- `withAnimation` 包裹增删操作，确保这些更新被动画化



---
url: /v2/zh/guide/Changelog/2.4.3/EnvironmentValuesReader.md
---

`EnvironmentValuesReader` 是 Scripting 提供的一个组件，用于读取 SwiftUI 风格的环境值（Environment Values）。
它允许脚本在视图层级中访问当前环境的上下文信息，例如颜色模式、尺寸类别、是否正在搜索、是否被呈现、编辑模式等。

该组件的定位与 SwiftUI 中的 `@Environment` 类似，但设计上更加明确：
**你必须指定要读取的 environment keys，系统仅在渲染时读取这些值并传入回调函数。**

***

# EnvironmentValues 类型

```ts
type EnvironmentValues = {
    colorScheme: ColorScheme;
    colorSchemeContrast: ColorSchemeContrast;
    displayScale: number;
    horizontalSizeClass: UserInterfaceSizeClass | null;
    verticalSizeClass: UserInterfaceSizeClass | null;
    dismiss: () => void;
    dismissSearch: () => void;
    editMode: EditMode | null;
    widgetRenderingMode: WidgetRenderingMode;
    showsWidgetContainerBackground: boolean;
    isSearching: boolean;
    isPresented: boolean;
    activityFamily: "small" | "medium";
    tabViewBottomAccessoryPlacement: 'expanded' | 'inline';
};
```

以下为每个字段的说明：

***

## 字段说明

### 1. colorScheme

类型：`ColorScheme`
说明：当前系统的颜色模式，例如 `light` 或 `dark`。

***

### 2. colorSchemeContrast

类型：`ColorSchemeContrast`
说明：颜色对比度模式，例如 `standard`、`increased`。

***

### 3. displayScale

类型：`number`
说明：设备屏幕的像素缩放比例，例如 **2.0**, **3.0**。

***

### 4. horizontalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：横向尺寸类别，可用于响应式布局。
可能值：`compact` / `regular`。

***

### 5. verticalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：纵向尺寸类别，行为同上。

***

### 6. dismiss

类型：`() => void`
说明：用于关闭当前呈现的界面，等价于 SwiftUI 的 `dismiss()`。

***

### 7. dismissSearch

类型：`() => void`
说明：关闭当前的搜索 UI（如果 `searchable` 处于激活状态）。

***

### 8. editMode

类型：`EditMode | null`
说明：当前视图是否处于编辑模式（例如 List 的编辑状态）。

***

### 9. widgetRenderingMode

类型：`WidgetRenderingMode`
说明：Widget 渲染模式，例如 `fullColor`、`accented` 等。

***

### 10. showsWidgetContainerBackground

类型：`boolean`
说明：指示 widget 是否显示系统容器背景。

***

### 11. isSearching

类型：`boolean`
说明：当前 view 是否处于搜索状态（来自 `searchable`）。

***

### 12. isPresented

类型：`boolean`
说明：当前 view 是否已呈现，和 `onAppear` 回调不同，不像 `onAppear` 会多次触发。

***

### 13. activityFamily

类型：`"small" | "medium"`
说明：当前LiveActivity的尺寸，同 SwiftUI 中的 `activityFamily`，用于根据些大小渲染 LiveActivity UI。

***

### 14. tabViewBottomAccessoryPlacement

类型：`'expanded' | 'inline'`
说明：当前 TabView 的底部辅助栏的显示方式，同 SwiftUI 中的 `tabViewBottomAccessoryPlacement`。

# EnvironmentValuesReader 组件

```ts
type EnvironmentValuesReaderProps = {
    /**
     * The keys to read from the environment values.
     */
    keys: Array<keyof EnvironmentValues>;
    /**
     * The callback function to render the children, it will be called with the environment values.
     */
    children: (values: EnvironmentValues) => VirtualNode;
};
```

***

# Props 说明

## keys

类型：`Array<keyof EnvironmentValues>`
说明：指定需要读取的 environment key 列表。

只有指定的 key 才会被 read 并传入 children。

***

## children(values)

类型：`(values: EnvironmentValues) => VirtualNode`
说明：用于渲染子节点的回调。
系统会收集你请求的 environment key，并将其值合并成一个对象传入。

***

# 组件定义

```ts
declare const EnvironmentValuesReader: FunctionComponent<EnvironmentValuesReaderProps>;
```

***

# 使用示例

## 示例：读取 colorScheme 和 displayScale

```tsx
import { EnvironmentValuesReader, Text, VStack } from "scripting"

function View() {
  return <EnvironmentValuesReader
    keys={["colorScheme", "displayScale"]}
  >
    {(env) => {
      return <VStack>
        <Text>Color Scheme: {env.colorScheme}</Text>
        <Text>Scale: {env.displayScale}</Text>
      </VStack>
    }}
  </EnvironmentValuesReader>
}
```

***

## 示例：读取 dismiss

```tsx
<EnvironmentValuesReader keys={["dismiss"]}>
  {(env) => {
    return <Button
      title="Close"
      action={() => env.dismiss()}
    />
  }}
</EnvironmentValuesReader>
```

***

## 示例：根据 sizeClass 动态布局

```tsx
<EnvironmentValuesReader keys={["horizontalSizeClass"]}>
  {(env) => {
    const compact = env.horizontalSizeClass === "compact"
    return compact ? <Text>Compact Layout</Text> : <Text>Regular Layout</Text>
  }}
</EnvironmentValuesReader>
```

***

# 使用注意事项

1. **必须显式指定 keys**，否则不会读取任何 environment 值。
2. 每次所指定的 environment key 发生变化时，`children()` 会重新渲染。
3. `dismiss` 和 `dismissSearch` 是实际可调用的操作，与 SwiftUI 一致。
4. environment 的来源来自父视图树，包括 `Navigation`, `searchable`, `editMode`, `Widget` 等组件。
5. 未在 keys 中声明的字段不会出现在 values 对象中。
6. 不用于替代全局状态，适用于读取系统环境或父组件传递的上下文信息。



---
url: /v2/zh/guide/Changelog/2.4.3/ForEach/index.md
---

`ForEach` 是 Scripting 中用于渲染可变数量子视图的组件，用于构建动态列表、可编辑列表，以及支持系统级的删除与移动行为。其设计参考 SwiftUI 的 `ForEach`，并与 Scripting 的 `Observable` 状态管理系统深度集成。

组件支持两种模式：

1. **旧版模式（已不推荐使用）**：`count + itemBuilder`
2. **推荐的现代模式**：`data: Observable<T[]> + builder`

***

# 1. 类型定义

## ForEachDeprecatedProps（已不推荐）

```ts
type ForEachDeprecatedProps = {
  count: number;
  itemBuilder: (index: number) => VirtualNode;
  onDelete?: (indices: number[]) => void;
  onMove?: (indices: number[], newOffset: number) => void;
};
```

### 参数说明

#### count: number

要渲染的元素数量，`itemBuilder` 将从 0 到 `count - 1` 依次构建每个子视图。

#### itemBuilder(index)

基于索引构建一个 `VirtualNode`。

#### onDelete(indices)

注册删除行为。
当 ForEach 放置在 `List` 中时，如果提供 `onDelete`，将启用系统级的滑动删除交互。
回调触发时，`List` 中对应的行已被移除，你必须在回调中同步删除数据源中的对应项目。

#### onMove(indices, newOffset)

注册移动行为，用于支持编辑状态下的拖动排序。
如希望禁用移动能力，可传入 `null`。

***

# 2. ForEachProps（推荐使用）

```ts
type ForEachProps<T extends { id: string }> =
  | ForEachDeprecatedProps
  | {
      data: Observable<T[]>;
      builder: (item: T, index: number) => VirtualNode;
      editActions?: "delete" | "move" | "all" | null;
    };
```

### 参数说明

#### data: Observable\<T\[]>

一个可观察数组，数组元素必须包含唯一的 `id: string` 字段。

使用 `Observable` 的好处：

- 当数组变动（增删改）时，会自动触发 SwiftUI 刷新
- 可以保留动画
- 更接近 SwiftUI 中 `ForEach($items)` 的使用体验
- 支持与 `List`、`NavigationStack` 等组件无缝联动

#### builder(item, index)

用于基于当前数组的每个元素构建对应的 VirtualNode。

**注意：必须为返回的子节点提供唯一的 key（通常使用 item.id）。**

#### editActions: "delete" | "move" | "all" | null

控制 ForEach 的可编辑能力：

| 值          | 含义            |
| ---------- | ------------- |
| `"delete"` | 仅启用删除         |
| `"move"`   | 仅启用移动（拖动排序）   |
| `"all"`    | 同时启用删除与移动     |
| `null`     | 不提供任何编辑能力（默认） |

当 `ForEach` 位于 `List` 内部时，编辑能力会自动映射到系统提供的交互方式。

***

# 3. ForEachComponent 接口

```ts
interface ForEachComponent {
  <T extends { id: string }>(props: ForEachProps<T>): VirtualNode;
}
```

`ForEach` 是一个泛型组件，接受带有 `id` 的任意数据类型。

***

# 4. 系统级删除交互示例

当 `ForEach` 放在 `List` 内部，并使用 `data + builder` 模式时，系统会自动启用 swipe-to-delete，只需正确提供 `id` 和编辑能力。

### 示例代码

```tsx
function View() {
  const fruits = useObservable(() =>
    ["Apple", "Bananer", "Papaya", "Mango"].map((name, index) => ({
      id: index.toString(),
      name,
    }))
  );

  return (
    <NavigationStack>
      <List
        navigationTitle="Fruits"
        toolbar={{
          topBarTrailing: <EditButton />,
        }}>
        <ForEach data={fruits} builder={(item, index) => <Text key={item.id}>{item.name}</Text>} />
      </List>
    </NavigationStack>
  );
}
```

***

# 5. 使用建议与最佳实践

### 1. 推荐使用 `data: Observable<T[]>` 方案

新版 API 更接近 SwiftUI 行为，拥有更好的性能与类型推断支持，且未来将接入更多 SwiftUI-style 的能力。

### 2. 每个元素必须拥有 `id: string`

这是确保 Diff 和动画正确工作的基础。

### 3. 必须为 builder 返回的节点提供 `key={item.id}`

否则可能导致:

- 动画不生效
- 列表渲染混乱
- 删除或移动行为出错

### 4. 若需要与编辑按钮联动，必须放置于 `List` 中

并设置 toolbar：

```tsx
toolbar={{
  topBarTrailing: <EditButton />
}}
```



---
url: /v2/zh/guide/Changelog/2.4.3/ForEach/iterating.md
---

# 示例

```tsx
import { Button, Font, ForEach, List, Navigation, NavigationStack, Script, Section, Text, useObservable, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  const namedFonts = useObservable(() => {
    return [
      "largeTitle",
      "title",
      "headline",
      "body",
      "caption"
    ].map(e => ({
      id: e,
      name: e as Font
    }))
  })

  return <NavigationStack>
    <List
      navigationTitle={"Iterating"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        header={
          <Text
            textCase={null}
          >ForEach</Text>
        }
      >
        <ForEach
          data={namedFonts}
          builder={(namedFont) => {
            return <Text
              key={namedFont.id}
              font={namedFont.name}
            >{namedFont.name}</Text>
          }}
        />
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >Iterating in code block</Text>
        }
      >
        <VStack>
          {namedFonts.value.map(namedFont =>
            <Text
              font={namedFont.name}
            >{namedFont.name}</Text>
          )}
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Changelog/2.4.3/GeometryReader.md
---

`GeometryReader` 是 Scripting 中与 SwiftUI 等效的几何布局读取组件。
它能够在视图构建阶段提供当前容器的尺寸、边距、安全区域和角落内边距等信息，使开发者可以根据环境动态布局内容。

当你需要根据父容器的大小进行自适应布局（响应式布局）时，`GeometryReader` 是非常重要的工具。

***

# GeometryProxy

当 `GeometryReader` 构建其子内容时，会将一个 `GeometryProxy` 实例传递给 `children` 回调。开发者可以使用此对象访问与当前容器相关的布局信息。

```ts
interface GeometryProxy {
  readonly size: Size;
  readonly safeAreaInsets: {
      leading: number;
      top: number;
      trailing: number;
      bottom: number;
  };
  /**
   * Requires iOS 26.0+.
   */
  readonly containerCornerInsets: {
      bottomLeading: Size;
      bottomTrailing: Size;
      topLeading: Size;
      topTrailing: Size;
  } | null;
}
```

***

# GeometryProxy 属性说明

## 1. size

```ts
readonly size: Size
```

当前容器在布局时的实际尺寸。

### Size 结构

```ts
type Size = {
  width: number
  height: number
}
```

### 示例

```tsx
proxy.size.width
proxy.size.height
```

用于动态计算子视图布局，例如宽高比、自适应排版等。

***

## 2. safeAreaInsets

```ts
readonly safeAreaInsets: {
  leading: number
  top: number
  trailing: number
  bottom: number
}
```

当前视图所处环境中的安全区域内边距，包括顶部、底部、左右侧的避让区域。
通常用于避免内容被刘海、Home Indicator 等遮挡。

### 示例用途：

- 内容距离屏幕底部安全区域以上对齐
- 自定义导航栏、工具栏时避免被遮挡
- 实现与设备 UI 边界一致的响应式布局

***

## 3. containerCornerInsets（iOS 26.0+）

```ts
readonly containerCornerInsets: {
  bottomLeading: Size
  bottomTrailing: Size
  topLeading: Size
  topTrailing: Size
} | null
```

该属性仅在 **iOS 26+** 提供，并在设备或容器具有物理圆角偏移时报告每个角落的内边距。

### 用途

- 为圆角窗口、Stage Manager 或分屏环境适配布局
- 在容器圆角内做精确的 UI 对齐

如果平台不支持，则为 `null`。

***

# GeometryReader

```ts
type GeometryReaderProps = {
  children: (proxy: GeometryProxy) => VirtualNode;
};
declare const GeometryReader: FunctionComponent<GeometryReaderProps>;
```

## Props 说明

| 属性名      | 类型                                      | 必须 | 说明                                     |
| -------- | --------------------------------------- | -- | -------------------------------------- |
| children | `(proxy: GeometryProxy) => VirtualNode` | 是  | 构建内容的回调函数，传入 `GeometryProxy` 用于读取布局信息。 |

***

# 工作机制

1. GeometryReader 占据父布局中的位置，并在布局阶段获取当前容器的尺寸与安全区域信息。
2. 将 `GeometryProxy` 注入给 `children(proxy)` 回调。
3. 回调返回的内容将根据读取的信息动态布局。

与 SwiftUI 一样，`GeometryReader` 默认会扩展到可用空间。

***

# 示例：居中布局

```tsx
import { GeometryReader, Text, VStack } from "scripting"

function View() {
  return <GeometryReader>
    {(proxy) => {
      return <VStack
        frame={{
          width: proxy.size.width,
          height: proxy.size.height,
          alignment: "center"
        }}
      >
        <Text>Hello Geometry</Text>
        <Text>
          width: {proxy.size.width}
        </Text>
        <Text>
          height: {proxy.size.height}
        </Text>
      </VStack>
    }}
  </GeometryReader>
}
```

***

# 示例：根据安全区域调整布局

```tsx
<GeometryReader>
  {(proxy) => {
    return <VStack
      padding={{
        top: proxy.safeAreaInsets.top,
        bottom: proxy.safeAreaInsets.bottom
      }}
    >
      <Text>Content inside safe area.</Text>
    </VStack>
  }}
</GeometryReader>
```

***

# 示例（iOS 26+）：读取 containerCornerInsets

```tsx
<GeometryReader>
  {(proxy) => {
    const corners = proxy.containerCornerInsets
    return <Text>
      {corners == null
        ? "Corner insets not available"
        : `Top Leading Corner: ${corners.topLeading.width}, ${corners.topLeading.height}`
      }
    </Text>
  }}
</GeometryReader>
```

***

# 使用建议

- 在需要响应容器尺寸时使用 GeometryReader，例如图片缩放、动态布局、等比布局。
- 避免将大量复杂布局放入 GeometryReader 内，可能影响性能（同 SwiftUI）。



---
url: /v2/zh/guide/Changelog/2.4.3/LiveActivity View Modifiers.md
---

Scripting 支持与 SwiftUI 等效的 Live Activity 外观控制修饰符。这些修饰符专门用于 **锁屏（Lock Screen）中的 Live Activity 界面**，用于自定义背景色和系统动作按钮颜色。

通过为 Activity UI 中的 `content` 视图设置这些修饰符，可使 Live Activity 更符合品牌风格或特定活动主题。

***

# 修饰符定义

```ts
/**
 * 用于设置 Live Activity 在锁屏界面显示时的背景着色。
 */
activityBackgroundTint?: Color | {
  light: Color
  dark: Color
}

/**
 * 用于设置 Live Activity 在锁屏界面显示时，系统提供的辅助操作按钮的文本（前景）颜色。
 */
activitySystemActionForegroundColor?: Color | {
  light: Color
  dark: Color
}
```

***

# 属性说明

## 1. activityBackgroundTint

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置 Live Activity 在锁屏界面显示时的背景 Tint。
这个颜色会影响系统渲染 Live Activity 主卡片的底色。

### 使用示例

- 使用品牌主色作为 Activity 背景
- 为不同活动提供独立主题色
- 让内容在亮色或深色背景下更易阅读

***

## 2. activitySystemActionForegroundColor

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置系统在锁屏的 Live Activity 卡片旁显示的“辅助操作按钮”的文本前景色。
这些操作按钮可能包括暂停、继续、停止等。

### 使用示例

- 在深色背景上显示浅色按钮文本
- 将关键操作按钮突出显示
- 使用和 UI 一致的主题色

***

# 示例：在 Live Activity UI Builder 中使用

Live Activity 的 UI builder 必须返回包含多个区域（content / compactLeading / compactTrailing / minimal等）的对象结构。

以下示例展示了如何在 **content** 区域中使用这两个修饰符：

```tsx
function ActivityView() {
  <LiveActivityUI
    content={
      <ContentView
        activityBackgroundTint={"blue"}
        activitySystemActionForegroundColor={"white"}
      />
    }
    compactLeading={...}
    compactTrailing={...}
    minimal={<Image systemName="clock" />}
  >
    <LiveActivityUIExpandedCenter>
      <ContentView />
    </LiveActivityUIExpandedCenter>
  </LiveActivityUI>
}
```

***

# 使用说明

- **修饰符仅在 Live Activity UI 中有效**，并且只影响 **锁屏界面** 的外观。
- 必须在 Live Activity UI builder 的 `content` 中使用。
- 如果不设置颜色，系统会使用默认样式。



---
url: /v2/zh/guide/Changelog/2.4.3/LiveActivity.md
---

`LiveActivity` API 允许你的脚本在 iOS 的锁屏界面以及支持的设备上的动态岛中展示实时数据。通过该 API，你可以创建、更新并结束 Live Activity，同时监听其生命周期状态和系统支持情况。

本文件详细介绍 Scripting app 中的 **LiveActivity API**，包括：

- Live Activity 的生命周期与核心概念
- 如何注册 Live Activity UI
- 如何在脚本中启动、更新、结束 Live Activity
- 如何构建 Live Activity UI（包括 Dynamic Island 多种布局）
- 所有类型参数说明
- 完整示例代码与最佳实践

本 API 基于 Apple ActivityKit 能力，并以 TypeScript/TSX 的方式封装，允许开发者使用 React 风格构建 Lock Screen 与 Dynamic Island 界面。

***

# 1. Live Activity 概念理解

Live Activity 展示在以下区域：

- **锁屏界面**
- **iPhone 14 Pro+ 的 Dynamic Island**
- **其他设备的悬浮样式（Banner）**

它能随着应用或脚本运行实时更新内容，如：

- 计时器
- 外卖进度
- 健身、运动状态
- 倒计时、打卡、提醒

**在 Scripting app 中，一个 Live Activity 由两部分组成：**

1. **内容状态（contentState）**
   一个 JSON 可序列化的对象，会随时间改变。
2. **UI Builder**
   通过 TSX 描述不同区域的展示方式。

***

# 2. Live Activity 状态类型

```ts
type LiveActivityState = "active" | "dismissed" | "ended" | "stale";
```

| 状态        | 描述                              |
| --------- | ------------------------------- |
| active    | 正在显示，可以更新内容                     |
| stale     | 已过期，需要更新 staleDate 后才能恢复 active |
| ended     | 活动已结束但仍在锁屏显示（最长 4 小时或自定时间）      |
| dismissed | 已被系统或用户移除，不再可见                  |

***

# 3. LiveActivityDetail 类型

```ts
type LiveActivityDetail = {
  id: string;
  state: LiveActivityState;
};
```

用于描述当前正在运行的所有 Live Activity 信息。

***

# 4. LiveActivity UI 构建类型

## 4.1 LiveActivityUIProps

```ts
type LiveActivityUIProps = {
  content: VirtualNode;
  compactLeading: VirtualNode;
  compactTrailing: VirtualNode;
  minimal: VirtualNode;
  children: VirtualNode | VirtualNode[];
};
```

这些字段对应 Dynamic Island：

- **content**：锁屏和普通设备顶部 Banner 显示
- **compactLeading / compactTrailing**：Dynamic Island 收缩状态左右区域
- **minimal**：最小化的单点显示
- **children**：展开后的多个区域（使用 `LiveActivityUIExpanded*` 包裹）

***

# 5. 注册 Live Activity UI

Live Activity 必须放在单独的文件中，例如 `live_activity.tsx`：

```tsx
import { LiveActivity, LiveActivityUI, LiveActivityUIBuilder } from "scripting";

export type State = {
  mins: number;
};

function ContentView(state: State) {
  return (
    <HStack activityBackgroundTint={{ light: "clear", dark: "clear" }}>
      <Image systemName="waterbottle" foregroundStyle="systemBlue" />
      <Text>{state.mins}分钟后补水</Text>
    </HStack>
  );
}

const builder: LiveActivityUIBuilder<State> = (state) => {
  return (
    <LiveActivityUI
      content={<ContentView {...state} />}
      compactLeading={
        <HStack>
          <Image systemName="clock" />
          <Text>{state.mins}m</Text>
        </HStack>
      }
      compactTrailing={<Image systemName="waterbottle" foregroundStyle="systemBlue" />}
      minimal={<Image systemName="clock" />}>
      <LiveActivityUIExpandedCenter>
        <ContentView {...state} />
      </LiveActivityUIExpandedCenter>
    </LiveActivityUI>
  );
};

export const MyLiveActivity = LiveActivity.register("MyLiveActivity", builder);
```

***

# 6. 在脚本中使用 Live Activity

下面展示如何启动、更新、监听状态并结束 Live Activity。

```tsx
import {
  Button,
  Text,
  VStack,
  Navigation,
  NavigationStack,
  useMemo,
  useState,
  LiveActivityState,
  BackgroundKeeper,
} from "scripting";
import { MyLiveActivity } from "./live_activity";

function Example() {
  const dismiss = Navigation.useDismiss();
  const [state, setState] = useState<LiveActivityState>();

  const activity = useMemo(() => {
    const instance = MyLiveActivity();

    instance.addUpdateListener((s) => {
      setState(s);
      if (s === "dismissed") {
        BackgroundKeeper.stop();
      }
    });

    return instance;
  }, []);

  return (
    <NavigationStack>
      <VStack
        navigationTitle="LiveActivity 示例"
        navigationBarTitleDisplayMode="inline"
        toolbar={{
          cancellationAction: <Button title="完成" action={dismiss} />,
        }}>
        <Text>当前状态：{state ?? "-"}</Text>

        <Button
          title="启动 Live Activity"
          disabled={state != null}
          action={() => {
            let count = 5;
            BackgroundKeeper.keepAlive();

            activity.start({ mins: count });

            function tick() {
              setTimeout(() => {
                count -= 1;

                if (count === 0) {
                  activity.end({ mins: 0 });
                  BackgroundKeeper.stop();
                } else {
                  activity.update({ mins: count });
                  tick();
                }
              }, 60000);
            }
            tick();
          }}
        />
      </VStack>
    </NavigationStack>
  );
}

async function run() {
  await Navigation.present(<Example />);
  Script.exit();
}

run();
```

***

# 7. LiveActivity 类 API 说明

## 7.1 start(contentState, options?)

```ts
start(contentState: T, options?: LiveActivityOptions): Promise<boolean>
```

- 请求系统启动 Live Activity
- contentState 必须可以 JSON 序列化

### LiveActivityOptions

```ts
type LiveActivityOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
};
```

- staleDate：到期变为 stale 的时间戳（ms） 或 Date 对象
- relevanceScore：控制 Dynamic Island 的优先级

***

## 7.2 update(contentState, options?)

```ts
update(contentState: T, options?: LiveActivityUpdateOptions)
```

### LiveActivityUpdateOptions

```ts
type LiveActivityUpdateOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  alert?: {
    title: string;
    body: string;
  };
};
```

可带 Apple Watch 的更新提示。

***

## 7.3 end(contentState, options?)

```ts
end(contentState: T, options?: LiveActivityEndOptions)
```

### LiveActivityEndOptions

```ts
type LiveActivityEndOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  dismissTimeInterval?: number;
};
```

dismissTimeInterval（单位秒）:

- 未提供：系统默认最长保留 4 小时
- \<= 0：立即移除
- \> 0：指定多久后移除

***

## 7.4 获取活动状态

```ts
getActivityState(): Promise<LiveActivityState | null>
```

***

## 7.5 监听状态更新

```ts
addUpdateListener(listener);
removeUpdateListener(listener);
```

当 Live Activity 状态变更时回调，例如：

- active → stale
- active → ended
- ended → dismissed

***

## 7.6 静态方法

```ts
static areActivitiesEnabled(): Promise<boolean>
static getAllActivities(): Promise<LiveActivityDetail[]>
static getAllActivitiesIds(): Promise<string[]>
static getActivityState(activityId: string)
static from(activityId, name)
static endAllActivities(options?)
```

***

# 8. Live Activity UI 组件

| 组件                             | 描述         |
| ------------------------------ | ---------- |
| LiveActivityUI                 | 注册 UI 的根结构 |
| LiveActivityUIExpandedCenter   | 展开状态的中间区域  |
| LiveActivityUIExpandedLeading  | 左侧区域       |
| LiveActivityUIExpandedTrailing | 右侧区域       |
| LiveActivityUIExpandedBottom   | 底部区域       |

用于构建 Dynamic Island 展开布局。

***

# 9. 注意事项与最佳实践

## 9.1 必须 JSON 可序列化

contentState 中不能包含：

- 函数
- Date 对象（需转 timestamp）
- class 实例
- 非可序列化对象

## 9.2 Live Activity 必须放在独立文件

例如：

```
live_activity.tsx
```

这与系统对 UI 构建的要求有关。

## 9.3 Scripting 的 Live Activity 与脚本生命周期隔离

即使脚本结束，Live Activity 会继续保持。

若你希望脚本保持运行，可使用：

```ts
BackgroundKeeper.keepAlive();
```

***

# 10. 完整示例（简化版）

```tsx
const activity = MyLiveActivity();

await activity.start({ mins: 10 });

await activity.update({ mins: 5 });

await activity.end({ mins: 0 }, { dismissTimeInterval: 0 });
```

# 11. 注意事项

- Live Activity 的启动是异步的，需要等到 `start` 返回 `true` 时才能调用 `update` 和 `end`
- Live Activity 不能访问 Documents 和 iCloud 目录，只能访问 app group 目录，如果你想要访问文件或者渲染图片，必须把文件或图片保存到 `FileManager.appGroupDocumentsDirectory` 目录中。 比如渲染图片，你保存到 `FileManager.appGroupDocumentsDirectory` 中， 再通过 `<Image filePath={Path.join(FileManager.appGroupDocumentsDirectory, 'example.png')} />` 渲染
- Live Activity 可以访问与 App 共享的 Storage 数据



---
url: /v2/zh/guide/Changelog/2.4.3/ReorderableForEach/index.md
---

# 可拖拽的 ForEach (ReorderableForEach)

`ReorderableForEach` 是 Scripting 提供的一个支持 **拖拽排序（Drag to Reorder）** 的高级渲染组件。
它在保持 `ForEach` 使用方式的同时，内置了拖拽手势识别、激活态管理、排序回调等能力，使开发者可以非常低成本地实现 **可拖拽排序的列表或网格布局**。

该组件特别适用于以下场景：

- 拖拽调整排序的卡片布局
- 拖拽调整顺序的网格（`LazyVGrid` / `LazyHGrid`）
- 脚本驱动的可交互功能模块编排界面

***

## 一、组件定义

```ts
type ReorderableForEachProps<T extends {
  id: string
}> = {
  active: Observable<T | null>
  data: T[]
  builder: (item: T, index: number) => VirtualNode
  onMove: (indices: number[], newOffset: number) => void
}

interface ReorderableForEachComponent {
  <T extends {
    id: string
  }>(props: ReorderableForEachProps<T>): VirtualNode
}

declare const ReorderableForEach: ReorderableForEachComponent
```

***

## 二、泛型约束说明

### 必须包含 `id` 字段

`ReorderableForEach` 的泛型参数 `T` 必须满足：

```ts
T extends { id: string }
```

也就是说，每一项数据必须具备：

- 唯一的 `id` 值
- 稳定不变的标识

该 `id` 用于：

- 识别当前被拖拽的元素
- 维持拖拽过程中的元素一致性
- 正确计算排序变更位置

如果 `id` 不唯一或在拖拽过程中发生变化，将导致排序错乱。

***

## 三、Props 参数说明

### 1. `active`

```ts
active: Observable<T | null>
```

用于表示 **当前正在被拖拽的元素状态**。

行为说明：

- 拖拽开始时，当前项会被写入 `active.value`
- 拖拽结束时，`active.value` 会恢复为 `null`
- 你可以利用它实现：

  - 拖拽元素高亮
  - 透明度变化
  - 联动动画
  - 状态辅助 UI

***

### 2. `data`

```ts
data: T[]
```

当前参与排序的数据数组。

重要说明：

- `ReorderableForEach` **不会自动修改该数组**
- 拖拽完成后，必须在 `onMove` 中手动更新该数组顺序
- 推荐与 `useObservable` 配合使用：

```ts
const data = useObservable<T[]>(...)
```

***

### 3. `builder`

```ts
builder: (item: T, index: number) => VirtualNode
```

用于渲染每一项的 UI 视图。

参数说明：

| 参数      | 含义                 |
| ------- | ------------------ |
| `item`  | 当前数据项              |
| `index` | 当前项在 `data` 中的实时索引 |

返回值必须是一个合法的 `VirtualNode`。

注意：

- 这里的 `index` 是拖拽后的实时索引
- 不应在此依赖旧索引逻辑做安全判断

***

### 4. `onMove`

```ts
onMove: (indices: number[], newOffset: number) => void
```

当用户完成一次拖拽排序后触发。

参数含义：

| 参数          | 类型         | 说明              |
| ----------- | ---------- | --------------- |
| `indices`   | `number[]` | 被拖动元素在原数组中的索引集合 |
| `newOffset` | `number`   | 新插入的起始位置        |

你必须在此方法中：

1. 根据 `indices` 取出被移动的元素
2. 从原数据中移除它们
3. 按 `newOffset` 重新插入
4. 使用 `Observable.setValue` 提交新顺序

标准实现如下：

```ts
const onMove = (indices: number[], newOffset: number) => {
  const movingItems = indices.map(index => data.value[index])
  const newValue = data.value.filter((_, index) => !indices.includes(index))
  newValue.splice(newOffset, 0, ...movingItems)
  data.setValue(newValue)
}
```

***

## 四、`contentShape` 的真实作用说明

在你的示例代码中：

```tsx
.contentShape({
  kind: 'dragPreview',
  shape: {
    type: 'rect',
    cornerRadius: 16
  }
})
```

该配置的核心作用是：

> **设置拖拽时的预览形状，使拖拽时显示的形状与非拖拽状态下保持一致（RoundedRectangle）。**

它并不是简单地“开启拖拽”，而是用于：

- 定义拖拽时的命中区域
- 同步拖拽预览的视觉形状
- 避免：

  - 拖拽时出现矩形裁切
  - 与原有圆角样式不一致的问题

如果不配置 `dragPreview` 形状，拖拽时可能会退化为默认矩形预览，破坏一致性。

***

## 五、完整使用流程说明

### 1. 数据模型定义

```ts
type Item = {
  id: string
  color: Color
}
```

***

### 2. 初始化可排序数据源

```ts
const data = useObservable<Item[]>(() => {
  return new Array(30)
    .fill(0)
    .map((_, index) => ({
      id: String(index),
      color: colors[index % colors.length]
    }))
})
```

***

### 3. 声明拖拽激活态

```ts
const active = useObservable<Item | null>(null)
```

***

### 4. 单项拖拽视图（保持拖拽前后外观一致）

```tsx
<VStack
  modifiers={
    modifiers()
      .frame({ height: 80 })
      .frame({ maxWidth: 'infinity' })
      .background(
        <RoundedRectangle
          cornerRadius={16}
          fill={item.color}
        />
      )
      .contentShape({
        kind: 'dragPreview',
        shape: {
          type: 'rect',
          cornerRadius: 16
        }
      })
  }
>
```

***

### 5. 在 `LazyVGrid` 中使用 ReorderableForEach

```tsx
<ReorderableForEach
  active={active}
  data={data.value}
  builder={(item) =>
    <ItemView item={item} />
  }
  onMove={onMove}
/>
```

***

## 六、关于在 `List` 中使用的限制说明

虽然从技术上讲，`ReorderableForEach` 可以放入 `List` 内部使用，但 **整体上并不推荐在 `List` 中使用该组件**，原因如下：

1. `List` 自带：

   - 行分隔线
   - 行高计算
   - 选中态
   - 系统滑动手势
   - 系统编辑模式

2. 这些系统行为会与：

   - 自定义拖拽动画
   - 自定义排序逻辑
   - 拖拽命中区域计算

   产生不可控的冲突。

3. 可能带来的问题包括：

- 拖拽过程中跳动
- 命中区域错位
- 拖拽排序时系统进入编辑态
- 行复用与拖拽状态不同步

因此推荐的使用容器是：

- `ScrollView`
- `LazyVGrid`
- `LazyHGrid`
- 纯自定义布局容器

而不是 `List`。

***

## 七、组件工作机制总结

`ReorderableForEach` 的行为逻辑可以总结为：

1. 依据 `data` 构建可拖拽子节点
2. 依据 `dragPreview contentShape` 确定拖拽命中区域与预览形状
3. 拖拽过程中：

   - 自动维护 `active`
   - 实时计算目标插入位置
4. 拖拽结束后：

   - 通过 `onMove` 将排序结果交给开发者处理
   - 由开发者负责最终数据顺序更新

***

## 八、适用场景

- 功能模块拖拽排序
- 工具栏按钮排序
- 卡片式任务优先级调整
- 桌面组件布局排序
- 视觉网格自由排序



---
url: /v2/zh/guide/Changelog/2.4.3/ReorderableForEach/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, ScrollView, useObservable, LazyVGrid, ReorderableForEach, RoundedRectangle, VStack, Toolbar, ToolbarItem, modifiers, Color } from "scripting"

type Item = {
  id: string
  color: Color
}

const colors: Color[] = [
  'systemRed',
  'systemBlue',
  'systemGreen',
  'systemPink',
  'systemOrange',
  'systemPurple',
]

function ItemView({
  item
}: {
  item: Item
}) {

  return <VStack
    modifiers={
      modifiers()
        .frame({
          height: 80
        })
        .frame({
          maxWidth: 'infinity'
        })
        .background(
          <RoundedRectangle
            cornerRadius={16}
            fill={item.color}
          />
        )
        .contentShape({
          kind: 'dragPreview',
          shape: {
            type: 'rect',
            cornerRadius: 16
          }
        })
    }
  >
    <Text
      foregroundStyle="white"
      font="title"
    >{item.id}</Text>
  </VStack>
}

function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  const data = useObservable<Item[]>(() => {
    return new Array(30)
      .fill(0)
      .map((_, index) => ({
        id: String(index),
        color: colors[index % colors.length]
      }))
  })

  const active = useObservable<Item | null>(null)

  const onMove = (indices: number[], newOffset: number) => {
    const movingItems = indices.map(index => data.value[index])
    const newValue = data.value.filter((_, index) => !indices.includes(index))
    newValue.splice(newOffset, 0, ...movingItems)
    data.setValue(newValue)
  }

  return <NavigationStack>
    <ScrollView
      navigationTitle="ReorderableForEach demo"
      toolbar={
        <Toolbar>
          <ToolbarItem
            placement="topBarLeading"
          >
            <Button
              title="Close"
              action={dismiss}
            />
          </ToolbarItem>
        </Toolbar>
      }
    >
      <LazyVGrid
        columns={[
          {
            size: {
              type: 'flexible'
            }
          },
          {
            size: {
              type: 'flexible'
            }
          }
        ]}
        padding={{
          horizontal: true
        }}
      >
        <ReorderableForEach
          active={active}
          data={data.value}
          builder={(item) =>
            <ItemView
              item={item}
            />
          }
          onMove={onMove}
        />
      </LazyVGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  // Present view.
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.3/SSH Client.md
---

# SSH 客户端

`SSHClient` 类用于连接远程 SSH 服务器，支持执行命令、打开 TTY/PTY 会话、使用 SFTP 进行文件传输，以及通过跳板主机进行多级 SSH 跳转。该类是建立和管理 SSH 会话的核心接口。

***

## 静态方法

### `SSHClient.connect(options): Promise<SSHClient>`

建立与远程 SSH 服务器的连接。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    服务器的主机名或 IP 地址。

  - `port?`（数字）：
    连接端口，默认是 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    SSH 身份验证方式，例如密码或私钥。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任服务器公钥列表。如果提供，客户端将验证服务器公钥。

  - `reconnect?`（`"never" | "once" | "always"`）：
    可选的重连策略，默认是 `"never"`。

#### 返回值：

- 成功连接时返回 `Promise<SSHClient>` 实例。

#### 示例：

```ts
const ssh = await SSHClient.connect({
  host: "192.168.0.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("root", "password")
})
```

***

## 属性

### `onDisconnect: (() => void) | null`

SSH 连接断开时触发的回调函数。

#### 示例：

```ts
ssh.onDisconnect = () => {
  console.log("SSH 已断开")
}
```

***

## 实例方法

### `executeCommand(command: string, options?): Promise<string>`

在远程服务器上执行命令，并返回结果字符串。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `options?`（对象）：

  - `maxResponseSize?`（数字）：
    最大响应字节数。

  - `includeStderr?`（布尔）：
    是否包含标准错误输出，默认为 `false`。

  - `inShell?`（布尔）：
    是否在 shell 中执行命令（如 `sh -c`），默认是 `false`。

#### 返回值：

- 返回一个 `Promise<string>`，为命令的输出。

#### 示例：

```ts
const result = await ssh.executeCommand("uname -a")
```

***

### `executeCommandStream(command, onOutput, options?): Promise<void>`

以流的形式逐行执行命令并获取输出。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `onOutput`（函数）：
  每一行输出都会调用该回调函数 `(data: Data, isStderr: boolean) => boolean`。返回 `false` 可提前终止输出接收。

- `options?`（对象）：

  - `inShell?`（布尔）：
    是否在 shell 中执行。

#### 返回值：

- 返回一个 `Promise`，命令执行完毕后 resolve。

#### 示例：

```ts
const output = Data.fromIntArray([])
await ssh.executeCommandStream("ping -c 4 google.com", (data, isStderr) => {
  output.append(data)
  return true
})
console.log(output.toDecodedString()())
```

***

### `withPTY(options): Promise<TTYStdinWriter>`

打开一个 PTY（伪终端）会话，支持交互式终端程序（如 `top`、`vim`）。

#### 参数：

- `options`（对象）：

  - `wantReply?`（布尔）：
    是否等待服务器回应，默认 `true`。

  - `term?`（字符串）：
    终端类型，默认是 `"xterm"`。

  - `terminalCharacterWidth?`（数字）：
    字符宽度，默认 `80`。

  - `terminalRowHeight?`（数字）：
    字符行数，默认 `24`。

  - `terminalPixelWidth?`（数字）：
    像素宽度，默认 `0`。

  - `terminalPixelHeight?`（数字）：
    像素高度，默认 `0`。

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>`，可用于写入输入和调整终端大小。

#### 示例：

```ts
let output: Data | undefined
let timerId: number | undefined
const writer = await ssh.withPTY({
  onOutput: (data, isStderr) => {
    if (output == null) {
      output = data
    } else {
      output.append(data)
    }
    clearTimeout(timerId)
    timerId = setTimeout(() => {
      console.log(output.toDecodedString()())
      output = undefined
    }, 500)
    return true
  }
})
await writer.write("top\n")
```

***

### `withTTY(options): Promise<TTYStdinWriter>`

打开一个简化的 TTY 会话（不包含终端尺寸设置）。

#### 参数：

- `options`（对象）：

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>` 实例。

***

### `openSFTP(): Promise<SFTPClient>`

打开一个 SFTP 会话，用于远程文件读写、目录管理等操作。

#### 返回值：

- 一个 `Promise<SFTPClient>` 实例。

#### 示例：

```ts
const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/test.txt", "Hello world")
```

***

### `jump(options): Promise<SSHClient>`

从当前连接跳转（跳板）至另一个远程 SSH 主机。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    目标主机地址。

  - `port?`（数字）：
    端口，默认为 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    跳转主机的身份验证方式。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任主机公钥。

#### 返回值：

- 一个新的 `SSHClient` 实例，表示跳转后的连接。

#### 示例：

```ts
const nextHop = await ssh.jump({
  host: "10.0.0.2",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user2", "pass2")
})
```

***

### `close(): Promise<void>`

关闭 SSH 连接并释放资源。

> **注意：** 当不再需要 SSH 连接时应显式调用该方法，以防资源或 socket 泄漏。

#### 返回值：

- 一个 `Promise`，成功关闭连接时 resolve。

#### 示例：

```ts
await ssh.close()
```

***

## 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "password")
})

const output = await ssh.executeCommand("uptime")
console.log("系统运行时间：", output)

const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/hello.txt", "Hello SSH")

await ssh.close()
```



---
url: /v2/zh/guide/Changelog/2.4.3/ScrollViewReader.md
---

**ScrollViewReader** 组件，用于在脚本中获得对可滚动内容的编程化控制能力，使开发者能够在运行时滚动至任意视图位置，包括列表项、文本节点等。

ScrollViewReader 与 SwiftUI 的行为保持一致：
开发者通过一个回调函数获得一个 `ScrollViewProxy` 实例，并可以在任意时机调用 `scrollTo(id)` 控制滚动视图的位置。

***

# ScrollViewProxy

`ScrollViewProxy` 是提供滚动控制的代理对象，由 `ScrollViewReader` 在渲染期间自动注入。

```ts
interface ScrollViewProxy {
    scrollTo: (id: string | number, anchor?: KeywordPoint | Point) => void;
}
```

## 方法

### scrollTo(id, anchor?)

滚动到某个具有指定 `id` 的元素。
该 `id` 必须在可滚动内容内存在，并通过 `key` 配置。

#### 参数说明

| 参数     | 类型             | 必须       | 说明 |                                         |
| ------ | -------------- | -------- | -- | --------------------------------------- |
| id     | `string`       | `number` | 是  | 要滚动到的目标元素的唯一标识符。通常对应 `<View key="xxx">` |
| anchor | `KeywordPoint` | `Point`  | 否  | 滚动目标在可视区域中的对齐方式。可为字符串关键字或坐标点。           |

### KeywordPoint 类型

属于字符串关键字，常用：

- `'top'`
- `'center'`
- `'bottom'`

### Point 类型

用于精确控制滚动位置：

```ts
type Point = {
  x: number
  y: number
}
```

***

# ScrollViewReader

ScrollViewReader 用于包裹可滚动内容，并提供一个 `scrollViewProxy` 以控制内部滚动。

```ts
type ScrollViewReaderProps = {
    children: (scrollViewProxy: ScrollViewProxy) => VirtualNode
};
declare const ScrollViewReader: FunctionComponent<ScrollViewReaderProps>
```

## Props 说明

| 名称       | 类型                                        | 必须 | 说明                                          |
| -------- | ----------------------------------------- | -- | ------------------------------------------- |
| children | `(proxy: ScrollViewProxy) => VirtualNode` | 是  | 回调函数，将滚动代理传给开发者，并返回 ScrollView、List 等可滚动视图。 |

***

# 使用说明

1. **ScrollViewReader 必须包裹 List、ScrollView 等可滚动组件**。
2. **回调中的 proxy 只在视图构建阶段提供一次**，开发者可利用 `useRef` 保存。
3. 支持在动画中使用，例如 `withAnimation`。
4. 锚点可选，不传则使用默认对齐方式。
5. 所有 ScrollView 内部节点都可以使用 `key` 来作为 `scrollTo` 的目标。

***

# 基础示例

下面是一个完整的使用示例，包括滚动到指定元素以及使用动画的方式。

```tsx
import {
  Button,
  Navigation,
  NavigationStack,
  Script,
  Text,
  List,
  ScrollViewReader,
  ScrollView,
  VStack,
  useRef,
  ScrollViewProxy,
  withAnimation
} from "scripting"

function Item({ index }: { index: number }) {
  return <Text>
    Item - {index}
  </Text>
}

function View() {
  const dismiss = Navigation.useDismiss()
  const proxyRef = useRef<ScrollViewProxy>()

  return <NavigationStack>
    <VStack navigationTitle="ScrollViewReader">

      <ScrollViewReader>
        {(proxy) => {
          // 记录 proxy 实例，供按钮点击时使用
          proxyRef.current = proxy

          return <List>
            {new Array(100).fill(0).map((_, index) =>
              <Item
                key={index}
                index={index}
              />
            )}
            <Text key="bottom">
              Bottom
            </Text>
          </List>
        }}
      </ScrollViewReader>

      <Button
        title="跳转"
        action={() => {
          if (proxyRef.current == null) {
            console.log("no proxy found")
            return
          }

          const index = Math.random() * 100 | 0

          withAnimation(() => {
            proxyRef.current?.scrollTo(index, "bottom")
            // proxyRef.current?.scrollTo("bottom", "bottom")
          })
        }}
      />

    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```

***

# 关于 ID（key）匹配的说明

`scrollTo(id)` 依赖于内部节点的 `key` 属性。
以下配置都可作为滚动目标：

```tsx
<Text key="bottom">Bottom</Text>
```

`key` 与 SwiftUI 的 `.id()` 行为保持一致。

***

# 动画支持

ScrollViewReader 支持结合 `withAnimation` 来进行平滑滚动。例如：

```tsx
withAnimation(() => {
  proxy.scrollTo("target", "center")
})
```

在动画块中触发滚动，将获得平滑过渡。

***

# 注意事项

1. **必须在 ScrollViewReader 回调中记录 proxy**，否则外部无法访问。
2. **必须确保目标元素存在并有唯一 id**，否则无法滚到目标位置。
3. **不支持在 ScrollViewReader 外部渲染可滚动组件**。
4. **滚动行为与 SwiftUI 基本一致**，包括 anchor 对齐方式。



---
url: /v2/zh/guide/Changelog/2.4.3/Set environment values (environments).md
---

`environments` 是 Scripting 新增的视图修饰符，用于向当前视图树（View Hierarchy）注入特定的 environment values。
它的作用与 SwiftUI 的 `.environment()` 类似，但基于 Scripting 的设计进行了显式声明和类型收敛，避免隐式行为。

目前 `environments` 支持以下 environment 值：

- `editMode`: 控制视图的编辑模式（如 List 的编辑状态）
- `openURL`: 自定义打开链接（URL）的处理方式

这些 environment 值会影响其子视图中的行为与交互能力。

***

# 修饰符定义

```ts
environments?: {
  editMode?: Observable<EditMode>;
  openURL?: (url: string) => OpenURLActionResult;
};
```

***

# 一、editMode（编辑模式）

`editMode` 用于设置当前视图树中所有支持编辑模式的组件的编辑状态。

典型用途：

- 控制 `List` 的编辑状态
- 启用批量删除、移动操作
- 与用户交互同步（如切换编辑按钮）

## 类型定义

```ts
class EditMode {
  readonly value: "active" | "inactive" | "transient" | "unknown"
  readonly isEditing: boolean

  static active(): EditMode
  static inactive(): EditMode
  static transient(): EditMode
}
```

### `value` 含义

| 值           | 描述           |
| ----------- | ------------ |
| `active`    | 编辑模式已开启      |
| `inactive`  | 编辑模式已关闭      |
| `transient` | 临时状态（如交互中切换） |
| `unknown`   | 非预期状态，通常不需使用 |

### 与 `Observable` 配合使用

由于 editMode 是动态值，必须使用 `Observable<EditMode>` 传递，以便视图随编辑状态变化而刷新。

***

## editMode 使用示例

```tsx
const editMode = useObservable(() => EditMode.active())

<List
  environments={{
    editMode: editMode
  }}
>
  <ForEach
    editActions="all"
    data={items}
    builder={item => <Text key={item.id}>{item}</Text>}
  />
</List>
```

说明：

- 将 `editMode` 设置到 List 的 environment 中
- List 中的 `ForEach` 会根据该状态启用、禁用删除/移动等编辑能力
- 修改 `editMode.value` 将自动刷新界面

***

# 二、openURL（自定义 URL 打开行为）

`openURL` environment 允许为当前视图树定义一套自定义的 URL 打开逻辑。
这会覆盖如 `<Link>`、`Text(url:)` 等组件的默认行为。

用途示例：

- 控制 URL 在 App 内打开还是系统浏览器打开
- 根据 URL 类型执行不同逻辑
- 拦截 URL 点击并进行验证或跳转处理

## 类型定义

```ts
openURL?: (url: string) => OpenURLActionResult;
```

***

# OpenURLActionResult

自定义 URL 打开逻辑的返回类型。

```ts
class OpenURLActionResult {
  type: string

  static handled(): OpenURLActionResult
  static discarded(): OpenURLActionResult

  static systemAction(options?: {
    url?: string
    prefersInApp: boolean // Requires iOS26.0+
  }): OpenURLActionResult
}
```

## 作用说明

| 返回值                     | 含义                         |
| ----------------------- | -------------------------- |
| `handled()`             | URL 已处理，不执行默认行为            |
| `discarded()`           | 忽略该 URL                    |
| `systemAction(options)` | 要求系统打开给定 URL（支持 App 内或外打开） |

***

## openURL 使用示例

```tsx
<Group
  environments={{
    openURL: (url) => {
      return OpenURLActionResult.systemAction({
        url,
        prefersInApp: false
      })
    }
  }}
>
  {urls.map(url =>
    <Link url={url}>{url}</Link>
  )}
</Group>
```

说明：

- 所有 `<Link>` 均会交给自定义的 `openURL` 方法处理
- 示例将所有 URL 交由系统处理，并要求“非 App 内打开（prefersInApp: false）”

***

# 使用总结

| environment key | 类型                             | 作用范围      | 使用场景         |
| --------------- | ------------------------------ | --------- | ------------ |
| `editMode`      | `Observable<EditMode>`         | 影响所有可编辑组件 | List 编辑、批量操作 |
| `openURL`       | `(url) => OpenURLActionResult` | 所有链接组件    | 自定义 URL 处理逻辑 |

***

# 完整示例：同时使用 editMode 与 openURL

```tsx
const editMode = useObservable(() => EditMode.inactive())

<VStack
  environments={{
    editMode,
    openURL: (url) => {
      if (url.startsWith("https://safe.com")) {
        return OpenURLActionResult.systemAction({ url, prefersInApp: true })
      }
      return OpenURLActionResult.discarded()
    }
  }}
>
  <Button
    title="Toggle Edit"
    action={() => {
      editMode.value = editMode.value.isEditing
        ? EditMode.inactive()
        : EditMode.active()
    }}
  />

  <List>
    ...
  </List>

  <Link url="https://safe.com">Safe Link</Link>
  <Link url="https://blocked.com">Blocked Link</Link>
</VStack>
```

***

# 注意事项

1. `environments` 为局部作用域，仅影响其子视图。
2. `editMode` 必须是 `Observable<EditMode>` 才能触发界面更新。
3. `openURL` 若返回 `handled()`，将阻止默认行为。
4. `systemAction` 中的 `prefersInApp` 会影响是否在 App 内打开链接。
5. 与 SwiftUI 不同，Scripting 的 `environment` 是显式声明，不会隐式传播所有 key。



---
url: /v2/zh/guide/Changelog/2.4.3/Thread.md
---

# 线程（Thread）

Scripting 的 UI 渲染系统以及绝大多数 JavaScript 执行逻辑默认运行在主线程中，因此通常开发者无需主动切换线程。

为了确保 UI 更新安全、避免主线程阻塞，并在必要时执行后台任务，Scripting 提供了全局 `Thread` API。部分系统 API 或运行时逻辑可能会在后台执行，此 API 能帮助你安全地处理复杂场景。

`Thread` 为全局命名空间，无需导入即可使用。

***

## `Thread.isMainThread: boolean`

指示当前 JavaScript 执行环境是否在主线程。

在大多数情况下此值为 `true`，但某些系统回调或内部任务可能会切换到后台线程。在需要进行 UI 更新时，可以通过此属性确认当前线程是否安全。

```ts
if (Thread.isMainThread) {
  console.log('当前在主线程')
} else {
  console.log('当前不在主线程')
}
```

***

## `Thread.runInMain(execute: () => void): void`

在主线程中执行指定的函数。

由于 JavaScript 默认运行在主线程，通常无需手动调用此方法。它主要用于以下情况：

- 某些系统 API 回调在后台线程触发，开发者需要确保 UI 更新在主线程执行
- 希望严格保证某段逻辑在主线程中执行

此方法不会返回值，也不会切回执行前的线程，仅保证同步在主线程执行。

```ts
Thread.runInMain(() => {
  title.value = 'Updated on main thread'
})
```

***

## `Thread.runInBackground<T>(execute: () => T | Promise<T>): Promise<T>`

在后台线程执行指定函数，并以 Promise 形式将结果切回到调用处所在的线程（通常是主线程）。

适用于：

- 计算密集型任务
- 大型数据处理
- 不希望阻塞 UI 的耗时操作

`execute` 可以返回值或 Promise。

```ts
const sum = await Thread.runInBackground(() => {
  let v = 0
  for (let i = 0; i < 5_000_000; i++) v += i
  return v
})

console.log('结果:', sum)
```

异步示例：

```ts
const image = await Thread.runInBackground(async () => {
  const raw = await loadImage()
  return processImage(raw)
})

Thread.runInMain(() => {
  setImage(image)
})
```

***

## 异步 I/O 的自动线程切换行为

Scripting 中 **大量异步 I/O 方法**（包括文件、网络、数据库等）会自动在后台线程执行，无需开发者手动使用 `runInBackground`。

例如：

```ts
const content = await FileManager.readAsString(path)
```

`readAsString` 会自动切换到后台线程执行文件读取操作，然后将结果以 Promise 的方式切回调用时所在的线程（通常是主线程）。
这意味着你可以放心地直接调用异步 API，而无需担心阻塞 UI。

### 只有同步方法会在主线程执行

例如：

```ts
const content = FileManager.readAsStringSync(path)
```

同步方法不会切线程，会在主线程直接执行 I/O 操作。因此：

- 不建议在同步方法中处理大型文件或执行耗时操作
- 如果需要高性能且不阻塞 UI，应使用异步版本（如 readAsString）

***

## 使用建议

- JavaScript 默认在主线程运行，大部分场景不需要调用 `runInMain`
- 异步 I/O（如 FileManager.readAsString）已经自动在后台线程执行
- 仅在执行计算密集型任务或同步 I/O 时需要使用 `runInBackground`
- 如果某些系统 API 回调在后台线程中触发，可使用 `runInMain` 保证 UI 更新安全
- 不应在后台线程中直接访问 UI，应在后台任务完成后再回到主线程处理



---
url: /v2/zh/guide/Changelog/2.4.3/useObservable.md
---

Scripting 提供一套响应式状态系统，由 `Observable<T>` 与 `useObservable<T>` 组成，用于驱动组件渲染、与动画系统协同工作，并与 SwiftUI 的双向绑定能力保持一致（例如 `List(selection:)`、`NavigationStack(path:)` 等未来扩展接口）。

***

# 1. Observable\<T>

`Observable<T>` 是一个可观察的数据容器，当 `.value` 更新时，会触发依赖该值的 UI 自动重新渲染。

## 1.1 类定义

```ts
class Observable<T> {
  constructor(initialValue: T);
  value: T;
  setValue(value: T): void;
  subscribe(callback: (value: T, oldValue: T) => void): void;
  unsubscribe(callback: (value: T, oldValue: T) => void): void;
  dispose(): void;
}
```

***

## 1.2 属性与方法说明

### value

存储当前值。读取 `.value` 不会产生副作用。

### setValue(newValue)

更新值，并触发 UI 重绘：

```ts
observable.setValue(newValue);
```

支持任何类型 `T`（包括对象、数组、字面量、类实例等）。

### subscribe / unsubscribe

用于在组件体系外手动监听值变化。

### dispose

释放监听器和内部资源。
一般无需手动调用，仅在高级场景使用。

***

# 2. useObservable\<T>

`useObservable<T>` 是在组件内部创建本地状态的 Hook。
返回值为 `Observable<T>`，用于驱动 UI 更新。

## 2.1 函数签名

```ts
declare function useObservable<T>(): Observable<T | undefined>;
declare function useObservable<T>(value: T): Observable<T>;
declare function useObservable<T>(initializer: () => T): Observable<T>;
```

***

## 2.2 初始化方式

### 1. 无初始值（value 为 undefined）

```tsx
const data = useObservable<string>();
```

### 2. 直接提供初始值

```tsx
const count = useObservable(0);
```

### 3. 惰性初始化（初次渲染时执行）

```tsx
const user = useObservable(() => createDefaultUser());
```

***

# 3. 在 UI 中使用 Observable

在组件中，只需读取 `.value`：

```tsx
<Text>{name.value}</Text>
```

当 `.setValue` 被调用，组件会自动重新渲染：

```tsx
<Button title="Tap" action={() => name.setValue("Updated")} />
```

无需手动触发更新，行为与 React useState 类似，但带来更 SwiftUI 式的数据绑定体验。

***

# 4. 与动画协同工作

Observable 是动画触发源。
支持以下场景：

## 4.1 显式动画：withAnimation

```tsx
withAnimation(() => {
  size.setValue(size.value + 20);
});
```

任何依赖 `size.value` 的视图都会执行动画。

***

## 4.2 隐式动画：animation 修饰符

视图可通过 animation 属性监听某个值的变化并执行动画。

### 正确写法：

```tsx
animation={{
  animation: Animation.spring({ duration: 0.3 }),
  value: size.value
}}
```

示例：

```tsx
<Rectangle
  frame={{
    width: size.value,
    height: size.value,
  }}
  animation={{
    animation: Animation.easeIn(0.25),
    value: size.value,
  }}
/>
```

***

# 5. 与 SwiftUI Binding 风格的 API 对接（扩展能力）

Observable 将作为未来 Scripting 的标准双向绑定机制，用于支持 SwiftUI 风格的 API，例如：

### 5.1 List(selection:)

```tsx
const selection = useObservable<string | undefined>(undefined)

<List selection={selection}>
  ...
</List>
```

### 5.2 NavigationStack(path:)

```tsx
const path = useObservable<string[]>([])

<NavigationStack path={path}>
  ...
</NavigationStack>
```

这类 API 使用方式与 SwiftUI 一致，开发者无需学习额外的绑定机制。

***

# 6. ForEach：推荐使用 Observable 数据源

为了获得更接近 SwiftUI 的体验，推荐使用：

```tsx
<ForEach data={observableArray} builder={(item, index) => <Text>{item.name}</Text>} />
```

其中：

```ts
T extends { id: string }
```

为什么推荐这种写法：

- 性能更佳
- 插入与删除动画体验更自然

示例：

```tsx
const items = useObservable([
  { id: "1", name: "Apple" },
  { id: "2", name: "Banana" }
])

<ForEach
  data={items}
  editActions="all"
  builder={(item) => <Text>{item.name}</Text>}
/>
```

***

# 7. 综合示例

```tsx
export function Demo() {
  const visible = useObservable(true);
  const size = useObservable(100);

  return (
    <VStack spacing={20}>
      {visible.value && (
        <Rectangle
          frame={{
            width: size.value,
            height: size.value,
          }}
          background="blue"
          animation={{
            animation: Animation.spring({ duration: 0.4, bounce: 0.3 }),
            value: size.value,
          }}
          transition={Transition.opacity()}
        />
      )}

      <Button
        title="Toggle Visible"
        action={() => {
          withAnimation(() => {
            visible.setValue(!visible.value);
          });
        }}
      />

      <Button
        title="Resize"
        action={() => {
          withAnimation(Animation.easeOut(0.25), () => {
            size.setValue(size.value === 100 ? 160 : 100);
          });
        }}
      />
    </VStack>
  );
}
```

***

# 8. 总结

- `Observable<T>` 是 Scripting 中的核心响应式数据结构
- `useObservable` 在组件内创建状态，支持任意类型 T
- 与 UI 自动联动，无需额外刷新逻辑
- 为动画系统提供依赖值，用于属性动画与显式动画
- 为未来的 SwiftUI 风格 API 提供双向绑定能力
- ForEach 推荐使用 `data: Observable<Array<T>>`，获得一致的 SwiftUI 体验



---
url: /v2/zh/guide/Changelog/2.4.4/ConcentricRectangle.md
---

# 同心圆矩形（ConcentricRectangle）

`ConcentricRectangle` 是 iOS 26+ 引入的一种**同心矩形（Concentric Rectangle）形状视图**，用于创建具有“向内递进圆角”特性的矩形结构。
该形状特别适合用于：

- 现代玻璃风格按钮
- 卡片容器背景
- 交互裁剪区域（命中测试形状）
- 玻璃过渡动画遮罩
- 动态层级 UI 结构

在 Scripting 中，`ConcentricRectangle` 既可以作为一个**独立 Shape 视图渲染**，也可以作为：

- `clipShape`
- `background`
- `contentShape`

中的**专用形状类型使用**。

***

## 一、ConcentricRectangle 基本定义

```ts
type ConcentricRectangleProps = ShapeProps & ConcentricRectangleShape

/**
 * A concentric rectangle aligned inside the frame of the view containing it.
 * @available iOS 26+.
 */
declare const ConcentricRectangle: FunctionComponent<ConcentricRectangleProps>
```

### 说明

- `ConcentricRectangle` 是一个标准 `Shape` 组件
- 同时支持：

  - 填充（fill）
  - 描边（stroke）
  - 路径裁剪（trim）
  - 复杂角样式控制（ConcentricRectangleShape）
- 该视图始终在其父视图的 `frame` 内部进行布局与渲染
- 仅支持 iOS 26 及以上系统

***

## 二、角样式系统：EdgeCornerStyle

`ConcentricRectangle` 的核心能力来自其角样式系统 `EdgeCornerStyle`，用于描述单个角的行为方式。

```ts
type EdgeCornerStyle =
  | {
      style: "fixed"
      radius: number
    }
  | {
      style: "concentric"
      minimum: number
    }
  | "concentric"
```

***

### 1. 固定圆角模式（fixed）

```ts
{
  style: "fixed"
  radius: number
}
```

用于创建传统固定半径圆角矩形。

参数说明：

| 参数       | 说明            |
| -------- | ------------- |
| `radius` | 固定圆角半径，单位为 pt |

该模式适合传统静态卡片、按钮等场景。

***

### 2. 同心递进圆角模式（concentric）

```ts
{
  style: "concentric"
  minimum: number
}
```

用于创建随尺寸递进变化的“同心圆角效果”。

参数说明：

| 参数        | 说明                       |
| --------- | ------------------------ |
| `minimum` | 最小内层圆角半径，系统会根据实际尺寸自动向外递进 |

该模式适用于：

- 玻璃按钮
- 动态尺寸卡片
- 层级叠加组件
- 动态动画遮罩

***

### 3. 简写模式

```ts
"concentric"
```

等价于：

```ts
{
  style: "concentric"
  minimum: 系统默认最小值
}
```

适用于无需手动控制最小值的快速使用场景。

***

## 三、ConcentricRectangleShape（角分布规则）

`ConcentricRectangleShape` 用于描述 **每个角是否统一控制，或分别控制**。
该类型支持 7 种结构组合模式。

***

### 1. 全角统一模式（最常用）

```ts
{
  corners: EdgeCornerStyle
  isUniform?: boolean
}
```

参数说明：

| 参数          | 说明                |
| ----------- | ----------------- |
| `corners`   | 应用于全部角的样式         |
| `isUniform` | 是否强制完全一致，默认 false |

示例：

```tsx
<ConcentricRectangle
  corners={{
    style: "concentric",
    minimum: 8
  }}
  fill="red"
/>
```

***

### 2. 四个角完全独立定义

```ts
{
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 不规则异形卡片
- 特殊边角 UI
- 半圆角容器

***

### 3. 底部统一角

```ts
{
  uniformBottomCorners?: EdgeCornerStyle
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 上直角，下圆角卡片
- 底部弹出面板背景

***

### 4. 顶部统一角

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 顶部弹窗
- 顶部玻璃标题栏

***

### 5. 顶部与底部统一组合

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  uniformBottomCorners?: EdgeCornerStyle
}
```

***

### 6. 左侧统一角

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

***

### 7. 左右统一组合

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  uniformTrailingCorners?: EdgeCornerStyle
}
```

***

## 四、通用 Shape 属性（ShapeProps）

```ts
type ShapeProps = {
  trim?: {
    from: number
    to: number
  }

  fill?: ShapeStyle | DynamicShapeStyle

  stroke?: ShapeStyle | DynamicShapeStyle | {
    shapeStyle: ShapeStyle | DynamicShapeStyle
    strokeStyle: StrokeStyle
  }
}
```

***

### 1. trim（路径裁剪）

```ts
trim={{
  from: 0.0,
  to: 0.5
}}
```

用于路径绘制动画、环形裁剪、渐进描边等效果。

***

### 2. fill（填充）

```ts
fill="red"
fill="ultraThinMaterial"
```

支持：

- 纯色
- 动态材质
- 渐变样式

***

### 3. stroke（描边）

```ts
stroke="blue"

stroke={{
  shapeStyle: "blue",
  strokeStyle: {
    lineWidth: 2
  }
}}
```

***

## 五、ConcentricRectangle 在 View Modifiers 中的使用

### 1. 作为 clipShape 使用

```ts
clipShape?: Shape | "concentricRect" | ({
  type: "concentricRect"
} & ConcentricRectangleShape)
```

示例：

```tsx
<VStack
  clipShape={{
    type: "concentricRect",
    corners: {
      style: "concentric",
      minimum: 10
    }
  }}
/>
```

用于：

- 裁剪真实内容显示区域
- 玻璃过渡遮罩
- 动态蒙版

***

### 2. 作为 background 使用

```ts
background?: ShapeStyle | DynamicShapeStyle | {
  style: ShapeStyle | DynamicShapeStyle
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
} | VirtualNode | {
  content: VirtualNode
  alignment: Alignment
}
```

示例：

```tsx
<VStack
  background={{
    style: "ultraThinMaterial",
    shape: {
      type: "concentricRect",
      corners: "concentric"
    }
  }}
/>
```

***

### 3. 作为 contentShape 使用（命中测试区域）

```ts
contentShape?: Shape | {
  kind: ContentShapeKinds
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
}
```

用于控制点击、悬停、拖拽等交互命中区域。

***

## 六、完整示例解析

示例代码：

```tsx
<ZStack
  frame={{
    width: 300,
    height: 200
  }}
  containerShape={{
    type: "rect",
    cornerRadius: 32
  }}
>
  <ConcentricRectangle
    corners={{
      style: "concentric",
      minimum: 8
    }}
    fill="red"
  />
</ZStack>
```

该示例实现了：

- 外部容器为固定圆角矩形
- 内部使用同心递进圆角矩形
- 内外形成层级差异与视觉纵深感
- 红色填充用于强调 ConcentricRectangle 的实际形态

***

## 七、设计与实现注意事项

1. `minimum` 不应超过实际高度或宽度的一半
2. 同心圆角更适合与：

   - `glass`
   - `material`
   - `blur`
   - `opacity`
     等视觉效果配合使用
3. 作为 `contentShape` 使用时，仅影响点击区域，不影响视觉裁剪
4. 作为 `clipShape` 使用时，会真实裁剪子视图渲染内容



---
url: /v2/zh/guide/Changelog/2.4.4/Glass Effect Transition/index.md
---

Liquid Glass 在 iOS 26 引入了更先进的几何匹配与材质过渡能力。
Scripting 完整支持这些特性，并通过 `glassEffectTransition`、`glassEffectID`、`glassEffectUnion`、`GlassEffectContainer` 以及 `NamespaceReader` 组合实现自然、顺滑且结构化的玻璃动画体验。

本文将详细说明：

- 什么是 Glass Effect Transition
- 三种过渡类型
- 为什么需要 glassEffectID 与 namespace
- glassEffectUnion 的作用
- NamespaceReader 的设计目的与机制
- 实际示例解析
- 最佳实践

***

# 1. 概述：什么是 Glass Effect Transition

`glassEffectTransition` 用于指定 Liquid Glass 在视图出现、消失或布局变化期间应如何过渡。

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

Glass Effect Transition 控制三个核心内容：

1. **玻璃材质如何出现 / 消失**
2. **玻璃的几何形状是否会参与动画**
3. **玻璃是否与容器中其他视图的几何形状匹配**

过渡效果只影响“玻璃材质本身”，而不是普通视图的 opacity 或 scale。

***

# 2. 三种过渡类型

## 2.1 identity（无过渡）

```tsx
glassEffectTransition="identity"
```

含义：

- 不应用任何几何或材质动画。
- 内容会直接呈现，不做淡入或几何匹配。

适用于：

- 禁用动画
- 确保界面非常静态
- 开发调试

***

## 2.2 materialize（材质出现动画）

```tsx
glassEffectTransition="materialize"
```

特点：

- 内容会逐渐淡入。
- Liquid Glass 材质会以柔和方式出现和消失。
- 不进行几何匹配，不尝试从其他玻璃形状“过渡”。

适用于：

- 材质出现／消失强调明显
- 不需要几何跟随效果
- 简单切换菜单或按钮

***

## 2.3 matchedGeometry（匹配几何）

```tsx
glassEffectTransition="matchedGeometry"
```

特点：

- 玻璃材质会尝试“继承”同一 namespace 内、相同 ID 的玻璃形状。
- 在视图切换时，从旧形状平滑过渡到新形状。
- 需要使用 `glassEffectID` 指定对应关系。

适用于：

- 复杂菜单切换
- 视图替换（Edit → Home）
- 需要视觉连续性的动画

是 Liquid Glass 最强大也是最常用的模式。

***

# 3. glassEffectID 与 namespace：匹配几何的核心

## 3.1 为什么需要 ID？

几何匹配动画需要知道：

- “旧玻璃”是谁
- “新玻璃”是谁

因此必须给玻璃效果一个身份标识：

```tsx
glassEffectID={{
  id: 1,
  namespace
}}
```

如果两个玻璃视图：

- 位于相同 namespace
- glassEffectID 的 id 相同

系统会认为它们是同一“玻璃实体”的不同状态，允许过渡。

***

## 3.2 为什么必须有 namespace？

SwiftUI 的 matchedGeometry 效果依赖 `@Namespace`，在 Scripting 中我们通过 `NamespaceReader` 暴露给 TSX。

`NamespaceReader` 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ... 在此作用域中所有 glassEffectID 都应使用这个 namespace ...
  )}
</NamespaceReader>
```

原因：

- namespace 用于组织 matchedGeometry 的作用域
- 同一 namespace 内的 ID 才能互相匹配
- 不同 namespace 之间永远不会彼此动画匹配

***

# 4. glassEffectUnion：玻璃材质的联合区域

除了匹配几何形状外，Liquid Glass 还能把多个玻璃区域合并为一个连续材质区域：

```tsx
glassEffectUnion={{
  id: 1,
  namespace
}}
```

效果：

- 相同 union ID 的按钮共享同一个玻璃材质分区
- 多个按钮可看起来像“同一块玻璃切出来的”
- 提升视觉统一性

通常和 matchedGeometry 同时使用。

***

# 5. 示例解析

以下示例展示菜单在两种布局之间切换，并使用动画呈现玻璃过渡：

```tsx
isAlternativeMenu.value
  ? <>
      <Button
        title="Home"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Settings"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
  : <>
      <Button
        title="Edit"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Erase"
        glassEffectID={{id:3, namespace}}
        glassEffectUnion={{id:1,namespace}}
        glassEffectTransition="materialize"
      />
      <Button
        title="Delete"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
```

重点说明：

### 1. 按钮之间共享 Union ID = 1

所有按钮（无论菜单 A 或 B）实际上共享一个玻璃材质“池”。
这样切换时材质背景连续且自然。

### 2. Home / Edit 共享 ID = 1

- 当菜单切换时，Edit → Home 的玻璃材质会自动匹配几何形状，触发 matchedGeometry 动画。

### 3. Delete / Settings 共享 ID = 2

- Delete → Settings 也会使用 matching transition。

### 4. Erase 设置了 materialize

```tsx
glassEffectTransition="materialize"
```

它不会尝试匹配几何，而是用材质淡入淡出的动画。
这可以让某个按钮以不同方式呈现，令人体验变化更明显。

### 5. 整个 HStack 包裹在 GlassEffectContainer

```tsx
<GlassEffectContainer>
  <HStack> ... </HStack>
</GlassEffectContainer>
```

容器提供：

- 匹配几何所需的上下文
- 优化渲染性能
- 让 union 生效

***

# 6. NamespaceReader：Scripting 如何暴露 @Namespace

在 SwiftUI 中：

```swift
@Namespace private var ns
```

只能在 SwiftUI View 中使用，无法直接从 TypeScript 中访问。

因此 Scripting 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ...
  )}
</NamespaceReader>
```

### 作用：

1. 实际内部创建 SwiftUI 的 `@Namespace`
2. 自动管理生命周期
3. 将 namespace 提供给 TS
4. 保证同一 TSX 作用域使用同一个 namespace

等价于：

```tsx
@Namespace var namespace

glassEffectID={{ id: x, namespace }}
```

没有 NamespaceReader，无论 matchedGeometry 还是 union 都无法工作。

***

# 7. 动画触发方式（withAnimation）

玻璃过渡不会自行动画，必须使用动画触发状态切换：

```tsx
withAnimation(() => {
  isAlternativeMenu.setValue(
    !isAlternativeMenu.value
  )
})
```

匹配几何、材质出现动画等会自动附着到这次动画事务中。

***

# 8. 最佳实践

### 1. 所有参与动画的视图必须在同一个 GlassEffectContainer

否则 matchedGeometry 不会生效。

### 2. namespace 必须由同一个 NamespaceReader 提供

**不要跨层级或重复构造 namespace**。

### 3. glassEffectID 必须在两个状态中都出现

否则 SwiftUI 无法关联动画。

### 4. 若要连续的材质外观，应使用 glassEffectUnion

让按键像同一块玻璃切换。

### 5. 除特殊情况外，尽量使用 matchedGeometry

可获得更自然的“流动感”。

***

# 9. 总结

Glass Effect Transition 是 iOS 26 Liquid Glass 系统的核心特性之一，它让玻璃材质在视图切换中具备几何匹配、材质渐变与联合区域动画。

在 Scripting 中：

- `glassEffectTransition` 控制动画类型
- `glassEffectID` + `namespace` 让几何匹配成为可能
- `glassEffectUnion` 提供材质连续感
- `GlassEffectContainer` 管理动画环境
- `NamespaceReader` 使 TSX 能访问 SwiftUI 的 @Namespace



---
url: /v2/zh/guide/Changelog/2.4.4/Glass Effect Transition/index_example.md
---

# 示例

```tsx
import { Button, GlassEffectContainer, HStack, NamespaceReader, Navigation, Script, VStack, useObservable } from "scripting"

function View() {

  const isAlternativeMenu = useObservable(false)

  return <NamespaceReader>{namespace => <VStack
    spacing={50}
    frame={{
      maxWidth: 'infinity',
      maxHeight: 'infinity'
    }}
    background="systemYellow"
  >
    <GlassEffectContainer
    >
      <HStack
        spacing={0}
        font="largeTitle"
        imageScale="large"
        buttonStyle="glass"
        labelStyle="iconOnly"
      >
        {
          isAlternativeMenu.value
            ? <>
              <Button
                title="Home"
                systemImage="house"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Settings"
                systemImage="gear"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>

            : <>
              <Button
                title="Edit"
                systemImage="pencil"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Erase"
                systemImage="eraser"
                action={() => { }}
                glassEffectID={{
                  id: 3,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
                glassEffectTransition="materialize"
              />
              <Button
                title="Delete"
                systemImage="trash"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>
        }
      </HStack>
    </GlassEffectContainer>

    <Button
      title="Toggle"
      buttonStyle="bordered"
      action={() => {
        withAnimation(() => {
          isAlternativeMenu.setValue(
            !isAlternativeMenu.value
          )
        })
      }}
    />
  </VStack>
  }</NamespaceReader>
}

async function run() {
  await Navigation.present(<View />)

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.4/Intent.continueInForeground.md
---

`Intent.continueInForeground` 用于在脚本从 Shortcuts 中后台执行时，**请求系统将流程转移到 Scripting App 的前台继续运行**。
此过程需要用户明确确认。

适用场景包括：

- 需要展示完整 UI（如表单、列表、导航页面）
- 需要用户在 App 内进行交互操作
- 后续步骤无法在后台执行

调用此方法后，系统会弹出确认对话框：

- 用户 **允许** → Scripting App 打开到前台，脚本继续执行
- 用户 **取消** → 当前脚本立即终止
- 此行为完全由系统管理，开发者无需手动处理跳转流程

由于该能力基于 iOS 26 引入的 AppIntents 行为：

**该 API 只能在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function continueInForeground(
  dialog?: Dialog | null,
  options?: {
    alwaysConfirm?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## dialog?: Dialog | null

用于提示用户为什么需要切换到前台继续执行。

`Dialog` 的类型格式支持三种形式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否前往应用继续执行？";
```

或带辅助说明：

```ts
{
  full: "需要在应用中继续执行下一步操作",
  supporting: "接下来的步骤需要完整的 UI 交互。",
  systemImageName: "app"
}
```

若传入 `null`，系统可能不显示提示，仅直接触发系统确认（不推荐）。

***

## `options?: { alwaysConfirm?: boolean }`

用于控制系统是否每次都显示确认提示。

- `alwaysConfirm: false`（默认）
  系统一般会根据上下文自动判断是否需要确认。

- `alwaysConfirm: true`
  每次调用都会提示用户明确确认。

示例：

```ts
{
  alwaysConfirm: true;
}
```

***

# 执行流程

执行 `await Intent.continueInForeground(...)` 时：

1. 快捷指令执行暂停

2. 系统弹出确认对话框

3. 用户选择：

   - **确认** → 打开 Scripting App → 脚本继续
   - **取消** → 脚本立即终止

4. 后续脚本在 Scripting App 前台环境中继续执行

**注意：脚本不会在后台继续运行，必须等待用户操作。**

***

# 典型应用场景

推荐在以下场景调用：

- 需要展示完整的导航界面或交互表单（如示例中的 TextField）
- 需要使用 `Navigation.present` 呈现 UI
- 需要 App 内操作如：

  - 预览文件
  - 编辑长文本
  - 选择复杂数据
  - 多步骤流程

不推荐在以下情况使用：

- 单纯的数据处理，不需要 UI
- 简单操作已经可通过 SnippetIntent 完成

***

# 完整示例代码

以下示例展示如何从 Shortcuts 通过 `continueInForeground` 切换到 Scripting App 前台，然后展示 UI 让用户输入文本，输入结束后再返回 Shortcuts。

```tsx
// intent.tsx
import {
  Button,
  Intent,
  List,
  Navigation,
  NavigationStack,
  Script,
  Section,
  TextField,
  useState,
} from "scripting";

function View() {
  const dismiss = Navigation.useDismiss();
  const [text, setText] = useState("");

  return (
    <NavigationStack>
      <List navigationTitle="Intent Demo">
        <TextField title="Enter a text" value={text} onChanged={setText} />

        <Section>
          <Button
            title="Return Text"
            action={() => {
              dismiss(text);
            }}
            disabled={!/\S+/.test(text)}
          />
        </Section>
      </List>
    </NavigationStack>
  );
}

async function runIntent() {
  // 请求系统将执行流程切换到 Scripting App 前台
  await Intent.continueInForeground("Do you want to open the app and continue?");

  // 在前台呈现交互式 UI，用户填写文本
  const text = await Navigation.present<string | null>(<View />);

  // 可选：返回到快捷指令界面
  Safari.openURL("shortcuts://");

  // 返回结果给 Shortcuts
  Script.exit(Intent.text(text ?? "No text return"));
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**，否则会抛出异常或行为不可用。
- 若脚本依赖用户输入、复杂 UI 或操作，请使用该 API 触发前台模式。
- 对话内容应清晰说明需要用户切换前台的原因，提升用户信任度。
- 若用户拒绝，脚本将终止，开发者无需自行处理取消逻辑。
- 可以与 SnippetIntent 结合，构建完整的后台 UI + 前台 UI 混合流程。



---
url: /v2/zh/guide/Changelog/2.4.4/Intent.requestConfirmation.md
---

`Intent.requestConfirmation` 用于在脚本执行过程中，**向用户请求确认某项操作**。
调用后，系统会暂停脚本执行，并展示一个基于 **SnippetIntent 的 UI** 作为确认界面，同时可显示提示对话内容。

确认流程行为：

- 用户 **确认** → Promise resolve，脚本继续执行
- 用户 **取消** → 当前脚本终止执行
- 确认界面通过传入的 **SnippetIntent** 的 UI 定义
- 系统自动管理此流程，无需开发者处理 UI 呈现逻辑

**该 API 仅可在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function requestConfirmation(
  actionName: ConfirmationActionName,
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## actionName: ConfirmationActionName

用于告诉系统“要确认的行为语义是什么”，系统会根据该值生成自然语言文案。例如：

- `"set"` → “确定要设置…？”
- `"buy"` → “确定要购买…？”
- `"toggle"` → “是否切换…？”

可选值如下（与苹果 AppIntents 框架一致）：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" |
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

选择合适的语义有助于提高确认界面的自然体验。

***

## snippetIntent: SnippetIntent

必须是一个 **注册为 SnippetIntent 类型的 AppIntent**：

```ts
AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>;
```

用户在确认界面中看到的内容就是该 SnippetIntent 的 `perform()` 返回的 UI，例如选项列表、内容预览等。

***

## `options?: { dialog?: Dialog; showDialogAsPrompt?: boolean }`

### dialog?: Dialog

用于在确认 UI 上方或系统对话框中显示提示文本。
支持四种格式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否继续？";
```

更复杂的：

```ts
{
  full: "确定要设置此颜色吗？",
  supporting: "此操作将更新应用的主题颜色。",
  systemImageName: "paintpalette"
}
```

用途：

- 解释确认动作含义
- 提醒用户可能产生的影响
- 提供更友好的交互上下文

***

### showDialogAsPrompt?: boolean

默认值：`true`
决定系统是否以「提示弹窗」方式显示对话文本。

设为 `false` 时，文本可能以更沉浸的方式显示在 Snippet 卡片内部。

***

# 执行流程

调用 `await Intent.requestConfirmation(...)` 时脚本执行顺序如下：

1. 脚本暂停执行

2. 系统展示确认界面（SnippetIntent UI + 可选 dialog 文案）

3. 用户进行交互：

   - **确认** → Promise resolve，脚本继续
   - **取消** → 脚本终止执行

4. 不需要开发者手动关闭 UI

此流程完全由系统管理。

***

# 使用场景

以下场景推荐使用 `requestConfirmation`：

- 修改重要设置（如主题颜色、隐私设置）
- 对数据执行有副作用的操作（如删除、更新、重置）
- 流程中一步需用户明确授权
- 启动某个需要用户选择的 UI 子流程（如颜色选择器、账号切换器）

不适用场景：

- 简单数据处理，不需要用户确认
- 可以在后台无 UI 完成的操作

***

# 完整示例代码

以下示例展示如何使用 `requestConfirmation` 请求用户确认一次颜色选择，并在确认后继续执行脚本。

假设你已有两个 SnippetIntent：

- `PickColorIntent`：颜色选择 UI
- `ShowResultIntent`：结果展示 UI

## intent.tsx 示例

```tsx
import { Intent, Script } from "scripting";
import { PickColorIntent, ShowResultIntent } from "./app_intents";

async function runIntent() {
  // 第一步：请求用户确认颜色选择
  await Intent.requestConfirmation("set", PickColorIntent(), {
    dialog: {
      full: "确定要设置此颜色吗？",
      supporting: "此操作将更新应用的主题颜色。",
      systemImageName: "paintpalette",
    },
  });

  // 第二步：读取来自 Shortcuts 的输入（如果有）
  const text =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts";

  // 第三步：呈现最终 SnippetIntent
  const snippet = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: text }),
  });

  Script.exit(snippet);
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**
  提前检查系统版本或优雅降级。

- **总是提供清晰的 dialog 文案**
  确认行为应让用户理解，不应仅依赖 Snippet UI 本身。

- **用于重要或可逆性较差的操作**
  如修改设置、启动后台任务、提交数据等。

- **与 SnippetIntent 配合使用效果最佳**
  因为确认 UI 直接展示 SnippetIntent 的视图。

- **用户取消时脚本会被系统直接终止**
  不要在后续代码中假设脚本一定会继续执行。



---
url: /v2/zh/guide/Changelog/2.4.4/IntentMemoryStorage.md
---

IntentMemoryStorage 是一个用于 **在多个 AppIntent 执行之间保留临时数据** 的内存存储系统。然而，它的生命周期并不严格绑定在单次 AppIntent 或 Script.exit 以上，而是由系统对 Extension 环境（Intent Extension / Widget Extension）的运行状态决定，因此具有一定的非确定性。

以下文档基于你之前确认的完整版结构，并加入系统行为的解释。

***

# 概述

在 Scripting 中，每个 AppIntent 都运行在其所属脚本的 **脚本执行上下文（Script Execution Context）** 中。当 AppIntent 的 `perform()` 执行完成，或在 `intent.tsx` 中调用 `Script.exit()` 时，当前 AppIntent 的执行流程会结束。

但关键点是：

**IntentMemoryStorage 不会在 AppIntent 或 Script.exit 结束时被立即销毁**

它的生命周期依赖于：

- 系统是否继续保留当前 Extension 进程
- 系统是否因为内存压力或其他策略回收 Extension
- Widget 或 Live Activity 是否仍在使用同一 Extension

因此：

- 在 Shortcuts 再次运行同一个脚本时
  **有可能读取到上次设置的 MemoryStorage 值**
- 在 Widget 或 Live Activity 中调用 AppIntent
  **同一个脚本的 JS Context 可能被重用，因此 MemoryStorage 也会保留**
- 系统何时清除 MemoryStorage **不可预测**

MemoryStorage 的本质是：

**存储在当前 Extension 进程中的短期内存，非持久化、非可靠、非严格会话级**

***

# 作用范围（Scopes）

IntentMemoryStorage 提供两类存储区域：

## 1. 脚本级（Script-scoped）存储

默认行为。

- 属于单个脚本项目
- 脚本 A 不能访问脚本 B 的脚本级存储
- Extension 不被系统销毁时，会保留该脚本的存储
- Extension 一旦被销毁，存储也随之清空

适用于该脚本内部多步骤流程。

***

## 2. 共享（Shared）存储

使用 `{ shared: true }` 可访问一个共享区域：

- 所有脚本的 AppIntent 都可访问
- 在 Extension 未被系统释放前可以持续存在
- Extension 被销毁后清空

适合在多个脚本之间协调状态。

***

# Extension 生命周期与 JS Context 行为

## 情况一：在 Shortcuts 中运行 Intent

- Shortcuts 执行完成后：

  - 当前 JS Context 会被销毁
  - 当前 AppIntent 执行结束
- 但：**IntentMemoryStorage 不一定被销毁**
  因为系统未必会立即销毁 Intent Extension

因此：

### 再次运行同一个脚本时，可能读到上次的数据。

例：

```ts
IntentMemoryStorage.set("color", "red")
```

下一次 Shortcut 再运行时：

```ts
const c = IntentMemoryStorage.get("color")
```

可能仍然得到 `"red"`。

这是系统层面的行为，并非 Scripting 的行为。

***

## 情况二：在小组件（Widget/Control Widget）中调用 AppIntent

Widget Extension 的特点：

- Scripting 会尽量复用 JS Context
- 即使 AppIntent 执行结束，JS Context 也可能继续存在
- 因此 MemoryStorage 也可能持续存在

但：

### 系统随时可能回收 Extension（尤其在内存压力下），JS Context 和 MemoryStorage 都会被清空。

***

## 情况三：Live Activity 调用 AppIntent

Live Activity Extension 也可能复用上下文：

- 多次调用 AppIntent 通常复用同一 JS Context
- MemoryStorage 可能继续保留
- 但系统没有保证稳定性
- 扩展环境被杀死后 MemoryStorage 立即失效

***

## 总结生命周期（非常关键）

| 行为                         | 是否导致 MemoryStorage 清空 |
| -------------------------- | --------------------- |
| AppIntent 执行结束             | 否                     |
| Script.exit()              | 否                     |
| Shortcut 流程结束              | 不一定                   |
| Widget 更新 AppIntent        | 不一定                   |
| Live Activity 调用 AppIntent | 不一定                   |
| 系统回收 Extension 进程          | 是（彻底清空）               |

MemoryStorage 的生命周期与 **Extension 进程生命周期** 完全一致，而 Extension 何时被系统保留/销毁是不可预测的系统行为。

***

# API 定义

```ts
namespace IntentMemoryStorage {
  function get<T>(key: string, options?: { shared?: boolean }): T | null
  function set(key: string, value: any, options?: { shared?: boolean }): void
  function remove(key: string, options?: { shared?: boolean }): void
  function contains(key: string, options?: { shared?: boolean }): boolean
  function clear(): void
  function keys(): string[]
}
```

说明：

- `shared` 仅作用于 get / set / remove / contains
- clear() 和 keys() 始终只针对脚本级存储区域

***

# API 详细说明

## get

```ts
function get<T>(key: string, options?: { shared?: boolean }): T | null
```

读取键值。注意：

- 若 Extension 尚未被销毁，则可能读到上一次执行留下的值
- 若系统已清理 Extension，则可能返回 null

脚本级：

```ts
const color = IntentMemoryStorage.get<string>("color")
```

shared：

```ts
const token = IntentMemoryStorage.get<string>("token", { shared: true })
```

***

## set

```ts
function set(key: string, value: any, options?: { shared?: boolean }): void
```

写入存储区域。

脚本级：

```ts
IntentMemoryStorage.set("color", "systemBlue")
```

shared：

```ts
IntentMemoryStorage.set("sessionID", "abc123", { shared: true })
```

***

## remove

```ts
function remove(key: string, options?: { shared?: boolean }): void
```

删除键值。

脚本级：

```ts
IntentMemoryStorage.remove("color")
```

shared：

```ts
IntentMemoryStorage.remove("sessionID", { shared: true })
```

***

## contains

```ts
function contains(key: string, options?: { shared?: boolean }): boolean
```

检查键是否存在。
注意：此结果取决于当前 Extension 是否仍在。

***

## clear

```ts
function clear(): void
```

清空脚本级存储。
shared 区域不会被清空。

***

## keys

```ts
function keys(): string[]
```

返回脚本级存储的 key 列表。

***

# 使用场景

## 脚本级（默认）

适用于：

- 单脚本的多步骤流程
- 融合 SnippetIntent → AppIntent → SnippetIntent
- 临时保存当前 UI 状态、表单数据、步骤编号

示例：

```ts
IntentMemoryStorage.set("step", 2)
```

***

## shared（跨脚本）

适用于：

- 多脚本协同
- 工作流中跨多个项目传递会话状态
- 保存当前 Shortcut 全局状态

示例：

```ts
IntentMemoryStorage.set("workflowID", "xyz", { shared: true })
```

***

# 不适用用途

- 不保证一定存在
- 不保证一定被清理
- 不适合存储大对象
- 不适合存储持久数据
- 不适合跨天或长期使用（可能在任何时间丢失）

推荐持久方案：

- `Storage`
- `FileManager`

***

# 示例

## 脚本级示例

```ts
IntentMemoryStorage.set("color", "red")

const color = IntentMemoryStorage.get<string>("color")
```

***

## shared 跨脚本示例

Script A：

```ts
IntentMemoryStorage.set("sessionID", "12345", { shared: true })
```

Script B：

```ts
const id = IntentMemoryStorage.get<string>("sessionID", { shared: true })
```

***

# 存储结构示例

脚本级：

```json
{
  "color": "green",
  "step": 2
}
```

shared：

```json
{
  "token": "xyz"
}
```

***

# 最佳实践

- 不保证 MemoryStorage 一定存在或一定被清理
- 不要用于关键数据
- 不要用于大数据存储
- 对 shared 使用清晰命名，例如：

  - `"global.sessionID"`
  - `"workflow.status"`
- 在依赖该存储前考虑数据可能不存在



---
url: /v2/zh/guide/Changelog/2.4.4/Liquid Glass Effect/index.md
---

**GlassEffect、GlassEffectContainer、UIGlass** 等相关 API 基于 SwiftUI 新引入的 Liquid Glass 技术，让开发者能够在脚本中以 TSX 方式使用流体化、动态的玻璃材质效果，并支持过渡动画、匹配几何、联合玻璃区域等高级特性。

***

## 1. Liquid Glass 概述

Liquid Glass 是 iOS 26 新增的视觉效果系统，用于创建带有流动质感、半透明材质与动态边界的玻璃效果。与早期的 `blur` 或 `material` 不同，Liquid Glass 提供了：

- 动态玻璃形状（使用 Shape）
- 基于几何匹配的过渡动画
- 可交互的玻璃（interactive）
- 可指定 tint 色彩的玻璃材质
- 可组合多个视图的玻璃“联合”

***

# 2. GlassEffect 基础用法

所有支持玻璃效果的视图，都可以通过 `glassEffect` 修饰符添加 Liquid Glass 材质。

### 属性定义

```ts
type GlassProps = {
  glassEffect?: boolean | UIGlass | Shape | {
      glass: UIGlass
      shape: Shape
  }

  glassEffectTransition?: GlassEffectTransition

  glassEffectID?: {
      id: string | number
      namespace: NamespaceID
  }

  glassEffectUnion?: {
      id: string | number
      namespace: NamespaceID
  }
}
```

***

## 2.1 `glassEffect`

glassEffect 有四种主要使用方式：

### 方式一：启用默认玻璃材质

```tsx
<Text glassEffect>Foo</Text>
```

使用系统默认的 Liquid Glass 材质（相当于 `UIGlass.regular()`）。

***

### 方式二：使用指定的 UIGlass

```tsx
<Text glassEffect={UIGlass.regular().interactive(false)}>Foo</Text>
```

可以链式配置 tint、interactive 等属性。

***

### 方式三：设置玻璃的形状（Shape）

```tsx
<Text glassEffect={{ glass: UIGlass.regular(), shape: { type: 'rect', cornerRadius: 10 } }}>
  Foo
</Text>
```

或直接传入 Shape：

```tsx
<Text
  glassEffect={{
    type: 'rect',
    cornerRadius: 10
  }}
>
  Foo
</Text>
```

表示该视图的玻璃材质会严格限定在指定几何图形内。

***

### 方式四：Boolean 短写

```tsx
<View glassEffect />
```

等同于默认 UIGlass.regular()。

***

# 3. UIGlass 类

`UIGlass` 用于描述玻璃材质本身，可以选用内置材质或链式组合属性。

### 可用静态方法

| 方法                   | 描述                        |
| -------------------- | ------------------------- |
| `UIGlass.clear()`    | 完全透明的玻璃材质，用于融合或叠加效果。      |
| `UIGlass.regular()`  | 默认的 Liquid Glass 材质。      |
| `UIGlass.identity()` | 身份材质，不会改变内容外观，相当于不应用玻璃效果。 |

### 链式配置方法

```ts
interactive(value?: boolean): UIGlass
tint(color: Color): UIGlass
```

示例：

```tsx
glassEffect={UIGlass.regular().interactive().tint("red")}
```

***

# 4. GlassEffectTransition（玻璃过渡动画）

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

### 三种模式说明

| transition          | 描述                                 |
| ------------------- | ---------------------------------- |
| `'identity'`        | 不应用任何几何或材质的动画变化。                   |
| `'materialize'`     | 内容渐入，同时玻璃材质出现或消失，但不尝试匹配几何形状。       |
| `'matchedGeometry'` | 根据容器内其他玻璃形状的几何信息匹配过渡动画，具备更自然的动画效果。 |

### 使用方式

```tsx
<Text 
  glassEffect
  glassEffectTransition="materialize"
>
  Foo
</Text>
```

matchedGeometry 通常需要配合 `glassEffectID` 或 `glassEffectUnion` 使用。

***

# 5. glassEffectID 与 glassEffectUnion

Liquid Glass 支持“识别”不同视图间的玻璃效果，用于 matched geometry 动画或合并多块玻璃区域。

***

## 5.1 glassEffectID

为玻璃效果赋予唯一的 ID，用于 matchedGeometry 动画。

```tsx
<Text
  glassEffect
  glassEffectID={{ id: "avatar", namespace }}
>
  Foo
</Text>
```

多个视图使用相同 ID + namespace 时，系统会尝试匹配形状，从而产生流体几何动画效果。

***

## 5.2 glassEffectUnion

用于将多个玻璃效果统一为一个更大区域。

```tsx
<Text
  glassEffect
  glassEffectUnion={{ id: 1, namespace }}
/>
```

多个视图的玻璃材质将被合并，形成更一致的视觉区域。

***

# 6. GlassEffectContainer

`GlassEffectContainer` 是用于组织和管理玻璃效果的容器。容器内部的所有 glassEffect 视图，都能参与几何匹配、联合效果和过渡动画。

### 示例

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image glassEffect systemName="1.circle" />
    <Image glassEffect systemName="2.circle" />
  </HStack>
</GlassEffectContainer>
```

在容器中：

- matchedGeometry 正常工作
- glassEffectUnion 可以跨子视图生效
- glassEffectID 的动画效果可互相关联

GlassEffectContainer 不需要额外参数，但提供了玻璃效果组织空间。

***

# 7. 按钮的玻璃样式 buttonStyle

Scripting 在 iOS 26 提供新增按钮样式：

- `"glass"`
- `"glassProminent"`

示例：

```tsx
<Button title="Glass" action={...} buttonStyle="glass" />
<Button title="Glass Prominent" action={...} buttonStyle="glassProminent" />

<Button
  title="Glass & Tint"
  buttonStyle="glass"
  tint="red"
/>
```

这些按钮会自动使用 Liquid Glass 材质，并适配 tint、press 动效。

***

# 8. 实战示例说明

以下示例展示完整的用法，包括：

- 背景图片
- Glass 按钮
- GlassEffectContainer
- 使用 UIGlass 自定义玻璃
- 使用指定形状的玻璃

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image
      systemName="1.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: 30, y: 0 }}
    />
    <Image
      systemName="2.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: -30, y: 0 }}
    />
  </HStack>
</GlassEffectContainer>
```

***

# 9. 使用建议与最佳实践

### 1. 大量玻璃视图应包裹在同一个 GlassEffectContainer

可提高动画一致性与性能。

### 2. 使用 matchedGeometry 时务必提供 glassEffectID

否则无法产生几何跟随动画。

### 3. 复杂的玻璃区域可使用 glassEffectUnion 合并

让多个子视图形成连续材质。

### 4. 为了避免过度渲染，玻璃不应嵌套太深

可以多用 ZStack 管理效果。

### 5. UIGlass.identity 非常适合“禁用玻璃但保持结构”

它允许你保留现有布局但不实际渲染材质。



---
url: /v2/zh/guide/Changelog/2.4.4/Liquid Glass Effect/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, VStack, ZStack, Image, Path, GlassEffectContainer, HStack } from "scripting"

function View({
  image
}: {
  image: UIImage
}) {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle="GlassEffect DEMO"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <ZStack>
        <Image
          image={image}
          resizable
          scaleToFill
        />
        <VStack>
          <HStack>
            <Button
              title="Glass"
              action={() => { }}
              buttonStyle="glass"
            />
            <Button
              title="Glass & Tint"
              action={() => { }}
              buttonStyle="glass"
              tint="red"
            />
          </HStack>
          <HStack>
            <Button
              title="Glass Prominent"
              action={() => { }}
              buttonStyle="glassProminent"
            />
            <Button
              title="Glass Prominent & Tint"
              action={() => { }}
              buttonStyle="glassProminent"
              tint="red"
            />
          </HStack>
          <GlassEffectContainer>
            <HStack spacing={40}>
              <Image
                systemName="1.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: 30, y: 0 }}
              />
              <Image
                systemName="2.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: -30, y: 0 }}
              />
            </HStack>
          </GlassEffectContainer>
          <HStack spacing={12}>
            <Text
              padding
              glassEffect
            >Foo</Text>
            <Text
              padding
              glassEffect={{
                type: 'rect',
                cornerRadius: 10
              }}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().interactive()}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().tint("red")}
              foregroundStyle="white"
            >Foo</Text>
          </HStack>
        </VStack>
      </ZStack>
    </VStack>
  </NavigationStack>
}

async function run() {
  try {
    const image = (await Photos.pickPhotos(1))?.at(0)
    if (!image) {
      throw new Error("You must pick an image as the background.")
    }
    // Present view.
    await Navigation.present({
      element: <View
        image={image}
      />
    })
  } catch (e) {
    console.present()
    console.error(e)
  }

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.4/NamespaceReader.md
---

# 命名空间读取器（NamespaceReader）

`NamespaceReader` 用于 **创建并管理一个几何动画命名空间（Namespace）**。
该命名空间是实现以下能力的**前提条件**：

- `matchedGeometryEffect`（组件级几何联动动画）
- `matchedTransitionSource`（页面级导航转场动画）
- `navigationTransition`（如 zoom 转场）

可以将 `NamespaceReader` 理解为：

> 一个“动画坐标系提供者”，用于告诉系统：哪些视图属于**同一组几何动画作用域**。

***

## 一、API 角色说明

`NamespaceReader` 并不是一个普通的 UI 组件，而是一个 **命名空间生成器**，用于：

- 创建一个全新的 `NamespaceID`
- 通过 render function 方式暴露给子视图使用
- 作为几何匹配动画系统的“分组边界”

它在 Scripting 中对应 SwiftUI 的：

- `@Namespace`
- `Namespace.ID`

***

## 二、基本使用方式

### 1. 最小用法结构

```tsx
<NamespaceReader>
  {namespace => (
    // 在这个作用域内
    // 使用 namespace 绑定 matchedGeometryEffect 或 matchedTransitionSource
  )}
</NamespaceReader>
```

说明：

- `NamespaceReader` 是一个 **函数式子节点组件**
- 其子节点必须是一个函数
- 该函数的参数 `namespace` 即为当前创建的命名空间实例

***

## 三、Namespace 的本质作用

### 1. 命名空间的真正含义

`namespace` 的本质作用是：

- 把一组“逻辑上可能互相关联的视图”
- 显式地声明为：

  > “它们允许进行几何匹配动画”

如果没有相同的 `namespace`：

- 即使两个视图的 `id` 完全一致
- 依然 **不会产生任何几何动画**

***

### 2. Namespace 的隔离能力

| 情况                       | 是否发生几何匹配 |
| ------------------------ | -------- |
| 相同 `id` + 相同 `namespace` | 会        |
| 相同 `id` + 不同 `namespace` | 不会       |
| 不同 `id` + 相同 `namespace` | 不会       |
| 不同 `id` + 不同 `namespace` | 不会       |

结论：

> **必须同时满足 `id` 与 `namespace` 完全一致，系统才会建立几何匹配关系。**

***

## 四、NamespaceReader 与几何动画系统的关系

### 1. 与 matchedGeometryEffect 的关系

- `matchedGeometryEffect` 依赖 `namespace` 建立“跨视图几何映射”
- `NamespaceReader` 是 `matchedGeometryEffect` 的 **前置条件**
- 没有 `NamespaceReader`：

  - `matchedGeometryEffect` 无法工作

***

### 2. 与 matchedTransitionSource 的关系

- 页面级转场动画依赖 `namespace` 来配对：

  - 转场源视图
  - 目标页面
- `NamespaceReader` 用于：

  - 在源页面生成 namespace
  - 并传递给目标页面作为统一坐标系统

***

## 五、最基础的 NamespaceReader 示例（组件级）

```tsx
const expanded = useObservable(false)

<NamespaceReader>
  {namespace => (
    <VStack>
      {!expanded.value && (
        <Circle
          matchedGeometryEffect={{
            id: "shape",
            namespace
          }}
          onTapGesture={() => {
            expanded.setValue(true)
          }}
        />
      )}

      {expanded.value && (
        <Circle
          frame={{ width: 200, height: 200 }}
          matchedGeometryEffect={{
            id: "shape",
            namespace,
            isSource: false
          }}
        />
      )}
    </VStack>
  )}
</NamespaceReader>
```

该示例中：

- `NamespaceReader` 负责创建动画坐标系
- 两个 `Circle` 因为：

  - `id` 相同
  - `namespace` 相同
    从而建立起几何联动关系

***

## 六、导航转场中的 NamespaceReader 典型结构

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

该结构说明：

- `namespace` 由 `NamespaceReader` 生成
- 同时被：

  - 源视图使用
  - 目标页面使用
- 从而建立完整的页面级共享几何动画

***

## 七、命名空间的生命周期与作用范围

### 1. 生命周期

- `NamespaceReader` 每次创建：

  - 都会生成一个 **全新的 namespace**
- 该 namespace 的生命周期：

  - 仅存在于当前组件树
  - 随组件卸载而销毁

***

### 2. 作用范围

- namespace 只对其 render function 内部的视图生效
- 不可跨越组件树自动共享
- 如果需要跨组件共享：

  - 必须通过 props 显式传递 `namespace`

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- 是否真的使用了 `NamespaceReader`
- 是否正确接收并传递了 `namespace`
- source 与 target 是否引用的是 **同一个 namespace 实例**

***

### 2. 动画偶尔失效、不稳定

常见原因：

- `NamespaceReader` 被条件渲染反复销毁与重建
- 每次重建都会生成新的 namespace
- 导致旧视图与新视图：

  - 实际上不在同一个动画坐标系中

建议：

- 将 `NamespaceReader` 放在 **稳定的父级节点**
- 避免在 `if / ternary` 结构中频繁切换

***

### 3. 多个 NamespaceReader 嵌套导致动画错乱

问题表现：

- id 相同
- 但实际 namespace 不同
- 系统无法建立匹配关系

排查思路：

- 确认 source 与 target 是否真的来自：

  - 同一个 `NamespaceReader` 实例

***

## 九、设计层面的使用建议

1. 一个独立动画区域使用一个 `NamespaceReader`
2. 不要为每一个视图都单独创建 `NamespaceReader`
3. 页面级动画：

   - NamespaceReader 应放在整个页面的根节点
4. 组件级动画：

   - NamespaceReader 应包裹同一个逻辑模块
5. 同一个 namespace 内：

   - 不要复用相同的 `id` 给不相关的视图

***

## 十、适用场景总结

适合使用 `NamespaceReader` 的场景：

- 卡片 → 详情页的共享元素动画
- Tab 指示器几何联动
- 图片放大预览
- 列表项 → 详情内容过渡
- 多视图间的空间连续动画

不需要使用 `NamespaceReader` 的场景：

- 普通 opacity / scale 动画
- 单视图内部的简单过渡
- 不涉及跨视图几何同步的动画



---
url: /v2/zh/guide/Changelog/2.4.4/New List View Modifiers.md
---

# 属性概览

| 属性名                          | 类型                                                          | 系统要求      | 说明                         |
| ---------------------------- | ----------------------------------------------------------- | --------- | -------------------------- |
| `listSectionIndexVisibility` | `Visibility`                                                | iOS 26.0+ | 控制 List 右侧 Section 索引条的可见性 |
| `listSectionMargins`         | `number \| EdgeSets \| { edges: EdgeSets; length: number }` | iOS 26.0+ | 自定义 Section 边距，替换系统默认边距规则  |
| `sectionIndexLabel`          | `string`                                                    | iOS 26.0+ | 设置 Section 在索引条中的字符标签      |
| `sectionActions`             | `VirtualNode`                                               | iOS 18.0+ | 为 Section 添加自定义操作区域        |

***

# 1. listSectionIndexVisibility

```ts
/**
 * Sets the visibility of the list section index.
 * @available iOS 26.0+.
 */
listSectionIndexVisibility?: Visibility
```

### 功能说明

控制 List 的右侧索引条是否显示。常用于需要类似通讯录 A-Z 快速跳转的场景。

可选值：

- `"visible"`
- `"hidden"`
- `"automatic"`（系统自行判断）

### 示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```

***

# 2. listSectionMargins

```ts
/**
 * Set the section margins for the specific edges.
 * @available iOS 26.0+.
 */
listSectionMargins?: number | EdgeSets | {
  edges: EdgeSets
  length: number
}
```

### 功能说明

设置 Section 的外边距，完全替换系统默认边距。可使用数值、 EdgeSets，或指定边的写法。

### 三种写法说明

### 2.1 使用单一数字作为四边边距

```tsx
listSectionMargins={12}
```

### 2.2 使用 EdgeInsets

```tsx
listSectionMargins={"all"}
```

### 2.3 针对特定边设置长度

```tsx
listSectionMargins={{
  edges: "horizontal",
  length: 20
}}
```

此写法等同于 SwiftUI 中：

```swift
.listSectionMargins(.horizontal, 20)
```

### 示例

```tsx
<Section
  header={<Text>Favorites</Text>}
  listSectionMargins={{
    edges: "vertical",
    12
  }}
>
  <Text>Item A</Text>
  <Text>Item B</Text>
</Section>
```

***

# 3. sectionIndexLabel

```ts
/**
 * Sets the label that is used in a section index.
 * @available iOS 26.0+.
 */
sectionIndexLabel?: string
```

### 功能说明

为 Section 设置索引条的显示字符，一般为单字母，如 “A”、“B”、“C”。

### 示例

```tsx
<Section
  header={<Text>A</Text>}
  sectionIndexLabel="A"
>
  <Text>Adam</Text>
  <Text>Ana</Text>
</Section>
```

***

# 4. sectionActions

```ts
/**
 * Adds custom actions to a section.
 * @available iOS 18.0+
 */
sectionActions?: VirtualNode
```

### 功能说明

为 Section 添加自定义操作按钮、菜单等 UI，位置通常显示在 Section Header 区域的右侧。

### 示例：添加刷新按钮

```tsx
<Section
  header={<Text>Downloads</Text>}
  sectionActions={
    <Button title="Refresh" action={() => doRefresh()} />
  }
>
  <Text>File 1</Text>
  <Text>File 2</Text>
</Section>
```

### 示例：添加菜单动作

```tsx
<Section
  header={<Text>Photos</Text>}
  sectionActions={
    <Menu title="Actions">
      <Button title="Upload All" action={() => uploadAll()} />
      <Button title="Delete All" action={() => deleteAll()} />
    </Menu>
  }
>
  {photos.map(photo => <Text key={photo.id}>{photo.name}</Text>)}
</Section>
```

***

# 完整示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
        listSectionMargins={12}
        sectionActions={
          <Button title="Refresh" action={() => refreshGroup(group)} />
        }
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```



---
url: /v2/zh/guide/Changelog/2.4.4/Notification/index.md
---

# 通知

Scripting App 中的 `Notification` 模块用于安排、管理和展示本地通知，支持多种触发方式、交互操作按钮和富交互界面（自定义 UI）。

***

## 目录

1. [安排通知](#安排通知)
2. [通知触发器](#通知触发器)

   - [TimeIntervalNotificationTrigger](#timeintervalnotificationtrigger)
   - [CalendarNotificationTrigger](#calendarnotificationtrigger)
   - [LocationNotificationTrigger](#locationnotificationtrigger)
3. [通知操作按钮](#通知操作按钮)
4. [富通知（自定义 UI）](#富通知自定义-ui)
5. [通知管理](#通知管理)
6. [通知信息与请求结构](#通知信息与请求结构)
7. [完整示例](#完整示例)

***

## 安排通知

使用 `Notification.schedule` 来安排本地通知。它支持标题、触发器、点击行为、操作按钮、自定义 UI 和其他投递选项：

```ts
await Notification.schedule({
  title: "提醒事项",
  body: "该起身活动了！",
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 1800,
    repeats: true
  }),
  actions: [
    {
      title: "我知道了",
      icon: "checkmark",
      url: Script.createRunURLScheme("确认脚本", { acknowledged: true })
    }
  ],
  tapAction: {
    type: "runScript",
    scriptName: "确认脚本"
  },
  customUI: false
})
```

### 参数说明

| 参数名                 | 类型                                                                                                            | 说明                                          |
| ------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| `title`             | `string`                                                                                                      | 必填，通知标题。                                    |
| `subtitle`          | `string?`                                                                                                     | 可选，副标题内容。                                   |
| `body`              | `string?`                                                                                                     | 可选，正文内容。                                    |
| `iconImageData`     | `Data` \| `SystemImageIcon` \| `null`                                                                         | 可选，自定义通知图标图片的二进制数据或系统图标名称。                  |
| `badge`             | `number?`                                                                                                     | 可选，应用图标角标数字。                                |
| `silent`            | `boolean?`                                                                                                    | 可选，默认为 `false`。设为 `true` 则不播放声音静默送达。        |
| `interruptionLevel` | `"active"` \| `"passive"` \| `"timeSensitive"`                                                                | 可选，通知的重要级别和投递优先级。                           |
| `userInfo`          | `Record<string, any>?`                                                                                        | 可选，附加的自定义数据。                                |
| `threadIdentifier`  | `string?`                                                                                                     | 可选，用于通知分组的标识符。                              |
| `trigger`           | `TimeIntervalNotificationTrigger` \| `CalendarNotificationTrigger` \| `LocationNotificationTrigger` \| `null` | 可选，定义何时发送通知。                                |
| `actions`           | `NotificationAction[]?`                                                                                       | 可选，通知展开后展示的操作按钮。                            |
| `customUI`          | `boolean?`                                                                                                    | 可选，设为 `true` 可使用 `notification.tsx` 自定义 UI。 |
| `tapAction`         | `"none"` \| `{ type: "runScript", scriptName: string }` \| `{ type: "openURL", url: string }`                 | 可选，定义用户点击通知时执行的操作。                          |

#### SystemImageIcon

```ts
type SystemImageIcon = {
  systemImage: string
  color: Color
}
```

用于定义通知图标的系统图标名称和颜色。

- `systemImage`: 系统图标（SFSymbol）名称
- `color`: 图标颜色

***

### 通知操作按钮（`actions`）

通过 `actions` 参数，你可以为通知添加操作按钮。操作按钮会在通知展开后出现，用户可以点击进行操作。

#### 通知操作按钮类型（`NotificationAction`）

```ts
type NotificationAction = {
    title: string;
    icon?: string;
    url: string;
    destructive?: boolean;
}
```

- `title`: 按钮标题
- `icon`: 按钮图标
- `url`: 点击后打开的 URL
- `destructive`: 是否为破坏性操作

***

### 点击行为（`tapAction`）

通过 `tapAction` 参数，你可以完全控制用户**点击通知**时的行为：

- `"none"`：点击后无任何响应
- `{ type: "runScript", scriptName: string }`：运行指定脚本
- `{ type: "openURL", url: string }`：打开指定 URL，可为 deeplink 或 https 链接

如果不设置 `tapAction`，默认行为是运行**当前脚本**，你可以通过 `Notification.current` 获取通知内容。

***

## 通知触发器

### TimeIntervalNotificationTrigger

在指定秒数后触发通知：

```ts
new TimeIntervalNotificationTrigger({
  timeInterval: 3600,
  repeats: true
})
```

- `timeInterval`: 延迟秒数
- `repeats`: 是否重复触发
- `nextTriggerDate()`: 返回下次预期触发的时间

***

### CalendarNotificationTrigger

根据特定日期和时间触发通知：

```ts
const components = new DateComponents({ hour: 8, minute: 0 })
new CalendarNotificationTrigger({
  dateMatching: components,
  repeats: true
})
```

- 支持设置 `year`、`month`、`day`、`hour` 等
- 适用于每日、每周或特定时间提醒

***

### LocationNotificationTrigger

当进入或离开某个地理区域时触发：

```ts
new LocationNotificationTrigger({
  region: {
    identifier: "公司",
    center: { latitude: 37.7749, longitude: -122.4194 },
    radius: 100,
    notifyOnEntry: true,
    notifyOnExit: false
  },
  repeats: false
})
```

- 支持进入/离开圆形区域的触发

***

## 通知操作按钮

通过 `actions` 参数添加通知操作按钮：

```ts
actions: [
  {
    title: "查看详情",
    url: Script.createRunURLScheme("详情脚本", { fromNotification: true })
  },
  {
    title: "忽略",
    url: Script.createRunURLScheme("忽略脚本", { dismissed: true }),
    destructive: true
  }
]
```

- 使用 `Script.createRunURLScheme(...)` 创建 URL
- 按钮在长按或下拉通知时显示

***

## 富通知（自定义 UI）

你可以使用 TSX 文件定义通知的展开视图：

1. 安排通知时设置 `customUI: true`
2. 在脚本中添加 `notification.tsx` 文件
3. 使用 `Notification.present(<JSX>)` 渲染 UI

### `Notification.present(element: JSX.Element): void`

在 `notification.tsx` 中调用，用于渲染富通知界面。

***

### 示例 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function NotificationView() {
  return (
    <VStack>
      <Text>需要完成你的任务吗？</Text>
      <Button title="已完成" action={() => console.log("任务完成")} />
      <Button title="稍后提醒" action={() => console.log("稍后提醒")} />
    </VStack>
  )
}

Notification.present(<NotificationView />)
```

***

## 通知管理

| 方法名                                    | 说明              |
| -------------------------------------- | --------------- |
| `getAllDelivereds()`                   | 获取所有已送达的通知      |
| `getAllPendings()`                     | 获取所有已安排但尚未送达的通知 |
| `removeAllDelivereds()`                | 移除所有已送达的通知      |
| `removeAllPendings()`                  | 取消所有待发送通知       |
| `removeDelivereds(ids)`                | 移除指定 ID 的已送达通知  |
| `removePendings(ids)`                  | 取消指定 ID 的已安排通知  |
| `getAllDeliveredsOfCurrentScript()`    | 获取当前脚本发送的已送达通知  |
| `getAllPendingsOfCurrentScript()`      | 获取当前脚本安排的待发送通知  |
| `removeAllDeliveredsOfCurrentScript()` | 清除当前脚本的所有已送达通知  |
| `removeAllPendingsOfCurrentScript()`   | 清除当前脚本的所有待发送通知  |
| `setBadgeCount(count)`                 | 设置应用图标的角标数值     |

***

## 通知信息与请求结构

当脚本是通过点击通知启动时，可以通过 `Notification.current` 获取上下文信息：

```ts
if (Notification.current) {
  const { title, userInfo } = Notification.current.request.content
  console.log(`从通知启动：${title}`, userInfo)
}
```

### `NotificationRequest` 字段

| 字段名                        | 说明              |
| -------------------------- | --------------- |
| `identifier`               | 通知请求的唯一标识符      |
| `content.title`            | 通知标题            |
| `content.subtitle`         | 通知副标题           |
| `content.body`             | 通知正文            |
| `content.userInfo`         | 附加信息            |
| `content.threadIdentifier` | 分组标识            |
| `trigger`                  | 触发器对象，控制通知的投递逻辑 |

***

## 完整示例

以下示例展示了通知的完整用法：自定义 UI、交互按钮、点击行为、重复触发等。

### 第一步：安排通知

```ts
await Notification.schedule({
  title: "喝水提醒",
  body: "别忘了喝水哦！",
  interruptionLevel: "timeSensitive",
  iconImageData: UIImage
    .fromSFSymbol("waterbottle")!
    .withTintColor("systemBlue")!
    .toPNGData(),
  customUI: true,
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 3600,
    repeats: true
  }),
  tapAction: {
    type: "runScript",
    scriptName: "喝水记录"
  },
  actions: [
    {
      title: "已喝水",
      url: Script.createRunURLScheme("喝水记录", { drank: true }),
    },
    {
      title: "忽略",
      url: Script.createRunURLScheme("喝水记录", { drank: false }),
      destructive: true
    }
  ]
})
```

### 第二步：创建 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function HydrationUI() {
  return (
    <VStack>
      <Text>你刚刚喝水了吗？</Text>
      <Button title="是的" action={() => console.log("已确认喝水")} />
      <Button title="还没" action={() => console.log("忽略提醒")} />
    </VStack>
  )
}

Notification.present(<HydrationUI />)
```

***

## 总结

Scripting 中的 `Notification` API 提供了强大的本地通知功能：

- 支持时间、日历、位置触发器
- 支持操作按钮及跳转脚本
- 通过 `tapAction` 自定义点击通知的行为
- 使用 `notification.tsx` 创建富交互通知界面
- 提供全面的通知生命周期管理



---
url: /v2/zh/guide/Changelog/2.4.4/Notification/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Notification, Script, Section, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Notification"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
      >
        <Button
          title={"Schedule a Notification with actions"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down",
              actions: [
                {
                  title: "Widget",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "Widget",
                  })
                },
                {
                  title: "LiveActivity",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "LiveActivity",
                  })
                }
              ]
            })
          }}
        />
      </Section>

      <Section
      >
        <Button
          title={"Schedule a Notification with Rich Content"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down to show rich content.",
              customUI: true,
              userInfo: {
                title: "AudioRecorder",
                subtitle: "The interface allows you to record audio data to a file. It provides functionalities to start, stop, pause, and manage audio recordings, with configurable settings for audio quality, sample rate, format, and more.",
              }
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.4/SFTP Client.md
---

`SFTPClient` 用于通过 SSH 连接访问远程文件系统，基于 **SFTP 协议**。
它提供目录操作、文件操作、路径解析等能力，并可通过 `openFile()` 获得更强大的 `SFTPFile` 对象执行读取、写入等低层操作。

该类实例通常由：

```ts
const sftp = await ssh.openSFTP()
```

返回。

***

## 属性

### `readonly isActive: boolean`

指示当前 SFTP 连接是否仍然有效。

- `true`：连接仍然处于活跃状态
- `false`：连接已关闭或发生错误

***

## 方法

***

## `close(): Promise<void>`

关闭当前 SFTP 连接。

#### 返回值：

- `Promise<void>`：关闭成功后 resolve

#### 示例：

```ts
await sftp.close()
```

***

## `readDirectory(atPath: string): Promise<DirectoryEntry[]>`

读取指定目录下的文件与子目录。

#### 参数：

- **`atPath`**：远程目录路径

#### 返回值：

**`DirectoryEntry[]`** 数组，结构如下：

```ts
{
  filename: string
  longname: string
  attributes: {
    size?: number
    userId?: number
    groupId?: number
    accessTime?: Date
    modificationTime?: Date
    permissions?: number
  }
}[]
```

#### 示例：

```ts
const items = await sftp.readDirectory("/var/log")
```

***

## `createDirectory(atPath: string): Promise<void>`

在指定路径创建一个目录。

#### 参数：

- `atPath`：目标目录路径

#### 返回值：

- `Promise<void>`：创建成功后 resolve

#### 示例：

```ts
await sftp.createDirectory("/home/user/new-folder")
```

***

## `removeDirectory(atPath: string): Promise<void>`

删除一个目录（需为空目录）。

#### 参数：

- `atPath`：要删除的目录路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.removeDirectory("/home/user/empty-dir")
```

***

## `rename(oldPath: string, newPath: string): Promise<void>`

重命名或移动文件 / 目录。

#### 参数：

- `oldPath`：原路径
- `newPath`：目标路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.rename("/home/user/a.txt", "/home/user/b.txt")
```

***

## `getAttributes(atPath: string): Promise<FileAttributes>`

读取文件或目录的信息。

#### 返回值：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

#### 示例：

```ts
const attrs = await sftp.getAttributes("/etc/hosts")
```

***

## `openFile(filePath: string, flags: SFTPOpenFileFlags | SFTPOpenFileFlags[]): Promise<SFTPFile>`

以指定模式打开远程文件，返回 `SFTPFile` 对象进行读写。

#### 参数：

- `filePath`：文件路径
- `flags`：打开文件的模式，可为单个 flag 或数组

可用的 flag：

```
"read" | "write" | "append" | "create" | "truncate" | "forceCreate"
```

#### 返回值：

- `Promise<SFTPFile>`：一个可读写、可关闭的文件对象

#### 示例：

```ts
const file = await sftp.openFile("/home/user/log.txt", ["read"])
const data = await file.readAll()
await file.close()
```

***

## `remove(atPath: string): Promise<void>`

删除指定路径的文件。

#### 参数：

- `atPath`：要删除的文件路径

#### 示例：

```ts
await sftp.remove("/home/user/old.txt")
```

***

## `getRealPath(atPath: string): Promise<string>`

解析符号链接、相对路径、`~` 等，返回绝对路径。

#### 示例：

```ts
const real = await sftp.getRealPath("~/documents")
```

***

# 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "pass")
})

const sftp = await ssh.openSFTP()

// 查看目录内容
const list = await sftp.readDirectory("/home/user")

// 打开文件读取
const file = await sftp.openFile("/home/user/info.txt", "read")
const data = await file.readAll()
await file.close()

// 创建目录
await sftp.createDirectory("/home/user/new-folder")

// 删除文件
await sftp.remove("/home/user/temp.txt")

await sftp.close()
```



---
url: /v2/zh/guide/Changelog/2.4.4/SFTP File.md
---

`SFTPFile` 表示一个已经通过 SFTP 打开的远程文件句柄。
通过该类，你可以对文件执行读取、写入、获取属性、关闭等底层操作。

实例通常通过：

```ts
const file = await sftp.openFile(path, flags)
```

获得。

***

## 属性

***

### `readonly isActive: boolean`

指示当前文件是否仍然处于打开状态。

- `true`：文件句柄有效，可继续读写
- `false`：文件已关闭或出现错误

***

## 方法

***

# `readAttributes(): Promise<FileAttributes>`

读取文件的元数据属性。

### 返回值：

一个包含文件属性的对象：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

### 示例：

```ts
const attrs = await file.readAttributes()
console.log(attrs.size)
```

***

# `read(options?: { from?: number, length?: number }): Promise<Data>`

按指定范围读取文件内容。

### 参数：

- `from?`：读取的起始偏移（字节），默认从 `0` 开始
- `length?`：读取的字节数，默认读取到文件末尾

### 返回值：

- 一个 `Promise<Data>`，包含读取到的数据

### 示例：

```ts
const data = await file.read({ from: 100, length: 50 })
```

***

# `readAll(): Promise<Data>`

读取文件的全部内容。

### 返回值：

- 一个 `Promise<Data>`，包含完整的文件数据

### 示例：

```ts
const data = await file.readAll()
```

***

# `write(data: Data, at?: number): Promise<void>`

向文件写入数据。

### 参数：

- `data`：要写入的二进制数据
- `at?`：写入的起始偏移（字节）。

  - 若未提供，则根据 flags 的模式决定：

    - 若使用 `"append"` 打开，则追加到文件末尾
    - 若使用 `"write"` 打开，则从当前偏移或默认 0 写入

### 返回值：

- `Promise<void>`，写入成功后 resolve

### 示例：

```ts
await file.write(Data.fromRawString("Hello world"))
```

***

# `close(): Promise<void>`

关闭文件句柄。
关闭后，`isActive` 将变为 `false`，无法继续读写。

### 示例：

```ts
await file.close()
```

***

# 使用示例

```ts
// 打开文件（读取模式）
const file = await sftp.openFile("/home/user/info.txt", ["read"])

// 获取文件属性
const attrs = await file.readAttributes()

// 读取内容
const allData = await file.readAll()

// 部分读取
const partial = await file.read({ from: 50, length: 100 })

// 关闭文件
await file.close()
```



---
url: /v2/zh/guide/Changelog/2.4.4/SnippetIntent.md
---

SnippetIntent 是一种特殊类型的 AppIntent，可在 Shortcuts 中生成原生的 Snippet UI 卡片。它适用于：

- 多步骤表单式交互
- 从 Shortcuts 中获取用户输入
- 键值选择、确认、展示结果等轻量级交互
- 在 Shortcuts 工作流中内嵌 UI 组件

SnippetIntent 特点如下：

1. 在 Scripting 中必须通过 `AppIntentManager.register` 注册
2. `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
3. `perform()` 必须返回一个 `VirtualNode`（TSX UI）
4. 在脚本中必须以 `Intent.snippetIntent()` 封装后返回
5. Shortcuts 必须使用「Show Snippet Intent」动作才能显示 Snippet UI

***

# 系统要求

**SnippetIntent 只能在 iOS 26 及以上系统运行。**

在 iOS 26 以下环境：

- 无法调用 `Intent.snippetIntent`
- 无法使用 `Intent.requestConfirmation`
- Shortcuts 中不存在「Show Snippet Intent」动作
- SnippetIntent 类型的 AppIntent 不会被 Shortcuts 正常识别

***

# 注册 SnippetIntent（app\_intents.tsx）

在 `app_intents.tsx` 中声明 SnippetIntent：

```tsx
export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})
```

再例如：

```tsx
export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    return <ResultView content={content} />
  }
})
```

要求：

- `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
- `perform()` 必须返回 `VirtualNode`
- 与普通 AppIntent 区别在于返回的是 UI，而非数据

***

# SnippetIntent 返回值封装：Intent.snippetIntent

SnippetIntent 不能直接作为 JS 返回值，必须通过 `Intent.snippetIntent()` 包装成 `IntentSnippetIntentValue`。

```tsx
const snippetValue = Intent.snippetIntent({
  value: Intent.text("Some value returning for Shortcuts"),
  snippetIntent: ShowResultIntent({
    content: "Example Text"
  })
})

Script.exit(snippetValue)
```

### 类型定义

```ts
type SnippetIntentValue = {
  value?: IntentAttributedTextValue | IntentFileURLValue | IntentJsonValue | IntentTextValue | IntentURLValue | IntentFileValue | null
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>
}

declare class IntentSnippetIntentValue extends IntentValue<
  'SnippetIntent',
  SnippetIntentValue
> {
  value: SnippetIntentValue
  type: 'SnippetIntent'
}
```

封装的返回值可被 Shortcuts 的「Show Snippet Intent」动作识别并展示 UI。

***

# Snippet 确认界面：Intent.requestConfirmation

SnippetIntent 支持在执行逻辑中先请求用户确认某个操作。此能力同样基于 iOS 26。

```ts
Intent.requestConfirmation(
  actionName: ConfirmationActionName,
  intent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>
```

### ConfirmationActionName

这些名称会影响 Shortcuts UI 中呈现的文案，例如 “Set …”、“Add …”、“Toggle …” 等。

示例值：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" | 
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

### 示例

```tsx
await Intent.requestConfirmation(
  "set",
  PickColorIntent()
)
```

效果：

- Shortcuts 弹出 PickColorIntent 对应的 Snippet UI
- 用户点击确认后 Promise resolve
- 用户取消时脚本执行终止

***

# Shortcuts 的「Show Snippet Intent」动作（iOS 26+）

Shortcuts 在 iOS 26 新增动作：

**Show Snippet Intent**

用于展示 SnippetIntent 返回的 Snippet UI。

### 与其他动作对比

| Shortcuts 动作                 | 显示界面                 | 支持 SnippetIntent | 场景               |
| ---------------------------- | -------------------- | ---------------- | ---------------- |
| Run Script                   | 无 UI                 | 否                | 纯数据处理            |
| Run Script in App            | Scripting App UI（前台） | 否                | 大型 UI、文件选择等      |
| Show Snippet Intent（iOS 26+） | Snippet 卡片 UI        | 是                | SnippetIntent 场景 |

使用方式：

1. 在 Shortcuts 中添加「Show Snippet Intent」
2. 选择脚本项目（需包含 intent.tsx）
3. 脚本返回 `Intent.snippetIntent(...)`
4. Shortcuts 显示 Snippet UI

***

# IntentMemoryStorage — 跨 AppIntent 状态共享

## 1. 为什么需要 IntentMemoryStorage

由于系统行为，每次 Intent 执行后：

- AppIntent 的 `perform()` 执行完毕后立即销毁上下文
- `intent.tsx` 执行完并调用 `Script.exit()` 后脚本上下文也会完全释放

因此无法依赖 JS 变量在多个 Intent 之间保持状态。

例如：

- PickColorIntent（选择颜色）
- SetColorIntent（设置颜色）
- ShowResultIntent（展示颜色结果）

在这些 Intent 之间共享状态必须依赖持久化存储。

## 2. IntentMemoryStorage 提供轻量级、跨 Intent 的共享存储

API 定义：

```ts
namespace IntentMemoryStorage {
  function get<T>(key: string): T | null
  function set(key: string, value: any): void
  function remove(key: string): void
  function contains(key: string): boolean
  function clear(): void
  function keys(): string[]
}
```

用途：

- 存储小量状态，例如当前颜色、当前步骤、临时选项
- 在多个 AppIntent 之间共享数据
- 生命周期跨 Intent 调用，但随脚本生命周期管理

### 示例：存储用户颜色选择

```ts
IntentMemoryStorage.set("color", "systemBlue")

const color = IntentMemoryStorage.get<Color>("color")
```

### 建议

- 不要存储大型数据（如大图像、长文本）
- 大型数据请使用：

  - `Storage`（持久键值存储）
  - `FileManager` 写入 appGroupDocumentsDirectory

IntentMemoryStorage 适合作为临时状态共享，不适合当作数据库使用。

***

# 完整示例（iOS 26+）

## app\_intents.tsx

```tsx
export const SetColorIntent = AppIntentManager.register({
  name: "SetColorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async (color: Color) => {
    IntentMemoryStorage.set("color", color)
  }
})

export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})

export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    const color = IntentMemoryStorage.get<Color>("color") ?? "systemBlue"
    return <ResultView content={content} color={color} />
  }
})
```

## intent.tsx

```tsx
async function runIntent() {

  // 1. 通过 Snippet 请求用户确认颜色
  await Intent.requestConfirmation(
    "set",
    PickColorIntent()
  )

  // 2. 从 Shortcuts 输入中读取文本
  const textContent =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts"

  // 3. 创建 SnippetIntent 返回结果
  const snippetIntentValue = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: textContent })
  })

  Script.exit(snippetIntentValue)
}

runIntent()
```



---
url: /v2/zh/guide/Changelog/2.4.4/TabView.md
---

Scripting 提供了与最新 iOS TabView 体系一致的 API：
通过 `TabView`、`Tab`、`TabSection` 组织界面结构，使应用能够在 iOS 18+ 环境下完整支持多标签视图、侧边栏标签、可定制布局等。

相比旧版本依赖 `tabItem` 修饰符的方式，新的结构更加灵活、分组更清晰，并能与 TabViewCustomization 等新特性无缝配合。

***

# 一、基础结构：TabView + Tab

在最基本的形式中，`TabView` 作为容器，内部包含多个 `Tab`。
每个 `Tab` 定义：

- 标签标题
- 图标
- 标识值（value）
- 角色（如 search）
- 对应的内容视图

示例：

```tsx
function RootView() {
  const selection = useObservable<number>(0)

  return (
    <TabView selection={selection}>
      <Tab
        title="首页"
        systemImage="house.fill"
        value={0}
      >
        <HomeView />
      </Tab>

      <Tab
        title="搜索"
        systemImage="magnifyingglass"
        value={1}
        role="search"
      >
        <SearchView />
      </Tab>

      <Tab
        title="设置"
        systemImage="gearshape.fill"
        value={2}
      >
        <SettingsView />
      </Tab>
    </TabView>
  )
}
```

要点：

- `selection` 通过 Observable 控制当前激活的标签
- `value` 必须与 `selection` 的泛型类型匹配（string 或 number）
- Search Tab 可使用 `role="search"` 与搜索相关行为联动

***

# 二、使用 TabSection 组织分组标签

当 Tab 数量较多、需要按功能分类、需要在侧边栏中显示复杂结构时，可以使用 `TabSection`。

结构关系为：

```
TabView
 ├─ TabSection
 │   ├─ Tab
 │   ├─ Tab
 │   └─ ...
 ├─ TabSection
 │   ├─ Tab
 │   └─ ...
```

## 1. 使用 title 作为分组标题

```tsx
<TabView selection={selection}>
  <TabSection title="收件箱">
    <Tab title="收件箱" systemImage="tray.fill" value="inbox">
      <InboxView />
    </Tab>
    <Tab title="已发送" systemImage="paperplane.fill" value="sent">
      <SentView />
    </Tab>
  </TabSection>

  <TabSection title="标签">
    <Tab title="重要" systemImage="star.fill" value="important">
      <ImportantView />
    </Tab>
  </TabSection>
</TabView>
```

## 2. 使用 header 作为自定义组头

如需显示图标、说明文字或复合内容，可用 `header`：

```tsx
<TabSection
  header={
    <HStack spacing={8}>
      <Image systemName="folder.fill" />
      <VStack>
        <Text fontWeight="bold">项目</Text>
        <Text fontSize={12} foregroundColor="secondary">
          最近打开的项目
        </Text>
      </VStack>
    </HStack>
  }
>
  <Tab title="项目 A" systemImage="doc.fill" value="projectA">
    <ProjectAView />
  </Tab>
</TabSection>
```

***

# 三、TabSection 的高级能力：布局、操作区、拖拽与可见性

`TabSection` 提供了丰富的分组级配置，让 Tab 分组的呈现方式更加灵活。

## 1. tabPlacement（标签位置策略）

支持：

- `automatic`
- `pinned`
- `sidebarOnly`

例如将某组仅显示在侧边栏：

```tsx
<TabSection title="标签" tabPlacement="sidebarOnly">
  <Tab title="重要" systemImage="star.fill" value="important">
    <ImportantView />
  </Tab>
</TabSection>
```

## 2. sectionActions（分组操作区）

为某一组提供额外操作按钮：

```tsx
<TabSection
  title="列表"
  sectionActions={
    <Button title="添加" systemImage="plus" action={addItem} />
  }
>
  ...
</TabSection>
```

## 3. 分组可见性与可定制行为

通过：

- `defaultVisibility`
- `customizationID`
- `customizationBehavior`
- `draggable`
- `dropDestination`

可以为每个分组提供：

- 默认显示策略
- 是否允许用户自定义排序或隐藏
- 是否可以拖动
- 外部拖拽数据的处理

例如：

```tsx
<TabSection
  title="文件"
  customizationID="file-section"
  customizationBehavior="reorderable"
  draggable="file-section"
  dropDestination={items => handleDrop(items)}
>
  ...
</TabSection>
```

***

# 四、TabView 级别的高级配置

TabView 本身提供了一系列属性，可用于构建高级 UI（iOS 18～26）。

包括：

- `tabBarMinimizeBehavior`
- `tabViewBottomAccessory`
- `tabViewSearchActivation`
- `tabViewCustomization`
- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

以下为每项能力的说明。

***

## 1. tabBarMinimizeBehavior（iOS 26.0+）

控制 TabBar 是否根据滚动方向自动最小化：

- `automatic`
- `never`
- `onScrollDown`
- `onScrollUp`

示例：

```tsx
<TabView
  selection={selection}
  tabBarMinimizeBehavior="onScrollDown"
>
  ...
</TabView>
```

***

## 2. tabViewBottomAccessory（iOS 26.0+）

为 TabView 添加底部附加视图，例如提示栏：

```tsx
<TabView
  selection={selection}
  tabViewBottomAccessory={
    <HStack>
      <Text>左右滑动切换标签</Text>
      <Spacer />
      <Button title="知道了" action={dismiss} />
    </HStack>
  }
>
  ...
</TabView>
```

***

## 3. tabViewSearchActivation（iOS 26.0+）

控制搜索 Tab 的激活方式：

- `automatic`
- `searchTabSelection`

与 `role="search"` 搭配使用：

```tsx
<TabView
  selection={selection}
  tabViewSearchActivation="searchTabSelection"
>
  ...
</TabView>
```

***

## 4. 侧边栏附属视图（iOS 18.0+）

包括：

- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

示例：

```tsx
<TabView
  selection={selection}
  tabViewSidebarHeader={<UserHeader />}
  tabViewSidebarFooter={<SettingsButton />}
  tabViewSidebarBottomBar={<UpgradeButton />}
>
  ...
</TabView>
```

***

# 五、TabViewCustomization：标签页可定制化体系（重点补充）

`TabViewCustomization` 是一个可序列化的状态对象，用于存储和恢复用户对 Tab 布局的自定义行为，包括：

- Tab 分组顺序
- 分组内部的 Tab 排序
- Tab 可见性（在 TabBar 与 Sidebar 中分别独立管理）
- 重置各种设置
- 持久化与恢复

它通常放在 TabView 根视图中，通过：

```tsx
tabViewCustomization={customizationState}
```

来注入。

## 1. 创建与加载 TabViewCustomization

创建方式通常是：

```tsx
const customization = useObservable<TabViewCustomization >(() => {
  const data = Storage.get('tab_customization')
  if (data) {
    return TabViewCustomization.fromData(data) ?? new TabViewCustomization()
  }
  return new TabViewCustomization()
})

useEffect(() => {
  const listener = (newValue: TabViewCustomization) => {
    const data = newValue.toData()
    if (data) {
      Storage.set('tab_customization', data)
    }
  }
  customization.subscribe(listener)
  return () => {
    customization.unsubscribe(listener)
  }
}, [])
```

如需创建一个新的空自定义对象，可使用：

```tsx
const customizationState = useObservable(() => new TabViewCustomization())
```

## 2. 保存自定义内容

你可以将用户调整后的 Tab 布局序列化保存：

```tsx
const data = customization.value?.toData()
Storage.set('tab_customization', data)
```

`toData()` 会将内部状态转换为可存储的 `Data` 对象。

## 3. 获取并操作分组（Section）

```ts
getSection(id: string): TabViewCustomizationSection | null
```

`TabSection` 通常带有 `customizationID`，这样就可以获取特定分组并操作它：

```tsx
const section = customization.value?.getSection('file-section')

section?.tabOrder        // 一个包含 tab ID 顺序的数组，或 null
section?.resetTabOrder() // 重置排序
```

场景示例：

- 用户将“文件”分组中的 Tab 重新排序
- 用户将某些 Tab 移动到“更多”区域
- 应用需要根据用户排序更新 UI

## 4. 获取并操作单个 Tab

```ts
getTab(id: string): TabViewCustomizationTab | null
```

可通过 Tab 的 `customizationID` 获取并调整其可见性：

```tsx
const tab = customization.value?.getTab('important-tab')

tab?.tabBarVisibility         // Visibility 类型
tab.sidebarVisibility = 'hidden'
```

适用场景：

- 控制 Tab 在 TabBar 或 Sidebar 中是否显示
- 用户可通过自定义界面操作 Tab 可见性
- 程序自动隐藏某些 Tab

## 5. 全局重置

```ts
resetSectionOrder(): void
resetVisibility(): void
```

通常用于：

- 点击“恢复默认布局”按钮
- 版本更新后清理已有布局逻辑

示例：

```tsx
<Button
  title="恢复默认"
  action={() => {
    customization.value?.resetSectionOrder()
    customization.value?.resetVisibility()
  }}
/>
```

***

# 六、与旧的 tabItem 写法的关系

此文档采用全新的结构化写法：

- TabView
- Tab
- TabSection
- TabViewCustomization

旧的 `tabItem` 写法仍可用于简单场景以及兼容iOS 17，但与侧边栏、Tab 分组、自定义布局等高级能力不兼容。
在复杂应用中，建议全面迁移到新的组件体系。



---
url: /v2/zh/guide/Changelog/2.4.4/Use with Toolbar Component.md
---

Scripting 的工具栏系统不仅支持直接在 `toolbar` 属性中传入 `ToolBarProps` 对象，也支持使用与 SwiftUI 结构一致的 `<Toolbar>`、`<ToolbarItem>`、`<ToolbarItemGroup>`、`<ToolbarSpacer>`、`<DefaultToolbarItem>` 等组件，构建更灵活、更强大的导航栏和工具栏布局。

这些组件能够提供更精细的控制，允许开发者像 SwiftUI 一样以声明式方式编排工具栏内容，并为复杂布局提供更高可读性和可维护性。

***

# 基本概念

工具栏组件始终通过视图的 `toolbar` 属性使用：

```tsx
<List
  toolbar={
    <Toolbar>
      {/* 工具栏项 */}
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

`toolbar` 可以接受：

- `ToolBarProps` 对象（与原机制一致）
- `VirtualNode`（必须为 `<Toolbar>` 组件）

使用 `<Toolbar>` 时，所有内容都通过 `<ToolbarItem>` 系列组件明确定义位置和呈现方式。

***

# Toolbar

`Toolbar` 组件是工具栏的容器，用于包含多个工具栏项。它本身不定义位置，内部的 `ToolbarItem` 或 `ToolbarItemGroup` 决定实际布局。

## 用法示例

```tsx
<List
  toolbar={
    <Toolbar>
      <ToolbarItem placement="topBarLeading">
        <Button title="关闭" action={() => dismiss()} />
      </ToolbarItem>
      <ToolbarItem placement="topBarTrailing">
        <Button title="完成" action={() => handleDone()} />
      </ToolbarItem>
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

***

# ToolbarItem

`ToolbarItem` 表示放置在工具栏指定位置的单个项目。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明                                                       |
| ----------- | ---------------------- | ----------- | -------------------------------------------------------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 指定工具栏位置，如 `topBarLeading`、`navigation`、`primaryAction` 等 |
| `children`  | `VirtualNode`          | 无           | 工具栏项的实际内容，例如按钮或文本                                        |

## 示例

```tsx
<Toolbar>
  <ToolbarItem placement="navigation">
    <Button title="返回" action={Navigation.useDismiss()} />
  </ToolbarItem>
</Toolbar>
```

***

# ToolbarItemGroup

`ToolbarItemGroup` 用于在同一位置放置多个工具栏项目，所有子项目将作为一组呈现。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明      |
| ----------- | ---------------------- | ----------- | ------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 工具栏位置   |
| `children`  | 多个 VirtualNode         | 无           | 多个工具栏元素 |

## 示例

```tsx
<Toolbar>
  <ToolbarItemGroup placement="topBarTrailing">
    <Button title="刷新" action={reload} />
    <Button title="更多" action={openMenu} />
  </ToolbarItemGroup>
</Toolbar>
```

***

# ToolbarSpacer

`ToolbarSpacer` 用于在工具栏项之间添加空白区域，适合需要自定义布局的场景。

## 参数说明

| 参数          | 类型                      | 默认值         | 说明                   |
| ----------- | ----------------------- | ----------- | -------------------- |
| `sizing`    | `'fixed' \| 'flexible'` | `flexible`  | 控制 Spacer 是否固定大小或可伸缩 |
| `placement` | `ToolbarItemPlacement`  | `automatic` | Spacer 所在位置          |

### 行为说明

- `flexible`: 工具栏中的弹性空间，它会占据剩余区域。
- `fixed`: 提供固定间隔，适合多个按钮之间进行细微布局。

## 示例：在同一组中强制按钮分隔

```tsx
<Toolbar>
  <ToolbarItem placement="topBarTrailing">
    <Button title="Edit" action={edit} />
  </ToolbarItem>
  <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
  <ToolbarItem placement="topBarTrailing">
    <Button title="Save" action={save} />
  </ToolbarItem>
</Toolbar>
```

***

# DefaultToolbarItem

```ts
type ToolbarDefaultItemKind = "sidebarToggle" | "search" | "title";

type DefaultToolbarItemProps = {
  kind: ToolbarDefaultItemKind;
  placement?: ToolbarItemPlacement;
};

declare const DefaultToolbarItem: FunctionComponent<DefaultToolbarItemProps>;
```

用于渲染系统提供的默认工具栏项目，例如侧边栏切换按钮、搜索按钮、标题显示等。

## 参数说明

| 参数          | 类型                                       | 默认值         | 说明         |
| ----------- | ---------------------------------------- | ----------- | ---------- |
| `kind`      | `"sidebarToggle" \| "search" \| "title"` | 无           | 选择系统默认项目类型 |
| `placement` | `ToolbarItemPlacement`                   | `automatic` | 放置位置       |

## 示例：添加默认的搜索栏按钮

```tsx
<Toolbar>
  <DefaultToolbarItem kind="search" placement="topBarTrailing" />
</Toolbar>
```

***

# 综合示例：使用 Toolbar 构建复杂工具栏

```tsx
<NavigationStack>
  <List
    toolbar={
      <Toolbar>

        {/* 左侧导航按钮 */}
        <ToolbarItem placement="navigation">
          <Button title="返回" action={Navigation.useDismiss()} />
        </ToolbarItem>

        {/* 标题 */}
        <DefaultToolbarItem kind="title" />

        {/* 右侧一组按钮 */}
        <ToolbarItem placement="topBarTrailing">
          <Button title="编辑" action={edit} />
        </ToolbarItem>
        <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
        <ToolbarItem placement="topBarTrailing">
          <Button title="完成" action={finish} />
        </ToolbarItem>

        {/* 底部区域按钮 */}
        <ToolbarItem placement="bottomBar">
          <Button title="帮助" action={showHelp} />
        </ToolbarItem>

      </Toolbar>
    }
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

此结构灵活而清晰，可复现 SwiftUI 中复杂的工具栏布局。

***

# 与 ToolBarProps 的关系

在 API 层面：

| 方式                                          | 说明                  |
| ------------------------------------------- | ------------------- |
| `toolbar={ { topBarTrailing: <Button/> } }` | 简洁、直观，适合简单场景        |
| `toolbar={<Toolbar>...</Toolbar>}`          | 可组合，可精确布局，适合复杂、多组内容 |

两种方式完全兼容，可根据需要选择。

***

# 总结

Toolbar 组件提供了高度灵活的工具栏布局能力，包括：

- 单项工具栏项 (`ToolbarItem`)
- 工具栏项目组 (`ToolbarItemGroup`)
- 自适应空白区域 (`ToolbarSpacer`)
- 系统默认工具栏元素 (`DefaultToolbarItem`)
- 容器式声明 (`<Toolbar>`)



---
url: /v2/zh/guide/Changelog/2.4.4/matchedGeometryEffect.md
---

# 匹配几何效果（matchedGeometryEffect）

`matchedGeometryEffect` 用于在 **不同视图之间建立几何关联关系**，使视图在：

- 位置变化
- 尺寸变化
- 布局层级变化
- 条件渲染切换

这些场景中，仍然保持 **连续、平滑、空间一致的动画过渡效果**。

该能力对应 SwiftUI 中的 `matchedGeometryEffect`，属于 **组件级几何联动动画系统**，不依赖导航系统。

***

## 一、API 定义

```ts
matchedGeometryEffect?: {
  id: string | number
  namespace: NamespaceID
  properties?: MatchedGeometryProperties
  anchor?: Point | KeywordPoint
  isSource?: boolean
}
```

```ts
type MatchedGeometryProperties = "frame" | "position" | "size"
```

***

## 二、核心作用

`matchedGeometryEffect` 的核心作用是：

> 让两个“逻辑上是同一个元素”的视图，在 **不同布局结构中共享几何信息**，从而产生连续的过渡动画。

它解决的问题包括：

- 视图从一个容器移动到另一个容器时的“跳变”
- 视图尺寸变化时的“突变”
- 列表项展开为详情页时的“断层感”
- Tab 切换指示器的“瞬移感”

***

## 三、参数详解

### 1. id（几何匹配唯一标识）

```ts
id: string | number
```

- 用于标识这是 **哪一个几何元素**
- 在同一个 `namespace` 下：

  - **id 相同的视图才会参与几何匹配**
- 通常来自：

  - 数据模型 ID
  - 索引值
  - 业务唯一标识

规则：

- id 必须稳定
- 动画期间不能频繁变化
- 同一时刻：

  - 一个 id 只能有一个 `isSource = true`

***

### 2. namespace（几何命名空间）

```ts
namespace: NamespaceID
```

- 用于将多个匹配动画分组隔离
- 不同 namespace 之间：

  - 即使 id 相同，也不会产生动画
- 必须由 `NamespaceReader` 创建并注入

规则：

- source 与 target 必须使用 **同一个 namespace**
- 不允许跨 namespace 匹配

***

### 3. properties（参与匹配的几何属性）

```ts
properties?: "frame" | "position" | "size"
```

默认值：

```ts
properties = "frame"
```

含义说明：

| 值            | 含义          |
| ------------ | ----------- |
| `"frame"`    | 同时匹配位置 + 尺寸 |
| `"position"` | 仅匹配中心点位置    |
| `"size"`     | 仅匹配尺寸，不匹配位置 |

选择原则：

- `"frame"`：最完整、最自然的动画
- `"position"`：指示器、滑块、选中背景
- `"size"`：放大缩小、展开收起

***

### 4. anchor（锚点）

```ts
anchor?: Point | KeywordPoint
```

默认值：

```ts
anchor = "center"
```

作用：

- 决定动画进行时：

  - 元素是从哪个相对位置进行对齐和计算的

常见取值：

- `"center"`
- `"topLeading"`
- `"topTrailing"`
- `"bottomLeading"`
- `"bottomTrailing"`

使用场景：

- 卡片从左上角展开
- 头像从右上角放大
- 底部元素向上弹出

***

### 5. isSource（是否作为几何数据的“源”）

```ts
isSource?: boolean
```

默认值：

```ts
isSource = true
```

含义说明：

| 值       | 行为             |
| ------- | -------------- |
| `true`  | 当前视图向外“提供”几何数据 |
| `false` | 当前视图“接收”几何动画结果 |

标准使用模式：

- 原始视图：`isSource = true`
- 目标视图：`isSource = false`

如果省略：

- 第一个出现的视图默认作为 source
- 其余作为接收方

***

## 四、最小可用示例（位置 + 尺寸联动）

该示例演示：
一个圆形在两个区域之间切换位置与尺寸，并保持连续动画。

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <VStack spacing={40}>
      <Button
        title="Toggle"
        action={() => {
          expanded.setValue( !expanded.value)
        }}
      />

      <ZStack
        frame={{ width: 300, height: 200 }}
        background="systemGray6"
      >
        {!expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 60, height: 60 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace
            }}
          />
        )}
      </ZStack>

      <ZStack
        frame={{ width: 300, height: 300 }}
        background="systemGray4"
      >
        {expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 150, height: 150 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace,
              isSource: false
            }}
          />
        )}
      </ZStack>
    </VStack>
  )}
</NamespaceReader>
```

该示例实现的动画效果：

- 同一个圆：

  - 从上方小尺寸区域
  - 平滑移动并放大到下方大区域
- 无跳变、无突变、无瞬移

***

## 五、仅同步“位置”的示例（指示器动画）

```tsx
const selected = useObservable(0)

return <NamespaceReader>
  {namespace => (
    <HStack spacing={24}>
      <Text
        onTapGesture={() => selected.setValue(0)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 0
        }}
      >
        Tab 1
      </Text>

      <Text
        onTapGesture={() => selected.setValue(1)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 1
        }}
      >
        Tab 2
      </Text>
    </HStack>
  )}
</NamespaceReader>
```

适用于：

- Tab 选中动画
- 滑块指示器
- 选中背景平移

***

## 六、仅同步“尺寸”的示例（放大缩小）

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <ZStack>
      <Circle
        fill="systemBlue"
        frame={{
          width: expanded.value ? 200 : 80,
          height: expanded.value ? 200 : 80
        }}
        matchedGeometryEffect={{
          id: "avatar",
          namespace,
          properties: "size"
        }}
        onTapGesture={() => {
          expanded.setValue(!expanded.value)
        }}
      />
    </ZStack>
  )}
</NamespaceReader>
```

适用于：

- 头像放大
- 卡片展开
- 按钮按压动画

***

## 七、多元素联动示例（卡片 → 详情）

```tsx
<NamespaceReader>
  {namespace => (
    <ZStack>
      {!showDetail.value && (
        <VStack spacing={16}>
          <Image
            source="cover"
            matchedGeometryEffect={{
              id: "card.image",
              namespace
            }}
          />
          <Text
            matchedGeometryEffect={{
              id: "card.title",
              namespace
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}

      {showDetail.value && (
        <VStack spacing={24}>
          <Image
            source="cover"
            frame={{ width: 300, height: 200 }}
            matchedGeometryEffect={{
              id: "card.image",
              namespace,
              isSource: false
            }}
          />
          <Text
            font="largeTitle"
            matchedGeometryEffect={{
              id: "card.title",
              namespace,
              isSource: false
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}
    </ZStack>
  )}
</NamespaceReader>
```

效果说明：

- 图片与标题同时参与几何匹配
- 从卡片形态平滑过渡为详情页布局
- 无需使用导航动画

***

## 八、关键使用规则总结

1. **namespace 必须完全相同**
2. **id 必须完全一致**
3. 同一时刻：

   - 一个 id 只能有一个 `isSource = true`
4. 默认行为：

   ```ts
   properties = "frame"
   anchor = "center"
   isSource = true
   ```
5. source 与 target 必须：

   - 同一渲染周期内完成切换
6. 如果 source 和 target：

   - 同时存在，且都为 `isSource = true`
     → 动画不确定，可能失效
7. Widget 与 Live Activity 环境不支持完整 matchedGeometry 动画能力

***

## 九、适用场景总结

适合使用 `matchedGeometryEffect` 的场景：

- Tab 指示器动画
- 卡片 → 详情展开
- 图片放大预览
- 列表项选中动画
- 分栏布局中的选中项切换

不适合使用的场景：

- 高频数据刷新列表
- 大量同时进行几何动画的复杂视图树
- 帧率敏感的实时图表



---
url: /v2/zh/guide/Changelog/2.4.4/matchedTransitionSource.md
---

# 匹配过渡源（matchedTransitionSource）

`matchedTransitionSource` 用于 **标记某个视图作为“导航转场动画的几何源视图”**，使该视图在页面跳转时可以作为：

- 缩放动画的起点
- 位置过渡的起点
- 共享几何动画的起始帧

该能力对应 SwiftUI 中的 `matchedTransitionSource`，主要用于：

- 页面级导航动画
- Zoom（缩放）转场
- Hero 动画（共享元素转场）

它 **只用于导航转场**，不用于组件级几何联动（组件级联动应使用 `matchedGeometryEffect`）。

***

## 一、API 定义

```ts
/**
 * Identifies this view as the source of a navigation transition, such as a zoom transition.
 * @available iOS 18.0+
 */
matchedTransitionSource?: {
  id: string | number
  namespace: NamespaceID
}
```

***

## 二、核心作用

`matchedTransitionSource` 的核心作用是：

> 在一次导航跳转中，指定“从哪个视图开始做几何过渡动画”。

它解决的问题是：

- 页面跳转时视图“瞬间消失 + 新页面突然出现”的割裂感
- 图片、卡片、头像等元素在跳转时缺乏空间连续性
- 无法实现从“点击的那个元素”缩放进入目标页面的效果

通过 `matchedTransitionSource`，可以实现典型的：

- 图片 → 图片详情页的缩放动画
- 卡片 → 详情页的 Hero 动画
- 头像 → 个人主页的放大过渡

***

## 三、参数详解

### 1. id（转场源唯一标识）

```ts
id: string | number
```

含义：

- 标识“这是哪一个转场源视图”
- 必须与目标页面中 `navigationTransition.sourceID` 完全一致

规则：

- 同一个 `namespace` 内：

  - `id` 必须唯一
- 一次导航转场中：

  - 只能有一个 `matchedTransitionSource` 与 `sourceID` 对应

***

### 2. namespace（转场命名空间）

```ts
namespace: NamespaceID
```

含义：

- 用于把“源视图”和“目标页面”放入同一个转场作用域
- 由 `NamespaceReader` 创建并注入

规则：

1. 源视图与目标页面 **必须使用同一个 namespace**
2. 不同 namespace 之间 **绝对不会发生转场匹配**
3. 即使 `id` 相同，只要 namespace 不同，也不会触发动画

***

## 四、matchedTransitionSource 的工作机制

一次完整的导航缩放转场，必须同时满足以下四个条件：

1. **源视图定义了 `matchedTransitionSource`**
2. **目标页面定义了 `navigationTransition`**
3. **`sourceID === matchedTransitionSource.id`**
4. **两者使用的是同一个 `namespace`**

只有在这四个条件全部满足时，系统才会：

- 读取源视图的：

  - 真实 Frame
  - 屏幕位置
  - 缩放比例
- 读取目标页面的最终布局 Frame
- 自动计算：

  - 初始缩放比例
  - 平移路径
  - 最终尺寸
- 并生成完整的缩放过渡动画

***

## 五、最小可用示例：图片缩放进入详情页

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        frame={{
          width: 120,
          height: 160
        }}
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

### 该示例实现的效果

1. 用户点击封面图片
2. 页面开始跳转到 `DetailPage`
3. 新页面并不是“直接出现”
4. 而是：

   - 从点击的那张图片位置开始
   - 按比例放大
   - 平滑过渡到详情页的最终布局

***

## 六、卡片 → 详情页 Hero 动画示例

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "card-1"
          }}
        />
      }
    >
      <VStack
        frame={{
          width: 280,
          height: 180
        }}
        background="systemGray6"
        matchedTransitionSource={{
          id: "card-1",
          namespace
        }}
      >
        <Text>Card Title</Text>
      </VStack>
    </NavigationLink>
  )}
</NamespaceReader>
```

该示例实现：

- 整个卡片作为转场起点
- 跳转后卡片“变形为”详情页容器
- 具备典型的 Hero 动画特征

***

## 七、matchedTransitionSource 与 matchedGeometryEffect 的本质区别

| 对比项             | matchedTransitionSource | matchedGeometryEffect |
| --------------- | ----------------------- | --------------------- |
| 使用场景            | 页面级导航转场                 | 组件级几何联动               |
| 是否依赖 Navigation | 是                       | 否                     |
| 是否支持多个元素同步      | 否                       | 是                     |
| 是否需要 sourceID   | 是                       | 否                     |
| 是否控制 properties | 否                       | 是                     |
| 是否支持布局内动画       | 否                       | 是                     |

一句话总结：

- `matchedTransitionSource`：**只负责“从哪儿开始跳页面”**
- `matchedGeometryEffect`：**负责“布局内部怎么动”**

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- `sourceID` 是否与 `matchedTransitionSource.id` 完全一致
- 是否使用了同一个 `namespace`
- 是否真的发生了 `NavigationLink` 跳转

***

### 2. 动画方向异常或缩放错位

常见原因：

- 源视图有 `scaleEffect`、`offset` 等变换
- 源视图所在的容器使用了：

  - `clipShape`
  - `mask`
  - `containerShape`

这些变换会影响系统获取“真实几何 Frame”。

***

### 3. 同时存在多个 source

错误示例：

- 同一个页面中：

  - 多个视图都使用了相同 `id`
  - 且都设置了 `matchedTransitionSource`

后果：

- 系统无法判定哪个才是转场源
- 动画结果不可预测

***

## 九、使用限制说明

1. `matchedTransitionSource` 仅适用于：

   - `NavigationLink`
   - 基于 Navigation 的页面跳转
2. 在以下环境中不支持或行为受限：

   - Widget
   - Live Activity
3. 不适用于：

   - 组件内部状态切换
   - tab 切换
   - 展开折叠菜单

这些场景应使用 `matchedGeometryEffect`。

***

## 十、适用场景总结

非常适合使用 `matchedTransitionSource` 的场景：

- 图片点击 → 图片详情页
- 文章封面 → 阅读页
- 商品卡片 → 商品详情页
- 用户头像 → 个人主页
- 卡片列表 → 大卡详情页

不适合使用的场景：

- 高频切换的 UI 状态
- 大量小组件同时动画
- 实时刷新型界面



---
url: /v2/zh/guide/Changelog/2.4.5/AVPlayerView.md
---

# 视频播放组件(AVPlayerView)

`AVPlayerView` 是 Scripting 提供的视频播放组件，基于系统原生 `AVPlayerViewController` 封装。
与 `VideoPlayer` 不同，`AVPlayerView` **完整支持系统级 Picture in Picture（画中画，PiP）**，并允许脚本层监听 PiP 的生命周期变化。

该组件适用于对**原生播放行为、后台播放、PiP、锁屏与控制中心联动**有明确需求的媒体类场景。

***

## 一、何时使用 AVPlayerView

当你的场景满足以下任意条件时，应使用 `AVPlayerView`：

- 需要视频进入系统 PiP 模式
- 需要原生播放控制 UI
- 需要在后台持续播放视频
- 需要与系统 Now Playing / 锁屏 / 控制中心联动
- 需要精确感知 PiP 的开始与结束

如果仅做简单的视频展示且不需要 PiP，`VideoPlayer` 仍然是更轻量的选择。

***

## 二、核心属性详解

### 1. `player`

```ts
player: AVPlayer
```

- 实际执行播放的核心对象
- 由开发者自行创建和管理
- 支持网络视频、本地文件、HLS 等格式

`AVPlayerView` **不会管理播放器的生命周期**，播放器在 PiP 期间必须保持存活。

***

### 2. `pipStatus`

```ts
pipStatus: Observable<PIPStatus>
```

用于监听系统 PiP 的生命周期状态变化。

可能的取值如下：

| 状态                 | 含义            |
| ------------------ | ------------- |
| `willStart`        | PiP 即将开始      |
| `didStart`         | PiP 已开始       |
| `willStop`         | PiP 即将结束      |
| `didStop`          | PiP 已结束       |
| `undefined / null` | 尚未进入 PiP 生命周期 |

该状态完全由系统控制，**只能监听，不应手动修改**。

***

## 三、PiP 相关配置项

### 1. `allowsPictureInPicturePlayback`

```ts
allowsPictureInPicturePlayback?: boolean
```

- 是否允许视频进入 PiP
- 默认值：`true`

若设为 `false`：

- 系统 PiP 按钮不会显示
- 视频无法进入画中画模式

***

### 2. `canStartPictureInPictureAutomaticallyFromInline`

```ts
canStartPictureInPictureAutomaticallyFromInline?: boolean
```

- 当应用从前台切换到后台时，是否自动进入 PiP
- 默认值：`false`

适合以下场景：

- 用户按下 Home 键离开应用
- 希望播放不中断并自动进入 PiP

***

### 3. `updatesNowPlayingInfoCenter`

```ts
updatesNowPlayingInfoCenter?: boolean
```

- 是否自动更新系统 Now Playing 信息
- 默认值：`true`

开启后，视频信息会显示在：

- 锁屏界面
- 控制中心
- 外接播放设备

***

## 四、全屏播放行为

### 1. `entersFullScreenWhenPlaybackBegins`

```ts
entersFullScreenWhenPlaybackBegins?: boolean
```

- 播放开始时是否自动进入全屏
- 默认值：`false`

***

### 2. `exitsFullScreenWhenPlaybackEnds`

```ts
exitsFullScreenWhenPlaybackEnds?: boolean
```

- 播放结束时是否自动退出全屏
- 默认值：`false`

***

## 五、视频显示方式（videoGravity）

```ts
videoGravity?: AVLayerVideoGravity
```

| 值                  | 行为说明           |
| ------------------ | -------------- |
| `resize`           | 拉伸填满，不保持比例     |
| `resizeAspect`     | 保持比例，完整显示（默认）  |
| `resizeAspectFill` | 保持比例，填满区域，可能裁剪 |

***

## 六、完整 DEMO 示例

以下示例演示了：

- 创建并配置 `AVPlayer`
- 正确配置音频会话
- 监听 PiP 生命周期
- 控制播放 / 暂停
- 正确释放资源

```tsx
function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(
    TimeControlStatus.paused
  )
  const pipstatus = useObservable<PIPStatus>()

  console.log(pipstatus.value)

  const player = useMemo(() => {
    const player = new AVPlayer()

    player.setSource(
      "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
    )

    player.onTimeControlStatusChanged = status => {
      setStatus(status)
    }

    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      "playback",
      ["defaultToSpeaker"]
    )

    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="VideoPlayer"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        cancellationAction: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <AVPlayerView
        player={player}
        pipStatus={pipstatus}
        canStartPictureInPictureAutomaticallyFromInline
        updatesNowPlayingInfoCenter
        entersFullScreenWhenPlaybackBegins
      />

      <Button
        title={
          status === TimeControlStatus.paused
            ? "Play"
            : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 七、PiP 生命周期说明

PiP 状态通常按以下顺序变化：

1. `willStart`
2. `didStart`
3. PiP 运行中
4. `willStop`
5. `didStop`

在异常或系统打断情况下，部分状态可能被跳过，因此应以 `didStart` 和 `didStop` 作为最终判断依据。

***

## 八、重要注意事项

### 1. AVPlayerView 使用的是系统级视频 PiP

- 基于系统原生视频 PiP
- 与 Scripting 的自定义 PiP View Modifiers **完全不同**
- 两种 PiP 机制不可混用

***

### 2. PiP 依赖正确的音频会话配置

要保证 PiP 正常工作，必须：

- 激活音频会话
- 使用 `playback` 类别
- 正确配置后台音频能力

否则可能出现 PiP 无法启动或静默失败的情况。

***

### 3. PiP 期间不要销毁 AVPlayer

- PiP 运行中销毁或替换 `AVPlayer`
- 会导致 PiP 异常退出
- 甚至触发系统错误

应在 `pipStatus` 变为 `didStop` 后再释放播放器资源。

***

## 九、推荐实践总结

- 视频 PiP 场景始终使用 `AVPlayerView`
- 将 `pipStatus` 视为只读状态
- PiP 期间保持 `AVPlayer` 生命周期稳定
- 显式配置音频会话
- 避免频繁创建或替换播放器
- 在 PiP 完全结束后再释放资源



---
url: /v2/zh/guide/Changelog/2.4.5/AppStore.md
---

# AppStore

`AppStore` API 用于在 **不离开 Scripting 应用** 的情况下，展示 App Store 中某个应用的详情页面。
该能力基于系统原生的 App Store 展示组件，适合用于实现 **应用推荐、应用收藏夹、关联应用跳转、生态扩展入口** 等场景。

***

## 命名空间：`AppStore`

```ts
namespace AppStore
```

***

## 功能概述

- 在 Scripting App 内以 **模态窗口（Modal）** 方式展示指定 App 的 App Store 页面
- 用户可直接查看应用介绍、截图、评分、更新日志
- 用户可在该页面中完成 **下载 / 更新 / 打开应用**
- 关闭后自动返回当前脚本页面
- 不会跳转到系统 App Store 应用

***

## 方法一览

| 方法                       | 说明                      |
| ------------------------ | ----------------------- |
| `presentApp(id: string)` | 打开指定 App 的 App Store 页面 |
| `dismissApp()`           | 主动关闭当前展示的 App Store 页面  |

***

## 方法说明

### `presentApp(id: string): Promise<void>`

在 Scripting App 内展示指定 App 的 App Store 页面。

#### 参数

| 参数   | 类型       | 说明                              |
| ---- | -------- | ------------------------------- |
| `id` | `string` | App 的 **App Store 标识符（App ID）** |

- 该 ID 是 App Store 中的数字 ID
- 通常可从 App Store URL 中获取
  例如：
  `https://apps.apple.com/app/id123456789`
  则 `id` 为 `"123456789"`

#### 返回值

- 返回一个 `Promise<void>`
- 当用户 **关闭 App Store 模态页面** 时，Promise resolve
- 如果当前已经有一个 App Store 页面在展示中，则会抛出错误

#### 行为说明

- 以模态方式打开 App Store 页面
- 同一时间 **只能存在一个 App Store 模态窗口**
- 如果重复调用 `presentApp`，将导致 Promise reject

#### 示例

```ts
await AppStore.presentApp("123456789")
```

***

### `dismissApp(): Promise<void>`

关闭当前通过 `presentApp` 打开的 App Store 页面。

#### 返回值

- 返回一个 `Promise<void>`
- 当模态页面成功关闭后 resolve

#### 使用说明

- 一般情况下不需要手动调用
- 适用于：

  - 自定义 UI 控制关闭行为
  - 脚本中需要在特定逻辑点强制关闭 App Store 页面

#### 示例

```ts
await AppStore.dismissApp()
```

***

## 使用示例

### 示例一：应用推荐入口

```ts
import { Button } from "scripting"

function AppRecommendation() {
  return (
    <Button
      title="查看推荐应用"
      action={() => {
        AppStore.presentApp("123456789")
      }}
    />
  )
}
```

***

### 示例二：应用收藏夹

```ts
const favoriteApps = [
  { name: "App A", id: "123456789" },
  { name: "App B", id: "987654321" }
]

function AppList() {
  return favoriteApps.map(app => (
    <Button
      title={app.name}
      action={() => {
        AppStore.presentApp(app.id)
      }}
    />
  ))
}
```

***

## 错误与注意事项

### 常见错误

- **已有 App Store 页面正在展示**

  - 再次调用 `presentApp` 会抛出错误
  - 建议在逻辑层控制调用时机

### 使用限制

- 仅支持 App Store 应用页面
- 不支持展示订阅页、开发者主页等其他 App Store 内容
- 必须传入有效的 App Store App ID



---
url: /v2/zh/guide/Changelog/2.4.5/Assistant/Assistant Conversation APIs.md
---

# 智能助手会话 API

Conversation API 用于**启动、控制和展示一个由系统托管的 Assistant 对话会话**。
该会话对应一个**完整的聊天页面（Chat Page）**，由 Scripting App 统一管理 UI、状态和模型交互。

与 `requestStreaming` / `requestStructuredData` 的区别在于：

- Conversation API 面向**交互式聊天体验**
- 系统负责消息发送、流式输出、Provider 切换、UI 渲染
- 开发者只需关注“何时开始 / 何时结束 / 是否展示”

***

## 会话生命周期概览

一个典型的会话生命周期如下：

1. `startConversation` —— 创建会话（可选自动开始）
2. `present` —— 展示 Assistant 聊天页面
3. 用户与 Assistant 进行交互
4. `dismiss` —— 临时关闭聊天页面（会话仍存在）
5. `present` —— 再次展示会话
6. `stopConversation` —— 结束会话并释放资源

重要约束：

- **同一时间只能存在一个活动会话**
- 若已有会话在运行，再次调用 `startConversation` 会抛出错误
- 调用 `stopConversation` 会自动触发 `dismiss`

***

## startConversation

### API 定义

```ts
function startConversation(options: {
  message: string
  images?: UIImage[]
  autoStart?: boolean
  systemPrompt?: string
  modelId?: string
  provider?: Provider
}): Promise<void>
```

***

### 参数说明

#### options.message

- 类型：`string`
- 必填
- 会话的**初始用户消息**
- 相当于聊天页面中的第一条用户输入

***

#### options.images（可选）

- 类型：`UIImage[]`
- 会与 `message` 一起作为首条用户消息发送
- 适用于：

  - 图片分析
  - 拍照 / 截图后直接发起对话

***

#### options.autoStart（可选）

- 类型：`boolean`
- 默认值：`false`

行为说明：

- `true`：

  - 创建会话后立即开始生成回复
- `false`：

  - 仅创建会话，不自动发送
  - 通常配合 `present` 使用，由用户点击发送

***

#### options.systemPrompt（可选）

- 类型：`string`

说明：

- 若未提供：

  - 使用 Scripting Assistant 内置 system prompt
  - Assistant Tools 可用
- 若提供：

  - 完全替换默认 system prompt
  - **Assistant Tools 将不可用**

适用场景：

- 构建高度定制的聊天角色
- 禁用工具调用，仅使用纯模型能力

***

#### options.modelId（可选）

- 类型：`string`
- 指定本次会话使用的模型
- 用户仍可在聊天页面中手动切换模型（若 UI 允许）

***

#### options.provider（可选）

- 类型：`Provider`
- 指定默认 Provider
- 用户可在聊天页面中更改 Provider（若 UI 允许）

***

### 返回值

```ts
Promise<void>
```

- 会话创建成功即 resolve
- 若已有会话存在，将 reject

***

## present

### API 定义

```ts
function present(): Promise<void>
```

***

### 行为说明

- 展示当前会话对应的 Assistant 聊天页面
- 若页面已展示，调用不会产生额外效果
- 可在以下场景调用：

  - `startConversation` 之后首次展示
  - `dismiss` 后重新展示同一会话

***

### 返回值

```ts
Promise<void>
```

- 当聊天页面被用户关闭时 resolve

***

## dismiss

### API 定义

```ts
function dismiss(): Promise<void>
```

***

### 行为说明

- 关闭 Assistant 聊天页面
- **不会终止会话**
- 会话状态、历史消息仍保留

适用场景：

- 临时让出界面空间
- 页面跳转或多任务切换

***

### 返回值

```ts
Promise<void>
```

- 页面成功关闭后 resolve

***

## stopConversation

### API 定义

```ts
function stopConversation(): Promise<void>
```

***

### 行为说明

- 彻底终止当前会话
- 自动调用 `dismiss`
- 清理会话状态与资源
- 结束后可再次调用 `startConversation` 创建新会话

***

### 返回值

```ts
Promise<void>
```

***

## 会话状态相关常量

### Assistant.isAvailable

```ts
const isAvailable: boolean
```

- 表示当前用户是否**具备使用 Assistant 的权限**
- 若为 `false`：

  - 所有 Conversation API 均不可用

***

### Assistant.isPresented

```ts
const isPresented: boolean
```

- 表示 Assistant 聊天页面当前是否处于展示状态

***

### Assistant.hasActiveConversation

```ts
const hasActiveConversation: boolean
```

- 表示当前是否存在一个活动会话
- 常用于防止重复调用 `startConversation`

***

## 使用示例

### 示例一：最常见的使用方式

```ts
await Assistant.startConversation({
  message: "帮我总结这篇文章的要点",
  autoStart: true
})

await Assistant.present()
```

***

### 示例二：创建会话但不自动发送

```ts
await Assistant.startConversation({
  message: "我们来讨论一下系统架构设计",
  autoStart: false
})

await Assistant.present()
// 由用户在 UI 中手动点击发送
```

***

### 示例三：暂时关闭，再次展示

```ts
await Assistant.startConversation({
  message: "分析这张图片",
  images: [image],
  autoStart: true
})

await Assistant.present()

// 用户关闭页面
await Assistant.dismiss()

// 稍后再次展示同一会话
await Assistant.present()
```

***

### 示例四：结束当前会话并重新开始

```ts
if (Assistant.hasActiveConversation) {
  await Assistant.stopConversation()
}

await Assistant.startConversation({
  message: "开始一个新的话题",
  autoStart: true
})

await Assistant.present()
```

***

## 使用建议与最佳实践

- 将 Conversation API 视为“**托管聊天界面**”
- 不要在同一业务流中混用 Conversation API 与 `requestStreaming`
- 在调用 `startConversation` 前检查 `hasActiveConversation`
- 若仅需要数据或一次性输出，应使用：

  - `requestStructuredData`
  - `requestStreaming`
- 若用户需要持续交互体验，应使用 Conversation API

***

## 设计边界说明

- Conversation API 不适合无 UI 场景
- 不适合后台自动化任务
- 不适合需要完全控制 Prompt / Token / 输出格式的场景



---
url: /v2/zh/guide/Changelog/2.4.5/Assistant/Assistant Quick Start.md
---

# 快速了解智能助手

Scripting 的 Assistant API 提供了三类能力，分别面向 **数据处理**、**流式输出** 和 **交互式聊天** 三种不同使用场景。
在使用之前，建议先明确你的需求属于哪一类。

***

## Assistant API 分类总览

| API 分类 | 主要方法                                                             | 适用场景                   |
| ------ | ---------------------------------------------------------------- | ---------------------- |
| 结构化数据  | `requestStructuredData`                                          | 从文本 / 图片中提取结构化 JSON 数据 |
| 流式生成   | `requestStreaming`                                               | 实时展示 AI 输出内容           |
| 会话聊天   | `startConversation` / `present` / `dismiss` / `stopConversation` | 托管式聊天体验                |

***

## requestStructuredData

**用途**
用于请求**严格符合 JSON Schema 的结构化结果**。

**适合场景**

- 解析票据、发票、账单
- 从自然语言中提取字段
- 生成配置、规则、表单数据
- 需要直接用于程序逻辑的数据

**特点**

- 返回值稳定、可预测
- 不适合长文本或展示型输出
- 适合后台或无 UI 场景

**一句话总结**

> 需要“数据”，用 `requestStructuredData`

***

## requestStreaming

**用途**
用于获取**流式输出**，在模型生成过程中持续接收内容。

**适合场景**

- 聊天气泡逐字显示
- 长文本生成（文章、说明、分析）
- 需要低延迟反馈的 UI

**特点**

- 支持文本、推理、用量等多种 Chunk
- 可边生成边渲染
- 不保证输出结构

**一句话总结**

> 需要“过程”和“实时展示”，用 `requestStreaming`

***

## Conversation API（会话聊天）

**相关方法**

- `startConversation`
- `present`
- `dismiss`
- `stopConversation`

**用途**
用于创建并展示一个**系统托管的 Assistant 聊天页面**。

**适合场景**

- 类 ChatGPT 的交互体验
- 用户需要多轮对话
- 希望系统管理 UI、Provider 切换、消息状态

**特点**

- 内置完整聊天 UI
- 自动处理流式输出
- 同一时间仅支持一个会话

**一句话总结**

> 需要“完整聊天体验”，用 Conversation API

***

## 如何选择合适的 API

### 常见选择指南

- **我要解析一张账单 →** `requestStructuredData`
- **我要展示 AI 写文章的过程 →** `requestStreaming`
- **我要打开一个聊天页面让用户和 AI 对话 →** Conversation API
- **我不需要 UI，只要结果 →** `requestStructuredData` 或 `requestStreaming`
- **我希望系统帮我处理聊天 UI →** Conversation API

***

## 简单示例

### 结构化数据

```ts
const data = await Assistant.requestStructuredData(...)
```

***

### 流式输出

```ts
const stream = await Assistant.requestStreaming(...)
for await (const chunk of stream) {
  // handle chunk
}
```

***

### 聊天会话

```ts
await Assistant.startConversation({ message: "你好", autoStart: true })
await Assistant.present()
```

***

## 使用建议

- 不要在同一业务流程中混用 Conversation API 和 `requestStreaming`
- 有明确数据结构需求时，优先选择 `requestStructuredData`
- 展示型输出和交互体验优先考虑 `requestStreaming` 或 Conversation API

***

## 下一步

如果你需要更深入的内容，可以继续阅读：

- `requestStructuredData` 详细文档
- `requestStreaming` 详细文档
- Conversation API 生命周期说明



---
url: /v2/zh/guide/Changelog/2.4.5/Assistant/requestStreaming.md
---

# 请求流式数据

`requestStreaming` 用于向 Assistant 请求**流式输出（Streaming Response）**。
与一次性返回完整结果不同，该 API 会在模型生成内容的过程中**持续返回数据片段（Chunk）**，调用方可以边接收边处理，从而实现：

- 实时展示 AI 输出（打字机效果）
- 流式日志 / 分段结果处理
- 长文本生成的低延迟体验
- 在生成过程中提前终止或切换 UI 状态

该 API 返回的是一个 **`ReadableStream<StreamChunk>`**，你可以通过 `for await ... of` 逐块读取。

***

## API 定义

```ts
function requestStreaming(options: {
  systemPrompt?: string | null
  messages: MessageItem | MessageItem[]
  provider?: Provider
  modelId?: string
}): Promise<ReadableStream<StreamChunk>>
```

***

## 参数说明

### options.systemPrompt（可选）

- 类型：`string | null`
- 指定本次请求使用的 system prompt
- 若未提供：

  - 使用 Assistant 内置的默认 system prompt
- 若显式传入：

  - 将**完全替换默认 system prompt**
  - Assistant Tools 将**不可用**

适用场景：

- 构建专用角色（如代码审查、翻译、摘要）
- 严格约束模型行为或输出风格

***

### options.messages

- 类型：`MessageItem | MessageItem[]`
- 必填
- 用于描述对话上下文的消息列表

#### MessageItem 结构

```ts
type MessageItem = {
  role: "user" | "assistant"
  content: MessageContent | MessageContent[]
}
```

- `role`

  - `"user"`：用户输入
  - `"assistant"`：历史 Assistant 输出（用于上下文补全）

***

### MessageContent 类型

#### 文本内容

```ts
type MessageTextContent =
  | string
  | { type: "text"; content: string }
```

***

#### 图片内容

```ts
type MessageImageContent = {
  type: "image"
  content: string // data:image/...;base64,...
}
```

***

#### 文档内容

```ts
type MessageDocumentContent = {
  type: "document"
  content: {
    mediaType: string
    data: string // base64
  }
}
```

***

### options.provider（可选）

- 类型：`Provider`
- 指定使用的 AI Provider
- 若未指定：

  - 使用 Assistant 当前配置的默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 若未指定，使用 Provider 默认模型

***

## 返回值

```ts
Promise<ReadableStream<StreamChunk>>
```

该 Promise resolve 后，你将获得一个可异步迭代的流对象。

***

## StreamChunk 类型说明

`requestStreaming` 的流中会返回以下三类 Chunk。

***

### StreamTextChunk（文本输出）

```ts
type StreamTextChunk = {
  type: "text"
  content: string
}
```

- 表示 Assistant 生成的**可展示文本**
- 多个 chunk 拼接后构成完整回复

***

### StreamReasoningChunk（推理输出）

```ts
type StreamReasoningChunk = {
  type: "reasoning"
  content: string
}
```

- 表示模型的**中间推理过程**
- 是否返回、返回粒度取决于 Provider / Model

***

### StreamUsageChunk（用量信息）

```ts
type StreamUsageChunk = {
  type: "usage"
  content: {
    totalCost: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    inputTokens: number
    outputTokens: number
  }
}
```

说明：

- 通常在流的**末尾**返回一次
- 不同 Provider 支持的字段略有差异
- `totalCost` 可能为 `null`（例如 Provider 未提供费用信息）

***

## 使用示例

### 示例一：最基本的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: {
    role: "user",
    content: "给我讲一个简短的科幻故事"
  },
  provider: "openai"
})

let text = ""

for await (const chunk of stream) {
  if (chunk.type === "text") {
    text += chunk.content
    console.log(chunk.content)
  }
}
```

***

### 示例二：区分文本、推理和用量

```ts
const stream = await Assistant.requestStreaming({
  systemPrompt: "你是一个严谨的技术写作助手",
  messages: [
    {
      role: "user",
      content: "解释什么是 HTTP/3"
    }
  ]
})

let answer = ""
let reasoningLog = null
let usage = null

for await (const chunk of stream) {
  switch (chunk.type) {
    case "text":
      answer += chunk.content
      break

    case "reasoning":
      reasoningLog = (reasoningLog ?? "") + chunk.content
      break

    case "usage":
      usage = chunk.content
      break
  }
}

console.log(answer)
console.log(usage)
```

***

### 示例三：包含图片与文档的流式请求

```ts
const stream = await Assistant.requestStreaming({
  messages: [
    {
      role: "user",
      content: [
        {
          type: "text",
          content: "请分析这份文档的核心内容"
        },
        {
          type: "document",
          content: {
            mediaType: "application/pdf",
            data: "JVBERi0xLjQKJcfs..."
          }
        }
      ]
    }
  ],
  provider: "anthropic"
})

for await (const chunk of stream) {
  if (chunk.type === "text") {
    console.log(chunk.content)
  }
}
```

***

## 使用建议与注意事项

- 流式结果**必须按顺序消费**，不可并发读取
- UI 场景下建议：

  - 文本 chunk 实时渲染
  - reasoning chunk 仅用于调试
  - usage chunk 延迟处理
- 若中途不再需要结果，应主动中止读取，避免无意义消耗
- 并非所有 Provider / Model 都会返回 reasoning 或 usage
- 不同 Provider 的 chunk 粒度不同，不应假设单次 chunk 是完整句子



---
url: /v2/zh/guide/Changelog/2.4.5/Assistant/requestStructuredData.md
---

# 请求结构化数据

`requestStructuredData` 用于向 Assistant 请求**严格符合指定 JSON Schema 的结构化 JSON 数据**。
该 API 适合在你需要**可预测、可直接用于程序逻辑**的数据结果时使用，而不是自由文本。

典型使用场景包括：

- 从自然语言中提取结构化字段
- 解析发票、收据、账单、票据
- 生成配置对象、规则数据
- 在不同 AI Provider / Model 之间获得一致的数据结构

***

## 支持的 JSON Schema 类型

Scripting 提供了一套轻量级、跨模型可用的 Schema 描述方式，由三种基础类型组成。

### Primitive（基础类型）

```ts
type JSONSchemaPrimitive = {
  type: "string" | "number" | "boolean"
  required?: boolean
  description: string
}
```

***

### Object（对象类型）

```ts
type JSONSchemaObject = {
  type: "object"
  properties: Record<string, JSONSchemaType>
  required?: boolean
  description: string
}
```

***

### Array（数组类型）

```ts
type JSONSchemaArray = {
  type: "array"
  items: JSONSchemaType
  required?: boolean
  description: string
}
```

***

## API 定义

### 不包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

### 包含图片输入

```ts
function requestStructuredData<R>(
  prompt: string,
  images: string[],
  schema: JSONSchemaArray | JSONSchemaObject,
  options?: {
    provider: Provider
    modelId?: string
  }
): Promise<R>
```

***

## 参数说明

### prompt

- 类型：`string`
- 必填
- 向模型说明**需要解析或生成什么结构化数据**
- 强烈建议在 prompt 中明确：

  - 时间格式（如 ISO-8601）
  - 金额是否为纯数字
  - 缺失字段的处理规则

***

### images（可选）

- 类型：`string[]`
- 每一项必须是 Data URI，例如：

```text
data:image/png;base64,iVBORw0KGgoAAAANS...
```

- 并非所有 Provider / Model 都支持图片输入
- 图片数量过多可能导致请求失败

***

### schema

- 类型：`JSONSchemaArray | JSONSchemaObject`
- 必填
- 定义模型**唯一允许返回的 JSON 结构**
- 每一个字段都应提供清晰的 `description`，这是保证结果稳定的关键

***

### options.provider

- 类型：`Provider`
- 可选，未指定时使用 Assistant 当前默认 Provider
- 支持：

  - `"openai"`
  - `"gemini"`
  - `"anthropic"`
  - `"deepseek"`
  - `"openrouter"`
  - `{ custom: string }`

***

### options.modelId（可选）

- 类型：`string`
- 指定具体模型 ID
- 必须与 Provider 实际支持的模型匹配
- 未指定时使用 Provider 默认模型

***

## 返回值

```ts
Promise<R>
```

- `R` 为调用方声明的泛型类型
- 返回结果应严格符合 Schema 描述
- 若模型无法生成合法结构，Promise 将被 reject

***

## 使用示例

### 示例一：解析票据 / 收据，提取消费项目、时间和金额

该示例演示如何将一段票据文本解析为结构化数据，包括：

- 整体消费时间（`purchasedAt`）
- 币种（`currency`）
- 消费项目列表（`items`）

  - 项目名称
  - 项目时间（若无则为空）
  - 金额
- 合计金额（`total`）

```ts
type ReceiptItem = {
  name: string
  time: string
  amount: number
}

type ReceiptParsed = {
  purchasedAt: string
  currency: string
  items: ReceiptItem[]
  total: number
}

const receiptText = `
Star Coffee
2026-01-08 14:23
Latte (Large)   $5.50
Blueberry Muffin $3.20
Tax             $0.79
Total           $9.49
`

const parsed = await Assistant.requestStructuredData<ReceiptParsed>(
  [
    "请分析以下票据文本，并提取结构化信息：",
    "- purchasedAt：整体消费时间，使用 ISO-8601 格式，若无法判断则返回空字符串",
    "- currency：币种代码（如 USD / EUR / CNY），若无法判断则返回空字符串",
    "- items：仅包含实际消费项目，不包含税费、合计等行",
    "  - name：项目名称",
    "  - time：项目级时间，若无则返回空字符串",
    "  - amount：数值类型的金额",
    "- total：合计金额，若无则返回 -1",
    "",
    "票据内容：",
    receiptText
  ].join("\n"),
  {
    type: "object",
    description: "票据解析结果",
    properties: {
      purchasedAt: {
        type: "string",
        description: "整体消费时间（ISO-8601），若无则为空字符串"
      },
      currency: {
        type: "string",
        description: "币种代码，若无法判断则为空字符串"
      },
      items: {
        type: "array",
        description: "消费项目列表（不包含税费、合计等）",
        items: {
          type: "object",
          description: "单个消费项目",
          properties: {
            name: {
              type: "string",
              description: "项目名称"
            },
            time: {
              type: "string",
              description: "项目时间（ISO-8601），若无则为空字符串"
            },
            amount: {
              type: "number",
              description: "项目金额"
            }
          }
        }
      },
      total: {
        type: "number",
        description: "合计金额，若不存在则为 -1"
      }
    }
  },
  {
    provider: "openai"
  }
)

// 建议在业务层将空字符串 / -1 归一化为 null
console.log(parsed)
```

***

### 示例二：生成数组结构

```ts
type Expense = {
  name: string
  amount: number
}

const expenses = await Assistant.requestStructuredData<Expense[]>(
  "列出三项常见的日常支出及其大致金额",
  {
    type: "array",
    description: "支出列表",
    items: {
      type: "object",
      description: "单项支出",
      properties: {
        name: {
          type: "string",
          description: "支出名称"
        },
        amount: {
          type: "number",
          description: "金额"
        }
      }
    }
  },
  {
    provider: "gemini"
  }
)
```

***

### 示例三：结合图片生成结构化结果

```ts
type ImageSummary = {
  description: string
  containsText: boolean
}

const summary = await Assistant.requestStructuredData<ImageSummary>(
  "分析这张图片的主要内容",
  ["data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD..."],
  {
    type: "object",
    description: "图片分析结果",
    properties: {
      description: {
        type: "string",
        description: "图片内容描述"
      },
      containsText: {
        type: "boolean",
        description: "是否包含可识别文本"
      }
    }
  },
  {
    provider: "openai"
  }
)
```

***

## 使用建议与注意事项

- 当返回结果用于业务逻辑时，优先使用 `requestStructuredData`
- Schema 描述越明确，结果越稳定
- 复杂业务规则不要放在 Schema 中，应由业务代码处理



---
url: /v2/zh/guide/Changelog/2.4.5/CalendarEvent.md
---

`CalendarEvent` API 用于在 iOS 日历中创建、读取、编辑与管理事件。
开发者可以操作事件的标题、时间、地点、参与者、重复规则、提醒（EventAlarm）、事件可用性以及地理位置信息，并且可以使用系统提供的创建/编辑界面。

***

# 一、类型说明

## EventParticipant

表示事件的参与者：

- `isCurrentUser: boolean`：是否为当前用户
- `name?: string`：姓名
- `role: ParticipantRole`：角色
- `type: ParticipantType`：类型
- `status: ParticipantStatus`：出席状态

### ParticipantRole

- `chair`（主持人）
- `nonParticipant`（非参与者）
- `optional`（可选）
- `required`（必需）
- `unknown`（未知）

### ParticipantType

- `group`（群组）
- `person`（个人）
- `resource`（资源）
- `room`（房间）
- `unknown`（未知）

### ParticipantStatus

- `unknown`（未知）
- `pending`（待定）
- `accepted`（接受）
- `declined`（拒绝）
- `tentative`（暂定）
- `delegated`（已委托）
- `completed`（已完成）
- `inProcess`（处理中）

***

## EventAvailability

用于表明事件在日程中的可用性状态：

- `notSupported`：日历不支持可用性设置
- `busy`：忙碌
- `free`：空闲
- `tentative`：暂定
- `unavailable`：不可用

***

## EventStructuredLocation

用于地理位置提醒的结构化位置：

- `title: string | null`：名称
- `geoLocation: LocationInfo | null`：地理位置（经纬度）
- `radius: number`：触发半径（米）

此结构与 `EventAlarm.structuredLocation` 配合使用。

***

## AlarmProximity

位置提醒的触发方式：

- `none`：不使用位置触发
- `enter`：进入区域时触发
- `leave`：离开区域时触发

***

# 二、EventAlarm（事件提醒）

CalendarEvent 支持添加多个 `EventAlarm`，包括：

- **绝对时间提醒**
- **相对事件开始时间提醒**
- **位置提醒（geofence）**

详细说明请参考独立的 EventAlarm 文档。

***

# 三、CalendarEvent 类

## 构造函数

```ts
new(): CalendarEvent
```

创建一个新的事件实例（尚未保存到日历）。

***

# 四、属性说明

## 基本信息

### identifier: string

事件的唯一标识符。

### title: string

事件标题。

### notes: string | null

事件备注。

### url: string | null

关联 URL。

### calendar: Calendar | null

事件所属的日历。
不可设为 `null`。
如果需要删除事件，请使用 `remove()`。

***

## 时间与地点

### isAllDay: boolean

是否为全天事件。

### startDate: Date

开始时间。

### endDate: Date

结束时间。

### timeZone: string | null

事件使用的时区。

### location: string | null

纯文本地点信息。

### structuredLocation: EventStructuredLocation | null

结构化位置（支持 geofence 提醒）。

***

## 事件状态与生成信息（新增）

### creationDate: Date | null

事件创建日期（只读）。

### lastModifiedDate: Date | null

事件最后修改时间（只读）。

### occurrenceDate: Date

对于重复事件中的“单个实例”，此属性表示该实例原始发生日期。

### isDetached: boolean

是否为重复事件的“脱离实例”。
例如用户单独修改某一发生日期的事件时，该实例会成为 detached instance。

***

## 参与者与可用性（新增相关属性）

### attendees: EventParticipant\[] | null

参与者数组（只读）。

### organizer: EventParticipant | null

事件组织者（只读）。

### hasAttendees: boolean

是否包含参与者。

### availability: EventAvailability

事件在日程中的可用性状态。

***

## 提醒（Alarm）相关

### alarms: EventAlarm\[] | null

事件绑定的提醒列表。

### hasAlarm: boolean

事件是否包含提醒。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

事件的重复规则数组。

### hasRecurrenceRules: boolean

是否包含重复规则。

***

## 其他状态属性（新增）

### hasNotes: boolean

是否包含备注。

### hasChanges: boolean

事件或其内部对象是否有未保存的更改。

***

# 五、实例方法

## 1. 提醒管理

### addAlarm(alarm: EventAlarm): void

为事件添加一个提醒。

### removAlarm(alarm: EventAlarm): void

从事件移除一个提醒。
（注意拼写：API 为 `removAlarm`）

***

## 2. 重复规则

### addRecurrenceRule(rule: RecurrenceRule): void

添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除一条重复规则。

***

## 3. 事件保存与删除

### `save(): Promise<void>`

保存事件（或重复事件的变化）。

### `remove(): Promise<void>`

从日历中移除事件。

***

## 4. 显示编辑界面

### `presentEditView(): Promise<EventEditViewAction>`

显示系统提供的事件编辑界面，并返回用户执行的操作：

- `"saved"`
- `"deleted"`
- `"canceled"`

***

# 六、静态方法

## `getAll(startDate: Date, endDate: Date, calendars?: Calendar[]): Promise<CalendarEvent[]>`

获取指定日期范围内的事件。

- 可传入 `calendars` 数组过滤事件
- 若不传或传 `null`，则搜索所有可访问的日历

***

## `presentCreateView(): Promise<CalendarEvent | null>`

显示事件创建界面。

- 用户点击保存时返回创建的事件
- 用户取消时返回 `null`

***

# 七、使用示例

## 1. 创建并保存事件

```ts
const defaultCalendar = await Calendar.defaultForEvents()
const event = new CalendarEvent()
event.title = "团队会议"
event.calendar = defaultCalendar!
event.startDate = new Date("2024-01-15T09:00:00")
event.endDate = new Date("2024-01-15T10:00:00")
event.location = "会议室"

await event.save()
```

***

## 2. 添加重复规则

```ts
const rule = RecurrenceRule.create({
  frequency: "weekly",
  interval: 1,
  daysOfTheWeek: ["monday", "wednesday", "friday"],
  end: RecurrenceEnd.fromDate(new Date("2024-12-31")),
})

event.addRecurrenceRule(rule)
await event.save()
```

***

## 3. 添加提醒（Alarm）

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
event.addAlarm(alarm)
await event.save()
```

***

## 4. 获取日期范围内的事件

```ts
const events = await CalendarEvent.getAll(
  new Date("2024-01-01"),
  new Date("2024-01-31")
 )

for (const e of events) {
  console.log(`事件: ${e.title} 开始时间: ${e.startDate}`)
}
```

***

## 5. 使用事件创建界面

```ts
const created = await CalendarEvent.presentCreateView()
if (created) {
  console.log("新事件已创建:", created.title)
}
```

***

## 6. 编辑事件

```ts
const result = await event.presentEditView()
console.log("编辑操作:", result)
```

***

## 7. 删除事件

```ts
await event.remove()
console.log("事件已移除")
```

***

# 八、补充说明

### 时区处理

当处理跨时区事件时，请务必设置 `timeZone`，否则可能出现偏移时间或显示错误。

### 重复事件编辑

- 修改单个重复事件实例会创建一个 detached instance
- `occurrenceDate` 可用于识别该实例对应的原始日期

### 参与者

参与者信息由系统从日历源（如 iCloud、Exchange）读取。
部分字段可能因日历源不同而缺失。

### structuredLocation 与 geofence

若使用位置提醒，请确保用户授权位置权限。



---
url: /v2/zh/guide/Changelog/2.4.5/DateFormatter.md
---

`DateFormatter` 类用于将 `Date` 类型格式化为字符串，或将字符串解析为 `Date`。
该类封装了 iOS 的 `DateFormatter` 能力，适用于格式化日期、时间、本地化展示、农历日期展示（通过切换日历）、相对日期显示等场景。

***

# 枚举与类型定义

## DateFormatterStyle

用于指定日期或时间的格式化级别。

| 枚举值      | 含义                                |
| -------- | --------------------------------- |
| `none`   | 不显示日期或时间                          |
| `short`  | 短格式，例如 `12/1/25`、`3:20 PM`        |
| `medium` | 中等格式，例如 `Dec 1, 2025`             |
| `long`   | 长格式，例如 `December 1, 2025`         |
| `full`   | 全格式，例如 `Monday, December 1, 2025` |

***

## DateFormatterBehavior

指定格式化器的行为模式。

| 枚举值            | 含义                 |
| -------------- | ------------------ |
| `default`      | 系统默认行为             |
| `behavior10_4` | 兼容旧系统格式化行为（通常无需使用） |

***

## CalendarIdentifier

指定 `DateFormatter` 使用的历法类型。可用于格式化如：

- 公历（gregorian）
- 农历（chinese）
- 佛历（buddhist）
- 日本历（japanese）
- 伊斯兰历（islamic）
  等。

可选值示例：

```
"current" | "gregorian" | "chinese" | "japanese" | "islamic" | "iso8601" | ...
```

其中：

- `"current"` 代表当前系统日历
- `"autoupdatingCurrent"` 表示系统日历变更后自动更新

***

## TimeZoneIdentifier

指定时区。

可选值：

```
"current" | "autoupdatingCurrent" | "gmt" | string
```

当传入普通字符串时，可以使用任意合法时区 ID，例如：

- `"Asia/Shanghai"`
- `"America/Los_Angeles"`
- `"UTC"`

***

# 类：DateFormatter

## 初始化

### `new(): DateFormatter`

创建一个新的日期格式器实例。

***

# 静态方法

## `DateFormatter.localizedString(date, options)`

根据指定的日期格式与时间格式返回本地化后的字符串。

```ts
DateFormatter.localizedString(date: Date, options: {
  dateStyle: DateFormatterStyle
  timeStyle: DateFormatterStyle
}): string
```

适用于快速格式化，无需手动设置 formatter 属性。

***

## `DateFormatter.dateFormat(template, locale?)`

根据日期模板生成本地化后的格式化字符串。

```
static dateFormat(template: string, locale?: string): string | null
```

示例模板：`"yyyyMMdd"`, `"MMM d"`, `"HH:mm"`

如果传入 locale，则按指定语言区域生成；否则使用系统 locale。

***

# 实例方法

## `string(date: Date): string`

将 Date 转换为格式化字符串。

注意：如果设置了 `dateFormat`，则优先使用自定义格式；
否则根据 `dateStyle` 和 `timeStyle` 自动格式化。

***

## `date(string: string): Date | null`

将字符串解析为 Date。
解析能力依赖于当前 dateFormat、locale、calendar 等属性。

***

## `setLocalizedDateFormatFromTemplate(template: string): void`

根据模板生成本地化格式，并自动设置到 `dateFormat` 属性中。

***

# 属性说明

以下为所有可配置属性的功能说明。

## 日期与时间格式属性

### `calendar: CalendarIdentifier`

选择日期格式化使用的历法，如公历、农历、佛历等。

***

### `timeZone: TimeZoneIdentifier`

设置时区，例如 `"Asia/Shanghai"`。

***

### `locale: string`

指定区域语言，例如：

- `"zh_CN"`
- `"en_US"`
- `"ja_JP"`

***

### `dateFormat: string`

手动指定格式化模板。例如：

```
"yyyy-MM-dd HH:mm"
"MMM d, yyyy"
"EEEE"
```

如果设置该属性，则忽略 `dateStyle` 和 `timeStyle`。

***

### `dateStyle/timeStyle: DateFormatterStyle`

分别控制日期和时间格式级别。

***

## 行为属性

### `generatesCalendarDates: boolean`

是否生成历法日期，一般保持默认即可。

***

### `formatterBehavior: DateFormatterBehavior`

控制格式器行为，通常使用默认值。

***

### `isLenient: boolean`

是否宽松解析输入，例如解析模糊格式字符串。
一般保持 `false`，避免误解析。

***

### `twoDigitStartDate: Date | null`

设置双位数年份的起始范围。用于解析如 `"20"` 这样的年份值。

***

### `defaultDate: Date | null`

解析字符串无法获得时间时，使用的默认日期。

***

## 本地化符号与文案属性

以下属性用于自定义本地化符号，如月份名称、星期名称等。
这些属性通常无需手动设置，除非需要覆盖本地化字符串。

举例属性：

- `eraSymbols`
- `monthSymbols`
- `shortMonthSymbols`
- `weekdaySymbols`
- `shortWeekdaySymbols`
- `standaloneMonthSymbols`
- `amSymbol`
- `pmSymbol`
- `quarterSymbols`
- `standaloneQuarterSymbols`
- `veryShortWeekdaySymbols`
- `gregorianStartDate`

这些属性主要作用于需要深度定制本地化展示的场景。

***

## `doesRelativeDateFormatting: boolean`

启用相对日期格式化，例如：

- Today
- Yesterday
- Tomorrow

在中文环境中可显示为：

- 今天
- 昨天
- 明天

通常与 `dateStyle = .medium` 等组合使用。

***

# 示例代码

以下示例展示如何使用 `DateFormatter` 进行多种日期格式化场景。

***

## 示例一：使用 dateStyle 和 timeStyle 进行本地化格式化

```tsx
import { DateFormatter } from "scripting"

const df = new DateFormatter()
df.locale = "zh_CN"
df.dateStyle = DateFormatterStyle.full
df.timeStyle = DateFormatterStyle.short

const result = df.string(new Date())
// 输出示例： "2025年12月12日 星期五 下午3:20"
```

***

## 示例二：自定义日期格式模板

```tsx
const df = new DateFormatter()
df.locale = "en_US"
df.dateFormat = "yyyy-MM-dd HH:mm"

df.timeZone = "Asia/Shanghai"

const str = df.string(new Date())
// 输出示例： "2025-12-12 15:20"
```

***

## 示例三：使用农历格式化（chinese calendar）

```tsx
const df = new DateFormatter()

df.calendar = "chinese"
df.locale = "zh_CN"
df.dateFormat = "yyyy年MM月dd日 EEEE"

const lunar = df.string(new Date())
// 输出示例： "四十三年十月廿二日 星期五"
```

***

## 示例四：解析字符串为日期

```tsx
const df = new DateFormatter()
df.dateFormat = "yyyy/MM/dd HH:mm"

const date = df.date("2025/12/12 08:00")
```

***

## 示例五：使用模板生成本地化格式

```tsx
const df = new DateFormatter()
df.locale = "zh_CN"

// 自动设置为符合中文习惯的格式，例如 "12月12日"
df.setLocalizedDateFormatFromTemplate("MMdd")

const str = df.string(new Date())
```

***

## 示例六：使用静态快速格式化

```tsx
const str = DateFormatter.localizedString(new Date(), {
  dateStyle: DateFormatterStyle.medium,
  timeStyle: DateFormatterStyle.short
})
```



---
url: /v2/zh/guide/Changelog/2.4.5/EventAlarm.md
---

# 事件闹钟

`EventAlarm` 用于为 **日历事件（CalendarEvent）** 和 **提醒事项（Reminder）** 设置提醒规则。
通过该类，开发者可以创建：

- 基于绝对时间触发的提醒
- 基于事件开始时间的相对提醒
- 基于地理围栏（Geofence）触发的提醒

此类为 Scripting Calendar/Reminder API 的基础能力，用于构建灵活的提醒行为。

***

## 一、创建 Alarm

### 1. `EventAlarm.fromAbsoluteDate(date: Date): EventAlarm`

创建一个基于绝对时间触发的提醒。

- 不依赖事件的开始时间
- 在系统时间到达指定时刻时触发

示例：

```ts
const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-01-01T09:00:00"))
```

***

### 2. `EventAlarm.fromRelativeOffset(offset: DurationInSeconds): EventAlarm`

创建一个以「事件开始时间」为基准的提醒。

`offset`（秒）含义如下：

- 负数：事件开始前触发
- 正数：事件开始后触发

示例（事件开始前 10 分钟提醒）：

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
```

***

## 二、属性说明

### 1. `absoluteDate: Date | null`

提醒的绝对触发时间。

行为规则：

- 如果为相对提醒设置 `absoluteDate`，提醒会自动转换为绝对提醒，同时 `relativeOffset` 会被清除。
- 如果为 `null`，表示提醒可能为相对提醒或位置提醒。

***

### 2. `relativeOffset: number`

事件开始时间的偏移量（秒）。

行为规则：

- 若为绝对提醒设置该属性，则提醒会转换为相对提醒，且 `absoluteDate` 会被置空。
- 相对提醒永远以 CalendarEvent 或 Reminder 的开始时间为基准。

示例：

```ts
alarm.relativeOffset = -300  // 提前 5 分钟触发
```

***

### 3. `structuredLocation: EventStructuredLocation | null`

位置提醒的触发地点。

`EventStructuredLocation` 包含：

- `title: string | null`：地点名称
- `geoLocation: LocationInfo | null`：经纬度位置
- `radius: number`：地理围栏触发半径（米）

示例：

```ts
alarm.structuredLocation = {
  title: "公司",
  geoLocation: { latitude: 37.332, longitude: -122.030 },
  radius: 100
}
```

***

### 4. `proximity: AlarmProximity`

位置提醒的触发方式。

支持的值：

| 值       | 含义         |
| ------- | ---------- |
| `none`  | 默认，不使用位置触发 |
| `enter` | 进入该地点范围时触发 |
| `leave` | 离开该地点范围时触发 |

示例：

```ts
alarm.proximity = AlarmProximity.enter
```

***

## 三、EventAlarm 在不同 API 中的使用方式

### 1. 在 CalendarEvent 中使用

```ts
const event = new CalendarEvent()
event.title = "会议"
event.startDate = ...
event.endDate = ...

const alarm = EventAlarm.fromRelativeOffset(-900)
event.addAlarm(alarm)

await event.save()
```

***

### 2. 在 Reminder 中使用

`Reminder` 与 `CalendarEvent` 均支持添加 `EventAlarm`：

```ts
const reminder = new Reminder()
reminder.title = "交电费"

const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-02-01T10:00:00"))
reminder.addAlarm(alarm)

await reminder.save()
```

位置提醒同样适用于 `Reminder`。

***

## 四、使用建议

1. **绝对提醒适合作为固定时间提醒**
   如生日、账单日等。

2. **相对提醒适用于基于事件开始时间的通知**
   如会议开始前十分钟提醒。

3. **地理围栏提醒适用于“到达某地时执行某事”**
   如到家提醒拿快递。

4. 使用位置提醒时，应确保用户授予定位权限。



---
url: /v2/zh/guide/Changelog/2.4.5/Keychain.md
---

# 钥匙串

`Keychain` 提供对系统钥匙串（Keychain）的安全访问接口，用于在 **Scripting 脚本环境中安全、持久地存储敏感数据**，典型用途包括：

- 登录凭证
- Token
- 许可证信息
- 订阅状态
- 加密密钥
- 用户隐私数据

所有数据均使用系统级 Keychain 安全机制存储，具备高安全性与持久性。

***

## 一、Keychain 的脚本作用域隔离规则

在 Scripting 中，`Keychain` 采用 **按脚本隔离（Per-Script Sandbox）** 的安全模型：

### 1. 作用域规则

- **每一个脚本拥有独立的 Keychain 作用域**

- 每个脚本 **只能访问自己写入的 Keychain 数据**

- 不同脚本之间：

- 即使 Key 名相同

- 即使 `synchronizable: true`

- 也 **无法互相读取或覆盖数据**

- 脚本被视为独立安全单元

***

### 2. 该规则的安全意义

该设计确保：

- 不同脚本之间的数据完全隔离
- 防止第三方脚本窃取用户隐私数据
- 防止恶意脚本读取登录态、订阅状态、授权信息
- 提供比系统 Keychain 更细粒度的安全隔离层

***

### 3. 脚本卸载对 Keychain 的影响

- 当脚本被删除后：

  - 该脚本作用域下的 Keychain 数据将被系统回收
- 其他脚本的数据不会受到任何影响

***

## 二、API 命名空间

```ts
namespace Keychain
```

***

## 三、支持的数据类型

`Keychain` 支持以下三种数据类型：

| 类型    | 写入        | 读取        |
| ----- | --------- | --------- |
| 字符串   | `set`     | `get`     |
| 布尔值   | `setBool` | `getBool` |
| 二进制数据 | `setData` | `getData` |

***

## 四、KeychainAccessibility 可访问性策略

```ts
type KeychainAccessibility =
  | 'passcode'
  | 'unlocked'
  | 'unlocked_this_device'
  | 'first_unlock'
  | 'first_unlock_this_device'
```

| 值                          | 说明                  |
| -------------------------- | ------------------- |
| `passcode`                 | 仅在设备设置锁屏密码时可访问，不会迁移 |
| `unlocked`                 | 仅在设备解锁状态下可访问        |
| `unlocked_this_device`     | 仅限本设备访问，不会迁移        |
| `first_unlock`             | 重启后首次解锁即可访问         |
| `first_unlock_this_device` | 重启后首次解锁即可访问，不会迁移    |

默认值：

```ts
accessibility: "unlocked"
```

***

## 五、iCloud 同步（synchronizable）

```ts
synchronizable?: boolean
```

| 值       | 说明                 |
| ------- | ------------------ |
| `true`  | 在同一 Apple ID 设备间同步 |
| `false` | 仅存储在本设备            |

默认值：

```ts
synchronizable: false
```

***

## 六、写入数据

### 1. 写入字符串

```ts
Keychain.set(key: string, value: string, options?): boolean
```

```ts
Keychain.set("token", "abcdef")
```

```ts
Keychain.set("token", "abcdef", {
  accessibility: "first_unlock",
  synchronizable: true
})
```

***

### 2. 写入布尔值

```ts
Keychain.setBool(key: string, value: boolean, options?): boolean
```

```ts
Keychain.setBool("is_login", true)
```

***

### 3. 写入二进制数据

```ts
Keychain.setData(key: string, value: Data, options?): boolean
```

```ts
Keychain.setData("avatar", imageData)
```

***

### 4. 覆盖规则

- Key 已存在时会自动覆盖
- 成功返回 `true`
- 失败返回 `false`

***

## 七、读取数据

### 字符串

```ts
Keychain.get(key: string, options?): string | null
```

### 布尔值

```ts
Keychain.getBool(key: string, options?): boolean | null
```

### 二进制数据

```ts
Keychain.getData(key: string, options?): Data | null
```

***

## 八、删除数据

```ts
Keychain.remove(key: string, options?): boolean
```

- Key 存在：删除并返回 `true`
- Key 不存在：安全返回 `true`

***

## 九、是否存在

```ts
Keychain.contains(key: string, options?): boolean
```

***

## 十、获取所有 Key

```ts
Keychain.keys(options?): string[]
```

***

## 十一、清空 Keychain

```ts
Keychain.clear(options?): boolean
```

- 仅清空当前脚本作用域内的数据
- 不影响其他脚本
- 不影响 App 自身或其他 App 的系统 Keychain 数据

***

## 十二、synchronizable 的读写一致性规则

如果某 Key 使用：

```ts
synchronizable: true
```

则后续所有操作必须带相同参数：

```ts
Keychain.set("token", "abc", { synchronizable: true })

Keychain.get("token") // 读取不到
Keychain.get("token", { synchronizable: true }) // 可读取
```

***

## 十三、安全性与使用建议

### 适合存储的数据

- 登录 Token
- 订阅与授权状态
- 用户唯一标识
- 加密密钥

### 不建议存储

- 大体积文件
- 高频变化的缓存数据
- 可公开的普通配置

***

## 十四、典型使用示例

```ts
// 写入
Keychain.set("token", "abcdef")
Keychain.setBool("is_login", true)
Keychain.setData("avatar", avatarData)

// 读取
const token = Keychain.get("token")
const isLogin = Keychain.getBool("is_login")
const avatar = Keychain.getData("avatar")

// 删除
Keychain.remove("token")

// 判断是否存在
Keychain.contains("token")

// 获取所有 Key
Keychain.keys()

// 清空
Keychain.clear()
```



---
url: /v2/zh/guide/Changelog/2.4.5/LivePhotoView.md
---

# LivePhotoView

LivePhoto 表示一张 **系统级 Live Photo**，它由以下两部分组成：

- 一张高分辨率静态图片
- 一段与图片绑定的短视频（通常为 MOV）

在 Scripting 中，LivePhoto 是一个 **不可直接 new 的系统对象**，通常来源于：

- 照片选择器返回的结果
- 使用本地图片与视频文件动态构建

LivePhoto 的主要用途包括：

- 在界面中实时展示 Live Photo
- 读取并处理其底层资源（图片 / 视频）
- 将其拆解、重建或重新保存到系统相册

***

## LivePhoto 类

### LivePhoto.size

```
readonly size: Size
```

表示 Live Photo 的尺寸信息，对应其 **主图像（静态图片）** 的像素宽高。

该属性常用于：

- UI 布局约束
- 计算缩放比例
- 判断 Live Photo 的原始分辨率

***

### LivePhoto.getAssetResources()

```
getAssetResources(): Promise<{
  data: Data
  assetLocalIdentifier: string
  contentType: UTType
  originalFilename: string
  pixelHeight: number
  pixelWidth: number
}[]>
```

用于获取 Live Photo 的 **底层资源列表**。

一个 Live Photo 通常至少包含以下资源：

- 静态图片资源（JPEG / HEIC）
- 视频资源（QuickTime MOV）

返回数组中每一项代表一个资源，其字段含义如下：

- `data`
  资源的二进制数据，可直接用于写入文件、保存或传输

- `assetLocalIdentifier`
  Photos 框架中该资源的本地唯一标识

- `contentType`
  资源的统一类型标识（UTType），用于区分图片或视频类型

- `originalFilename`
  系统中该资源的原始文件名

- `pixelWidth` / `pixelHeight`
  该资源的实际像素尺寸

典型使用场景包括：

- 手动保存 Live Photo（避免中间临时文件）
- 将 Live Photo 拆解为独立的图片与视频
- 对 Live Photo 进行自定义导出或重建

***

### LivePhoto.from(options)

```
static from(options: {
  imagePath: string
  videoPath: string
  targetSize?: Size | null
  placeholderImage: UIImage | null
  contentMode?: "aspectFit" | "aspectFill"
  onResult: (result: LivePhoto | null, info: {
    error: string | null
    degraded: boolean | null
    cancelled: boolean | null
  }) => void
}): Promise<() => void>
```

用于 **从本地图片文件与视频文件异步构建 Live Photo**。

该方法的特点如下：

- 构建过程是异步的
- `onResult` 可能会被调用多次
- 支持降级结果（低质量预览）
- 支持主动取消请求

#### 参数说明

- `imagePath`
  静态图片文件路径，通常为 JPEG 或 HEIC

- `videoPath`
  与图片对应的视频文件路径，通常为 MOV

- `targetSize`
  指定返回 Live Photo 的目标尺寸
  传入 `null` 表示使用原始尺寸

- `placeholderImage`
  Live Photo 尚未加载完成时用于占位显示的 UIImage

- `contentMode`
  占位图的显示方式

  - `aspectFit`：完整显示，保持比例
  - `aspectFill`：填满区域，可能裁剪

- `onResult(result, info)`
  Live Photo 加载完成或状态更新时触发的回调

#### info 参数说明

- `error`
  构建失败时的错误信息

- `degraded`
  表示当前结果是否为低质量版本

- `cancelled`
  表示请求是否被取消

#### 返回值

该方法返回一个 Promise，成功后解析为一个 **可取消函数**：

```
() => void
```

调用该函数可立即取消 Live Photo 的加载过程。

***

## LivePhotoView 组件

LivePhotoView 是用于 **在界面中展示 Live Photo 的原生视图组件**，行为与系统 Photos App 中的 Live Photo 播放体验一致。

***

### LivePhotoViewProps

```
type LivePhotoViewProps = {
  livePhoto: Observable<LivePhoto | null>
}
```

#### livePhoto

- 类型：`Observable<LivePhoto | null>`
- 必填

该属性用于绑定当前要显示的 Live Photo。

设计为 `Observable` 的原因是：

- Live Photo 通常是异步获取的
- 允许在同一个视图中动态切换 Live Photo
- 便于与选择器、加载逻辑解耦

当 Observable 的值发生变化时，LivePhotoView 会自动更新显示内容。

***

## 使用示例说明

以下示例展示了一个典型使用流程：

- 用户选择一张 Live Photo
- 将 Live Photo 存入 Observable
- LivePhotoView 自动展示并播放该 Live Photo

```tsx
import { LivePhotoView, Button, useObservable } from "scripting"

function Example() {
  const livePhoto = useObservable<LivePhoto | null>(null)

  return <>
    <Button
      title="Set Live Photo"
      action={async () => {
        const lp = await getLivePhotoSomehow()
        livePhoto.setValue(lp)
      }}
    />

    <LivePhotoView
      livePhoto={livePhoto}
      frame={{ idealHeight: 300 }}
    />
  </>
}
```

### 核心流程说明

- 使用 `useObservable<LivePhoto | null>` 创建可观察状态
- 在用户选择 Live Photo 后，通过 `setValue` 更新状态
- LivePhotoView 自动响应状态变化并展示内容

LivePhotoView 不负责：

- Live Photo 的获取
- 权限处理
- 数据保存

它仅专注于 **展示与交互体验**。

***

## 设计原则与注意事项

- LivePhoto 是系统资源对象，生命周期由系统管理
- LivePhotoView 必须绑定 Observable，而不是直接传值
- 同一个 LivePhoto 实例可被多个 LivePhotoView 使用
- Live Photo 的加载与 UI 渲染解耦，推荐始终通过 Observable 驱动

***

## 总结

LivePhoto 相关能力在 Scripting 中主要由两部分组成：

- **LivePhoto 数据模型**
  用于表示、构建和解析系统 Live Photo

- **LivePhotoView 展示组件**
  用于以原生方式展示 Live Photo，并支持动态更新



---
url: /v2/zh/guide/Changelog/2.4.5/NavigationStack with path.md
---

# NavigationStack 配合 path

`NavigationStack.path` 用于为 `NavigationStack` 提供**可观察的导航路径控制能力**，用于实现：

- 编程式导航（Programmatic Navigation）
- 多级页面堆栈控制
- 页面回退到指定层级或根视图
- 与 `NavigationDestination` 的动态页面映射联动

***

## 一、API 定义

```ts
type NavigationStackProps = {
  path?: Observable<string[]>
  ...
}

declare const NavigationStack: FunctionComponent<NavigationStackProps>
```

***

## 二、path 的类型与含义

```ts
path?: Observable<string[]>
```

`path` 是一个字符串数组的可观察对象，用于表示当前导航栈中的**页面路径序列**。

其语义规则如下：

- 每一个 `string` 表示一个页面标识
- 数组顺序表示页面入栈顺序
- 数组末尾元素表示当前显示的页面
- 数组为空表示回到根页面（Root）

示例说明：

```ts
[]
```

表示当前在根视图

```ts
["a"]
```

表示已导航到页面 `a`

```ts
["a", "b"]
```

表示先进入页面 `a`，再进入页面 `b`

***

## 三、基础使用示例

```tsx
function Page() {
  const path = useObservable<string[]>(["a"])

  return <NavigationStack
    path={path}
  >
    <VStack
      navigationTitle="Navigation Demo"
      navigationDestination={
        <NavigationDestination>
          {(page) =>
            <VStack>
              <Text>
                Current page:
                {page}
              </Text>
              {path.value.length > 1
                && <Button
                  title="Go to Root"
                  action={() => {
                    path.setValue([])
                  }}
                />}
            </VStack>
          }
        </NavigationDestination>
      }
    >
      <Button
        title="Show page a"
        action={() => {
          path.setValue(["a"])
        }}
      />
      <Button
        title="Show page b"
        action={() => {
          path.setValue(["b"])
        }}
      />
      <Button
        title="Show page a then b"
        action={() => {
          path.setValue(["a", "b"])
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 四、path 的工作机制说明

### 1. path 作为导航状态的唯一数据源

当 `NavigationStack` 绑定了 `path` 后：

- 当前页面层级将完全由 `path.value` 决定
- UI 导航状态将与 `path` 保持双向同步
- 不再依赖隐式的 Push / Pop 状态管理

***

### 2. 页面入栈规则

当执行：

```ts
path.setValue(["a"])
```

系统行为：

- 根页面入栈
- 跳转至页面 `a`

当执行：

```ts
path.setValue(["a", "b"])
```

系统行为：

- 先进入页面 `a`
- 再进入页面 `b`
- 当前显示页面为 `b`

***

### 3. 页面出栈与回到根页面

当执行：

```ts
path.setValue([])
```

系统行为：

- 清空整个导航路径
- 立即回到根页面

***

## 五、NavigationDestination 与 path 的关系

`NavigationDestination` 用于根据 `path` 中的当前值动态构建目标页面。

```tsx
<NavigationDestination>
  {(page) => ...}
</NavigationDestination>
```

其中：

- `page` 参数来自 `path.value` 的当前末尾元素
- 当 `path` 发生变化时：

  - `page` 会自动更新
  - 对应的页面内容会重新渲染

示例逻辑：

```ts
["a"]  -> page === "a"
["a","b"] -> page === "b"
```

***

## 六、通过按钮控制 path 进行导航

跳转到页面 `a`：

```ts
path.setValue(["a"])
```

跳转到页面 `b`：

```ts
path.setValue(["b"])
```

连续跳转两个页面：

```ts
path.setValue(["a", "b"])
```

返回根页面：

```ts
path.setValue([])
```

***

## 七、path 与手势返回的同步关系

当用户通过系统返回手势或导航栏返回按钮返回时：

- `path.value` 会自动同步更新
- 显示页面与 `path` 始终保持一致
- 不需要额外监听返回事件进行手动同步

***

## 八、path 的典型使用场景

`NavigationStack.path` 适用于以下场景：

- 深层页面跳转
- 跨页面编程式导航控制
- 统一的路由状态管理
- 脚本控制页面跳转
- 恢复上次浏览路径
- 多步骤流程（向导式界面）

***

## 九、常见错误说明

### 1. path 未初始化为空数组

错误：

```ts
const path = useObservable<string[]>(null)
```

正确：

```ts
const path = useObservable<string[]>([])
```

***

### 2. path 中的值类型错误

错误：

```ts
path.setValue([1, 2])
```

正确：

```ts
path.setValue(["1", "2"])
```

当前 `path` 仅支持 `string[]` 作为路径类型。

***

## 十、与不使用 path 的 NavigationStack 的区别

| 功能      | 不使用 path | 使用 path |
| ------- | -------- | ------- |
| 手动 Push | 支持       | 不建议     |
| 编程式跳转   | 不支持      | 支持      |
| 多层跳转    | 受限       | 完全支持    |
| 状态恢复    | 困难       | 简单      |
| 路由统一管理  | 不可控      | 完全可控    |



---
url: /v2/zh/guide/Changelog/2.4.5/Photos/index.md
---

# 照片

`Photos` 模块为 Scripting 提供了对系统相册与相机能力的统一访问接口，用于：

- 使用系统相机拍照或录制视频
- 从系统照片库中选择图片、视频或 Live Photo
- 获取最近拍摄的照片
- 将图片或视频保存到系统 Photos 应用

所有 API 均基于 iOS 原生框架（Photos、PHPicker、UIImagePicker 等）封装，并遵循以下设计原则：

- 系统级权限管理
- Promise 异步接口
- 系统 UI 托管，不可自定义
- 媒体数据访问安全、受控

***

## CaptureInfo

```ts
type CaptureInfo = {
  cropRect: {
    x: number
    y: number
    width: number
    height: number
  } | null
  originalImage: UIImage | null
  editedImage: UIImage | null
  imagePath: string | null
  mediaMetadata: Record<string, any> | null
  mediaPath: string | null
  mediaType: string | null
}
```

`CaptureInfo` 描述了一次拍摄操作（照片或视频）的完整返回信息。

### 字段说明

- `cropRect`
  用户在编辑阶段应用的裁剪区域
  若未裁剪则为 `null`

- `originalImage`
  拍摄得到的原始图片（未编辑）

- `editedImage`
  用户编辑后的图片
  仅在 `allowsEditing` 启用且实际编辑后存在

- `imagePath`
  图片在磁盘中的文件路径

- `mediaMetadata`
  媒体的元数据，如 EXIF、方向信息等

- `mediaPath`
  视频文件在磁盘中的路径

- `mediaType`
  媒体的 UTType 字符串标识

***

## availableMediaTypes()

```ts
function availableMediaTypes(): string[] | null
```

返回当前设备相机支持的媒体类型（UTType 字符串数组）。

常用于：

- 判断设备是否支持视频拍摄
- 根据设备能力动态配置拍摄参数

当信息不可获取时返回 `null`。

***

## capture(options)

```ts
function capture(options: {
  mode: "photo" | "video"
  mediaTypes: UTType[]
  allowsEditing?: boolean
  cameraDevice?: "rear" | "front"
  cameraFlashMode?: "auto" | "on" | "off"
  videoMaximumDuration?: DurationInSeconds
  videoQuality?: 
    | "low"
    | "medium"
    | "high"
    | "640x480"
    | "iFrame960x540"
    | "iFrame1280x720"
}): Promise<CaptureInfo | null>
```

展示系统相机界面以进行拍照或视频录制。

### 参数说明

- `mode`
  拍摄模式

  - `"photo"`：拍照
  - `"video"`：录制视频

- `mediaTypes`
  允许拍摄的媒体类型（UTType 数组）

- `allowsEditing`
  是否允许用户在完成拍摄后编辑媒体

- `cameraDevice`
  使用的摄像头
  默认为 `"rear"`

- `cameraFlashMode`
  闪光灯模式
  默认为 `"auto"`

- `videoMaximumDuration`
  视频最长录制时长（秒）

- `videoQuality`
  视频分辨率与编码质量设置

### 行为说明

- 拍摄界面完全由系统管理
- Promise 在用户完成或取消操作后返回
- 权限请求由系统自动处理

***

## pick(options)

```ts
function pick(options?: {
  mode?: "default" | "compact"
  filter?: PHPickerFilter
  limit?: number
}): Promise<PHPickerResult[]>
```

展示系统照片选择器，用于从相册中选择媒体资源。

### 参数说明

- `mode`
  选择器布局模式

  - `default`：网格布局
  - `compact`：线性紧凑布局

- `filter`
  用于限制可选择资源类型的 `PHPickerFilter`

- `limit`
  最大选择数量
  默认为 `1`

### 返回值

返回 `PHPickerResult` 数组。
每个结果必须显式调用对应方法解析为具体资源。

***

## PHPickerFilter

`PHPickerFilter` 用于描述 **Photos.pick** 可选择的资源类型。
它是一个不可实例化的类，仅通过静态方法构建。

### 基础过滤器

- `PHPickerFilter.images()`
  仅允许选择普通图片

- `PHPickerFilter.videos()`
  仅允许选择视频

- `PHPickerFilter.livePhotos()`
  仅允许选择 Live Photo

- `PHPickerFilter.bursts()`
  连拍照片

- `PHPickerFilter.panoramas()`
  全景照片

- `PHPickerFilter.screenshots()`
  屏幕截图

- `PHPickerFilter.screenRecordings()`
  屏幕录制视频

- `PHPickerFilter.depthEffectPhotos()`
  含景深效果的照片（人像）

- `PHPickerFilter.cinematicVideos()`
  电影效果视频

- `PHPickerFilter.slomoVideos()`
  慢动作视频

- `PHPickerFilter.timelapseVideos()`
  延时摄影视频

***

### 组合过滤器

- `PHPickerFilter.all(filters)`
  同时满足所有过滤条件
  相当于逻辑 AND

- `PHPickerFilter.any(filters)`
  满足任意一个过滤条件
  相当于逻辑 OR

- `PHPickerFilter.not(filter)`
  排除指定过滤条件
  相当于逻辑 NOT

### 示例说明

```ts
// 仅允许选择 Live Photo 或普通图片
const filter = PHPickerFilter.any([
  PHPickerFilter.livePhotos(),
  PHPickerFilter.images()
])

await Photos.pick({ filter })
```

***

## PHPickerResult

表示照片选择器返回的单个选择结果。

### itemProvider: ItemProvider

获取结果的 `ItemProvider`对象，是一个Swift 的 `NSItemProvider` 对象的包装。

### livePhoto()

```ts
livePhoto(): Promise<LivePhoto | null>
```

尝试将结果解析为 Live Photo。
若资源不支持 Live Photo，则返回 `null`。

***

### uiImage()

```ts
uiImage(): Promise<UIImage | null>
```

尝试将结果解析为 `UIImage`。
若资源不是图片，则返回 `null`。

***

### imagePath()

```ts
imagePath(): Promise<string | null>
```

尝试将结果解析为图片。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回图片路径。
你应该在使用完成后删除该文件。

#### 示例

```ts
const filePath = await result.imagePath()
```

***

### videoPath()

```ts
videoPath(): Promise<string | null>
```

尝试将结果解析为视频。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回视频路径。
你应该在使用完成后删除该文件。

***

## getLatestPhotos(count)

```ts
function getLatestPhotos(count: number): Promise<UIImage[] | null>
```

获取相册中最新的若干张照片。

### 行为说明

- 仅返回图片
- 顺序为从最新到最旧
- 无权限时返回 `null`

***

## pickPhotos(count)

```ts
function pickPhotos(count: number): Promise<UIImage[]>
```

旧版便捷 API，用于快速选择固定数量的照片。

直接返回 `UIImage` 数组，不包含路径或元数据。

***

## takePhoto()

```ts
function takePhoto(): Promise<UIImage | null>
```

快速拍照接口。

- 不支持高级配置
- 用户取消时返回 `null`

***

## savePhoto(path, options)

```ts
function savePhoto(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将磁盘中的图片文件保存到系统 Photos 应用。

***

## savePhoto(image, options)

```ts
function savePhoto(
  image: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将图片二进制数据直接写入系统相册，避免创建临时文件。

***

## saveVideo(path, options)

```ts
function saveVideo(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频文件保存到系统 Photos 应用。

***

## saveVideo(video, options)

```ts
function saveVideo(
  video: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频二进制数据直接写入系统相册。

***

## 设计说明

- 所有 API 均为异步 Promise 接口
- 所有 UI 均由系统托管
- Picker 返回的结果为惰性对象，需显式解析
- 保存接口仅返回成功状态，不暴露系统资源标识



---
url: /v2/zh/guide/Changelog/2.4.5/Photos/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Photos"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Get the latest specified number of photos from the Photos app.</Text>
        }
      >
        <Button
          title={"Photos.getLatestPhotos"}
          action={async () => {
            const images = await Photos.getLatestPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Present a photo picker dialog and pick limited number of photos.</Text>
        }
      >

        <Button
          title={"Photos.pickPhotos"}
          action={async () => {
            const images = await Photos.pickPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Take a photo and return a UIImage instance.</Text>
        }
      >
        <Button
          title={"Photos.takePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Save an image to the Photos app. Returns a boolean value indicates that whether the operation is successful.</Text>
        }
      >
        <Button
          title={"Photos.savePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              const success = await Photos.savePhoto(Data.fromJPEG(image, 0.5)!)
              Dialog.alert({
                message: "The photo has been saved: " + success
              })
            } else {
              Dialog.alert({
                message: "Canceled"
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.5/Picture in Pictuer View Modifiers.md
---

# Picture in Picture （画中画）

Scripting 提供了一组 PiP（Picture in Picture，画中画）相关的 View Modifiers，用于将任意 SwiftUI View 以系统级 PiP 窗口的形式呈现。
开发者无需直接接触底层 AVPictureInPicture API，即可完整控制 PiP 的展示、隐藏、交互行为及生命周期。

PiP 适用于以下典型场景：

- 实时状态展示（计时、运动、任务进度）
- 音频 / 视频播放的辅助 UI
- 应用进入后台后仍需持续展示的轻量信息视图

***

## 一、PiPProps API 定义

```ts
type PiPProps = {
  pip?: {
    isPresented: Observable<boolean>
    maximumUpdatesPerSecond?: number
    content: VirtualNode
  }
  
  onPipStart?: () => void
  onPipStop?: () => void
  onPipPlayPauseToggle?: (isPlaying: boolean) => void
  onPipSkip?: (isForward: boolean) => void
  onPipRenderSizeChanged?: (size: Size) => void

  pipHideOnForeground?: boolean
  pipShowOnBackground?: boolean
}
```

***

## 二、核心属性详解

### 1. `pip.isPresented`

```ts
isPresented: Observable<boolean>
```

- PiP 的**唯一控制开关**
- `true`：系统 PiP 窗口展示
- `false`：PiP 窗口关闭

通常由用户操作（按钮、手势）或应用生命周期驱动。

***

### 2. `pip.content`

```ts
content: VirtualNode
```

- 指定 PiP 窗口中实际渲染的视图
- 强烈建议使用**专门为 PiP 设计的 View**
- 视图结构应尽量简单、稳定、可预测

***

### 3. `pip.maximumUpdatesPerSecond`

```ts
maximumUpdatesPerSecond?: number
```

- **默认值：30**
- 用于限制 PiP 视图每秒最大刷新次数
- 是影响 PiP 稳定性和性能的关键参数

#### 使用建议

- **无动画 / 低频更新场景**
  建议设置为 `1 ~ 5`

- **包含动画的 PiP 视图**
  可设置为 `60`

**重要提示**
将该值设置为 `60` 会显著增加 CPU 与 GPU 压力，对系统性能影响非常明显，应谨慎使用，仅适用于确有必要的动画场景。

***

## 三、PiP 生命周期回调（仅限 PipView 使用）

### `onPipStart`

```ts
onPipStart?: () => void
```

- 当 PiP 窗口**成功开始展示**时触发
- 适合执行以下操作：

  - 启动定时器
  - 开始状态更新
  - 订阅数据流

***

### `onPipStop`

```ts
onPipStop?: () => void
```

- 当 PiP 被关闭或系统回收时调用
- 必须在此清理所有副作用：

  - 定时器
  - 订阅
  - 长时间运行任务

***

## 四、PiP 交互回调（仅限 PipView 使用）

### 1. 播放 / 暂停切换

```ts
onPipPlayPauseToggle?: (isPlaying: boolean) => void
```

- 当用户点击 PiP 控制区的播放 / 暂停按钮
- `isPlaying` 表示切换后的状态
- 常用于音频、视频、运动记录等场景

***

### 2. 快进 / 快退按钮

```ts
onPipSkip?: (isForward: boolean) => void
```

- `true`：向前
- `false`：向后

***

## 五、PiP 渲染尺寸变化

### `onPipRenderSizeChanged`

```ts
onPipRenderSizeChanged?: (size: Size) => void
```

- 当 PiP 窗口尺寸发生变化时触发
- 可根据尺寸动态调整布局
- 适用于横竖屏切换或系统自动调整 PiP 大小时

***

## 六、前后台行为控制（仅限 PipView 使用）

### `pipHideOnForeground`

```ts
pipHideOnForeground?: boolean
```

- 当应用进入前台时：

  - 若 PiP 正在运行，是否自动关闭
- 默认：`false`

***

### `pipShowOnBackground`

```ts
pipShowOnBackground?: boolean
```

- 当应用进入后台时是否自动启动 PiP
- 常用于音频播放、实时状态展示类场景

***

## 七、完整代码示例

### 1. PiP 内容视图（PipView）

```tsx
function PipView() {
  const started = useObservable(false)
  const count = useObservable(0)

  useEffect(() => {
    if (!started.value) {
      return
    }

    let timerId: number

    function startTimer() {
      timerId = setTimeout(() => {
        count.setValue(count.value + 1)
        startTimer()
      }, 1000)
    }

    startTimer()

    return () => {
      clearTimeout(timerId)
    }
  }, [started.value])

  return <HStack
    onPipStart={() => {
      started.setValue(true)
    }}
    frame={{
      width: Device.screen.width,
      height: 50
    }}
    background="systemBlue"
  >
    <Image
      systemName="figure.walk"
      font="title"
    />
    <Text foregroundStyle="white">
      Count: {count.value}
    </Text>
  </HStack>
}
```

***

### 2. 页面中启用 PiP

```tsx
function PageView() {
  const dismiss = Navigation.useDismiss()
  const pipPresented = useObservable(false)

  return <NavigationStack>
    <List
      navigationTitle="PiP Demo"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
      pip={{
        isPresented: pipPresented,
        content: <PipView />
      }}
    >
      <Button
        title="Toggle PiP"
        action={() => {
          pipPresented.setValue(!pipPresented.value)
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 八、重要注意事项（必须阅读）

### 1. PiPView 在 `isPresented = false` 时仍会被构建

- PiPView **不可见**
- 但仍然参与状态绑定与生命周期
- 不应在构建阶段执行任何重计算或副作用

**推荐做法**

- 所有逻辑延迟到 `onPipStart`
- 在 `onPipStop` 中彻底释放资源

***

### 2. PiP 专用修饰符只能在 PipView 中使用

以下属性和回调：

- `onPipStart`
- `onPipStop`
- `onPipPlayPauseToggle`
- `onPipSkip`
- `onPipRenderSizeChanged`
- `pipHideOnForeground`
- `pipShowOnBackground`

**只能定义在 PiP 内容视图（PipView）中**

如果定义在普通页面 View 中：

- 不会触发
- 无法获取正确状态
- 行为不可预测

***

### 3. PiP 不适合复杂 UI

不建议在 PiP 中使用：

- `List`、`ScrollView`
- 复杂动画
- 高频状态更新
- 网络请求驱动的 UI

PiP 的设计目标是：

> 轻量、稳定、可持续展示的系统级辅助视图

***

## 九、推荐实践总结

- 为 PiP 单独设计一个最小化 View
- 控制更新频率，合理设置 `maximumUpdatesPerSecond`
- 所有副作用延迟到 `onPipStart`
- 始终在 `onPipStop` 中清理资源
- 不在 PiP 中复用页面级复杂视图



---
url: /v2/zh/guide/Changelog/2.4.5/Reminder.md
---

`Reminder` API 用于在 iOS 日历系统中创建、编辑和管理提醒事项。
它支持通过 `DateComponents` 设置截止日期、管理完成状态、设置优先级、添加备注、配置重复规则，以及使用提醒的各种相关属性，例如闹钟（EventAlarm）、参与者信息、状态检测属性等。

***

## 类：`Reminder`

`Reminder` 类用于操作单个提醒事项，包括读取与修改其属性、管理重复规则与闹钟，以及执行保存或删除操作。

***

# 一、属性说明

### identifier: string

唯一标识符，由系统分配（只读）。

### calendar: Calendar

提醒所属的日历。必须为有效的日历对象。

### title: string

提醒的标题或摘要。

### notes: string | null

备注信息，用于补充提醒内容。

***

## 完成状态相关属性

### isCompleted: boolean

记录提醒是否已完成。

- 设置为 `true` 时，会自动将 `completionDate` 设为当前时间。
- 设置为 `false` 时，会将 `completionDate` 设为 `null`。

说明：如果在其他设备完成了提醒，系统可能出现 `isCompleted = true` 但 `completionDate = null` 的情况。

### completionDate: Date | null

提醒被完成的时间。

- 设置为某个日期时，会自动令 `isCompleted = true`。
- 设置为 `null` 会将提醒标记为未完成。

***

## 截止时间相关属性

### dueDateComponents: DateComponents | null

表示提醒的截止时间，使用 `DateComponents` 可只设置日期部分或同时包含时间部分。

可使用 `DateComponents.isValidDate` 检查是否为有效日期组合。

### dueDate: Date | null

（已被替代的旧字段）

请使用 `dueDateComponents?.date` 获取实际日期。

### dueDateIncludesTime: boolean

（遗留字段）

可通过以下判断是否包含时间字段：
`dueDateComponents?.hour != null && dueDateComponents?.minute != null`

***

## 优先级

### priority: number

提醒的优先级，数值越大表示越重要或紧急。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

重复规则数组。

### hasRecurrenceRules: boolean

是否存在重复规则（只读）。

***

## 闹钟（Alarm）相关

### alarms: EventAlarm\[] | null

提醒绑定的提醒闹钟列表。

支持：

- 绝对时间闹钟
- 相对截止时间的闹钟（基于事件开始时间时使用）
- 地理围栏位置提醒

### hasAlarm: boolean

是否包含闹钟。

***

## 参与者相关

### attendees: EventParticipant\[] | null

提醒可包含参与者对象（只读）。

说明：并非所有来源的提醒都支持参与者。

### hasAttendees: boolean

指示是否存在参与者。

***

## 状态标识属性

### hasNotes: boolean

是否包含备注信息。

### hasChanges: boolean

当前实例或其内部对象是否含有尚未保存的更改。

***

# 二、实例方法

### addAlarm(alarm: EventAlarm): void

为提醒添加一个闹钟。

### removAlarm(alarm: EventAlarm): void

移除提醒中的某个闹钟。
（方法名称为 `removAlarm`）

***

### addRecurrenceRule(rule: RecurrenceRule): void

向提醒添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除指定的重复规则。

***

### `save(): Promise<void>`

保存提醒的修改。若为新建提醒，将自动添加到所属日历。

### `remove(): Promise<void>`

从日历中删除该提醒事项。

***

# 三、静态方法

### `Reminder.getAll(calendars?: Calendar[]): Promise<Reminder[]>`

获取所有提醒，可选指定日历列表。

***

### `Reminder.getIncompletes(options?): Promise<Reminder[]>`

获取未完成的提醒事项，可按截止时间与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含截止时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含截止时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

说明：
该方法不会展开重复提醒实例，仅返回基础提醒条目。

***

### `Reminder.getCompleteds(options?): Promise<Reminder[]>`

获取已完成的提醒事项，可按完成日期范围与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含完成时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含完成时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

***

# 四、示例

## 使用 DateComponents 设置提醒

```ts
const reminder = new Reminder()
reminder.title = "准备会议资料"
reminder.notes = "周一会议前完成"

reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
  hour: 9,
  minute: 30,
})

reminder.priority = 2
await reminder.save()
```

***

## 创建仅包含日期的提醒（无时间）

```ts
reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
})
```

***

## 从 Date 创建 DateComponents

```ts
const now = new Date()
reminder.dueDateComponents = DateComponents.fromDate(now)
```

***

## 获取提醒事项

```ts
const reminders = await Reminder.getAll()
for (const r of reminders) {
  console.log(`提醒：${r.title}`)
}
```

***

## 获取未完成的提醒

```ts
const incompletes = await Reminder.getIncompletes({
  startDate: new Date("2025-01-01"),
  endDate: new Date("2025-01-31"),
})
```

***

## 标记提醒完成

```ts
reminder.isCompleted = true
await reminder.save()
```

***

## 删除提醒

```ts
await reminder.remove()
```

***

# 五、补充说明

### 日期管理

建议使用 `dueDateComponents` 统一处理截止时间相关逻辑。
支持：

- 仅日期
- 完整日期与时间
- 部分字段指定（如只指定小时与分钟）

可使用 `.isValidDate` 判断组件组合是否有效。

***

### 重复提醒

查询方法不展开重复实例，而是返回提醒对象本身。
可通过 `addRecurrenceRule` 与 `removeRecurrenceRule` 管理重复模式。

***

### 闹钟（EventAlarm）

Reminder 与 CalendarEvent 均可使用 `EventAlarm`。
闹钟可基于绝对时间、相对时间或地理位置触发。

***

### 参与者字段

部分提醒来源不一定支持参与者，因此 `attendees` 可能为 `null`。



---
url: /v2/zh/guide/Changelog/2.4.5/ReorderableForEach/index.md
---

# 可拖拽的 ForEach (ReorderableForEach)

`ReorderableForEach` 是 Scripting 提供的一个支持 **拖拽排序（Drag to Reorder）** 的高级渲染组件。
它在保持 `ForEach` 使用方式的同时，内置了拖拽手势识别、激活态管理、排序回调等能力，使开发者可以非常低成本地实现 **可拖拽排序的列表或网格布局**。

该组件特别适用于以下场景：

- 拖拽调整排序的卡片布局
- 拖拽调整顺序的网格（`LazyVGrid` / `LazyHGrid`）
- 脚本驱动的可交互功能模块编排界面

***

## 一、组件定义

```ts
type ReorderableForEachProps<T extends {
  id: string
}> = {
  active: Observable<T | null>
  data: T[]
  builder: (item: T, index: number) => VirtualNode
  onMove: (indices: number[], newOffset: number) => void
}

interface ReorderableForEachComponent {
  <T extends {
    id: string
  }>(props: ReorderableForEachProps<T>): VirtualNode
}

declare const ReorderableForEach: ReorderableForEachComponent
```

***

## 二、泛型约束说明

### 必须包含 `id` 字段

`ReorderableForEach` 的泛型参数 `T` 必须满足：

```ts
T extends { id: string }
```

也就是说，每一项数据必须具备：

- 唯一的 `id` 值
- 稳定不变的标识

该 `id` 用于：

- 识别当前被拖拽的元素
- 维持拖拽过程中的元素一致性
- 正确计算排序变更位置

如果 `id` 不唯一或在拖拽过程中发生变化，将导致排序错乱。

***

## 三、Props 参数说明

### 1. `active`

```ts
active: Observable<T | null>
```

用于表示 **当前正在被拖拽的元素状态**。

行为说明：

- 拖拽开始时，当前项会被写入 `active.value`
- 拖拽结束时，`active.value` 会恢复为 `null`
- 你可以利用它实现：

  - 拖拽元素高亮
  - 透明度变化
  - 联动动画
  - 状态辅助 UI

***

### 2. `data`

```ts
data: T[]
```

当前参与排序的数据数组。

重要说明：

- `ReorderableForEach` **不会自动修改该数组**
- 拖拽完成后，必须在 `onMove` 中手动更新该数组顺序
- 推荐与 `useObservable` 配合使用：

```ts
const data = useObservable<T[]>(...)
```

***

### 3. `builder`

```ts
builder: (item: T, index: number) => VirtualNode
```

用于渲染每一项的 UI 视图。

参数说明：

| 参数      | 含义                 |
| ------- | ------------------ |
| `item`  | 当前数据项              |
| `index` | 当前项在 `data` 中的实时索引 |

返回值必须是一个合法的 `VirtualNode`。

注意：

- 这里的 `index` 是拖拽后的实时索引
- 不应在此依赖旧索引逻辑做安全判断

***

### 4. `onMove`

```ts
onMove: (indices: number[], newOffset: number) => void
```

当用户完成一次拖拽排序后触发。

参数含义：

| 参数          | 类型         | 说明              |
| ----------- | ---------- | --------------- |
| `indices`   | `number[]` | 被拖动元素在原数组中的索引集合 |
| `newOffset` | `number`   | 新插入的起始位置        |

你必须在此方法中：

1. 根据 `indices` 取出被移动的元素
2. 从原数据中移除它们
3. 按 `newOffset` 重新插入
4. 使用 `Observable.setValue` 提交新顺序

标准实现如下：

```ts
const onMove = (indices: number[], newOffset: number) => {
  const movingItems = indices.map(index => data.value[index])
  const newValue = data.value.filter((_, index) => !indices.includes(index))
  newValue.splice(newOffset, 0, ...movingItems)
  data.setValue(newValue)
}
```

***

## 四、`contentShape` 的真实作用说明

在你的示例代码中：

```tsx
.contentShape({
  kind: 'dragPreview',
  shape: {
    type: 'rect',
    cornerRadius: 16
  }
})
```

该配置的核心作用是：

> **设置拖拽时的预览形状，使拖拽时显示的形状与非拖拽状态下保持一致（RoundedRectangle）。**

它并不是简单地“开启拖拽”，而是用于：

- 定义拖拽时的命中区域
- 同步拖拽预览的视觉形状
- 避免：

  - 拖拽时出现矩形裁切
  - 与原有圆角样式不一致的问题

如果不配置 `dragPreview` 形状，拖拽时可能会退化为默认矩形预览，破坏一致性。

***

## 五、完整使用流程说明

### 1. 数据模型定义

```ts
type Item = {
  id: string
  color: Color
}
```

***

### 2. 初始化可排序数据源

```ts
const data = useObservable<Item[]>(() => {
  return new Array(30)
    .fill(0)
    .map((_, index) => ({
      id: String(index),
      color: colors[index % colors.length]
    }))
})
```

***

### 3. 声明拖拽激活态

```ts
const active = useObservable<Item | null>(null)
```

***

### 4. 单项拖拽视图（保持拖拽前后外观一致）

```tsx
<VStack
  modifiers={
    modifiers()
      .frame({ height: 80 })
      .frame({ maxWidth: 'infinity' })
      .background(
        <RoundedRectangle
          cornerRadius={16}
          fill={item.color}
        />
      )
      .contentShape({
        kind: 'dragPreview',
        shape: {
          type: 'rect',
          cornerRadius: 16
        }
      })
  }
>
```

***

### 5. 在 `LazyVGrid` 中使用 ReorderableForEach

```tsx
<ReorderableForEach
  active={active}
  data={data.value}
  builder={(item) =>
    <ItemView item={item} />
  }
  onMove={onMove}
/>
```

***

## 六、关于在 `List` 中使用的限制说明

虽然从技术上讲，`ReorderableForEach` 可以放入 `List` 内部使用，但 **整体上并不推荐在 `List` 中使用该组件**，原因如下：

1. `List` 自带：

   - 行分隔线
   - 行高计算
   - 选中态
   - 系统滑动手势
   - 系统编辑模式

2. 这些系统行为会与：

   - 自定义拖拽动画
   - 自定义排序逻辑
   - 拖拽命中区域计算

   产生不可控的冲突。

3. 可能带来的问题包括：

- 拖拽过程中跳动
- 命中区域错位
- 拖拽排序时系统进入编辑态
- 行复用与拖拽状态不同步

因此推荐的使用容器是：

- `ScrollView`
- `LazyVGrid`
- `LazyHGrid`
- 纯自定义布局容器

而不是 `List`。

***

## 七、组件工作机制总结

`ReorderableForEach` 的行为逻辑可以总结为：

1. 依据 `data` 构建可拖拽子节点
2. 依据 `dragPreview contentShape` 确定拖拽命中区域与预览形状
3. 拖拽过程中：

   - 自动维护 `active`
   - 实时计算目标插入位置
4. 拖拽结束后：

   - 通过 `onMove` 将排序结果交给开发者处理
   - 由开发者负责最终数据顺序更新

***

## 八、适用场景

- 功能模块拖拽排序
- 工具栏按钮排序
- 卡片式任务优先级调整
- 桌面组件布局排序
- 视觉网格自由排序



---
url: /v2/zh/guide/Changelog/2.4.5/ReorderableForEach/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, ScrollView, useObservable, LazyVGrid, ReorderableForEach, RoundedRectangle, VStack, Toolbar, ToolbarItem, modifiers, Color } from "scripting"

type Item = {
  id: string
  color: Color
}

const colors: Color[] = [
  'systemRed',
  'systemBlue',
  'systemGreen',
  'systemPink',
  'systemOrange',
  'systemPurple',
]

function ItemView({
  item
}: {
  item: Item
}) {

  return <VStack
    modifiers={
      modifiers()
        .frame({
          height: 80
        })
        .frame({
          maxWidth: 'infinity'
        })
        .background(
          <RoundedRectangle
            cornerRadius={16}
            fill={item.color}
          />
        )
        .contentShape({
          kind: 'dragPreview',
          shape: {
            type: 'rect',
            cornerRadius: 16
          }
        })
    }
  >
    <Text
      foregroundStyle="white"
      font="title"
    >{item.id}</Text>
  </VStack>
}

function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  const data = useObservable<Item[]>(() => {
    return new Array(30)
      .fill(0)
      .map((_, index) => ({
        id: String(index),
        color: colors[index % colors.length]
      }))
  })

  const active = useObservable<Item | null>(null)

  const onMove = (indices: number[], newOffset: number) => {
    const movingItems = indices.map(index => data.value[index])
    const newValue = data.value.filter((_, index) => !indices.includes(index))
    newValue.splice(newOffset, 0, ...movingItems)
    data.setValue(newValue)
  }

  return <NavigationStack>
    <ScrollView
      navigationTitle="ReorderableForEach demo"
      toolbar={
        <Toolbar>
          <ToolbarItem
            placement="topBarLeading"
          >
            <Button
              title="Close"
              action={dismiss}
            />
          </ToolbarItem>
        </Toolbar>
      }
    >
      <LazyVGrid
        columns={[
          {
            size: {
              type: 'flexible'
            }
          },
          {
            size: {
              type: 'flexible'
            }
          }
        ]}
        padding={{
          horizontal: true
        }}
      >
        <ReorderableForEach
          active={active}
          data={data.value}
          builder={(item) =>
            <ItemView
              item={item}
            />
          }
          onMove={onMove}
        />
      </LazyVGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  // Present view.
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.5/Selectable List.md
---

# 可选择的列表

`List.selection` 用于为 `List` 组件提供**选择状态绑定能力**，用于实现列表的：

- 单选模式（Single Selection）
- 多选模式（Multiple Selection）
- 与编辑模式（`EditButton`）联动的批量选择行为

***

## 一、API 定义

```ts
type ListProps = {
  selection?: Observable<string | null> | Observable<string[]>
  ...
}

declare const List: FunctionComponent<ListProps>
```

***

## 二、selection 类型说明

`selection` 通过 `Observable` 的泛型类型自动区分选择模式：

| 模式 | Observable 类型                | 说明         |
| -- | ---------------------------- | ---------- |
| 单选 | `Observable<string \| null>` | 仅允许选中一个元素  |
| 多选 | `Observable<string[]>`       | 允许同时选中多个元素 |

***

## 三、selection 与 ForEach 的自动绑定规则

当 `List` 绑定 `selection` 时，`ForEach` 的 `data` **必须满足以下规则**：

```ts
ForEach 的 data 数组中，每一个元素都必须包含：

{
  id: string
}
```

系统行为规则如下：

1. `id` 会被自动作为该行的 **唯一选择标识**
2. 当用户点击某一行时：

   - 单选模式：`selected.value` 会被自动设置为该行的 `id`
   - 多选模式：该 `id` 会被自动加入或移出 `selected.value` 数组
3. 不需要手动在 `onTap` 中处理选中逻辑
4. `id` 必须唯一且稳定，否则会导致选择状态错乱或失效

***

## 四、单选模式（Single Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string | null>(null)
```

### 2. 使用示例

```tsx
function View() {
  const selected = useObservable<string | null>(null)

  const options = useObservable<{ id: string }[]>(() =>
    new Array(10).fill(0).map((_, i) => ({ id: i.toString() }))
  )

  return <NavigationStack>
    <List selection={selected}>
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

- `null`：当前没有选中任何项
- `"3"`：当前选中 `id === "3"` 的项

***

## 五、多选模式（Multiple Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string[]>([])
```

### 2. 使用示例

```tsx
function View() {
  const dismiss = Navigation.useDismiss()
  const selected = useObservable<string[]>([])

  const options = useObservable<{ id: string }[]>(() =>
    new Array(30).fill(0).map((_, i) => ({
      id: i.toString() 
    }))
  )

  console.log(selected.value)

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />,
        topBarTrailing: <EditButton />
      }}
      selection={selected}
    >
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

`selected.value` 始终为一个字符串数组，例如：

```ts
["2", "5", "8"]
```

表示当前有 3 项被同时选中。

***

## 六、selection 与 EditButton 的编辑模式行为

当 `List` 绑定了 `selection` 后：

1. `EditButton` 会自动启用选择编辑模式
2. 进入编辑模式后：

   - 单选：点击某一项即切换选中项
   - 多选：支持多项同时勾选
3. 退出编辑模式后：

   - `selected.value` 会被 **自动重置**

     - 单选模式重置为 `null`
     - 多选模式重置为空数组 `[]`

该行为与 SwiftUI 原生编辑模式保持一致。

***

## 七、selection 的程序化控制

除了用户交互以外，也可以通过代码主动修改选中状态。

### 单选模式

```ts
selected.setValue("5")
```

### 多选模式

```ts
selected.setValue(["1", "3", "7"])
```

设置后 UI 会自动同步对应的勾选状态。

***

## 八、selection 与 NavigationStack 的兼容性

`List.selection` 可以安全地在 `NavigationStack` 内使用，不会影响：

- 页面导航行为
- Toolbar 显示
- EditButton 编辑模式
- 页面返回逻辑

标准推荐结构如下：

```tsx
<NavigationStack>
  <List selection={selected}>
    ...
  </List>
</NavigationStack>
```

***

## 九、常见错误说明

### 1. selection 类型错误

错误：

```ts
const selected = useObservable<number | null>(null)
```

正确：

```ts
const selected = useObservable<string | null>(null)
```

目前 `selection` 仅支持 `string` 作为选择标识类型。

***

### 2. 多选模式初始化错误

错误：

```ts
const selected = useObservable<string[]>(null)
```

正确：

```ts
const selected = useObservable<string[]>([])
```

***

### 3. data 未包含 id:string

错误示例：

```tsx
const options = [{ name: "A" }, { name: "B" }]
```

该写法将导致：

- selection 无法正常工作
- 勾选状态丢失
- 列表复用异常

***

## 十、适用场景

`List.selection` 适用于以下场景：

- 单选设置项（主题、语言、偏好）
- 批量删除
- 批量导出
- 批量分享
- 文件管理器
- 通讯录选择
- 任务列表勾选



---
url: /v2/zh/guide/Changelog/2.4.5/VideoPreviewView.md
---

# 视频预览视图（VideoPreviewView）

`VideoPreviewView` 用于实时展示 `VideoRecorder` 当前相机会话的预览画面（camera preview）。
它是 UI 层组件，不负责录制控制逻辑；录制的准备、开始、暂停、恢复与停止由 `VideoRecorder` 负责。

`VideoPreviewView` 的核心职责是：将录制器内部的预览输出渲染到界面中，并支持通过通用 View props（如 `frame`、`aspectRatio` 等）进行布局。

***

## 组件定义

```ts
type VideoPreviewViewProps = {
  recorder: VideoRecorder
}

declare const VideoPreviewView: FunctionComponent<VideoPreviewViewProps>
```

***

## Props 说明

### recorder

```ts
recorder: VideoRecorder
```

绑定的 `VideoRecorder` 实例。`VideoPreviewView` 会从该实例获取预览画面来源。

#### 行为约定

- 当 `recorder.prepare()` 成功后，预览画面可用并开始更新。
- 当 `recorder.dispose()` 被调用后，预览画面停止并释放底层资源。
- `VideoPreviewView` 不会自动调用 `prepare()` 或自动开始录制。

***

## 与 VideoRecorder 状态的关系

`VideoPreviewView` 的显示效果通常与 `VideoRecorder.state` 对应如下（具体表现可能受系统行为影响）：

| Recorder 状态 | 预览表现           |
| ----------- | -------------- |
| `idle`      | 尚未准备，可能为空画面    |
| `preparing` | 正在准备中，画面可能尚不可用 |
| `ready`     | 预览可用           |
| `recording` | 正常实时预览         |
| `paused`    | 通常停留在暂停时的最后一帧  |
| `finishing` | 停止更新或逐步停止      |
| `finished`  | 不再更新           |
| `failed`    | 不可用            |

***

## 推荐用法与生命周期管理

建议将 `VideoRecorder` 作为页面级对象创建，并在页面卸载时调用 `dispose()` 释放资源。
同时，使用 `onStateChanged` 监听状态，以驱动 UI 文案、按钮可用性、错误提示等。

要点：

- `VideoRecorder` 建议通过 `useMemo` 创建，避免每次渲染重复构造。
- 在 `useEffect` 中绑定 `onStateChanged`，并在 cleanup 中调用 `dispose()`。
- 录制前必须 `await recorder.prepare()`。

***

## 完整示例

```tsx
function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()
  const recorder = useMemo(() => {
    return new VideoRecorder({
      camera: {
        position: "front",
      },
      frameRate: 30,
      audioEnabled: true,
      orientation: "portrait",
      sessionPreset: "hd1280x720",
      videoCodec: "hevc"
    })
  }, [])
  const [state, setState] = useState<VideoRecorderState>("idle")

  useEffect(() => {
    recorder.onStateChanged = (state, details) => {
      setState(state)

      if (state === "failed") {
        Dialog.alert(details!)
      }
    }

    return () => {
      recorder.dispose()
    }
  }, [])

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <Text>State: {state}</Text>

      <Button
        title="Start"
        action={async () => {
          await recorder.prepare()
          recorder.startRecording(
            Path.join(
              FileManager.documentsDirectory,
              "test.mov"
            )
          )
        }}
      />

      <Button
        title="Pause"
        action={() => {
          recorder.pauseRecording()
        }}
      />

      <Button
        title="Resume"
        action={() => {
          recorder.resumeRecording()
        }}
      />

      <Button
        title="Stop"
        action={async () => {
          await recorder.stopRecording()
        }}
      />

      <VideoPreviewView
        recorder={recorder}
        frame={{
          width: 300
        }}
        aspectRatio={{
          value: 3 / 4,
          contentMode: "fill"
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 布局与渲染建议

### 使用 frame 控制尺寸

`VideoPreviewView` 支持通过通用的 `frame` 属性约束宽高。例如：

- 仅指定 `width`：配合 `aspectRatio` 确定最终高度
- 指定 `width` + `height`：强制固定大小（可能导致裁剪或拉伸，取决于 aspect ratio 与 content mode）

### 使用 aspectRatio 控制比例与填充策略

示例：

```tsx
<VideoPreviewView
  recorder={recorder}
  aspectRatio={{ value: 3 / 4, contentMode: "fill" }}
/>
```

- `value`：宽高比
- `contentMode: "fill"`：按比例填充并裁剪
- 若你希望完整显示画面且允许留边，可使用 `contentMode: "fit"`（如果你们的通用 props 支持该值）

***

## 常见注意事项

### 必须 prepare 才能稳定显示预览

`VideoPreviewView` 绑定 `recorder` 并不意味着会自动启动会话。若未 `prepare()`：

- 预览可能为空
- 或短时间内不可用
- 不建议依赖隐式行为

最佳实践：在 Start 按钮中 `await recorder.prepare()` 后再 `startRecording()`，如示例所示。

### 释放资源

- 页面关闭或不再需要预览时，务必调用 `recorder.dispose()`。
- 建议使用 `useEffect` cleanup 释放，避免相机占用导致后续页面无法打开摄像头或耗电。

### 错误处理

当 `state === "failed"` 时，建议：

- 立即提示 `details`（如示例 `Dialog.alert(details!)`）
- 同时在 UI 上禁用录制按钮，或提供重试逻辑（例如 `await recorder.reset()` 后再 `prepare()`）

***

## 组件职责边界

- `VideoRecorder`：负责录制控制与状态机（prepare/start/pause/resume/stop/reset/dispose）
- `VideoPreviewView`：负责画面显示与 UI 布局（通过 `frame` / `aspectRatio` 等通用属性）



---
url: /v2/zh/guide/Changelog/2.4.5/VideoRecorder.md
---

# 视频录制（VideoRecorder）

`VideoRecorder` 用于在 Scripting 中创建和控制一个可编程的视频录制会话，完整封装了相机选择、音视频采集、编码、暂停/恢复、缩放、对焦、补光灯控制以及最终文件写入流程。

该 API 适用于自定义相机界面、视频采集工具、自动化录制脚本等场景。

***

## 核心能力概览

- 支持前置与后置摄像头
- 支持指定摄像头类型（广角、超广角、长焦等）
- 支持多种帧率（24 / 30 / 60 / 120）
- 支持音频录制的启用与禁用
- 支持多种系统 Session Preset
- 支持多种视频编码格式（HEVC / H.264 / ProRes 等）
- 支持录制过程中的暂停与恢复
- 支持对焦点、曝光点独立控制
- 支持变焦与平滑变焦（ramp）
- 支持补光灯（Torch）控制
- 明确的状态机与状态回调
- 明确的生命周期管理（prepare / reset / dispose）

***

## 类型定义

### CameraPosition

```ts
type CameraPosition = "front" | "back"
```

表示使用的摄像头朝向。

***

### CameraType

```ts
type CameraType =
  | "wide"
  | "ultraWide"
  | "telephoto"
  | "trueDepth"
  | "dual"
  | "dualWide"
  | "triple"
```

表示摄像头的物理类型。
是否支持某一类型取决于设备硬件能力。

***

### VideoRecorderState

```ts
type VideoRecorderState =
  | "idle"
  | "preparing"
  | "ready"
  | "recording"
  | "paused"
  | "finishing"
  | "finished"
  | "failed"
```

#### 状态说明

| 状态          | 含义             |
| ----------- | -------------- |
| `idle`      | 初始状态，尚未配置资源    |
| `preparing` | 正在配置相机会话与音视频管线 |
| `ready`     | 已准备完成，可以开始录制   |
| `recording` | 正在录制           |
| `paused`    | 录制已暂停          |
| `finishing` | 正在结束录制并写入文件    |
| `finished`  | 录制完成           |
| `failed`    | 发生错误，录制失败      |

***

### VideoCaptureSessionPreset

```ts
type VideoCaptureSessionPreset =
  | "high"
  | "medium"
  | "low"
  | "cif352x288"
  | "vga640x480"
  | "iFrame960x540"
  | "iFrame1280x720"
  | "hd1280x720"
  | "hd1920x1080"
  | "hd4K3840x2160"
```

表示捕捉会话的分辨率预设。

***

### VideoCodec

```ts
type VideoCodec =
  | "hevc"
  | "h264"
  | "jpeg"
  | "JPEGXL"
  | "proRes4444"
  | "appleProRes4444XQ"
  | "proRes422"
  | "proRes422HQ"
  | "proRes422LT"
  | "proRes422Proxy"
  | "proResRAW"
  | "proResRAWHQ"
  | "hevcWithAlpha"
```

表示视频编码格式。
具体是否可用取决于设备与系统支持情况。

***

### VideoOrientation

```ts
type VideoOrientation =
  | "portrait"
  | "landscapeLeft"
  | "landscapeRight"
```

表示输出视频的方向。

***

## 构造函数

```ts
new VideoRecorder(settings?)
```

### settings 参数

```ts
{
  camera?: {
    position: CameraPosition
    preferredTypes?: CameraType[]
  }
  frameRate?: number
  audioEnabled?: boolean
  sessionPreset?: VideoCaptureSessionPreset
  videoCodec?: VideoCodec
  videoBitRate?: number
  orientation?: VideoOrientation
  mirrorFrontCamera?: boolean
}
```

#### 参数说明

- **camera**

  - `position`
    使用的摄像头位置，默认 `"back"`
  - `preferredTypes`
    偏好的摄像头类型列表
    如果未提供，内部将根据摄像头位置自动选择合适的类型

- **frameRate**
  目标帧率，支持 24 / 30 / 60 / 120，默认 30
  实际帧率受设备与分辨率限制

- **audioEnabled**
  是否录制音频，默认 `true`

- **sessionPreset**
  捕捉会话分辨率预设，默认 `"high"`

- **videoCodec**
  视频编码格式，默认 `"hevc"`

- **videoBitRate**
  视频平均码率（bit/s），未指定时由系统自动选择

- **orientation**
  输出视频方向，默认 `"portrait"`

- **mirrorFrontCamera**
  前置摄像头是否镜像，默认 `true`
  仅在使用前置摄像头时生效

***

## 只读属性

### minZoomFactor

```ts
readonly minZoomFactor: number
```

当前设备支持的最小变焦倍率。

***

### maxZoomFactor

```ts
readonly maxZoomFactor: number
```

当前设备支持的最大变焦倍率。

***

### currentZoomFactor

```ts
readonly currentZoomFactor: number
```

当前变焦倍率。

***

### displayZoomFactor

```ts
readonly displayZoomFactor: number
```

用户可读的变焦倍率。

***

### hasTorch

```ts
readonly hasTorch: boolean
```

当前摄像头是否支持补光灯。

***

### torchMode

```ts
readonly torchMode: "auto" | "on" | "off"
```

当前补光灯模式。

***

## 状态与回调

### state

```ts
state: VideoRecorderState
```

表示当前录制器所处的状态。

***

### onStateChanged

```ts
onStateChanged?: (
  state: VideoRecorderState,
  details?: string
) => void
```

状态变化回调。

- 当 `state === "failed"`
  `details` 为错误信息描述

- 当 `state === "finished"`
  `details` 为最终视频文件的完整保存路径

***

## 方法说明

### prepare()

```ts
prepare(): Promise<void>
```

准备录制器资源，包括相机会话、输入输出与音视频管线配置。

#### 使用约束

- 必须在 `startRecording` 之前调用
- 成功后状态变为 `ready`
- 失败会进入 `failed` 状态

***

### startRecording(toPath)

```ts
startRecording(toPath: string): void
```

开始录制视频。

#### 参数

- **toPath**
  视频文件保存路径（完整路径）

#### 使用约束

- 仅允许在 `ready` 状态下调用
- 调用后状态变为 `recording`

***

### pauseRecording()

```ts
pauseRecording(): void
```

暂停当前录制。

#### 使用约束

- 仅允许在 `recording` 状态下调用
- 调用后状态变为 `paused`
- 时间线会被正确压缩，不产生空白帧

***

### resumeRecording()

```ts
resumeRecording(): void
```

恢复已暂停的录制。

#### 使用约束

- 仅允许在 `paused` 状态下调用
- 调用后状态回到 `recording`

***

### stopRecording()

```ts
stopRecording(): Promise<void>
```

停止录制并生成最终视频文件。

#### 行为说明

- 状态先进入 `finishing`
- 文件写入完成后进入 `finished`
- 最终文件路径通过 `onStateChanged` 回调返回

***

### reset()

```ts
reset(): Promise<void>
```

重置录制器状态，用于开始新一轮录制。

#### 使用场景

- 已完成一次录制
- 或录制失败后希望复用同一实例

#### 行为说明

- 成功后状态回到 `idle`
- 可再次调用 `prepare`

***

### setTorchMode()

```ts
setTorchMode(mode: "auto" | "off" | "on"): void
```

设置补光灯模式。

***

### setFocusPoint()

```ts
setFocusPoint(point: { x: number; y: number }): void
```

设置对焦点。

- 坐标为归一化值，范围 `0.0 ~ 1.0`
- `(0,0)` 表示画面左上角，`(1,1)` 表示右下角

***

### setExposurePoint()

```ts
setExposurePoint(point: { x: number; y: number }): void
```

设置曝光点，坐标规则与对焦点一致。

***

### resetFocus()

```ts
resetFocus(): void
```

恢复自动对焦模式。

***

### resetExposure()

```ts
resetExposure(): void
```

恢复自动曝光模式。

***

### setZoomFactor()

```ts
setZoomFactor(factor: number): void
```

立即设置变焦倍率。

- 值应位于 `minZoomFactor` 与 `maxZoomFactor` 之间

***

### rampZoomFactor()

```ts
rampZoomFactor(toFactor: number, rate: number): void
```

以平滑方式调整变焦倍率。

- `toFactor` 为目标倍率
- `rate` 为变化速率，单位为每秒的 2 次幂变化

***

### resetZoom()

```ts
resetZoom(): void
```

将变焦倍率恢复为默认值（通常为 1.0）。

***

### dispose()

```ts
dispose(): Promise<void>
```

释放并销毁录制器。

#### 使用约束

- 调用后实例不可再使用
- 会释放相机、音频与底层系统资源
- 建议在页面或脚本生命周期结束时调用

***

## 典型使用流程

```ts
const recorder = new VideoRecorder({
  camera: { position: "back" },
  frameRate: 60,
  videoCodec: "hevc"
})

recorder.onStateChanged = (state, details) => {
  if (state === "finished") {
    console.log("Video saved at:", details)
  }
}

await recorder.prepare()
recorder.startRecording("/path/to/tmp/demo.mov")
```

***

## 使用建议

- 始终监听 `onStateChanged` 以掌握完整状态变化
- 不要在未调用 `prepare` 的情况下开始录制
- 每次完成录制后，如需复用实例，应先调用 `reset`
- 生命周期结束时务必调用 `dispose` 释放资源



---
url: /v2/zh/guide/Changelog/2.4.5/WebViewController.md
---

# WebView 控制器

`WebViewController` 是一个用于显示和交互网页内容的控制器。它允许你在脚本中加载 HTML、展示 Web 页面、执行 JavaScript 脚本，并与页面中的 JavaScript 进行消息通信。你可以将它作为浏览器使用，也可以嵌入应用功能页面。

***

## 类：`WebViewController`

```ts
const webView = new WebViewController()
```

***

## 属性

### `shouldAllowRequest?: (request) => Promise<boolean>`

一个可选回调，用于决定是否允许或拦截 WebView 发起的请求。每次加载资源之前都会调用此函数，例如导航到新页面或提交表单时。

适用于拦截跳转行为、自定义安全策略或过滤广告等不需要的请求。

#### 参数

回调函数接收一个 `request` 对象，包含以下字段：

- `url: string`
  请求的完整 URL。

- `method: string`
  HTTP 方法，如 `GET`、`POST`。

- `body?: Data | null`
  可选，请求体数据（通常用于 `POST` 请求）。

- `headers: Record<string, string>`
  请求头信息。

- `timeoutInterval: number`
  请求的超时时间（单位为秒）。

- `navigationType: "linkActivated" | "reload" | "backForward" | "formResubmitted" | "formSubmitted" | "other"`
  触发导航的上下文。

#### 返回值

一个 `Promise<boolean>`，用于指示是否允许该请求：

- `true`：允许请求继续
- `false`：阻止该请求

#### 示例

```ts
const webView = new WebViewController()

webView.shouldAllowRequest = async (request) => {
  console.log('拦截到请求：', request.url)

  // 拦截所有访问 example.com 的请求
  if (request.url.includes('example.com')) {
    return false
  }

  return true
}

await webView.loadURL('https://www.wikipedia.org')
await webView.present({ navigationTitle: '已过滤的网页视图' })
```

***

## 方法

### `loadURL(url: string): Promise<boolean>`

加载指定 URL 的网页内容。

- **参数**：

  - `url`：要加载的网页完整地址。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadFile(path: string, allowingReadAccessTo?: string): Promise<boolean>`

加载文件内容作为网页。

- **参数**:

  - `path`：要加载的文件路径。
  - `allowingReadAccessTo`（可选）：允许读取文件的路径，默认为 `path`。
- **返回**：`Promise<boolean>`

### `loadHTML(html: string, baseURL?: string): Promise<boolean>`

加载原始 HTML 字符串内容。

- **参数**：

  - `html`：要渲染的 HTML 字符串。
  - `baseURL`（可选）：用于解析相对路径的基础 URL。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadData(data: Data, mimeType: string, encoding: string, baseURL: string): Promise<boolean>`

加载原始数据作为网页内容。

- **参数**：

  - `data`：要加载的二进制内容。
  - `mimeType`：内容的 MIME 类型，例如 `"text/html"`。
  - `encoding`：字符编码，例如 `"utf-8"`。
  - `baseURL`：用于解析相对路径的基础地址。
- **返回**：`Promise<boolean>`

***

### `waitForLoad(): Promise<boolean>`

等待 WebView 加载完成。

- **返回**：`Promise<boolean>`

***

### `getHTML(): Promise<string | null>`

获取当前页面的 HTML 内容。

- **返回**：`Promise<string | null>`

***

### `evaluateJavaScript<T = any>(javascript: string): Promise<T>`

在 WebView 中执行指定的 JavaScript 代码。

- **参数**：

  - `javascript`：要执行的 JavaScript 代码字符串。若希望返回值，必须在代码中使用 `return`。
- **返回**：`Promise<T>` — JavaScript 执行结果将作为 Promise 的值返回。

#### 示例

```ts
const webView = new WebViewController()
await webView.loadURL("https://example.com")
const title = await webView.evaluateJavaScript("return document.title")
console.log(title) // "Example Domain"
webView.dispose()
```

或：

```ts
const webView = new WebViewController()
await webView.loadHTML(`
  <html>
    <body>
      <script>
        window.myValue = 42
      </script>
    </body>
  </html>
`)

await webView.waitForLoad()

const result = await webView.evaluateJavaScript('return window.myValue')
console.log(result) // 42
```

***

### `addScriptMessageHandler<P = any, R = any>(name: string, handler: (params?: P) => R): Promise<void>`

添加一个脚本消息处理器，可在网页中通过 JavaScript 调用，并接收原生代码返回的结果。

- **参数**：

  - `name`：消息处理器名称，必须唯一且非空。
  - `handler`：处理函数，接收来自网页的参数并返回一个值，作为 Promise 的结果回传给网页。
- **返回**：`Promise<void>` — 添加成功后完成。

#### 示例

```ts
let webView = new WebViewController()

await webView.addScriptMessageHandler("sayHi", (greeting: string) => {
  console.log("收到消息", greeting)
  return "你好！"
})

await webView.loadHTML(`
  <html>
    <body>
      <script>
        (async () => {
          const response = await window.webkit.messageHandlers.sayHi.postMessage("Hi!")
          alert(response) // 弹出 "你好！"
        })()
      </script>
    </body>
  </html>
`)
```

***

### `present(options?: { fullscreen?: boolean, navigationTitle?: string }): Promise<void>`

以模态窗口形式展示 WebView。

- **选项**：

  - `fullscreen`：是否以全屏模式展示。
  - `navigationTitle`：导航栏标题（可选）。
- **返回**：`Promise<void>`

***

### `canGoBack(): Promise<boolean>`

判断 WebView 是否可以后退。

***

### `canGoForward(): Promise<boolean>`

判断 WebView 是否可以前进。

***

### `goBack(): Promise<boolean>`

返回上一页。

***

### `goForward(): Promise<boolean>`

前进到下一页。

***

### `reload(): Promise<void>`

重新加载当前网页。

***

### `dismiss(): void`

关闭 WebView 页面（若当前正在展示）。

***

### `dispose(): void`

释放 WebView 实例并清理资源。

- 如果 WebView 正在展示，将先自动关闭。
- **重要**：请务必调用此方法以避免内存泄漏。

***

## 完整示例

```ts
const webView = new WebViewController()

await webView.addScriptMessageHandler('greet', (name) => {
  return `你好，${name}`
})

await webView.loadHTML(`
  <html>
    <body>
      <h1>自定义网页视图</h1>
      <button onclick="sendMessage()">打招呼</button>
      <script>
        async function sendMessage() {
          const response = await window.webkit.messageHandlers.greet.postMessage("Alice")
          alert(response)
        }
      </script>
    </body>
  </html>
`)

await webView.present({ navigationTitle: '网页视图示例' })
webView.dispose()
```



---
url: /v2/zh/guide/Changelog/2.4.6/Device/index.md
---

# 设备

`Device` 命名空间提供当前运行设备的基础信息、系统环境、屏幕与电池状态、语言与地区设置，以及部分与设备能力相关的方法（如唤醒锁、网络接口信息）。

该 API 常用于：

- 设备差异化逻辑（iPhone / iPad / Mac）
- UI 布局与适配
- 多语言与本地化判断
- 网络调试与诊断
- 防止脚本执行期间设备休眠

***

## 设备与系统信息

### `Device.model: string`

设备型号名称，例如 `"iPhone"`、`"iPad"`。

***

### `Device.systemName: string`

当前操作系统名称，例如 `"iOS"`、`"iPadOS"`、`"macOS"`。

***

### `Device.systemVersion: string`

当前操作系统版本号，例如 `"17.2"`。

***

### `Device.isiPhone: boolean`

当前设备是否为 iPhone。

***

### `Device.isiPad: boolean`

当前设备是否为 iPad。

***

### `Device.isiOSAppOnMac: boolean`

当前进程是否为 **iPhone / iPad App 运行在 Mac 上**（Mac Catalyst / Apple Silicon Mac）。

***

## 屏幕信息

### `Device.screen`

当前主屏幕的信息。

```ts
{
  width: number
  height: number
  scale: number
}
```

字段说明：

- `width`：屏幕逻辑宽度（pt）
- `height`：屏幕逻辑高度（pt）
- `scale`：屏幕缩放因子（如 2 / 3）

常用于布局计算、画布尺寸、截图或渲染比例控制。

***

## 方向与姿态

### `Device.isPortrait: boolean`

当前设备是否处于竖屏方向。

***

### `Device.isLandscape: boolean`

当前设备是否处于横屏方向。

***

### `Device.isFlat: boolean`

设备是否平放（例如放在桌面上）。

该值通常基于设备姿态传感器，用于高级交互或方向判断。

***

## 外观与主题

### `Device.colorScheme: ColorScheme`

当前系统外观模式。

可能的值通常包括：

- `light`
- `dark`

可用于根据系统外观自动调整 UI 主题或样式。

***

## 电池信息

### `Device.batteryState`

当前电池状态：

```ts
"full" | "charging" | "unplugged" | "unknown"
```

说明：

- `full`：电池已充满
- `charging`：正在充电
- `unplugged`：未连接电源
- `unknown`：状态不可用

***

### `Device.batteryLevel: number`

当前电量百分比，取值范围：

- `0.0` \~ `1.0`
- 当电量不可用时，可能返回 `-1`

***

## 语言与地区设置

### `Device.systemLocale: string`

系统当前使用的 Locale，例如：

```text
"en_US"
```

***

### `Device.preferredLanguages: string[]`

用户偏好的语言列表（按优先级排序），例如：

```ts
["en-US", "zh-Hans-CN"]
```

推荐用于多语言内容选择。

***

### `Device.systemLocales: string[]` （已废弃）

用户偏好的 Locale 列表。

> 已废弃，请使用 `Device.preferredLanguages`。

***

### `Device.systemLanguageTag: string`

当前语言的 BCP-47 语言标签，例如：

```text
"en-US"
```

***

### `Device.systemLanguageCode: string`

当前语言代码，例如：

```text
"en"
```

***

### `Device.systemCountryCode: string | undefined`

当前国家 / 地区代码，例如：

```text
"US"
```

如果系统未设置国家信息，可能为 `undefined`。

***

### `Device.systemScriptCode: string | undefined`

当前语言的书写系统代码，例如：

```text
"Hans"   // zh_CN_Hans
```

常用于区分简体 / 繁体等书写系统。

***

## 唤醒锁（Wake Lock）

唤醒锁用于防止设备在脚本运行期间自动休眠。

### `Device.isWakeLockEnabled: Promise<boolean>`

获取当前是否启用了唤醒锁。

```ts
const enabled = await Device.isWakeLockEnabled
```

***

### `Device.setWakeLockEnabled(enabled: boolean): void`

启用或关闭唤醒锁。

```ts
Device.setWakeLockEnabled(true)
```

说明：

- 仅在 **Scripting App** 中可用
- 启用后可防止屏幕自动熄灭或设备进入休眠
- 建议在不需要时及时关闭，以节省电量

***

## 网络接口信息

### `Device.NetworkInterface`

网络接口对象结构：

```ts
type NetworkInterface = {
  address: string
  netmask: string | null
  family: 'IPv4' | 'IPv6'
  mac: string | null
  isInternal: boolean
  cidr: string | null
}
```

字段说明：

- `address`：IP 地址
- `netmask`：子网掩码
- `family`：地址类型（IPv4 / IPv6）
- `mac`：MAC 地址（部分系统可能为 null）
- `isInternal`：是否为内部接口（如回环接口）
- `cidr`：CIDR 表示法（如 `192.168.1.10/24`）

***

### `Device.networkInterfaces(): Record<string, NetworkInterface[]>`

获取设备当前的网络接口信息。

返回值结构：

```ts
{
  [interfaceName: string]: NetworkInterface[]
}
```

示例：

```ts
const interfaces = Device.networkInterfaces()

for (const name in interfaces) {
  for (const info of interfaces[name]) {
    console.log(name, info.address, info.family)
  }
}
```

常见用途：

- 获取本地 IP 地址
- 区分 Wi-Fi / 蜂窝网络 / 回环接口
- 网络调试与诊断
- 模拟 Node.js `os.networkInterfaces()` 行为

***

## 使用建议

- 语言与地区相关逻辑优先使用 `preferredLanguages`
- 唤醒锁应在任务完成后及时关闭
- 网络接口信息可能因系统权限或网络状态变化而不同
- 不要假设某个接口名称一定存在（如 `en0`）



---
url: /v2/zh/guide/Changelog/2.4.6/Device/index_example.md
---

# 示例

```tsx
import { Button, Device, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

 function Example() {
  const dismiss = Navigation.useDismiss()

  const details: {
    name: string
    value: string | boolean | number
  }[] = [
      {
        name: "Device.isiPhone",
        value: Device.isiPhone
      },
      {
        name: "Device.isiPad",
        value: Device.isiPad,
      },
      {
        name: "Device.systemVersion",
        value: Device.systemVersion,
      },
      {
        name: "Device.systemName",
        value: Device.systemName,
      },
      {
        name: "Device.isPortrait",
        value: Device.isPortrait,
      },
      {
        name: "Device.isLandscape",
        value: Device.isLandscape,
      },
      {
        name: "Device.isFlat",
        value: Device.isFlat,
      },
      {
        name: "Device.batteryLevel",
        value: Device.batteryLevel,
      },
      {
        name: "Device.batteryState",
        value: Device.batteryState,
      }
    ]

  return <NavigationStack>
    <List
      navigationTitle={"Device"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      {details.map(item =>
        <VStack
          badge={item.value.toString()}
          alignment={"leading"}
        >
          <Text font={"headline"}>{item.name}</Text>
          <Text font={"caption"}>{typeof item.value}</Text>
        </VStack>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Changelog/2.4.6/Intent.md
---

# Intent

Scripting 支持通过 `intent.tsx` 文件创建 iOS Intents，实现脚本与系统分享扩展（Share Sheet）和快捷指令（Shortcuts）的深度集成。你可以接收来自用户的文本、图片、文件和 URL 等输入，并返回结果供调用方使用。通过 UI 展示、数据处理与结果返回，可构建灵活且强大的自动化流程。

***

## 一、创建和配置 Intent

### 1. 创建 Intent 脚本

1. 在 Scripting 中新建一个脚本项目。
2. 添加名为 `intent.tsx` 的文件，并编写处理逻辑和可选的 UI 组件。

### 2. 配置支持的输入类型

点击编辑器顶部标题栏中的项目名称，打开 **Intent 设置页面**，选择该脚本支持的输入类型，如：

- 文本（Text）
- 图片（Image）
- 文件路径（File URL）
- URL

配置后，该脚本就能在分享扩展或 Shortcuts 中处理相应类型的数据。

***

## 二、处理输入数据

在 `intent.tsx` 中，可通过以下 API 访问用户传入的数据：

| 属性名                        | 说明                                       |
| -------------------------- | ---------------------------------------- |
| `Intent.shortcutParameter` | Shortcuts 中传入的单个参数，包含 `.type` 和 `.value` |
| `Intent.textsParameter`    | 文本字符串数组                                  |
| `Intent.urlsParameter`     | URL 字符串数组                                |
| `Intent.imagesParameter`   | 图片数组（UIImage 实例）                         |
| `Intent.fileURLsParameter` | 文件路径数组（本地 URL）                           |

示例：

```ts
if (Intent.shortcutParameter) {
  if (Intent.shortcutParameter.type === "text") {
    console.log(Intent.shortcutParameter.value)
  }
}
```

***

## 三、返回结果

使用 `Script.exit(result)` 结束脚本执行并返回结果给调用方，例如 Shortcuts 或另一个脚本。支持的返回类型包括：

- 文本：`Intent.text(value)`
- 富文本：`Intent.attributedText(value)`
- URL：`Intent.url(value)`
- JSON 数据：`Intent.json(value)`
- 文件路径：`Intent.file(value)` 或 `Intent.fileURL(value)`

示例：

```ts
import { Script, Intent } from "scripting"

Script.exit(Intent.text("处理完成"))
```

***

## 四、展示交互式 UI

你可以使用 `Navigation.present()` 呈现一个自定义界面，展示输入信息或收集用户反馈。在 UI 交互结束后调用 `Script.exit()` 返回结果。

示例：

```ts
import { Intent, Script, Navigation, VStack, Text } from "scripting"

function MyIntentView() {
  return (
    <VStack>
      <Text>{Intent.textsParameter?.[0]}</Text>
    </VStack>
  )
}

async function run() {
  await Navigation.present(<MyIntentView />)
  Script.exit()
}

run()
```

***

## 五、在分享扩展中使用

当脚本项目启用了对应类型的输入支持，Scripting 会自动集成到系统分享菜单：

1. 用户选中内容（如 Safari 中的文字或图片），点击分享按钮。
2. 分享列表中选择 **Scripting**。
3. 显示支持当前输入类型的脚本列表，供用户执行。

***

## 六、与 Shortcuts 集成

你可以在 Shortcuts 应用中调用 Scripting 脚本：

- **运行脚本（Run Script）**：后台执行，无 UI。
- **在 App 中运行脚本（Run Script in App）**：前台执行，支持 UI 展示。

操作步骤：

1. 在 Shortcuts 中添加 “Run Script” 或 “Run Script in App” 操作。
2. 选择目标脚本。
3. 配置参数，执行脚本。

***

## 七、Intent API 参考

### `Intent` 类属性

| 属性                  | 类型                  | 说明                                    |
| ------------------- | ------------------- | ------------------------------------- |
| `shortcutParameter` | `ShortcutParameter` | Shortcuts 传入的参数对象，包含 `type` 和 `value` |
| `textsParameter`    | `string[]`          | 文本输入数组                                |
| `urlsParameter`     | `string[]`          | URL 字符串数组                             |
| `imagesParameter`   | `UIImage[]`         | 图片数组（路径或图片对象）                         |
| `fileURLsParameter` | `string[]`          | 文件路径数组（本地 URL）                        |

### `Intent` 类方法

| 方法                             | 返回类型                        | 示例                                    |
| ------------------------------ | --------------------------- | ------------------------------------- |
| `Intent.text(value)`           | `IntentTextValue`           | `Intent.text("内容")`                   |
| `Intent.attributedText(value)` | `IntentAttributedTextValue` | `Intent.attributedText("富文本")`        |
| `Intent.url(value)`            | `IntentURLValue`            | `Intent.url("https://example.com")`   |
| `Intent.json(value)`           | `IntentJsonValue`           | `Intent.json({ key: "value" })`       |
| `Intent.file(filePath)`        | `IntentFileValue`           | `Intent.file("/path/to/file.txt")`    |
| `Intent.fileURL(filePath)`     | `IntentFileURLValue`        | `Intent.fileURL("/path/to/file.pdf")` |
| `Intent.image(UIImage)`        | `IntentImageValue`          | `Intent.image(uiImage)`               |

***

## 八、最佳实践与注意事项

- 所有脚本应显式调用 `Script.exit()` 以确保内存安全。
- 推荐在 UI 脚本中使用 `await Navigation.present()` 之后再调用 `Script.exit()`。
- 对于大文件或图像，建议使用 “Run Script in App” 模式，以避免系统内存限制导致的崩溃。
- 如果脚本需要共享数据，可通过 URL Scheme 或 `queryParameters` 实现。



---
url: /v2/zh/guide/Changelog/2.4.6/ItemProvider.md
---

# ItemProvider

`ItemProvider` 用于表示一个**可按需加载的数据提供者**，常见于拖放、文件导入、Photos 选择等场景。
它并不直接包含数据本身，而是描述**可以如何、安全地获取数据**。

`ItemProvider` 支持加载对象、文本、URL、原始数据以及文件路径，并对文件访问施加了明确的安全访问边界。

***

## 核心概念

- `ItemProvider` 描述的是能力，而不是数据
- 所有加载行为都必须遵循系统的安全作用域规则
- 文件类资源只能在受控的回调作用域内访问
- 是否支持原地访问（in-place）由底层系统决定

***

## 属性

### registeredTypes

```ts
readonly registeredTypes: UTType[]
```

表示该 `ItemProvider` 在语义上可以提供的所有类型。

- 包含直接类型以及可推导的父类型
- 用于判断内容大类或调试用途
- 不保证一定存在对应的底层文件表示

***

### registeredInPlaceTypes

```ts
readonly registeredInPlaceTypes: UTType[]
```

表示该 `ItemProvider` 支持原地访问（open-in-place）的类型集合。

- 常见于视频、音频、文档等大文件
- 是否真正原地访问需以加载结果为准

***

## 能力判断方法

### hasItemConforming

```ts
hasItemConforming(type: UTType): boolean
```

判断内容在语义上是否符合指定类型。

- 判断宽松
- 会考虑 UTType 的继承关系
- 适合用于业务分支判断

***

### hasRepresentationConforming

```ts
hasRepresentationConforming(type: UTType): boolean
```

判断是否存在一个真实的、可加载的底层表示符合指定类型。

- 判断严格
- 适合用于文件处理或精确格式要求的场景

***

### hasInPlaceRepresentationConforming

```ts
hasInPlaceRepresentationConforming(type: UTType): boolean
```

判断是否存在支持原地访问的底层表示。

- 常用于大文件加载策略选择

***

## 对象加载能力判断

### canLoadUIImage

```ts
canLoadUIImage(): boolean
```

判断是否可以加载为 `UIImage` 对象。

- 适合 UI 展示
- 不保证原始文件格式或元数据

***

### canLoadLivePhoto

```ts
canLoadLivePhoto(): boolean
```

判断是否可以加载为 `LivePhoto` 对象。

- 用于区分静态图片与 Live Photo
- 返回 `true` 时可调用 `loadLivePhoto`

***

## 加载方法

### loadUIImage

```ts
loadUIImage(): Promise<UIImage | null>
```

加载一个 `UIImage` 对象。

- 适合轻量展示
- 不适合用于文件级处理或资源保真

***

### loadLivePhoto

```ts
loadLivePhoto(): Promise<LivePhoto | null>
```

加载一个 `LivePhoto` 对象。

- 包含图片与配对视频
- 适合展示、保存或进一步处理

***

### loadURL

```ts
loadURL(): Promise<string | null>
```

加载一个 URL 字符串。

- 可能是网页 URL
- 也可能是文件 URL

***

### loadText

```ts
loadText(): Promise<string | null>
```

加载纯文本内容。

- 支持 plain text
- 富文本会被降级为纯文本

***

### loadData

```ts
loadData(type: UTType): Promise<Data | null>
```

加载指定类型的原始二进制数据。

- 数据会整体加载进内存
- 适合 JSON、配置文件、小体积资源
- 不适合视频、音频等大文件

***

## 文件路径加载（安全作用域）

文件路径的加载需要遵循系统的安全限制，所有文件访问都必须在指定的回调作用域内完成。

***

### loadFilePath

```ts
loadFilePath(type: UTType): Promise<string | null>
```

加载指定类型的文件路径，如果文件不存在或无法加载，返回 `null`。如果可以加载，文件会被复制到应用组的临时目录中，并返回文件路径。
如果你不再需要文件，请删除它。

示例：

```ts
const filePath = provider.loadFilePath("public.movie")
```

***

## 创建 ItemProvider

### fromUIImage

```ts
ItemProvider.fromUIImage(image: UIImage): ItemProvider
```

从 `UIImage` 创建 `ItemProvider`。

- 仅提供静态图片能力
- 不包含 Live Photo 或原始资源信息

***

### fromText

```ts
ItemProvider.fromText(text: string): ItemProvider
```

从文本创建 `ItemProvider`。

***

### fromURL

```ts
ItemProvider.fromURL(url: string): ItemProvider | null
```

从 URL 字符串创建 `ItemProvider`。

- URL 不合法时返回 `null`
- 支持网页 URL 与文件 URL

***

### fromFilePath

```ts
ItemProvider.fromFilePath(path: string): ItemProvider
```

从文件路径创建 `ItemProvider`。

- 保留原始文件
- 适合视频、音频、文档等资源
- 支持原地访问能力判断

***

## 使用建议

- 使用 `hasItemConforming` 进行内容类型判断
- 使用对象加载方法进行 UI 展示
- 使用文件路径加载方法处理大文件
- 文件路径只能在 `perform` 回调作用域内访问
- 不应在回调外部延迟访问安全作用域文件



---
url: /v2/zh/guide/Changelog/2.4.6/MediaComposer/MediaComposer Example.md
---

# MediaComposer 示例

本示例演示如何使用 `MediaComposer` 将 **视频 + 图片 + 音频** 组合成一个最终视频文件，并导出到脚本目录中。

示例流程包括：

1. 选择音频文件
2. 选择一张图片
3. 选择一个视频
4. 构建视频时间线（Video + Image）
5. 在指定时间点插入音频
6. 导出合成后的视频

***

## 示例代码

```tsx
import { Path, Script } from "scripting"

console.present().then(() => Script.exit())

async function run() {
  try {

    const audioPath = (await DocumentPicker.pickFiles({
      types: ["public.audio"]
    })).at(0)

    if (audioPath == null) {
      console.error("no audio")
      return
    }

    console.log("Audio Picked")

    const imageResult = (await Photos.pick({
      filter: PHPickerFilter.images()
    })).at(0)

    const imagePath = await imageResult?.itemProvider.loadFilePath("public.image")

    if (!imagePath) {
      console.log("No image")
      return
    }

    console.log("Image picked")

    const videoResult = (await Photos.pick({
      filter: PHPickerFilter.videos()
    })).at(0)

    const videoPath = await videoResult?.itemProvider.loadFilePath("public.movie")

    if (videoPath == null) {
      console.log("No video")
      return
    }

    console.log("Video Picked")

    console.log("Start composing...")

    const exportPath = Path.join(
      Script.directory,
      "dest.mp4"
    )

    const exportResult = await MediaComposer.composeAndExport({
      exportPath,
      timeline: {
        videoItems: [{
          videoPath: videoPath
        }, {
          imagePath: imagePath,
          duration: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }],
        audioClips: [{
          path: audioPath,
          at: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }]
      }
    })

    console.log(
      "Result:",
      exportResult.exportPath,
      "\n",
      exportResult.duration.getSeconds()
    )

  } catch (e) {
    console.error(e)
  }
}

run()
```

***

## 时间线解析

### 视频 / 图片时间线（videoItems）

```ts
videoItems: [
  { videoPath },
  {
    imagePath,
    duration: MediaTime.make({
      seconds: 5,
      preferredTimescale: 600
    })
  }
]
```

- 第一个 `VideoItem` 是完整视频
- 第二个 `VideoItem` 是一张图片，显示 5 秒
- 所有 `videoItems` **按顺序依次拼接**
- 最终视频总时长 = 视频时长 + 图片 5 秒

***

### 音频时间线（audioClips）

```ts
audioClips: [{
  path: audioPath,
  at: MediaTime.make({
    seconds: 5,
    preferredTimescale: 600
  })
}]
```

- 音频在最终视频的 **第 5 秒开始播放**
- 不指定 `at` 时，音频会顺序接在前一个外部音频之后
- 音频不会影响最终视频时长

***

## 导出结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- `exportPath`：导出文件的完整路径
- `duration`：最终视频时长（仅由 `videoItems` 决定）

***

## 常见错误与边界情况

### 1. ImageClip 未指定 duration

```ts
{
  imagePath: "...",
  //  缺少 duration
}
```

**问题：**

- ImageClip 没有天然时长
- 不指定 `duration` 会导致合成失败

**解决方案：**

- 必须显式提供 `MediaTime`

***

### 2. 使用浮点秒数而非 MediaTime

```ts
// 错误
at: 5
```

**正确做法：**

```ts
at: MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

MediaComposer 中 **所有时间必须使用 MediaTime**。

***

### 3. 混合不同 timescale 导致精度问题

**问题：**

- 不同音视频资源使用不同 timescale
- 在剪辑、拼接、淡入淡出时可能出现边界误差

**建议：**

- 在脚本中统一使用 `preferredTimescale: 600`
- 对外部时间先做 `convertScale`

***

### 4. 音频超出视频范围

**行为说明：**

- 音频即使超过视频末尾，也不会延长最终视频
- 超出部分会被自动截断

***

### 5. 同时存在视频原音与外部音频但音量异常

**原因：**

- 默认情况下，外部音频与视频原音会同时混合
- 未配置 ducking 时，可能出现人声被盖住的问题

***

## 音频 Ducking 行为说明

### 什么是 Ducking

Ducking 指的是：

> 当视频原音（如人声）存在时，自动降低外部音频（如背景音乐）的音量

***

### Ducking 配置

```ts
exportOptions: {
  ducking: {
    enabled: true,
    duckedVolume: 0.25,
    attackSeconds: 0.15,
    releaseSeconds: 0.25
  }
}
```

#### 参数说明

- **enabled**
  是否启用 ducking，默认 `true`

- **duckedVolume**
  被压低后的外部音频音量（0…1）

- **attackSeconds**
  在视频原音开始前，音量下降的过渡时间

- **releaseSeconds**
  在视频原音结束后，音量恢复的过渡时间

***

### Ducking 生效条件

Ducking 仅在以下条件同时满足时生效：

1. `VideoClip.keepOriginalAudio === true`
2. 存在外部 `audioClips`
3. `exportOptions.ducking.enabled !== false`

***

## 音频混音规则总结

1. **视频原音**

   - 只有在 `keepOriginalAudio: true` 时才参与混音

2. **外部音频**

   - 可指定时间点或顺序拼接
   - 可设置 `volume`、`fade`、`loopToFitVideoDuration`

3. **最终混音顺序**

   - 所有音频会被混合到单一音轨
   - 不会改变视频时长
   - Ducking 在混音阶段自动应用



---
url: /v2/zh/guide/Changelog/2.4.6/MediaComposer/MediaTime.md
---

# MediaTime

`MediaTime` 用于表示音视频处理中的**精确时间点或时间长度**，是 Scripting 中 MediaComposer 时间系统的基础类型。
它在语义上对应于底层媒体框架中的“带时间基准的时间值”（如 AVFoundation 的 `CMTime`），但对脚本侧提供了更安全、可读、可计算的抽象。

`MediaTime` 既可以表示**确定的数值时间**，也可以表示**无效、无限或不确定时间**，并支持严格的时间运算与比较。

***

## 核心特性

- 使用 **value + timescale** 或 **seconds + preferredTimescale** 精确构造时间
- 支持时间缩放（convertScale）及多种舍入策略
- 支持加减运算与大小比较
- 明确区分有效时间、无效时间、无限时间和不确定时间
- 适用于时间线计算、剪辑、对齐、放置（at）、淡入淡出等所有时间相关场景

***

## 时间精度模型

`MediaTime` 的底层模型基于以下概念：

- **value**：整数时间值
- **timescale**：每秒的时间单位数
  例如：

  - `value = 300`, `timescale = 600` 表示 0.5 秒
  - `value = 18000`, `timescale = 600` 表示 30 秒

通过 timescale，`MediaTime` 可以精确表达帧级或采样级时间，而不依赖浮点数。

***

## 只读属性

### secondes

```ts
readonly secondes: number
```

当前时间对应的秒数（浮点数形式）。
这是一个**派生值**，主要用于展示或调试，不建议用于时间计算。

***

### isValid

```ts
readonly isValid: boolean
```

表示该时间是否是一个有效、可用于计算的时间值。
当时间为 `invalid`、`indefinite` 或无穷大时，该值为 `false`。

***

### isPositiveInfinity / isNegativeInfinity

```ts
readonly isPositiveInfinity: boolean
readonly isNegativeInfinity: boolean
```

表示该时间是否为正无穷或负无穷。
常用于内部边界标记或时间线计算中的极值判断。

***

### isIndefinite

```ts
readonly isIndefinite: boolean
```

表示该时间是否为“不确定时间”。
通常用于尚未解析出真实时长的媒体资源。

***

### isNumeric

```ts
readonly isNumeric: boolean
```

表示该时间是否是一个可参与数值计算的时间。
只有在该值为 `true` 时，才应进行加减或比较操作。

***

### hasBeenRounded

```ts
readonly hasBeenRounded: boolean
```

表示该时间是否在构造或转换过程中发生过舍入。
对于帧精度或采样精度要求较高的场景，该属性可用于调试或验证。

***

## 时间转换

### convertScale

```ts
convertScale(newTimescale: number, method: MediaTimeRoundingMethod): MediaTime
```

将当前时间转换为新的 timescale，并使用指定的舍入策略。

**典型用途：**

- 对齐视频帧时间（如 600、90000）
- 对齐音频采样时间（如 44100、48000）
- 避免不同时间基准混用导致的误差

***

## 时间值获取

### getSeconds

```ts
getSeconds(): number
```

返回当前时间对应的秒数（浮点数）。
该方法等价于读取 `secondes`，但在语义上更明确。

***

## 时间运算

### plus / minus

```ts
plus(other: MediaItem): MediaItem
minus(other: MediaItem): MediaItem
```

执行时间加法或减法运算，返回新的 `MediaTime`。

- 运算双方必须为可计算时间
- 不会修改原对象
- 运算结果遵循内部时间基准规则

***

## 时间比较

```ts
lt(other: MediaItem): boolean
gt(other: MediaItem): boolean
lte(other: MediaItem): boolean
gte(other: MediaItem): boolean
eq(other: MediaItem): boolean
neq(other: MediaItem): boolean
```

用于比较两个时间的大小或相等性。

- 支持严格比较
- 对无效或非数值时间的比较结果是确定性的
- 推荐在进行时间线排序、裁剪判断、边界检测时使用

***

## 静态构造方法

### make

```ts
static make(options: {
  value: number
  timescale: number
} | {
  seconds: number
  preferredTimescale: number
}): MediaTime
```

用于创建一个 `MediaTime` 实例。

#### 使用 value + timescale

```ts
MediaTime.make({
  value: 300,
  timescale: 600
})
```

适用于需要精确控制时间单位的场景。

#### 使用 seconds + preferredTimescale

```ts
MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

适用于脚本层以“秒”为主的时间描述方式。

***

### zero

```ts
static zero(): MediaTime
```

返回一个表示 **0 秒** 的时间。

***

### invalid

```ts
static invalid(): MediaTime
```

返回一个无效时间。
用于显式表示错误、缺失或不可用的时间值。

***

### indefinite

```ts
static indefinite(): MediaTime
```

返回一个不确定时间。
通常用于媒体尚未加载完成、时长未知的状态。

***

### positiveInfinity / negativeInfinity

```ts
static positiveInfinity(): MediaTime
static negativeInfinity(): MediaTime
```

返回正无穷或负无穷时间。
主要用于内部时间线边界控制，不建议在普通脚本逻辑中使用。

***

## 使用建议与注意事项

- **避免直接使用浮点秒数进行时间计算**，应始终使用 `MediaTime`
- 不同媒体资源可能使用不同的 timescale，必要时显式调用 `convertScale`
- 在比较或运算前，建议检查 `isNumeric`
- 在构建时间线（如 `at`、`sourceTimeRange`）时，统一 timescale 可减少误差

***

## 在 MediaComposer 中的典型用途

- 指定音频或视频片段的放置时间（`AudioClip.at`）
- 定义剪辑的起点与时长（`TimeRange`）
- 计算最终导出视频的精确时长
- 控制淡入淡出、对齐、循环等时间行为



---
url: /v2/zh/guide/Changelog/2.4.6/MediaComposer/Quick Start.md
---

# 快速开始

`MediaComposer` 用于在 Scripting 中 **组合视频、图片与音频时间线并导出最终媒体文件**。
它封装了一套稳定的时间线模型，支持视频剪辑、图片片段、音频叠加、淡入淡出、音频 ducking、导出参数控制等高级能力。

该模块适用于：

- 视频与图片混合生成短片
- 给视频添加背景音乐、配音或音效
- 使用图片序列生成视频
- 自动化视频处理与内容生成脚本

***

## 设计概览

MediaComposer 的核心由三部分组成：

1. **时间模型**
   使用 `MediaTime` / `TimeRange` 精确描述时间点与时长

2. **时间线模型**

   - `VideoItem[]`：视频或图片片段（顺序拼接）
   - `AudioClip[]`：音频轨道（可指定时间点或自动顺序放置）

3. **导出系统**
   通过统一的 `composeAndExport` 接口完成渲染与导出

***

## 时间线结构

```ts
timeline: {
  videoItems: VideoItem[]
  audioClips: AudioClip[]
}
```

- **videoItems**
  定义视觉时间线，视频与图片会严格按数组顺序依次排列
- **audioClips**
  定义音频时间线，可自由指定放置时间（`at`），或顺序追加

最终导出的视频时长由 **videoItems 决定**。

***

## VideoItem

```ts
type VideoItem = XOR<VideoClip, ImageClip>
```

`VideoItem` 表示时间线中的一个“视觉片段”，可以是 **视频** 或 **图片**，但不能同时是两者。

***

## VideoClip（视频片段）

```ts
type VideoClip = {
  videoPath: string
  sourceTimeRange?: TimeRange | null
  keepOriginalAudio?: boolean
  fade?: FadeConfig | null
}
```

### videoPath

- 视频文件路径
- 支持本地视频文件

***

### sourceTimeRange

```ts
sourceTimeRange?: TimeRange | null
```

- 指定从源视频中使用的时间范围
- 不提供时，默认使用整个视频

**常见用途：**

- 裁剪视频片段
- 只取某一段作为素材

***

### keepOriginalAudio

```ts
keepOriginalAudio?: boolean
```

- 是否保留视频自带的音频
- 默认值：`false`

**说明：**

- 为 `true` 时，视频原音会参与混音
- 可与外部 `audioClips` 同时存在
- 是否对外部音频进行 ducking 由 `ExportOptions.ducking` 控制

***

### fade

```ts
fade?: FadeConfig | null
```

- 视频片段的淡入淡出配置
- 会覆盖全局视频淡入淡出设置（如果存在）

***

## ImageClip（图片片段）

```ts
type ImageClip = {
  imagePath: string
  duration: MediaTime
  contentMode?: "fit" | "crop"
  backgroundColor?: Color
  fade?: FadeConfig | null
}
```

`ImageClip` 用于将一张静态图片作为视频时间线中的一个片段。

***

### imagePath

- 图片文件路径
- 支持常见图片格式（JPEG / PNG / HEIC 等）

***

### duration

```ts
duration: MediaTime
```

- 图片片段在视频中的显示时长
- 必须显式指定

***

### contentMode

```ts
contentMode?: "fit" | "crop"
```

- 控制图片如何适配渲染尺寸
- 默认值：`fit`

说明：

- `fit`：完整显示图片，可能留黑边
- `crop`：填满画面，超出部分裁剪

***

### backgroundColor

```ts
backgroundColor?: Color
```

- 图片未覆盖区域的背景色
- 通常与 `fit` 模式搭配使用

***

### fade

```ts
fade?: FadeConfig | null
```

- 图片片段的淡入淡出配置
- 支持与视频片段统一使用

***

## AudioClip（音频片段）

```ts
type AudioClip = {
  path: string
  sourceTimeRange?: TimeRange | null
  at?: MediaTime
  volume?: number
  fade?: FadeConfig | null
  loopToFitVideoDuration?: boolean
}
```

音频片段用于在最终视频中添加背景音乐、配音或音效。

***

### path

- 音频文件路径

***

### sourceTimeRange

- 指定使用音频的某一时间段
- 默认使用整个音频文件

***

### at

```ts
at?: MediaTime
```

- 指定音频在最终时间线中的放置时间
- 不指定时：

  - 按顺序接在前一个外部音频片段之后

***

### volume

```ts
volume?: number
```

- 单个音频片段的音量（0…1）
- 默认值：1

***

### fade

- 音频淡入淡出配置
- 常用于背景音乐的自然过渡

***

### loopToFitVideoDuration

```ts
loopToFitVideoDuration?: boolean
```

- 是否循环音频以匹配视频总时长
- 常用于背景音乐

***

## FadeConfig（淡入淡出）

```ts
type FadeConfig = {
  fadeInSeconds?: number
  fadeOutSeconds?: number
}
```

- 单位：秒
- 可用于视频、图片、音频
- 未指定时默认为 0

***

## ExportOptions（导出配置）

```ts
type ExportOptions = {
  renderSize?: Size
  frameRate?: number
  scaleMode?: VideoScaleMode
  globalVideoFade?: FadeConfig | null
  externalAudioBaseVolume?: number
  ducking?: DuckingConfig
  presetName?: ExportPreset
  outputFileType?: ExportFileType
}
```

### 常用说明

- **renderSize**
  最终视频分辨率，默认 1080×1920

- **frameRate**
  渲染帧率，默认 30

- **globalVideoFade**
  全局视频淡入淡出（可被单个 clip 覆盖）

- **ducking**
  当视频存在原音时，自动降低外部音频音量

- **presetName / outputFileType**
  控制编码质量与文件格式

***

## composeAndExport

```ts
function composeAndExport(options: {
  exportPath: string
  timeline: {
    videoItems: VideoItem[]
    audioClips: AudioClip[]
  }
  exportOptions?: ExportOptions
  overwrite?: boolean
}): Promise<{
  exportPath: string
  duration: MediaTime
}>
```

### 参数说明

- **exportPath**
  导出文件路径

- **timeline.videoItems**
  视频 / 图片时间线（顺序执行）

- **timeline.audioClips**
  音频时间线（可自由放置）

- **exportOptions**
  导出配置，可选

- **overwrite**
  是否覆盖已有文件，默认 `true`

***

### 返回结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- **exportPath**：最终导出路径
- **duration**：最终视频时长（由 videoItems 决定）

***

## 使用建议与最佳实践

- 始终使用 `MediaTime` 描述时间，避免直接使用浮点秒数
- 图片片段必须显式指定 `duration`
- 音频与视频的时间线是 **独立但最终混合** 的
- 对复杂项目，建议统一 timescale（如 600）
- 背景音乐推荐使用 `loopToFitVideoDuration`

***

## 典型使用场景

- 图片 + 视频混合短片
- 自动生成带背景音乐的视频
- 视频剪辑与配音合成
- 内容创作与自动化视频生成



---
url: /v2/zh/guide/Changelog/2.4.6/SharedAudioSession.md
---

# SharedAudioSession

通过 `SharedAudioSession`，你可以在脚本中方便地管理和操作共享音频会话（audio session）。音频会话充当脚本、Scripting 应用、操作系统和底层音频硬件之间的中介，允许你有效地配置和控制音频的行为。

***

## 功能简介

- 获取和设置音频会话的类别（category）、模式（mode）和选项（options）。
- 配置音频输入和输出的首选采样率（sample rate）。
- 处理音频中断事件。
- 查询设备所支持的类别和模式。
- 根据具体的应用场景（如视频录制、语音聊天、后台播放等）来定制音频行为。

***

## 方法和属性

### 1. **会话类别与选项**

#### `category`

获取当前音频会话的类别（Category）。

```typescript
const category = await SharedAudioSession.category
console.log(category) // 示例输出：'playback'
```

#### `categoryOptions`

获取当前音频会话类别的选项（Options）。

```typescript
const options = await SharedAudioSession.categoryOptions
console.log(options) // 示例输出：['mixWithOthers', 'allowAirPlay']
```

#### `setCategory(category: AudioSessionCategory, options: AudioSessionCategoryOptions[])`

设置音频会话的类别并指定其选项。

```typescript
await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
```

***

### 2. **会话模式**

#### `mode`

获取当前音频会话模式（Mode）。

```typescript
const mode = await SharedAudioSession.mode
console.log(mode) // 示例输出：'videoChat'
```

#### `setMode(mode: AudioSessionMode)`

设置音频会话模式。

```typescript
await SharedAudioSession.setMode('voiceChat')
```

***

### 3. **采样率 (Sample Rate)**

#### `preferredSampleRate`

获取当前首选采样率（单位为 Hz）。

```typescript
const sampleRate = await SharedAudioSession.preferredSampleRate
console.log(sampleRate) // 示例输出：44100
```

#### `setPreferredSampleRate(sampleRate: number)`

设置音频输入和输出的首选采样率。

```typescript
await SharedAudioSession.setPreferredSampleRate(48000)
```

***

### 4. **音频中断处理**

#### `addInterruptionListener(listener: AudioSessionInterruptionListener)`

监听音频中断事件。

```typescript
SharedAudioSession.addInterruptionListener((type) => {
  if (type === 'began') {
    console.log('音频中断开始')
  } else if (type === 'ended') {
    console.log('音频中断结束')
  }
})
```

#### `removeInterruptionListener(listener: AudioSessionInterruptionListener)`

移除音频中断监听器。

```typescript
SharedAudioSession.removeInterruptionListener(myListener)
```

***

### 5. **设备功能查询**

#### `availableCategories`

获取设备上可用的音频会话类别列表。

```typescript
const categories = await SharedAudioSession.availableCategories
console.log(categories) // 示例输出：['playback', 'record', 'soloAmbient']
```

#### `availableModes`

获取设备上可用的音频会话模式列表。

```typescript
const modes = await SharedAudioSession.availableModes
console.log(modes) // 示例输出：['default', 'videoChat', 'voiceChat']
```

***

### 6. **其他属性**

#### `isOtherAudioPlaying`

检查设备上是否有其他音频正在播放。

```typescript
const isPlaying = await SharedAudioSession.isOtherAudioPlaying
console.log(isPlaying) // 示例输出：true
```

#### `secondaryAudioShouldBeSilencedHint`

检查次要音频是否应该被静音。

```typescript
const shouldSilence = await SharedAudioSession.secondaryAudioShouldBeSilencedHint
console.log(shouldSilence) // 示例输出：false
```

#### `allowHapticsAndSystemSoundsDuringRecording`

检查录音期间是否允许触觉反馈和系统声音。

```typescript
const allowHaptics = await SharedAudioSession.allowHapticsAndSystemSoundsDuringRecording
console.log(allowHaptics) // 示例输出：true
```

#### `prefersNoInterruptionsFromSystemAlerts`

检查音频会话是否偏好不被系统警报打断。

```typescript
const prefersNoInterruptions = await SharedAudioSession.prefersNoInterruptionsFromSystemAlerts
console.log(prefersNoInterruptions) // 示例输出：false
```

***

### 7. **会话激活**

#### `setActive(active: boolean, options?: AudioSessionSetActiveOptions[])`

激活或停用共享音频会话，可指定激活选项。

```typescript
await SharedAudioSession.setActive(
  true,
  ['notifyOthersOnDeactivation']
)
```

***

### 8. **系统设置**

#### `setAllowHapticsAndSystemSoundsDuringRecording(value: boolean)`

启用或禁用在录音期间允许触觉反馈和系统声音。

```typescript
await SharedAudioSession.setAllowHapticsAndSystemSoundsDuringRecording(true)
```

#### `setPrefersNoInterruptionsFromSystemAlerts(value: boolean)`

设置是否偏好不被系统警报打断。

```typescript
await SharedAudioSession.setPrefersNoInterruptionsFromSystemAlerts(true)
```

***

### 9. **系统输出音量**

#### `outputVolume: number`

获取当前系统输出音量（范围为 0 到 1）。

#### outputVolume 监听事件

类型类型

```ts
type AudioSessionOutputVolumeListener = (newValue: number, oldValue: number) => void
```

##### `addOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

添加系统输出音量监听器。

##### `removeOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

移除系统输出音量监听器。

***

## 枚举（Enumerations）

### **AudioSessionSetActiveOptions**

定义激活选项：

- `'notifyOthersOnDeactivation'`

### **AudioSessionCategory**

定义音频会话的类别：

- `'ambient'`
- `'multiRoute'`
- `'playAndRecord'`
- `'playback'`
- `'record'`
- `'soloAmbient'`

### **AudioSessionCategoryOptions**

定义类别的可选行为：

- `'mixWithOthers'`
- `'duckOthers'`
- `'interruptSpokenAudioAndMixWithOthers'`
- `'allowBluetooth'`
- `'allowBluetoothA2DP'`
- `'allowAirPlay'`
- `'defaultToSpeaker'`
- `'overrideMutedMicrophoneInterruption'`

### **AudioSessionMode**

指定会话模式：

- `'default'`
- `'gameChat'`
- `'measurement'`
- `'moviePlayback'`
- `'spokenAudio'`
- `'videoChat'`
- `'videoRecording'`
- `'voiceChat'`
- `'voicePrompt'`

### **AudioSessionInterruptionType**

指定中断类型：

- `'began'`
- `'ended'`
- `'unknown'`

***

通过此接口，你可以在 Scripting 应用中对音频会话进行深度管理，非常适合构建对音频依赖较高的脚本，如音乐播放器和视频会议工具等。



---
url: /v2/zh/guide/Changelog/2.4.6/VideoRecorder.md
---

# 视频录制（VideoRecorder）

`VideoRecorder` 用于在 Scripting 中创建和控制一个可编程的视频录制会话，完整封装了相机选择、音视频采集、编码、暂停/恢复、缩放、对焦、补光灯控制以及最终文件写入流程。

该 API 适用于自定义相机界面、视频采集工具、自动化录制脚本等场景。

***

## 核心能力概览

- 支持前置与后置摄像头
- 支持指定摄像头类型（广角、超广角、长焦等）
- 支持多种帧率（24 / 30 / 60 / 120）
- 支持音频录制的启用与禁用
- 支持多种系统 Session Preset
- 支持多种视频编码格式（HEVC / H.264 / ProRes 等）
- 支持录制过程中的暂停与恢复
- 支持对焦点、曝光点独立控制
- 支持变焦与平滑变焦（ramp）
- 支持补光灯（Torch）控制
- 明确的状态机与状态回调
- 明确的生命周期管理（prepare / reset / dispose）

***

## 类型定义

### CameraPosition

```ts
type CameraPosition = "front" | "back"
```

表示使用的摄像头朝向。

***

### CameraType

```ts
type CameraType =
  | "wide"
  | "ultraWide"
  | "telephoto"
  | "trueDepth"
  | "dual"
  | "dualWide"
  | "triple"
```

表示摄像头的物理类型。
是否支持某一类型取决于设备硬件能力。

***

### VideoRecorderState

```ts
type VideoRecorderState =
  | "idle"
  | "preparing"
  | "ready"
  | "recording"
  | "paused"
  | "finishing"
  | "finished"
  | "failed"
```

#### 状态说明

| 状态          | 含义             |
| ----------- | -------------- |
| `idle`      | 初始状态，尚未配置资源    |
| `preparing` | 正在配置相机会话与音视频管线 |
| `ready`     | 已准备完成，可以开始录制   |
| `recording` | 正在录制           |
| `paused`    | 录制已暂停          |
| `finishing` | 正在结束录制并写入文件    |
| `finished`  | 录制完成           |
| `failed`    | 发生错误，录制失败      |

***

### VideoCaptureSessionPreset

```ts
type VideoCaptureSessionPreset =
  | "high"
  | "medium"
  | "low"
  | "cif352x288"
  | "vga640x480"
  | "iFrame960x540"
  | "iFrame1280x720"
  | "hd1280x720"
  | "hd1920x1080"
  | "hd4K3840x2160"
```

表示捕捉会话的分辨率预设。

***

### VideoCodec

```ts
type VideoCodec =
  | "hevc"
  | "h264"
  | "jpeg"
  | "JPEGXL"
  | "proRes4444"
  | "appleProRes4444XQ"
  | "proRes422"
  | "proRes422HQ"
  | "proRes422LT"
  | "proRes422Proxy"
  | "proResRAW"
  | "proResRAWHQ"
  | "hevcWithAlpha"
```

表示视频编码格式。
具体是否可用取决于设备与系统支持情况。

***

### VideoOrientation

```ts
type VideoOrientation =
  | "portrait"
  | "landscapeLeft"
  | "landscapeRight"
```

表示输出视频的方向。

***

## 构造函数

```ts
new VideoRecorder(settings?)
```

### settings 参数

```ts
{
  camera?: {
    position: CameraPosition
    preferredTypes?: CameraType[]
  }
  frameRate?: number
  audioEnabled?: boolean
  sessionPreset?: VideoCaptureSessionPreset
  videoCodec?: VideoCodec
  videoBitRate?: number
  orientation?: VideoOrientation
  mirrorFrontCamera?: boolean
}
```

#### 参数说明

- **camera**

  - `position`
    使用的摄像头位置，默认 `"back"`
  - `preferredTypes`
    偏好的摄像头类型列表
    如果未提供，内部将根据摄像头位置自动选择合适的类型

- **frameRate**
  目标帧率，支持 24 / 30 / 60 / 120，默认 30
  实际帧率受设备与分辨率限制

- **audioEnabled**
  是否录制音频，默认 `true`

- **sessionPreset**
  捕捉会话分辨率预设，默认 `"high"`

- **videoCodec**
  视频编码格式，默认 `"hevc"`

- **videoBitRate**
  视频平均码率（bit/s），未指定时由系统自动选择

- **orientation**
  输出视频方向，默认 `"portrait"`

- **mirrorFrontCamera**
  前置摄像头是否镜像，默认 `true`
  仅在使用前置摄像头时生效

***

## 只读属性

### minZoomFactor

```ts
readonly minZoomFactor: number
```

当前设备支持的最小变焦倍率。

***

### maxZoomFactor

```ts
readonly maxZoomFactor: number
```

当前设备支持的最大变焦倍率。

***

### currentZoomFactor

```ts
readonly currentZoomFactor: number
```

当前变焦倍率。

***

### displayZoomFactor

```ts
readonly displayZoomFactor: number
```

用户可读的变焦倍率。

***

### hasTorch

```ts
readonly hasTorch: boolean
```

当前摄像头是否支持补光灯。

***

### torchMode

```ts
readonly torchMode: "auto" | "on" | "off"
```

当前补光灯模式。

***

## 状态与回调

### state

```ts
state: VideoRecorderState
```

表示当前录制器所处的状态。

***

### onStateChanged

```ts
onStateChanged?: (
  state: VideoRecorderState,
  details?: string
) => void
```

状态变化回调。

- 当 `state === "failed"`
  `details` 为错误信息描述

- 当 `state === "finished"`
  `details` 为最终视频文件的完整保存路径

***

## 方法说明

### prepare()

```ts
prepare(): Promise<void>
```

准备录制器资源，包括相机会话、输入输出与音视频管线配置。

#### 使用约束

- 必须在 `startRecording` 之前调用
- 成功后状态变为 `ready`
- 失败会进入 `failed` 状态

***

### startRecording(toPath)

```ts
startRecording(toPath: string): void
```

开始录制视频。

#### 参数

- **toPath**
  视频文件保存路径（完整路径）

#### 使用约束

- 仅允许在 `ready` 状态下调用
- 调用后状态变为 `recording`

***

### pauseRecording()

```ts
pauseRecording(): void
```

暂停当前录制。

#### 使用约束

- 仅允许在 `recording` 状态下调用
- 调用后状态变为 `paused`
- 时间线会被正确压缩，不产生空白帧

***

### resumeRecording()

```ts
resumeRecording(): void
```

恢复已暂停的录制。

#### 使用约束

- 仅允许在 `paused` 状态下调用
- 调用后状态回到 `recording`

***

### stopRecording()

```ts
stopRecording(): Promise<void>
```

停止录制并生成最终视频文件。

#### 行为说明

- 状态先进入 `finishing`
- 文件写入完成后进入 `finished`
- 最终文件路径通过 `onStateChanged` 回调返回

***

### reset()

```ts
reset(): Promise<void>
```

重置录制器状态，用于开始新一轮录制。

#### 使用场景

- 已完成一次录制
- 或录制失败后希望复用同一实例

#### 行为说明

- 成功后状态回到 `idle`
- 可再次调用 `prepare`

***

### setTorchMode()

```ts
setTorchMode(mode: "auto" | "off" | "on"): void
```

设置补光灯模式。

***

### setFocusPoint()

```ts
setFocusPoint(point: { x: number; y: number }): void
```

设置对焦点。

- 坐标为归一化值，范围 `0.0 ~ 1.0`
- `(0,0)` 表示画面左上角，`(1,1)` 表示右下角

***

### setExposurePoint()

```ts
setExposurePoint(point: { x: number; y: number }): void
```

设置曝光点，坐标规则与对焦点一致。

***

### resetFocus()

```ts
resetFocus(): void
```

恢复自动对焦模式。

***

### resetExposure()

```ts
resetExposure(): void
```

恢复自动曝光模式。

***

### setZoomFactor()

```ts
setZoomFactor(factor: number): void
```

立即设置变焦倍率。

- 值应位于 `minZoomFactor` 与 `maxZoomFactor` 之间

***

### rampZoomFactor()

```ts
rampZoomFactor(toFactor: number, rate: number): void
```

以平滑方式调整变焦倍率。

- `toFactor` 为目标倍率
- `rate` 为变化速率，单位为每秒的 2 次幂变化

***

### resetZoom()

```ts
resetZoom(): void
```

将变焦倍率恢复为默认值（通常为 1.0）。

***

### dispose()

```ts
dispose(): Promise<void>
```

释放并销毁录制器。

#### 使用约束

- 调用后实例不可再使用
- 会释放相机、音频与底层系统资源
- 建议在页面或脚本生命周期结束时调用

***

## 典型使用流程

```ts
const recorder = new VideoRecorder({
  camera: { position: "back" },
  frameRate: 60,
  videoCodec: "hevc"
})

recorder.onStateChanged = (state, details) => {
  if (state === "finished") {
    console.log("Video saved at:", details)
  }
}

await recorder.prepare()
recorder.startRecording("/path/to/tmp/demo.mov")
```

***

## 使用建议

- 始终监听 `onStateChanged` 以掌握完整状态变化
- 不要在未调用 `prepare` 的情况下开始录制
- 每次完成录制后，如需复用实例，应先调用 `reset`
- 生命周期结束时务必调用 `dispose` 释放资源



---
url: /v2/zh/guide/Changelog/2.4.6/onDrag and onDrop View Modifiers.md
---

# onDrag 和 onDrop 修饰符

Scripting 提供了一套与 SwiftUI Drag & Drop 行为模型高度一致的 API，用于在脚本中实现视图间、应用内或跨应用的拖拽与放置操作。

该能力主要由以下三部分构成：

- **onDrag**：将当前视图声明为拖拽源
- **onDrop**：将当前视图声明为放置目标
- **DropInfo / ItemProvider / UTType**：描述拖拽内容与状态的上下文对象

拖拽与放置是一个严格受系统控制的交互流程，部分 API 只能在特定回调中调用，文档中会明确指出这些限制。

***

## 核心数据类型

### DropInfo

`DropInfo` 描述一次拖拽在当前放置视图上的实时状态。该对象仅在 `onDrop` 相关回调中有效。

#### 属性

##### location: Point

- 表示拖拽当前位置
- 坐标空间为 **放置视图自身的本地坐标系**
- 可用于实现基于位置的高亮、插入指示线、排序逻辑等

#### 方法

##### hasItemsConforming(types: UTType\[]): boolean

- 用于判断拖拽内容中，是否至少有一个项目符合指定的 UTType
- 常用于：

  - `validateDrop`
  - `dropEntered`
  - `dropUpdated`
- 不会实际加载数据，仅用于能力判断

##### itemProviders(types: UTType\[]): ItemProvider\[]

- 返回符合指定 UTType 的 `ItemProvider` 列表
- **仅允许在 `performDrop` 回调中调用**
- 在该方法返回后，系统将撤销对拖拽数据的访问权限

> 重要约束
> 必须在 `performDrop` 方法作用域内 **立即开始** 对 ItemProvider 的数据加载（如 `loadData`、`loadText`）。
> 不允许延迟到其他回调或异步逻辑中再发起加载。

***

## DropOperation

`DropOperation` 用于描述当前拖拽更新阶段，目标视图期望执行的操作类型。

可选值如下：

- `"copy"`
  表示复制数据（最常见，用于文件、文本、图片等）

- `"move"`
  表示移动数据（通常仅用于应用内部拖拽）

- `"cancel"`
  取消本次拖拽，不执行任何数据传输

- `"forbidden"`
  明确禁止当前拖拽行为，系统通常会显示禁止指示

`DropOperation` 通常由 `dropUpdated` 回调返回，用于动态控制拖拽行为。

***

## DragDropProps

`DragDropProps` 是所有支持拖拽与放置能力的视图可选属性集合。

***

## onDrag

### 用途

将当前视图声明为 **拖拽源**，允许用户从该视图开始一次拖拽操作。

### 定义

```ts
onDrag?: {
  data: () => ItemProvider
  preview: VirtualNode
}
```

### 参数说明

#### data

```ts
data: () => ItemProvider
```

- 返回一个 `ItemProvider`
- 用于描述拖拽时传递的数据内容
- 支持文本、图片、文件、URL、自定义类型等
- 每次拖拽开始时调用

> 建议
> 仅在该回调中构造 ItemProvider，不要复用旧实例，以确保数据状态正确。

#### preview

```ts
preview: VirtualNode
```

- 指定拖拽开始后显示的预览视图
- 系统会自动将其渲染为拖拽浮层
- 预览视图默认居中于源视图

***

## onDrop

### 用途

将当前视图声明为 **放置目标**，并通过一组回调精细控制拖拽验证、状态变化与最终数据接收。

### 定义

```ts
onDrop?: {
  types: UTType[]
  validateDrop?: (info: DropInfo) => boolean
  dropEntered?: (info: DropInfo) => void
  dropUpdated?: (info: DropInfo) => DropOperation | null
  dropExited?: (info: DropInfo) => void
  performDrop: (info: DropInfo) => boolean
}
```

***

### onDrop.types

```ts
types: UTType[]
```

- 声明该视图 **允许接收的内容类型**
- 如果拖拽内容不包含任意一个匹配类型：

  - 放置区域不会激活
  - `validateDrop` 不会被调用
  - 视觉高亮不会出现

***

### validateDrop

```ts
validateDrop?: (info: DropInfo) => boolean
```

- 用于判断是否允许开始一次放置操作
- 返回 `false` 将直接拒绝拖拽
- 常见用途：

  - 检查类型数量
  - 校验业务状态（如只允许空列表接收）

默认行为：始终返回 `true`

***

### dropEntered

```ts
dropEntered?: (info: DropInfo) => void
```

- 当拖拽进入放置区域时触发
- 通常用于：

  - 显示高亮
  - 显示插入占位符
  - 触发动画状态

***

### dropUpdated

```ts
dropUpdated?: (info: DropInfo) => DropOperation | null
```

- 当拖拽在放置区域内部移动时反复调用
- 用于动态返回期望的 `DropOperation`

返回值说明：

- 返回具体的 `DropOperation`：更新当前拖拽行为
- 返回 `null`：

  - 使用上一次返回的有效值
  - 若没有历史值，默认使用 `"copy"`

***

### dropExited

```ts
dropExited?: (info: DropInfo) => void
```

- 当拖拽离开放置区域时触发
- 常用于清理高亮、移除占位 UI

***

### performDrop

```ts
performDrop: (info: DropInfo) => boolean
```

- **最关键的回调**
- 表示用户已松手，系统允许你读取拖拽数据
- 返回值：

  - `true`：表示成功接收并处理了拖拽
  - `false`：表示放置失败

#### 重要约束（必须遵守）

- 必须在该方法作用域内：

  - 调用 `info.itemProviders(...)`
  - 并立即开始数据加载
- 不允许：

  - 将 ItemProvider 保存到外部
  - 在异步回调中延迟访问拖拽数据

这是系统级安全限制，不遵守将导致数据无法访问。

***

## 典型使用流程总结

1. 用户从 `onDrag` 视图开始拖拽
2. 系统根据 `onDrop.types` 判断是否激活目标
3. 调用 `validateDrop`
4. 进入放置区域 → `dropEntered`
5. 移动过程中 → 多次 `dropUpdated`
6. 离开区域 → `dropExited`
7. 松手 → `performDrop`
8. 在 `performDrop` 中读取并处理数据

***

## 设计建议与最佳实践

- 始终精确声明 `UTType`，避免过于宽泛
- 在 `dropUpdated` 中返回 `"forbidden"` 可显式阻止非法拖拽
- 复杂数据解析逻辑应在 `ItemProvider` 加载完成后的异步回调中完成，而不是在 `performDrop` 中同步阻塞
- 跨应用拖拽时，优先使用系统标准类型（text、image、file、url）



---
url: /v2/zh/guide/Changelog/2.4.6/onDropContent.md
---

# 接收外部拖拽内容

`onDropContent` 是 Scripting 提供的一个视图修饰符，用于将当前视图设置为**拖放目标（Drop Target）**，以接收从其他 App 拖拽进入的文件、图片或文本内容。

***

## 功能说明

通过 `onDropContent`，你可以实现以下能力：

- 接收来自其他 App 的拖拽内容
- 使用 UTType 精确限制可接收的数据类型
- 实时感知拖拽指针是否悬停在视图上方
- 在内容被放下时，通过 `ItemProvider` 启动数据加载流程
- 对安全作用域文件建立持久访问权限

***

## 修饰符定义

```ts
onDropContent?: {
  types: UTType[]
  isTarget: {
    value: boolean
    onChanged: (value: boolean) => void
  } | Observable<boolean>
  perform: (attachments: ItemProvider[]) => boolean
}
```

***

## 参数说明

### types

用于指定当前视图**可以接收的内容类型列表**，类型值为 UTType 字符串。

当拖拽内容不包含任意匹配的类型时：

- 当前视图不会激活为放置目标
- `isTarget` 不会发生变化
- `perform` 不会被调用

示例：

```ts
types: ["public.image", "public.movie"]
```

***

### isTarget

用于表示拖拽操作是否悬停在当前视图上方。

- 当拖拽进入视图区域时，值为 `true`
- 当拖拽移出视图区域时，值为 `false`

支持以下两种形式：

- 绑定对象形式

  ```ts
  {
    value: boolean
    onChanged: (value: boolean) => void
  }
  ```

- Observable 形式

  ```ts
  Observable<boolean>
  ```

Observable 形式适合与 `useObservable` 搭配使用，语义更简洁。

***

### perform

当符合 `types` 要求的内容被成功放下时触发。

```ts
perform: (attachments: ItemProvider[]) => boolean
```

- 参数 `attachments` 为 `ItemProvider` 数组
- 每一个 `ItemProvider` 表示一个被拖入的内容项
- 函数返回值表示是否成功处理了此次拖放操作

返回值说明：

- 返回 `true` 表示拖放被成功接收
- 返回 `false` 表示未处理该拖放内容

***

## perform 的执行规则（重要）

在 `perform` 中需要遵循以下规则：

- 必须在 `perform` 函数的同步执行过程中**启动对 ItemProvider 的加载**
- 允许使用 `Promise` / `then` 等方式延迟完成加载
- 不允许在 `perform` 返回之后，再通过其他回调或事件启动加载
- 返回 `false` 时，系统会认为该拖放未被接受

原因说明：

- 拖放内容受系统安全机制保护
- 只有在 `perform` 执行期间，脚本才拥有对拖放数据的访问权限
- 若未在此期间启动加载，后续将无法访问对应资源

***

## ItemProvider 的使用方式

在 `perform` 中，开发者应当通过 `ItemProvider` 判断类型并启动加载。

常见流程包括：

- 使用 `hasItemConforming` 判断内容类型
- 根据内容类型选择合适的加载方式
- 对文件类资源获取路径并进行后续处理

***

## 示例用法

```tsx
const isTarget = useObservable(false)

return <VStack
  onDropContent={{
    types: ["public.image", "public.movie"],
    isTarget: isTarget,
    perform: (attachments) => {
      const images: UIImage[] = []
      const videos: string[] = []

      let found = false

      for (const attachment of attachments) {
        if (attachment.hasItemConforming("public.png")) {
          found = true
          attachment.loadUIImage().then(image => {
            if (image != null) {
              images.push(image)
            }
          })
        } else if (attachment.hasItemConforming("public.movie")) {
          found = true
          attachment.loadFilePath("public.movie").then(filePath => {
            if (filePath != null) {
              // 为安全作用域文件创建书签
              FileManager.addFileBookmark(filePath)
              videos.push(filePath)
            }
          })
        }
      }

      return found
    }
  }}
>
  ...
</VStack>
```

***

## 安全作用域文件访问

通过 `onDropContent` 获取的文件路径，通常属于**安全作用域资源**。

这类路径在以下情况下可能失效：

- `perform` 返回之后
- App 重启
- 脚本生命周期结束

为保证后续仍可访问文件，建议在获取路径后创建文件书签。

***

## FileManager.addFileBookmark

```ts
FileManager.addFileBookmark(path: string, name?: string): string | null
```

说明：

- 为指定文件或文件夹创建安全作用域书签
- 适用于通过 `Photos`、`onDropContent` 等 API 获取的路径
- 返回书签名称，用于后续访问或移除

示例：

```ts
const bookmarkName = FileManager.addFileBookmark(filePath)
```

***

## FileManager.removeFileBookmark

```ts
FileManager.removeFileBookmark(name: string): boolean
```

说明：

- 移除指定名称的文件书签
- 当不再需要访问对应文件时应及时调用
- 返回是否成功移除

示例：

```ts
FileManager.removeFileBookmark(bookmarkName)
```

***

## 使用建议

- 在 `types` 中尽量明确声明可接收的内容类型
- 在 `perform` 中只负责启动加载，不要等待加载完成
- 对图片等轻量内容可直接加载为对象
- 对视频、音频、文档等资源优先使用文件路径
- 对需要长期访问的文件务必创建书签
- 在资源不再使用时移除对应书签



---
url: /v2/zh/guide/Control Widget.md
---

# 控制中心的小组件

Scripting 支持用户在控制中心或锁屏界面添加按钮（Button）或开关（Toggle）控件，并通过绑定脚本 `AppIntent` 实现自定义逻辑。控件支持状态反馈、图标动态切换、隐私显示控制等能力。

***

## 控件标签类型定义

### `ControlWidgetLabel`

表示控件主标签或状态标签的信息结构。

| 字段名                | 类型         | 描述                   |
| ------------------ | ---------- | -------------------- |
| `title`            | `string`   | 标签的文本标题。             |
| `systemImage`      | `string?`  | 可选的 SF Symbols 图标名称。 |
| `privacySensitive` | `boolean?` | 控件在设备锁定时是否隐藏该标签内容。   |

***

## 一、按钮控件：`ControlWidgetButton`

用于添加一个点击后触发指定意图的按钮控件。

```ts
function ControlWidgetButton(props: ControlWidgetButtonProps): JSX.Element
```

### `ControlWidgetButtonProps`

| 字段名                  | 类型                            | 描述                                                   |
| -------------------- | ----------------------------- | ---------------------------------------------------- |
| `privacySensitive`   | `boolean?`                    | 控件是否在锁屏状态下隐藏其内容与状态。                                  |
| `intent`             | `AppIntent<any>`              | 点击按钮后触发的意图（AppIntent 实例）。                            |
| `label`              | `ControlWidgetLabel`          | 按钮主标签，显示标题与图标。                                       |
| `activeValueLabel`   | `ControlWidgetLabel \| null?` | 按钮激活（Active）状态时显示的标签。设置后需同时提供 `inactiveValueLabel`。  |
| `inactiveValueLabel` | `ControlWidgetLabel \| null?` | 按钮非激活（Inactive）状态时显示的标签。设置后需同时提供 `activeValueLabel`。 |

> 若提供了 `activeValueLabel` 或 `inactiveValueLabel`，建议同时提供两者，以确保状态一致性。此类状态标签的图标会覆盖 `label` 中的图标。

***

## 二、开关控件：`ControlWidgetToggle`

用于添加一个可切换状态的开关控件，自动将布尔值通过绑定意图传入。

```ts
function ControlWidgetToggle<T extends { value: boolean }>(props: ControlWidgetToggleProps<T>): JSX.Element
```

### `ControlWidgetToggleProps<T>`

| 字段名                  | 类型                            | 描述                                            |
| -------------------- | ----------------------------- | --------------------------------------------- |
| `privacySensitive`   | `boolean?`                    | 控件是否在锁屏状态下隐藏其内容与状态。                           |
| `intent`             | `AppIntent<T>`                | 控件状态切换时触发的意图。泛型参数 `T` 必须包含 `value: boolean`。  |
| `label`              | `ControlWidgetLabel`          | 控件主标签。                                        |
| `activeValueLabel`   | `ControlWidgetLabel \| null?` | 控件激活（开）状态时显示的标签。需与 `inactiveValueLabel` 搭配使用。 |
| `inactiveValueLabel` | `ControlWidgetLabel \| null?` | 控件非激活（关）状态时显示的标签。需与 `activeValueLabel` 搭配使用。  |

***

## 三、ControlWidget 命名空间

```ts
namespace ControlWidget
```

### `ControlWidget.parameter: string`

用户在控件配置界面中设置的参数值，通常用于标识目标对象，如设备 ID、门编号等。

***

### `ControlWidget.present(element: VirtualNode): void`

设置控件的显示内容。仅允许传入 `ControlWidgetButton` 或 `ControlWidgetToggle` 元素。

#### 注意：

- 若使用 `control_widget_button.tsx`，只能呈现 `ControlWidgetButton`；
- 若使用 `control_widget_toggle.tsx`，只能呈现 `ControlWidgetToggle`；
- 若控件需要在锁屏隐藏，可在顶层组件上设置 `privacySensitive`；
- 如果仅需要隐藏标签或状态信息，可在相应的 `ControlWidgetLabel` 中设置 `privacySensitive`。

#### 示例：

```tsx
/// app_intents.tsx
export const ToggleDoorIntent = AppIntentManager.register({
  name: "ToggleDoorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async ({ id, value }: { id: string; value: boolean }) => {
    await setDoorState(id, value)
    ControlWidget.reloadToggles()
  }
})

/// control_widget_toggle.tsx
async function run() {
  const doorId = ControlWidget.parameter || "default"
  const data = await fetchDoorData(doorId)

  ControlWidget.present(
    <ControlWidgetToggle
      privacySensitive
      intent={ToggleDoorIntent({ id: doorId, value: !data.doorOpened })}
      label={{
        title: `门 ${doorId}`,
        systemImage: data.doorOpened ? "door.garage.opened" : "door.garage.closed"
      }}
      activeValueLabel={{ title: "门已打开" }}
      inactiveValueLabel={{ title: "门已关闭" }}
    />
  )
}

run()
```

***

### `ControlWidget.reloadButtons(): void`

重新加载所有按钮控件。用于意图执行后刷新状态显示。

***

### `ControlWidget.reloadToggles(): void`

重新加载所有切换控件。常用于状态变更后触发 UI 更新。

***

## 四、开发建议

1. 所有控件必须绑定一个 `AppIntent`，用于定义交互逻辑。
2. 切换(Toggle)控件的参数必须包含 `{ value: boolean }`，可使用`AppIntentProtocol.AppIntent`协议，内部会强制切换为 `SetValueIntent` 协议。
3. 若为控件提供状态标签，建议提供完整的 `activeValueLabel` 与 `inactiveValueLabel` 配对，以提升可读性。
4. 图标使用 SF Symbols 命名的系统图标。
5. 在意图执行中变更控件状态时，应调用 `ControlWidget.reloadButtons()` 或 `reloadToggles()` 以触发前端刷新。



---
url: /v2/zh/guide/Custom Keyboard.md
---

# 自定义键盘

`CustomKeyboard` 是 Scripting 提供的全局命名空间，用于开发 iOS 自定义键盘扩展。在 `keyboard.tsx` 脚本中使用该 API，可以渲染自定义键盘 UI，并访问当前输入状态、插入文本、控制光标、监听输入事件、调整高度，并在多个脚本之间导航切换。

## 一、使用环境与前提

### 环境要求

- 必须在脚本项目中创建名为 **`keyboard.tsx`** 的文件；
- 所有 `CustomKeyboard` 方法 **仅可在键盘扩展环境中使用**；
- 在 **App 脚本、Intent (`intent.tsx`)、小组件 (`widget.tsx`) 中无法使用此 API**；
- 系统设置路径：

  ```
  设置 > 通用 > 键盘 > 键盘 > 添加新键盘 > 选择 Scripting
  ```

  添加后，进入 Scripting 键盘详情页，开启 **允许完全访问**，以启用网络请求、剪贴板访问等高级功能。

***

## 二、展示键盘 UI

### `present(node: VirtualNode): void`

用于展示自定义键盘界面。必须在 `keyboard.tsx` 中调用一次。

```tsx
function MyKeyboard() {
  return <Text>你好，世界</Text>
}

CustomKeyboard.present(<MyKeyboard />)
```

***

## 三、输入状态查询

| 属性名                | 类型                        | 说明          |
| ------------------ | ------------------------- | ----------- |
| `textBeforeCursor` | `Promise<string \| null>` | 光标前的文本      |
| `textAfterCursor`  | `Promise<string \| null>` | 光标后的文本      |
| `selectedText`     | `Promise<string \| null>` | 当前选中的文本（如有） |
| `hasText`          | `Promise<boolean>`        | 输入框是否包含文本内容 |

***

## 四、输入特征（traits）

### `useTraits(): TextInputTraits`

获取当前输入框的系统特征（如键盘类型、返回键样式等）。值在 `textDidChange` 和 `selectionDidChange` 事件中自动更新。

### `traits: TextInputTraits`

为静态快照，不会自动更新。建议在组件中使用 `useTraits()`。

常见字段包括：

- `keyboardType`：如 `'default'`, `'emailAddress'`, `'numberPad'`
- `returnKeyType`：如 `'done'`, `'go'`, `'search'`
- `textContentType`：如 `'username'`, `'password'`, `'oneTimeCode'`
- `keyboardAppearance`：`'light'`, `'dark'` 等

***

## 五、文本操作

### `insertText(text: string): Promise<void>`

在光标处插入文本。

### `deleteBackward(): Promise<void>`

删除光标前的一个字符。

### `moveCursor(offset: number): Promise<void>`

移动光标位置。负数为向左，正数为向右。

### `setMarkedText(text, location, length): Promise<void>`

设置标记文本（用于拼音输入等组合输入）。

### `unmarkText(): Promise<void>`

取消当前标记文本。

***

## 六、键盘行为控制

### `dismiss(): Promise<void>`

关闭键盘。

### `nextKeyboard(): Promise<void>`

切换至系统中的下一个键盘。

### `requestHeight(height: number): Promise<void>`

请求调整键盘高度（单位为 pt）。推荐范围为 **216\~360pt**，超出范围可能被系统忽略。

### `setHasDictationKey(value: boolean): Promise<void>`

设置是否显示语音输入按钮（麦克风图标）。

### `setToolbarVisible(visible: boolean): Promise<void>`

控制顶部工具栏的显示/隐藏。默认显示，适用于调试等场景。

***

## 七、导航控制

### `dismissToHome(): Promise<void>`

关闭当前键盘脚本，返回 Scripting 键盘首页（脚本列表）。适用于用户在多个脚本之间自由切换的场景。

```ts
await CustomKeyboard.dismissToHome()
```

***

## 八、用户反馈

### `playInputClick(): void`

播放标准键盘按键音，建议在模拟按键操作时调用，提升交互体验。

```ts
CustomKeyboard.playInputClick()
```

***

## 九、事件监听

### `addListener(event, callback): void`

注册事件监听器：

| 事件名                   | 回调参数                                | 说明     |
| --------------------- | ----------------------------------- | ------ |
| `textWillChange`      | `() => void`                        | 文本将要变更 |
| `textDidChange`       | `(traits: TextInputTraits) => void` | 文本已变更  |
| `selectionWillChange` | `() => void`                        | 光标将变更  |
| `selectionDidChange`  | `(traits: TextInputTraits) => void` | 光标已变更  |

### `removeListener(event, callback): void`

移除指定监听器。

### `removeAllListeners(event): void`

移除指定事件的所有监听器。

***

## 十、完整示例

```tsx
function MyKeyboard() {
  const traits = CustomKeyboard.useTraits()

  const insert = async (text: string) => {
    CustomKeyboard.playInputClick()
    await CustomKeyboard.insertText(text)
  }

  return (
    <VStack spacing={12}>
      <Text>输入类型：{traits.keyboardType}</Text>
      <HStack spacing={10}>
        <Button title="你" action={() => insert("你")} />
        <Button title="好" action={() => insert("好")} />
        <Button title="← 删除" action={() => CustomKeyboard.deleteBackward()} />
        <Button title="返回首页" action={() => CustomKeyboard.dismissToHome()} />
      </HStack>
    </VStack>
  )
}

CustomKeyboard.present(<MyKeyboard />)
```

***

## 十一、开发建议

- **必须调用 `present()` 并且仅调用一次**；
- 合理设置键盘高度，避免 UI 被遮挡；
- 使用 `useTraits()` 获取输入上下文信息；
- 调用 `dismissToHome()` 可以让用户在多个键盘脚本之间切换；
- 通过 `playInputClick()` 提升按键交互体验；
- 删除文本前请先判断 `hasText` 是否为 true；
- 监听事件时注意避免重复注册和内存泄漏；



---
url: /v2/zh/guide/Device Capabilities/AVMetadataItem.md
---

# AVMetadataItem

`AVMetadataItem` 类用于表示媒体文件（如音频或视频）中的单个元数据条目。
此类通常通过 `AVPlayer.loadMetadata()` 或 `AVPlayer.loadCommonMetadata()` 方法返回，用于访问媒体文件中嵌入的标准或自定义元数据信息。

元数据项可以包含标题、艺术家、专辑、封面图片、编码信息、语言标签等。
每个 `AVMetadataItem` 实例都表示一个独立的键值对，并且提供多种类型化访问方式。

***

## 类定义

### `class AVMetadataItem`

***

### **属性（Properties）**

#### `key: string`

元数据项的键（Key）。
该值通常与具体的媒体格式相关（例如 ID3、QuickTime、iTunes 等）。

**示例**

```ts
console.log(item.key) // 例如： "id3/TIT2"
```

***

#### `commonKey?: string`

元数据项的**通用键**。
此属性表示与 `key` 对应的“通用命名空间”键，用于跨格式访问常用元数据。
即使底层媒体格式不同，你仍然可以通过 `commonKey` 访问相同意义的字段。

**示例**

```ts
console.log(item.commonKey) // 例如： "title"
```

***

#### `identifier?: string`

元数据项的唯一标识符（Identifier）。
可用于区分相同类型的多个元数据条目。

***

#### `extendedLanguageTag?: string`

元数据项使用的语言扩展标签（如 `"en-US"` 或 `"zh-Hans"`）。
如果元数据内容与语言相关，则该值指示其语言环境。

***

#### `locale?: string`

表示与该元数据关联的地区或本地化信息。

***

#### `time?: number`

元数据项在媒体中的时间戳（以秒为单位）。
适用于时间相关的元数据，如字幕或歌词。

**示例**

```ts
console.log(item.time) // 输出例如：12.53
```

***

#### `duration?: number`

元数据项的持续时间（以秒为单位）。
例如某些可视化元数据（如图片、歌词）具有有效时长。

***

#### `startDate?: Date`

元数据项的起始时间（如果存在）。
若该项没有具体日期信息，则返回 `null`。

***

#### `dataType?: string`

元数据项值的数据类型（如 `"com.apple.metadata.datatype.UTF-8"`, `"public.jpeg"` 等）。

该属性可用于判断 `value` 的原始数据类型。

***

#### `extraAttributes: Promise<Record<string, any> | null>`

额外属性，包含特定元数据容器或键空间的附加信息。
例如 ID3 标签中 `"APIC"` 帧（封面图片）可能包含描述性文本、图片类型等额外属性。

**示例**

```ts
const extras = await item.extraAttributes
console.log(extras)
// 可能输出： { description: "Cover (front)", pictureType: 3 }
```

***

#### `dataValue: Promise<Data | null>`

将元数据项的值以 `Data` 类型返回。
适用于二进制内容（如封面图片、嵌入数据等）。

**示例**

```ts
const imageData = await item.dataValue
if (imageData) {
  const image = UIImage.fromData(imageData)
  // 使用 image
}
```

***

#### `stringValue: Promise<string | null>`

将元数据项的值以 `string` 类型返回。
常用于文本元数据（标题、艺术家、专辑等）。

**示例**

```ts
const title = await item.stringValue
console.log("标题：", title)
```

***

#### `numberValue: Promise<number | null>`

将元数据项的值以数字形式返回。
适用于数值型元数据（如比特率、采样率、音量等）。

**示例**

```ts
const bitrate = await item.numberValue
console.log("比特率：", bitrate)
```

***

#### `dateValue: Promise<Date | null>`

将元数据项的值以 `Date` 类型返回。
适用于时间相关的元数据（如录制日期、发布日期等）。

**示例**

```ts
const date = await item.dateValue
console.log("发布日期：", date?.toISOString())
```

***

## 使用示例

```ts
const metadata = await player.loadMetadata()
for (const item of metadata) {
  const key = item.commonKey ?? item.key
  const value = await item.stringValue ?? await item.numberValue
  console.log(`${key}: ${value}`)
}
```

**说明：**

- 若 `commonKey` 存在，建议优先使用，以保持跨格式一致性。
- 异步属性（如 `stringValue`、`dataValue`、`extraAttributes`）都以 Promise 形式提供，便于按需加载。
- 可结合 `AVPlayer.loadCommonMetadata()` 获取标准化元数据（如标题、专辑、艺术家、封面等）。

***

## 常见用途

| 用途   | 示例字段 (`commonKey`) | 说明              |
| ---- | ------------------ | --------------- |
| 标题   | `"title"`          | 媒体文件标题          |
| 艺术家  | `"artist"`         | 表演者或作者          |
| 专辑   | `"albumName"`      | 专辑名称            |
| 封面图片 | `"artwork"`        | 通常为 JPEG/PNG 数据 |
| 编码信息 | `"encoder"`        | 媒体编码器或软件        |
| 录制时间 | `"creationDate"`   | 录制或生成时间         |



---
url: /v2/zh/guide/Device Capabilities/AppStore.md
---

# AppStore

`AppStore` API 用于在 **不离开 Scripting 应用** 的情况下，展示 App Store 中某个应用的详情页面。
该能力基于系统原生的 App Store 展示组件，适合用于实现 **应用推荐、应用收藏夹、关联应用跳转、生态扩展入口** 等场景。

***

## 命名空间：`AppStore`

```ts
namespace AppStore
```

***

## 功能概述

- 在 Scripting App 内以 **模态窗口（Modal）** 方式展示指定 App 的 App Store 页面
- 用户可直接查看应用介绍、截图、评分、更新日志
- 用户可在该页面中完成 **下载 / 更新 / 打开应用**
- 关闭后自动返回当前脚本页面
- 不会跳转到系统 App Store 应用

***

## 方法一览

| 方法                       | 说明                      |
| ------------------------ | ----------------------- |
| `presentApp(id: string)` | 打开指定 App 的 App Store 页面 |
| `dismissApp()`           | 主动关闭当前展示的 App Store 页面  |

***

## 方法说明

### `presentApp(id: string): Promise<void>`

在 Scripting App 内展示指定 App 的 App Store 页面。

#### 参数

| 参数   | 类型       | 说明                              |
| ---- | -------- | ------------------------------- |
| `id` | `string` | App 的 **App Store 标识符（App ID）** |

- 该 ID 是 App Store 中的数字 ID
- 通常可从 App Store URL 中获取
  例如：
  `https://apps.apple.com/app/id123456789`
  则 `id` 为 `"123456789"`

#### 返回值

- 返回一个 `Promise<void>`
- 当用户 **关闭 App Store 模态页面** 时，Promise resolve
- 如果当前已经有一个 App Store 页面在展示中，则会抛出错误

#### 行为说明

- 以模态方式打开 App Store 页面
- 同一时间 **只能存在一个 App Store 模态窗口**
- 如果重复调用 `presentApp`，将导致 Promise reject

#### 示例

```ts
await AppStore.presentApp("123456789")
```

***

### `dismissApp(): Promise<void>`

关闭当前通过 `presentApp` 打开的 App Store 页面。

#### 返回值

- 返回一个 `Promise<void>`
- 当模态页面成功关闭后 resolve

#### 使用说明

- 一般情况下不需要手动调用
- 适用于：

  - 自定义 UI 控制关闭行为
  - 脚本中需要在特定逻辑点强制关闭 App Store 页面

#### 示例

```ts
await AppStore.dismissApp()
```

***

## 使用示例

### 示例一：应用推荐入口

```ts
import { Button } from "scripting"

function AppRecommendation() {
  return (
    <Button
      title="查看推荐应用"
      action={() => {
        AppStore.presentApp("123456789")
      }}
    />
  )
}
```

***

### 示例二：应用收藏夹

```ts
const favoriteApps = [
  { name: "App A", id: "123456789" },
  { name: "App B", id: "987654321" }
]

function AppList() {
  return favoriteApps.map(app => (
    <Button
      title={app.name}
      action={() => {
        AppStore.presentApp(app.id)
      }}
    />
  ))
}
```

***

## 错误与注意事项

### 常见错误

- **已有 App Store 页面正在展示**

  - 再次调用 `presentApp` 会抛出错误
  - 建议在逻辑层控制调用时机

### 使用限制

- 仅支持 App Store 应用页面
- 不支持展示订阅页、开发者主页等其他 App Store 内容
- 必须传入有效的 App Store App ID



---
url: /v2/zh/guide/Device Capabilities/Audio Player.md
---

# 音频播放器

`AVPlayer` 提供播放音频或视频的能力，并支持播放控制、循环播放、回调事件和元数据读取等功能。你可以通过 `setSource()` 设置媒体源（本地文件或远程 URL），然后使用 `play()` 开始播放。

***

## 入门指南

以下示例展示了 `AVPlayer` 的基本用法：

```typescript
const player = new AVPlayer()

// 设置媒体源（本地文件或远程 URL）
if (player.setSource("https://example.com/audio.mp3")) {
    player.onReadyToPlay = () => {
        player.play()
    }
    player.onEnded = () => {
        console.log("播放完成。")
    }
} else {
    console.error("设置媒体源失败。")
}
```

***

## API 参考

### 属性

#### `volume: number`

控制播放音量，范围为 `0.0`（静音）到 `1.0`（最大音量）。

```typescript
player.volume = 0.5 // 设置为 50% 音量
```

***

#### `duration: DurationInSeconds`

媒体总时长（单位：秒）。在媒体加载完成前，该值为 `0`。

```typescript
console.log(`媒体时长：${player.duration} 秒`)
```

***

#### `currentTime: DurationInSeconds`

当前播放时间（单位：秒）。可通过设置该值跳转播放位置。

```typescript
player.currentTime = 30 // 跳转到第 30 秒
```

***

#### `rate: number`

控制播放速率。`1.0` 为正常速度，值小于 `1.0` 为减速播放，大于 `1.0` 为加速播放。

```typescript
player.rate = 1.5 // 以 1.5 倍速播放
```

***

#### `timeControlStatus: TimeControlStatus`

指示播放状态。可取值：

- `paused`: 暂停中
- `waitingToPlayAtSpecifiedRate`: 正在等待可播放状态（如网络缓冲）
- `playing`: 正在播放

***

#### `numberOfLoops: number`

设置循环播放次数。

- `0`：不循环
- 正数：指定循环次数
- 负数：无限循环

```typescript
player.numberOfLoops = -1 // 无限循环播放
```

***

### 方法

#### `setSource(filePathOrURL: string): boolean`

设置播放源，可以是本地文件路径或远程 URL。

返回：

- `true`: 设置成功
- `false`: 设置失败

***

#### `play(): boolean`

开始播放媒体。

返回：

- `true`: 成功开始播放
- `false`: 失败

***

#### `pause()`

暂停播放。

***

#### `stop()`

停止播放并重置到起始位置。

***

#### `dispose()`

释放播放器资源、移除观察者。
应在播放器不再使用时调用以避免资源泄露。

***

#### `loadMetadata(): Promise<AVMetadataItem[] | null>`

加载当前媒体的完整元数据。

返回：

- 一个包含 `AVMetadataItem` 对象的数组
- 若媒体未加载或无元数据，则返回 `null`

示例：

```typescript
const metadata = await player.loadMetadata()
if (metadata) {
  for (const item of metadata) {
    console.log(item.key, await item.stringValue)
  }
}
```

***

#### `loadCommonMetadata(): Promise<AVMetadataItem[] | null>`

加载当前媒体的通用元数据（common metadata），这些元数据的 `commonKey` 属性提供跨格式可识别的键名。

示例：

```typescript
const commonMetadata = await player.loadCommonMetadata()
if (commonMetadata) {
  const titleItem = commonMetadata.find(i => i.commonKey === "title")
  console.log("标题：", await titleItem?.stringValue)
}
```

***

### 回调事件

#### `onReadyToPlay?: () => void`

媒体准备就绪、可播放时触发。

***

#### `onTimeControlStatusChanged?: (status: TimeControlStatus) => void`

播放状态变更时触发，例如从“等待中”到“播放中”。

***

#### `onEnded?: () => void`

媒体播放完成时触发。

***

#### `onError?: (message: string) => void`

播放过程中发生错误时触发，参数为错误信息。

***

## 使用音频会话

`AVPlayer` 依赖系统的共享音频会话。你可以通过 `SharedAudioSession` 进行配置，以确保播放行为符合预期。

```typescript
await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
await SharedAudioSession.setActive(true)
```

处理系统中断（如电话）：

```typescript
SharedAudioSession.addInterruptionListener((type) => {
  if (type === 'began') player.pause()
  else if (type === 'ended') player.play()
})
```

***

## 常见用例

### 播放远程音频

```typescript
player.setSource("https://example.com/audio.mp3")
player.onReadyToPlay = () => player.play()
```

***

### 播放本地文件

```typescript
player.setSource("/path/to/audio.mp3")
player.play()
```

***

### 循环播放

```typescript
player.numberOfLoops = 3 // 循环播放 3 次
player.play()
```

***

### 获取元数据

```typescript
const metadata = await player.loadCommonMetadata()
if (metadata) {
  const artist = metadata.find(i => i.commonKey === "artist")
  console.log("演唱者：", await artist?.stringValue)
}
```

***

## 最佳实践

1. **资源管理**
   使用完毕后务必调用 `dispose()` 释放资源。

2. **错误处理**
   实现 `onError` 回调，优雅地处理播放错误。

3. **中断管理**
   通过音频会话监听中断事件，自动暂停或恢复播放。

4. **UI 状态更新**
   使用 `onTimeControlStatusChanged` 更新播放状态显示。

5. **元数据使用**
   通过 `loadCommonMetadata()` 获取通用信息，如标题、艺术家、封面等，用于显示在 UI 上。

***

## 完整示例

```typescript
const player = new AVPlayer()

await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
await SharedAudioSession.setActive(true)

if (player.setSource("https://example.com/audio.mp3")) {
  player.onReadyToPlay = () => player.play()
  player.onEnded = () => {
    console.log("播放完成")
    player.dispose()
  }
  player.onError = (message) => {
    console.error("播放错误：", message)
    player.dispose()
  }

  // 读取元数据
  const commonMetadata = await player.loadCommonMetadata()
  if (commonMetadata) {
    const titleItem = commonMetadata.find(i => i.commonKey === "title")
    console.log("标题：", await titleItem?.stringValue)
  }
} else {
  console.error("设置媒体源失败")
}
```



---
url: /v2/zh/guide/Device Capabilities/AudioRecorder.md
---

# 录音

`AudioRecorder` 类允许您将音频数据录制到文件。它提供了开始、停止、暂停和管理音频录制的功能，并可配置音频质量、采样率、格式等。

## 功能

- 从系统的活跃输入设备录制音频。
- 可以录制指定时长，或在手动停止前一直录制。
- 暂停并恢复录制。
- 删除已录制的音频文件。

***

## 用法

### 设置 SharedAudioSession

在创建 `AudioRecorder` 实例之前，需要先设置 `SharedAudioSession`。因为音频会话与硬件相关，因此需要确保正确激活会话。

```ts
await SharedAudioSession.setActive(true)
await SharedAudioSession.setCategory(
  "playAndRecord",
  ["defaultToSpeaker"]
)
```

### 创建 AudioRecorder 实例

使用 `create` 方法来创建一个音频录制器实例：

```ts
async function createRecorder() {
  try {
    const filePath = Path.join(
      FileManager.documentsDirectory,
      "recording.m4a"
    )
    const recorder = await AudioRecorder.create(filePath, {
      format: "MPEG4AAC",
      sampleRate: 44100,
      numberOfChannels: 2,
      encoderAudioQuality: AVAudioQuality.high
    })
    return recorder
  } catch (error) {
    console.error("Failed to create recorder: ", error)
  }
}
```

### 录制音频

您可以使用 `record()` 方法开始录制：

```ts
async function startRecording() {
  const recorder = await createRecorder()
  if (recorder) {
    const success = recorder.record()
    console.log("Recording started: ", success)
  }
}
```

也可以提供额外的选项来控制录制开始的时间及录制时长：

```ts
function startSynchronizedRecording(recorderOne, recorderTwo) {
  let timeOffset = recorderOne.deviceCurrentTime + 0.01
  
  // 使两个 recorder 的录制时间同步
  recorderOne.record({ atTime: timeOffset })
  recorderTwo.record({ atTime: timeOffset })
}
```

### 暂停和停止录制

暂停录制：

```ts
function pauseRecording(recorder) {
  recorder.pause()
  console.log("Recording paused.")
}
```

停止录制：

```ts
function stopRecording(recorder) {
  recorder.stop()
  console.log("Recording stopped.")
}
```

### 删除录音文件

要删除已经录制好的文件：

```ts
function deleteRecording(recorder) {
  const success = recorder.deleteRecording()
  console.log("Recording deleted: ", success)
}
```

### 释放 Recorder

当不再需要使用录制器时，应调用 `dispose()` 来释放资源：

```ts
function disposeRecorder(recorder) {
  recorder.dispose()
  console.log("Recorder disposed.")
}
```

### 事件处理

可以使用 `onFinish` 和 `onError` 回调来处理录制完成和错误情况：

```ts
async function setupRecorder() {
  const recorder = await createRecorder()
  if (recorder) {
    recorder.onFinish = (success) => {
      console.log("Recording finished successfully: ", success)
    }

    recorder.onError = (message) => {
      console.error("Recording error: ", message)
    }
  }
}
```

***

## API 参考

### `AudioRecorder.create(filePath, settings?)`

使用指定的设置创建一个 `AudioRecorder` 实例。

- **filePath** (string): 要录制到的文件系统路径。
- **settings** (可选对象): 录音的音频设置：
  - **format** (AudioFormat): 音频数据的格式，可选值包括 `"LinearPCM"`, `"MPEG4AAC"`, `"AppleLossless"`, `"AppleIMA4"`, `"iLBC"`, `"ULaw"`。
  - **sampleRate** (number): 采样率，单位为赫兹 (范围 8000 到 192000)。
  - **numberOfChannels** (number): 声道数量 (1 到 64)。
  - **encoderAudioQuality** (AVAudioQuality): 音频编码质量 (从 `AVAudioQuality.min` 到 `AVAudioQuality.max`)。

**返回值**: 一个 `Promise`，解析后返回 `AudioRecorder` 实例。

### `AudioRecorder.isRecording`

一个布尔值，用于指示录制器当前是否正在录音。

### `AudioRecorder.currentTime`

从录音开始到当前的时间（单位为秒）。

### `AudioRecorder.deviceCurrentTime`

主机音频设备的当前时间（单位为秒）。

### `AudioRecorder.record(options?)`

开始录制音频。

- **options** (可选对象):
  - **atTime** (number): 相对于 `deviceCurrentTime`，指定开始录制的时间。
  - **duration** (number): 录音时长（单位为秒）。

**返回值**: 一个布尔值，表示录制是否成功开始。

### `AudioRecorder.pause()`

暂停当前录制。

### `AudioRecorder.stop()`

停止录制并关闭音频文件。

### `AudioRecorder.deleteRecording()`

删除已经录制的音频文件。

**返回值**: 一个布尔值，表示删除操作是否成功。

### `AudioRecorder.dispose()`

释放录制器所使用的资源。

### `AudioRecorder.onFinish`

录音完成后调用的回调函数。

- **success** (boolean): 表示录制是否成功完成。

### `AudioRecorder.onError`

在录制或编码出现错误时调用的回调函数。

- **message** (string): 描述错误的字符串。

***

## 使用示例

```ts
import { Path } from 'scripting'

async function run() {

  await SharedAudioSession.setActive(true)
  await SharedAudioSession.setCategory(
    "playAndRecord",
    ["defaultToSpeaker"]
  )

  try {
    const filePath = Path.join(
      FileManager.documentsDirectory,
      "recording.m4a"
    )
    const recorder = await AudioRecorder.create(filePath, {
      format: "MPEG4AAC",
      sampleRate: 48000,
      numberOfChannels: 2,
      encoderAudioQuality: AVAudioQuality.high
    })

    recorder.onFinish = (success) => console.log("Recording finished successfully: ", success)
    recorder.onError = (message) => console.error("Recording error: ", message)

    recorder.record()
    setTimeout(() => {
      recorder.stop()
    }, 5000) // 5秒后停止录制
  } catch (error) {
    console.error("Error: ", String(error))
  }
}

run()
```

使用 `AudioRecorder` 类，您可以在脚本中轻松管理音频录制操作，并灵活控制音频录制流程。



---
url: /v2/zh/guide/Device Capabilities/BackgroundKeeper.md
---

# 后台保活

`BackgroundKeeper` API 用于控制 **Scripting App** 的后台保活行为，使脚本在应用切换到后台后，能够在一定时间内继续运行。
这在需要保持持续操作（如网络连接、数据同步或后台任务）的场景中非常有用。

> **可用性：**
> 仅当脚本在主应用中运行 (即`Script.env === "index"`) 时可用。
> 请谨慎使用此功能，因为长时间保持后台运行可能会增加设备的电量消耗。

***

## 概述

当应用进入后台（例如由于系统事件触发状态切换）时，可以调用 `BackgroundKeeper.keepAlive()` 来请求保持 Scripting App 的运行。
当应用重新回到前台时，应调用 `BackgroundKeeper.stopKeepAlive()` 来停止后台保活进程并释放资源。

多个脚本可以同时请求后台保活。系统内部维护一个 **保活请求队列**：

- 每次调用 `keepAlive()` 会将当前脚本加入保活队列；
- 每次调用 `stopKeepAlive()` 会将当前脚本从队列中移除；
- 只有当队列为空时，后台保活进程才会真正停止。

> **注意：**
> 即使开启了保活，系统在某些情况下（如内存占用过高、电量过低等）仍可能终止 Scripting App。

***

## 命名空间：`BackgroundKeeper`

### 属性

#### `isActive: Promise<boolean>`

返回一个 Promise，用于指示当前后台保活进程是否处于激活状态。

**示例：**

```ts
const active = await BackgroundKeeper.isActive
if (active) {
  console.log("后台保活已激活")
} else {
  console.log("后台保活未启用")
}
```

***

### 方法

#### `keepAlive(): Promise<boolean>`

启动后台保活进程。

- 如果保活进程已处于激活状态，返回 `true`；
- 如果启动成功，返回 `true`；
- 如果系统拒绝保活请求，可能返回 `false`。

**返回值：**
`Promise<boolean>` — 表示后台保活是否成功启动。

**示例：**

```ts
const started = await BackgroundKeeper.keepAlive()
if (started) {
  console.log("后台保活已成功启动")
} else {
  console.log("无法启动后台保活")
}
```

***

#### `stopKeepAlive(): Promise<void>`

停止当前脚本的后台保活请求。
此操作并不保证整个保活进程立即停止，因为其他脚本可能仍在请求保活。只有当所有请求都被释放后，后台保活才会完全停止。

**返回值：**
`Promise<void>` — 在请求处理完成后 resolve。

**示例：**

```ts
await BackgroundKeeper.stopKeepAlive()
console.log("当前脚本的后台保活请求已释放")
```

***

## 示例用法

```ts
async function runBackgroundTask() {
  const started = await BackgroundKeeper.keepAlive()
  if (!started) {
    console.log("无法保持后台运行")
    return
  }

  try {
    console.log("正在后台执行任务...")
    // 在后台执行任务（例如同步数据、监听蓝牙设备等）
    await new Promise(resolve => setTimeout(resolve, 10000))
  } finally {
    await BackgroundKeeper.stopKeepAlive()
    console.log("已停止后台保活")
  }
}
```

***

## 注意事项与最佳实践

- **请谨慎使用**：持续的后台运行可能显著增加电量消耗。
- **任务完成后务必调用 `stopKeepAlive()`**，或在应用回到前台时停止保活。
- **不要依赖后台保活实现无限后台执行**，系统可能随时挂起或终止应用。
- **多个脚本可共享保活进程**：当所有脚本都调用 `stopKeepAlive()` 后，保活才会真正结束。



---
url: /v2/zh/guide/Device Capabilities/Bluetooth/BluetoothCentralManager.md
---

# 蓝牙中央设备管理器

`BluetoothCentralManager` 提供了用于操作 BLE 中央设备的核心接口，包括扫描附近蓝牙设备、连接外设、获取已知设备、断开连接等能力。适用于实现如外设控制、数据采集、IoT通信等典型蓝牙场景。

***

## 成员属性

### `isScanning: Promise<boolean>`

> 获取当前是否正在扫描外围设备。

- **类型**：`Promise<boolean>`
- **示例**：

  ```ts
  const scanning = await BluetoothCentralManager.isScanning
  console.log(scanning ? "正在扫描" : "未扫描")
  ```

***

## 方法

### `startScan(onDiscoverPeripheral, options?): Promise<void>`

> 启动 BLE 设备扫描，直到调用 `stopScan()` 结束。每发现一个设备都会触发 `onDiscoverPeripheral` 回调。

#### 参数

- `onDiscoverPeripheral: (peripheral, advertisementData, rssi) => void`

  - 每发现一个外围设备时调用
  - 参数说明：

    - `peripheral`: `BluetoothPeripheral` 外设对象
    - `advertisementData`: `BluetoothAdvertisementData` 广播数据
    - `rssi`: `number` 信号强度（dBm）

- `options?: { services?: string[]; allowDuplicates?: boolean; solicitedServiceUUIDs?: string[] }`

  - `services`: 只扫描包含指定服务 UUID 的外设
  - `allowDuplicates`: 是否允许重复回调同一设备，默认 `false`
  - `solicitedServiceUUIDs`: 一个包含外设请求的服务 UUID 的数组，表明希望由中央设备提供哪些服务

##### BluetoothAdvertisementData 广播数据结构

在使用 `BluetoothCentralManager.startScan()` 进行蓝牙扫描时，每次发现设备都会返回包含该设备广播数据的 `advertisementData` 对象。该对象包含设备在广播包中附带的多种信息字段，用于识别、过滤、分类外设。

***

###### 数据结构说明

```ts
type BluetoothAdvertisementData = {
  localName?: string
  txPowerLevel?: number
  manufacturerData?: Data
  serviceData?: Record<string, Data>
  serviceUUIDs?: string[]
  overflowServiceUUIDs?: string[]
  isConnectable?: boolean
  solicitedServiceUUIDs?: string[]
}
```

***

###### 字段详解

| 字段名                     | 类型                         | 说明                                            |
| ----------------------- | -------------------------- | --------------------------------------------- |
| `localName`             | `string`（可选）               | 外设广播的本地名称（若有）。用于展示用户可识别的设备名称。                 |
| `txPowerLevel`          | `number`（可选）               | 发射功率（单位 dBm）。用于估算设备距离，RSSI + TxPower 可用于计算距离。 |
| `manufacturerData`      | `Data`（可选）                 | 厂商自定义数据，常用于识别设备型号、序列号等。需自行解析 `Data`。          |
| `serviceData`           | `Record<string, Data>`（可选） | 服务数据字段，键为服务 UUID，值为对应的服务内容（`Data` 类型）。        |
| `serviceUUIDs`          | `string[]`（可选）             | 广播中声明支持的服务 UUID 列表。可用于快速判断设备功能类型。             |
| `overflowServiceUUIDs`  | `string[]`（可选）             | 当 `serviceUUIDs` 超出广播数据包大小限制时，会将溢出部分放入该字段。    |
| `isConnectable`         | `boolean`（可选）              | 该设备是否支持连接。扫描结果中用于快速过滤无法连接的广播型设备。              |
| `solicitedServiceUUIDs` | `string[]`（可选）             | 外设请求的服务 UUID，表明希望由中央设备提供哪些服务。                 |

***

###### 常见用途

- 根据 `localName` 或 `serviceUUIDs` 进行设备筛选
- 解析 `manufacturerData` 判断厂商/设备类型
- 结合 `txPowerLevel` 和 `RSSI` 估算设备距离
- 利用 `isConnectable` 判断是否需要尝试连接

***

###### 注意事项

- 所有字段均为可选项，某些设备可能不广播特定字段
- `manufacturerData` 和 `serviceData` 是原始二进制数据（`Data` 类型），需根据厂商协议解析
- `serviceUUIDs` 仅代表广播包中声明的服务，完整服务需通过 `discoverServices()` 获取

#### 返回值

- `Promise<void>`：扫描启动成功时 resolve，失败时 reject

#### 示例

```ts
await BluetoothCentralManager.startScan((peripheral, adv, rssi) => {
  console.log(`发现设备: ${peripheral.name}, 信号: ${rssi} dBm`)
}, {
  services: ["180D"], // 只扫描支持心率服务的设备
  allowDuplicates: false
})
```

***

### `stopScan(): Promise<void>`

> 停止正在进行的扫描操作。

#### 返回值

- `Promise<void>`：成功停止时 resolve

#### 示例

```ts
await BluetoothCentralManager.stopScan()
console.log("已停止扫描")
```

***

### `retrievePeripherals(ids: string[]): Promise<BluetoothPeripheral[]>`

> 根据设备 UUID 获取已知的蓝牙设备（可能已连接或已配对）。

#### 参数

- `ids: string[]`：设备的唯一标识符数组

#### 返回值

- `Promise<BluetoothPeripheral[]>`：返回符合 ID 的设备列表

#### 示例

```ts
const knownDevices = await BluetoothCentralManager.retrievePeripherals(["A1-B2-C3-D4"])
```

***

### `retrieveConnectedPeripherals(serviceUUIDs: string[]): Promise<BluetoothPeripheral[]>`

> 获取当前连接中并提供指定服务的外围设备。

#### 参数

- `serviceUUIDs: string[]`：过滤条件，仅返回包含这些服务 UUID 的设备

#### 返回值

- `Promise<BluetoothPeripheral[]>`：匹配的设备列表

#### 示例

```ts
const connected = await BluetoothCentralManager.retrieveConnectedPeripherals(["180F"])
console.log(`发现 ${connected.length} 个已连接电池服务设备`)
```

***

### `connect(peripheral, options?): Promise<void>`

> 与指定外围设备建立连接。

#### 参数

- `peripheral: BluetoothPeripheral`：要连接的设备
- `options?:` 可选连接配置：

  - `startDelay?: number`：延迟连接（秒）
  - `enableTransportBridging?: boolean`：启用传输桥接（用于特殊外设）
  - `requiresANCS?: boolean`：是否需要 ANCS 支持（苹果通知服务）
  - `enableAutoReconnect?: boolean`：是否自动重连
  - `notifyOnConnection?: boolean` - 是否通知app连接成功
  - `notifyOnDisconnection?: boolean` - 是否通知app连接已断开
  - `notifyOnNotification?: boolean` - 是否通知app收到通知

#### 返回值

- `Promise<void>`：连接成功 resolve，失败 reject

#### 示例

```ts
await BluetoothCentralManager.connect(peripheral, {
  startDelay: 100,
  enableAutoReconnect: true
})
console.log("已连接到外设")
```

***

### `disconnect(peripheral): Promise<void>`

> 断开与指定外围设备的连接。此操作是非阻塞的，部分尚未完成的操作可能无法继续。

#### 参数

- `peripheral: BluetoothPeripheral`：要断开的设备

#### 返回值

- `Promise<void>`

#### 注意事项

- 并不能保证物理连接立即断开（系统层面可能仍被其他 App 占用）
- 但从 Scripting 角度来看，设备即视为断开，`onDisconnected` 回调将被调用

#### 示例

```ts
await BluetoothCentralManager.disconnect(peripheral)
console.log("已断开连接")
```

***

## 注意事项

- 所有蓝牙方法需要在已授权蓝牙权限的前提下执行。
- 设备连接后请调用 `discoverServices()` 发现服务，然后通过 `discoverCharacteristics()` 获取特征值后再读写。
- 建议在扫描结束后手动调用 `stopScan()`，避免后台持续运行。

***

## 示例工作流程

```ts
await BluetoothCentralManager.startScan((peripheral) => {
  BluetoothCentralManager.stopScan()
  BluetoothCentralManager.connect(peripheral)
    .then(() => peripheral.discoverServices())
    .then(() => console.log("服务已发现"))
})
```



---
url: /v2/zh/guide/Device Capabilities/Bluetooth/BluetoothCharacteristic.md
---

# 蓝牙服务特征值

`BluetoothCharacteristic` 表示蓝牙服务（`BluetoothService`）中的一个特征值，是 BLE 设备数据交互的核心单元。每个特征值由唯一 UUID 标识，并定义了支持的操作类型、当前值、通知状态等属性。

***

## 一、属性字段

### `uuid: string`

特征值的 UUID（统一唯一标识符），用于识别特征的类型。

- 示例：

  - `"2A37"` 表示标准心率测量特征
  - `"6E400002-B5A3-F393-E0A9-E50E24DCCA9E"` 是一个自定义特征 UUID

***

### `serviceUUID: string | null`

当前特征值所属服务的 UUID，如果服务未被发现则可能为 `null`。

***

### `properties: BluetoothCharacteristicProperty[]`

当前特征值支持的操作类型，是以下字符串枚举值组成的数组（可能同时包含多个）：

#### 可用的属性（`BluetoothCharacteristicProperty` 枚举）：

| 属性名                            | 说明                      |
| ------------------------------ | ----------------------- |
| `"broadcast"`                  | 支持广播（较少使用）              |
| `"read"`                       | 支持读取特征值                 |
| `"writeWithoutResponse"`       | 支持写入但不要求响应（更快，适用于高频率写入） |
| `"write"`                      | 支持写入并要求响应（更安全）          |
| `"notify"`                     | 支持通知（value 变化时主动推送）     |
| `"indicate"`                   | 支持指示（带确认的通知）            |
| `"authenticatedSignedWrites"`  | 支持认证写入（安全性更高）           |
| `"extendedProperties"`         | 包含扩展属性（由额外属性描述符定义）      |
| `"notifyEncryptionRequired"`   | 通知需加密（必须加密连接才能启用通知）     |
| `"indicateEncryptionRequired"` | 指示需加密（同上）               |

#### 示例判断：

```ts
if (characteristic.properties.includes("read")) {
  const value = await peripheral.readValue(characteristic)
}
```

***

### `isNotifying: boolean`

当前是否处于通知（`notify`）或指示（`indicate`）订阅状态。

- `true`: 已启用订阅，设备会推送值变化
- `false`: 未启用订阅

> 可通过 `peripheral.subscribe()` 和 `unsubscribe()` 控制通知状态。

***

### `value: Data | null`

当前特征值的内容，通常在调用 `readValue()` 或接收到通知时更新。

- `Data` 为 Scripting 提供的二进制数据类型
- 若尚未读取或写入，此字段可能为 `null`

***

## 二、特征权限

虽然 `BluetoothCharacteristic` 接口本身不包含权限字段，但在创建或定义特征值（如 Peripheral 模式）时可用下列权限枚举类型：

### `BluetoothAttributePermissions` 枚举（权限类型）

| 权限值                         | 说明      |
| --------------------------- | ------- |
| `"readable"`                | 可被读取    |
| `"writeable"`               | 可被写入    |
| `"readEncryptionRequired"`  | 读取需加密连接 |
| `"writeEncryptionRequired"` | 写入需加密连接 |

***

## 三、操作示例

### 读取特征值（需支持 `"read"`）

```ts
if (characteristic.properties.includes("read")) {
  const value = await peripheral.readValue(characteristic)
  console.log("读取到内容:", value?.toRawString())
}
```

***

### 写入特征值（需支持 `"write"` 或 `"writeWithoutResponse"`）

```ts
const data = Data.fromRawString("COMMAND")
if (characteristic.properties.includes("writeWithoutResponse")) {
  await peripheral.writeValue(characteristic, data, "withoutResponse")
} else if (characteristic.properties.includes("write")) {
  await peripheral.writeValue(characteristic, data, "withResponse")
}
```

***

### 订阅通知（需支持 `"notify"` 或 `"indicate"`）

```ts
if (characteristic.properties.includes("notify")) {
  await peripheral.subscribe(characteristic, (error, value) => {
    if (!error && value) {
      console.log("收到通知:", value.toHexString())
    }
  })
}
```

***

### 取消通知订阅

```ts
await peripheral.unsubscribe(characteristic)
```

***

## 四、使用建议与注意事项

- 特征值操作前必须调用 `discoverCharacteristics(service)` 获取特征值列表。
- **不要假设**所有特征值都支持读写，请根据 `properties` 判断支持的操作。
- 通知（Notify）和指示（Indicate）必须先调用 `subscribe()`，停止时需配套调用 `unsubscribe()`。
- 使用 `"writeWithoutResponse"` 时，建议配合 `canSendWriteWithoutResponse` 状态控制频率。
- 写入前建议调用 `maxWriteValueLength()` 获取最大支持长度。



---
url: /v2/zh/guide/Device Capabilities/Bluetooth/BluetoothPeripheral.md
---

# 蓝牙外设

`BluetoothPeripheral` 表示一个 BLE 外围设备对象，支持读取设备信息、连接状态、发现服务与特征值、读取写入数据、订阅通知等。它是蓝牙通信的主要交互对象。

***

## 属性（只读）

### `id: string`

设备唯一标识符（UUID 格式），可用于标识并连接该设备。此值在 App 生命周期中保持不变。

***

### `name: string | null`

设备的名称，可能为 `null`（例如设备未广播名称）。

***

### `isConnected: boolean`

是否已连接到设备：

- `true`: 已连接，可以进行数据交互
- `false`: 未连接或已断开

***

### `canSendWriteWithoutResponse: boolean`

是否允许进行无响应写入：

- `true`: 可发送无响应数据（`writeWithoutResponse`）
- `false`: 需等待写入响应（使用 `write`）

当该值变为 `true` 时会触发 `onReadyToSendWriteWithoutResponse` 事件。

***

### `ancsAuthorized: boolean`

是否已授权使用 Apple Notification Center Service（仅适用于支持 ANCS 的设备）。

***

### `services: BluetoothService[] | null`

已发现的服务列表，如果尚未调用 `discoverServices()`，此值为 `null`。

***

## 事件回调（可选）

### `onConnected: (() => void) | null`

连接成功时触发。

***

### `onDisconnected: ((error: Error | null, isReconnecting: boolean) => void) | null`

断开连接时触发。

- `error`: 若为非主动断开，则包含错误信息；否则为 `null`
- `isReconnecting`: 是否正在尝试重连

***

### `onConnectFailed: ((error: Error) => void) | null`

连接失败时触发。

***

### `onNameChanged: ((name: string | null) => void) | null`

设备名称发生变更时触发。

***

### `onDiscoverServices: ((error: Error | null, services: BluetoothService[] | null) => void) | null`

调用 `discoverServices()` 后，服务发现完成时触发。

***

### `onDiscoverCharacteristics: ((error: Error | null, characteristics: BluetoothCharacteristic[] | null) => void) | null`

调用 `discoverCharacteristics()` 后，特征值发现完成时触发。

***

### `onDiscoverIncludedServices: ((error: Error | null, services: BluetoothService[] | null) => void) | null`

调用 `discoverIncludedServices()` 后，包含服务发现完成时触发。

***

### `onReadyToSendWriteWithoutResponse: (() => void) | null`

设备准备好接收新的无响应写入时触发。

***

## 方法

### `readValue(characteristic: BluetoothCharacteristic): Promise<Data>`

读取指定特征值的内容。

- **参数**：

  - `characteristic`: 要读取的特征值对象
- **返回**：`Promise<Data>`，表示读取到的数据

***

### `maxWriteValueLength(writeType: "withResponse" | "withoutResponse"): number`

获取设备支持的最大写入字节数。

- **参数**：

  - `writeType`: `"withResponse"` 或 `"withoutResponse"`
- **返回**：可写入的最大字节数（`number`）

***

### `writeValue(characteristic, value, writeType): Promise<void>`

向特征值写入数据。

- **参数**：

  - `characteristic`: 要写入的特征值对象
  - `value`: 要写入的 `Data` 数据
  - `writeType`: 写入类型 `"withResponse"` 或 `"withoutResponse"`
- **返回**：`Promise<void>`

***

### `subscribe(characteristic, handler): Promise<void>`

订阅特征值通知或指示。

- **要求**：该特征值必须包含 `"notify"` 或 `"indicate"` 属性
- **参数**：

  - `characteristic`: 要订阅的特征值
  - `handler(error, value)`: 通知触发时回调函数

    - `error`: 出错时为 `Error`，否则为 `null`
    - `value`: 通知传递的 `Data` 数据，可能为 `null`
- **返回**：`Promise<void>`

***

### `unsubscribe(characteristic): Promise<void>`

取消特征值的通知订阅。

- **参数**：

  - `characteristic`: 要取消订阅的特征值
- **返回**：`Promise<void>`

***

### `discoverServices(serviceUUIDs?: string[]): Promise<void>`

发现设备提供的服务。

- **参数**：

  - `serviceUUIDs`: 可选服务 UUID 列表，用于筛选
- **返回**：`Promise<void>`

***

### `discoverIncludedServices(service, includedServiceUUIDs?): Promise<void>`

发现指定服务中嵌套的服务。

- **参数**：

  - `service`: 要发现的服务
  - `includedServiceUUIDs`: 可选的服务 UUID 筛选
- **返回**：`Promise<void>`

***

### `discoverCharacteristics(service, characteristicUUIDs?): Promise<void>`

发现指定服务中的特征值。

- **参数**：

  - `service`: 要发现的服务
  - `characteristicUUIDs`: 可选的特征值 UUID 筛选
- **返回**：`Promise<void>`

***

### `readRSSI(): Promise<number>`

读取当前设备的信号强度（RSSI，单位 dBm）。

- **返回**：`Promise<number>`

***

## 示例

### 连接设备并读取特征值

```ts
await BluetoothCentralManager.connect(peripheral)
await peripheral.discoverServices()

for (const service of peripheral.services ?? []) {
  await peripheral.discoverCharacteristics(service)
  for (const char of service.characteristics ?? []) {
    if (char.properties.includes("read")) {
      const value = await peripheral.readValue(char)
      console.log("读取到值:", value?.toRawString())
    }
  }
}
```

***

### 写入数据并订阅通知

```ts
const data = Data.fromRawString("hello")
await peripheral.writeValue(characteristic, data, "withResponse")

await peripheral.subscribe(characteristic, (error, value) => {
  if (!error && value) {
    console.log("收到通知:", value.toHexString())
  }
})
```

***

## 注意事项

- 所有操作前必须确保设备已连接，并通过 `discoverServices()` 和 `discoverCharacteristics()` 获取服务和特征值。
- 订阅通知后应在合适时机调用 `unsubscribe()` 释放资源。
- `canSendWriteWithoutResponse` 为 `false` 时不应进行无响应写入。



---
url: /v2/zh/guide/Device Capabilities/Bluetooth/BluetoothPeripheralManager.md
---

# 蓝牙外设管理器

`BluetoothPeripheralManager` 提供将设备作为 BLE 外设运行的能力，允许你：

- 广播设备名称与服务 UUID
- 添加并移除服务
- 处理来自中央设备的读写请求
- 发送通知给已订阅的中央设备
- 管理连接参数（如连接延迟）

该 API 适用于构建如自定义传感器设备、蓝牙外设模拟器、控制器等场景。

***

## 基本状态属性

### `isAdvertising: Promise<boolean>`

查询当前是否正在进行广播。

- **类型**：`Promise<boolean>`
- **示例**：

```ts
const advertising = await BluetoothPeripheralManager.isAdvertising
console.log(advertising ? "正在广播" : "已停止广播")
```

***

## 广播控制

### `startAdvertising(advertisementData): Promise<void>`

启动蓝牙广播。

- **参数**：

  - `advertisementData`（对象）：

    - `localName?: string`：设备名称
    - `serviceUUIDs?: string[]`：要广播的服务 UUID

- **示例**：

```ts
await BluetoothPeripheralManager.startAdvertising({
  localName: "MyPeripheral",
  serviceUUIDs: ["1234", "ABCD"]
})
```

***

### `stopAdvertising(): Promise<void>`

停止当前的广播。

```ts
await BluetoothPeripheralManager.stopAdvertising()
```

***

## 服务管理

### `addService(service): Promise<void>`

向外设添加服务及其特征值。

- **参数**：

  - `service` 对象：

    - `uuid`: 服务 UUID
    - `characteristics`: 特征值列表，每项包含：

      - `uuid`
      - `properties`: 如 `"read"`, `"writeWithoutResponse"` 等
      - `permissions`: 如 `"readable"`, `"writeEncryptionRequired"` 等
      - `value?`: 初始值（`Data` 类型）

- **示例**：

```ts
await BluetoothPeripheralManager.addService({
  uuid: "180F",
  characteristics: [
    {
      uuid: "2A19",
      properties: ["read", "notify"],
      permissions: ["readable"],
      value: Data.fromIntArray([85]) // 初始电量 85%
    }
  ]
})
```

***

### `removeService(serviceUUID: string): Promise<void>`

移除指定 UUID 的服务（仅移除由当前脚本添加的实例）。

***

### `removeAllServices(): Promise<void>`

移除所有由脚本添加的服务。

***

## 中央设备交互事件

### `onRestoreState: ((state) => void) | null`

当系统因后台 BLE 任务恢复脚本时调用，用于恢复已添加的服务和广播状态。

#### 类型定义：

```ts
var onRestoreState: ((state: {
  services: BluetoothServiceInfo[]
  advertisementData: BluetoothAdvertisementData
}) => void) | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onRestoreState = (state) => {
  console.log("恢复状态，已注册服务数：", state.services.length)
}
```

***

### `onReadyToUpdateSubscribers: (() => void) | null`

如果调用 `updateValue()` 发送通知时因底层队列已满而失败，系统会在队列恢复后调用此回调，你可在此时重试发送。

#### 类型定义：

```ts
var onReadyToUpdateSubscribers: (() => void) | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onReadyToUpdateSubscribers = () => {
  console.log("队列已空，准备重新发送通知")
}
```

***

### `onReadCharacteristicValue: (characteristicId, offset, central) => Promise<{result, value}>`

当远程中央设备请求读取某个特征值时调用此回调。如果你未实现该回调，则该读取请求将以 `readNotPermitted` 响应失败。

#### 类型定义：

```ts
var onReadCharacteristicValue: (
  characteristicId: string,
  offset: number,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => Promise<{
  result: BluetoothATTResponseCode
  value?: Data | null
}> | null
```

#### 参数说明：

- `characteristicId`：请求读取的特征值 UUID 字符串。
- `offset`：从哪个偏移位置开始读取（通常为 0）。
- `central`：发起请求的中央设备信息：

  - `id`：中央设备的标识符。
  - `maximumUpdateValueLength`：该中央设备可接受的最大数据长度。

#### 返回：

一个 `Promise`，解析为对象：

- `result`：读取结果的响应码（参见 `BluetoothATTResponseCode` 枚举）。
- `value`：如果读取成功，返回一个 `Data` 对象；否则为 `null`。

#### 示例：

```ts
BluetoothPeripheralManager.onReadCharacteristicValue = async (id, offset, central) => {
  if (id === "2A19") {
    const batteryLevel = 85
    return {
      result: BluetoothATTResponseCode.success,
      value: Data.fromIntArray([batteryLevel])
    }
  }
  return { result: BluetoothATTResponseCode.attributeNotFound }
}
```

***

### `onWriteCharacteristicValue: (characteristicId, offset, value, central) => Promise<BluetoothATTResponseCode>`

当远程中央设备请求写入某个特征值时调用此回调。如果你未实现该回调，则写入请求将以 `writeNotPermitted` 响应失败。

#### 类型定义：

```ts
var onWriteCharacteristicValue: (
  characteristicId: string,
  offset: number,
  value: Data,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => Promise<BluetoothATTResponseCode> | null
```

#### 参数说明：

- `characteristicId`：请求写入的特征值 UUID。
- `offset`：写入偏移（一般为 0）。
- `value`：远程写入的数据（`Data` 类型）。
- `central`：发起写入请求的中央设备。

#### 返回：

一个 `Promise`，解析为响应码，表示写入是否成功。

#### 示例：

```ts
BluetoothPeripheralManager.onWriteCharacteristicValue = async (id, offset, value, central) => {
  console.log(`收到写入请求：${id}`, value.toIntArray())
  if (id === "2A19") {
    // 可存储或响应更新
    return BluetoothATTResponseCode.success
  }
  return BluetoothATTResponseCode.attributeNotFound
}
```

***

### `onSubscribe: (characteristicId, central) => void`

当远程中央设备订阅某个支持 notify 或 indicate 的特征值时调用。

#### 类型定义：

```ts
var onSubscribe: (
  characteristicId: string,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => void | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onSubscribe = (id, central) => {
  console.log(`设备 ${central.id} 订阅了 ${id}`)
}
```

***

### `onUnsubscribe: (characteristicId, central) => void`

当远程中央设备取消订阅某个特征值时调用。

#### 类型定义：

```ts
var onUnsubscribe: (
  characteristicId: string,
  central: {
    id: string
    maximumUpdateValueLength: number
  }
) => void | null
```

#### 示例：

```ts
BluetoothPeripheralManager.onUnsubscribe = (id, central) => {
  console.log(`设备 ${central.id} 取消订阅了 ${id}`)
}
```

***

## 通知与订阅管理

### `getSubscribers(characteristicId: string): Promise<Central[]>`

获取当前订阅某个特征值的所有中央设备。

- 返回项结构：

  - `id: string`
  - `maximumUpdateValueLength: number`

***

### `updateValue(characteristicId, value, options?): Promise<boolean>`

更新特征值并向订阅者发送通知或指示。

- `options.centrals`：指定要发送的中央设备 ID（否则广播给所有已订阅设备）

- 返回值：

  - `true`: 发送成功
  - `false`: 传输队列满，需等待 `onReadyToUpdateSubscribers`

***

## 连接参数设置

### `setDesiredConnectionLatency(centralId, latency): Promise<void>`

设置与指定中央设备的期望连接延迟等级：

- `latency` 取值：

  - `"low"`：高频率交互（更快但更耗电）
  - `"medium"`：平衡模式
  - `"high"`：低频率交互（省电）

***

## 响应码枚举：BluetoothATTResponseCode

用于表示对读取/写入操作的响应结果：

| 名称                              | 数值 | 含义           |
| ------------------------------- | -- | ------------ |
| `success`                       | 0  | 操作成功         |
| `invalidHandle`                 | 1  | 无效的句柄        |
| `readNotPermitted`              | 2  | 不允许读取        |
| `writeNotPermitted`             | 3  | 不允许写入        |
| `invalidPdu`                    | 4  | 无效的 PDU      |
| `insufficientAuthentication`    | 5  | 未通过身份验证      |
| `requestNotSupported`           | 6  | 不支持该请求       |
| `invalidOffset`                 | 7  | 偏移量无效        |
| `insufficientAuthorization`     | 8  | 授权不足         |
| `prepareQueueFull`              | 9  | Prepare 队列已满 |
| `attributeNotFound`             | 10 | 未找到指定属性      |
| `attributeNotLong`              | 11 | 属性不支持长读写     |
| `insufficientEncryptionKeySize` | 12 | 加密密钥长度不足     |
| `invalidAttributeValueLength`   | 13 | 属性值长度无效      |
| `unlikelyError`                 | 14 | 发生了不太可能的错误   |
| `insufficientEncryption`        | 15 | 未加密或加密级别不足   |
| `unsupportedGroupType`          | 16 | 不支持的组类型      |
| `insufficientResources`         | 17 | 系统资源不足       |

***

## 示例：构建一个广播电量的外围设备

```ts
await BluetoothPeripheralManager.addService({
  uuid: "180F",
  characteristics: [
    {
      uuid: "2A19",
      properties: ["read", "notify"],
      permissions: ["readable"],
      value: Data.fromIntArray([100]) // 电量 100%
    }
  ]
})

await BluetoothPeripheralManager.startAdvertising({
  localName: "BatteryPeripheral",
  serviceUUIDs: ["180F"]
})

BluetoothPeripheralManager.onReadCharacteristicValue = async (id, offset, central) => {
  return { result: BluetoothATTResponseCode.success, value: Data.fromIntArray([90]) }
}
```



---
url: /v2/zh/guide/Device Capabilities/Bluetooth/BluetoothService.md
---

# 蓝牙服务

`BluetoothService` 表示一个 BLE（低功耗蓝牙）服务。服务是外围设备中功能的逻辑分组，包含一个或多个特征值（`Characteristic`），也可以包含对其他服务的引用（包含服务）。

***

## 概述

每个服务都由一个唯一的 UUID 标识，用于描述设备提供的某项功能，例如：

- 标准服务，如 `"180F"` 表示电池服务
- 自定义服务，通常为厂商自定义的 UUID

服务的主要用途是组织设备提供的数据和操作。

***

## 属性说明

### `uuid: string`

服务的 UUID。

- 用于唯一标识服务类型
- 可通过此字段识别标准服务或自定义服务

***

### `peripheralId: string | null`

所属外围设备的标识符（UUID 字符串）。

- 如果上下文丢失或设备未记录，则可能为 `null`

***

### `isPrimary: boolean`

是否为主服务。

- `true`: 主服务，表示设备核心功能
- `false`: 次服务，通常被其他服务引用（嵌套）

***

### `includedServices: BluetoothService[] | null`

包含服务（referenced services）的数组。

- 这些服务可能是主服务或次服务
- 若尚未调用 `discoverIncludedServices()`，此值为 `null`
- 可通过 `BluetoothPeripheral.discoverIncludedServices(service)` 方法获取

***

### `characteristics: BluetoothCharacteristic[] | null`

当前服务下包含的特征值数组。

- 特征值用于实际的数据交互（读、写、通知等）
- 若尚未调用 `discoverCharacteristics()`，此值为 `null`
- 可通过 `BluetoothPeripheral.discoverCharacteristics(service)` 方法获取

***

## 使用示例

### 发现服务并列出特征值

```ts
await peripheral.discoverServices()
for (const service of peripheral.services ?? []) {
  console.log("服务 UUID:", service.uuid)

  await peripheral.discoverCharacteristics(service)
  for (const char of service.characteristics ?? []) {
    console.log("特征值 UUID:", char.uuid)
  }
}
```

***

### 发现包含服务（嵌套服务）

```ts
await peripheral.discoverServices()
for (const service of peripheral.services ?? []) {
  await peripheral.discoverIncludedServices(service)
  for (const included of service.includedServices ?? []) {
    console.log("包含服务 UUID:", included.uuid)
  }
}
```

***

## 注意事项

- 所有属性均为只读。
- 必须先调用 `discoverServices()` 才能访问 `characteristics` 和 `includedServices`。
- 包含服务可能嵌套更深层级，若需深入访问需递归调用发现方法。



---
url: /v2/zh/guide/Device Capabilities/Calendar.md
---

# 日历

Scripting 应用中的 `Calendar` API 提供了与 iOS 日历账户、日历对象、事件和提醒事项交互的能力。\
开发者可以通过此 API 获取默认日历、创建新的日历、列出支持特定实体类型（日程、提醒）的日历，以及管理日历属性。

***

## 类型定义

### CalendarType

定义日历的种类：

| 值                | 描述            |
| :--------------- | :------------ |
| `"birthday"`     | 生日日历          |
| `"calDAV"`       | CalDAV 协议日历   |
| `"exchange"`     | Exchange 账户日历 |
| `"local"`        | 本地日历          |
| `"subscription"` | 订阅日历          |

### CalendarSourceType

定义日历账户源的种类：

| 值              | 描述          |
| :------------- | :---------- |
| `"birthdays"`  | 生日账户        |
| `"calDAV"`     | CalDAV 协议账户 |
| `"exchange"`   | Exchange 账户 |
| `"local"`      | 本地账户        |
| `"mobileMe"`   | MobileMe 账户 |
| `"subscribed"` | 订阅账户        |

### CalendarEventAvailability

定义事件的可用性状态：

| 值               | 描述  |
| :-------------- | :-- |
| `"busy"`        | 忙碌  |
| `"free"`        | 空闲  |
| `"tentative"`   | 暂定  |
| `"unavailable"` | 不可用 |

### CalendarEntityType

定义日历中可管理的实体类型：

| 值            | 描述   |
| :----------- | :--- |
| `"event"`    | 日程事件 |
| `"reminder"` | 提醒事项 |

***

## 类：CalendarSource

代表一个日历账户源，例如本地账户、Exchange账户等。

### 属性

| 属性名          | 类型                   | 描述        |
| :----------- | :------------------- | :-------- |
| `type`       | `CalendarSourceType` | 账户源的类型    |
| `title`      | `string`             | 账户源的标题    |
| `identifier` | `string`             | 账户源的唯一标识符 |

### 方法

#### `getCalendars(entityType: CalendarEntityType): Promise<Calendar[]>`

获取该账户下指定实体类型（事件或提醒事项）支持的所有日历。

- **参数**
  - `entityType: CalendarEntityType` — 需要获取的日历实体类型。
- **返回**
  - `Promise<Calendar[]>` — 日历对象数组。

***

## 类：Calendar

代表一个具体的日历对象，可用于管理日程、提醒事项等。

### 属性

| 属性名                            | 类型                          | 描述                 |
| :----------------------------- | :-------------------------- | :----------------- |
| `identifier`                   | `string`                    | 日历的唯一标识符           |
| `title`                        | `string`                    | 日历标题               |
| `color`                        | `Color`                     | 日历颜色               |
| `type`                         | `CalendarType`              | 日历种类               |
| `source`                       | `CalendarSource`            | 日历帐户源              |
| `allowedEntityTypes`           | `CalendarEntityType`        | 日历允许包含的实体类型（事件或提醒） |
| `isForEvents`                  | `boolean`                   | 是否用于存储事件           |
| `isForReminders`               | `boolean`                   | 是否用于存储提醒事项         |
| `allowsContentModifications`   | `boolean`                   | 是否允许修改日历内容         |
| `isSubscribed`                 | `boolean`                   | 是否为订阅日历            |
| `supportedEventAvailabilities` | `CalendarEventAvailability` | 日历支持的事件可用性类型       |

### 方法

#### `remove(): Promise<void>`

删除该日历。

#### `save(): Promise<void>`

保存对该日历的更改。

#### `static defaultForEvents(): Promise<Calendar | null>`

获取当前系统设置的默认事件日历。

#### `static defaultForReminders(): Promise<Calendar | null>`

获取当前系统设置的默认提醒事项日历。

#### `static forEvents(): Promise<Calendar[]>`

列出所有支持事件的日历。

#### `static forReminders(): Promise<Calendar[]>`

列出所有支持提醒事项的日历。

#### `static create(options: { title: string, entityType: CalendarEntityType, sourceType: CalendarSourceType, color?: Color }): Promise<Calendar>`

创建一个新的日历。

- **参数**
  - `title: string` — 新日历的标题
  - `entityType: CalendarEntityType` — 支持的实体类型
  - `sourceType: CalendarSourceType` — 日历账户源类型
  - `color?: Color` — （可选）日历颜色
- **返回**
  - `Promise<Calendar>` — 新创建的日历对象。

#### `static presentChooser(allowMultipleSelection?: boolean): Promise<Calendar[]>`

展示一个日历选择器界面，供用户选择一个或多个日历。

- **参数**
  - `allowMultipleSelection?: boolean` — 是否允许多选，默认 `false`。
- **返回**
  - `Promise<Calendar[]>` — 用户选择的日历列表。

#### `static getSources(): CalendarSource[]`

获取当前设备上所有的日历账户源。

***

## 示例代码

### 获取默认事件日历

```tsx
const defaultEventCalendar = await Calendar.defaultForEvents()
if (defaultEventCalendar) {
  console.log(`默认事件日历: ${defaultEventCalendar.title}`)
} else {
  console.log('未找到默认事件日历')
}
```

### 创建新的本地事件日历

```tsx
const newCalendar = await Calendar.create({
  title: '锻炼计划',
  entityType: 'event',
  sourceType: 'local',
  color: '#FF5733'
})

await newCalendar.save()
console.log(`创建了新的日历: ${newCalendar.title}`)
```

### 列出所有支持事件的日历

```tsx
const eventCalendars = await Calendar.forEvents()
for (const calendar of eventCalendars) {
  console.log(`日历: ${calendar.title}`)
}
```

### 删除第一个事件日历

```tsx
const eventCalendars = await Calendar.forEvents()
if (eventCalendars.length > 0) {
  const calendarToRemove = eventCalendars[0]
  await calendarToRemove.remove()
  console.log(`已删除日历: ${calendarToRemove.title}`)
}
```

### 展示日历选择器并处理用户选择

```tsx
const selectedCalendars = await Calendar.presentChooser(true)
for (const calendar of selectedCalendars) {
  console.log(`选择了日历: ${calendar.title}`)
}
```



---
url: /v2/zh/guide/Device Capabilities/CalendarEvent.md
---

`CalendarEvent` API 用于在 iOS 日历中创建、读取、编辑与管理事件。
开发者可以操作事件的标题、时间、地点、参与者、重复规则、提醒（EventAlarm）、事件可用性以及地理位置信息，并且可以使用系统提供的创建/编辑界面。

***

# 一、类型说明

## EventParticipant

表示事件的参与者：

- `isCurrentUser: boolean`：是否为当前用户
- `name?: string`：姓名
- `role: ParticipantRole`：角色
- `type: ParticipantType`：类型
- `status: ParticipantStatus`：出席状态

### ParticipantRole

- `chair`（主持人）
- `nonParticipant`（非参与者）
- `optional`（可选）
- `required`（必需）
- `unknown`（未知）

### ParticipantType

- `group`（群组）
- `person`（个人）
- `resource`（资源）
- `room`（房间）
- `unknown`（未知）

### ParticipantStatus

- `unknown`（未知）
- `pending`（待定）
- `accepted`（接受）
- `declined`（拒绝）
- `tentative`（暂定）
- `delegated`（已委托）
- `completed`（已完成）
- `inProcess`（处理中）

***

## EventAvailability

用于表明事件在日程中的可用性状态：

- `notSupported`：日历不支持可用性设置
- `busy`：忙碌
- `free`：空闲
- `tentative`：暂定
- `unavailable`：不可用

***

## EventStructuredLocation

用于地理位置提醒的结构化位置：

- `title: string | null`：名称
- `geoLocation: LocationInfo | null`：地理位置（经纬度）
- `radius: number`：触发半径（米）

此结构与 `EventAlarm.structuredLocation` 配合使用。

***

## AlarmProximity

位置提醒的触发方式：

- `none`：不使用位置触发
- `enter`：进入区域时触发
- `leave`：离开区域时触发

***

# 二、EventAlarm（事件提醒）

CalendarEvent 支持添加多个 `EventAlarm`，包括：

- **绝对时间提醒**
- **相对事件开始时间提醒**
- **位置提醒（geofence）**

详细说明请参考独立的 EventAlarm 文档。

***

# 三、CalendarEvent 类

## 构造函数

```ts
new(): CalendarEvent
```

创建一个新的事件实例（尚未保存到日历）。

***

# 四、属性说明

## 基本信息

### identifier: string

事件的唯一标识符。

### title: string

事件标题。

### notes: string | null

事件备注。

### url: string | null

关联 URL。

### calendar: Calendar | null

事件所属的日历。
不可设为 `null`。
如果需要删除事件，请使用 `remove()`。

***

## 时间与地点

### isAllDay: boolean

是否为全天事件。

### startDate: Date

开始时间。

### endDate: Date

结束时间。

### timeZone: string | null

事件使用的时区。

### location: string | null

纯文本地点信息。

### structuredLocation: EventStructuredLocation | null

结构化位置（支持 geofence 提醒）。

***

## 事件状态与生成信息（新增）

### creationDate: Date | null

事件创建日期（只读）。

### lastModifiedDate: Date | null

事件最后修改时间（只读）。

### occurrenceDate: Date

对于重复事件中的“单个实例”，此属性表示该实例原始发生日期。

### isDetached: boolean

是否为重复事件的“脱离实例”。
例如用户单独修改某一发生日期的事件时，该实例会成为 detached instance。

***

## 参与者与可用性（新增相关属性）

### attendees: EventParticipant\[] | null

参与者数组（只读）。

### organizer: EventParticipant | null

事件组织者（只读）。

### hasAttendees: boolean

是否包含参与者。

### availability: EventAvailability

事件在日程中的可用性状态。

***

## 提醒（Alarm）相关

### alarms: EventAlarm\[] | null

事件绑定的提醒列表。

### hasAlarm: boolean

事件是否包含提醒。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

事件的重复规则数组。

### hasRecurrenceRules: boolean

是否包含重复规则。

***

## 其他状态属性（新增）

### hasNotes: boolean

是否包含备注。

### hasChanges: boolean

事件或其内部对象是否有未保存的更改。

***

# 五、实例方法

## 1. 提醒管理

### addAlarm(alarm: EventAlarm): void

为事件添加一个提醒。

### removAlarm(alarm: EventAlarm): void

从事件移除一个提醒。
（注意拼写：API 为 `removAlarm`）

***

## 2. 重复规则

### addRecurrenceRule(rule: RecurrenceRule): void

添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除一条重复规则。

***

## 3. 事件保存与删除

### `save(): Promise<void>`

保存事件（或重复事件的变化）。

### `remove(): Promise<void>`

从日历中移除事件。

***

## 4. 显示编辑界面

### `presentEditView(): Promise<EventEditViewAction>`

显示系统提供的事件编辑界面，并返回用户执行的操作：

- `"saved"`
- `"deleted"`
- `"canceled"`

***

# 六、静态方法

## `getAll(startDate: Date, endDate: Date, calendars?: Calendar[]): Promise<CalendarEvent[]>`

获取指定日期范围内的事件。

- 可传入 `calendars` 数组过滤事件
- 若不传或传 `null`，则搜索所有可访问的日历

***

## `presentCreateView(): Promise<CalendarEvent | null>`

显示事件创建界面。

- 用户点击保存时返回创建的事件
- 用户取消时返回 `null`

***

# 七、使用示例

## 1. 创建并保存事件

```ts
const defaultCalendar = await Calendar.defaultForEvents()
const event = new CalendarEvent()
event.title = "团队会议"
event.calendar = defaultCalendar!
event.startDate = new Date("2024-01-15T09:00:00")
event.endDate = new Date("2024-01-15T10:00:00")
event.location = "会议室"

await event.save()
```

***

## 2. 添加重复规则

```ts
const rule = RecurrenceRule.create({
  frequency: "weekly",
  interval: 1,
  daysOfTheWeek: ["monday", "wednesday", "friday"],
  end: RecurrenceEnd.fromDate(new Date("2024-12-31")),
})

event.addRecurrenceRule(rule)
await event.save()
```

***

## 3. 添加提醒（Alarm）

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
event.addAlarm(alarm)
await event.save()
```

***

## 4. 获取日期范围内的事件

```ts
const events = await CalendarEvent.getAll(
  new Date("2024-01-01"),
  new Date("2024-01-31")
 )

for (const e of events) {
  console.log(`事件: ${e.title} 开始时间: ${e.startDate}`)
}
```

***

## 5. 使用事件创建界面

```ts
const created = await CalendarEvent.presentCreateView()
if (created) {
  console.log("新事件已创建:", created.title)
}
```

***

## 6. 编辑事件

```ts
const result = await event.presentEditView()
console.log("编辑操作:", result)
```

***

## 7. 删除事件

```ts
await event.remove()
console.log("事件已移除")
```

***

# 八、补充说明

### 时区处理

当处理跨时区事件时，请务必设置 `timeZone`，否则可能出现偏移时间或显示错误。

### 重复事件编辑

- 修改单个重复事件实例会创建一个 detached instance
- `occurrenceDate` 可用于识别该实例对应的原始日期

### 参与者

参与者信息由系统从日历源（如 iCloud、Exchange）读取。
部分字段可能因日历源不同而缺失。

### structuredLocation 与 geofence

若使用位置提醒，请确保用户授权位置权限。



---
url: /v2/zh/guide/Device Capabilities/Contact/index.md
---

# 通讯录

Scripting 提供 `Contact` 模块，允许在脚本中访问和管理设备上的联系人数据，包括创建、查询、更新、删除联系人，以及操作联系人组和容器。

## 基本概念

| 类型                               | 描述                                |
| -------------------------------- | --------------------------------- |
| **ContactInfo**                  | 表示单个联系人的完整信息。                     |
| **ContactContainer**             | 联系人存储容器，来源如本地、Exchange、CardDAV 等。 |
| **ContactGroup**                 | 联系人组，用于将联系人分类管理。                  |
| **ContactLabeledValue**          | 带标签的值，如电话、邮箱。                     |
| **ContactPostalAddress**         | 邮寄地址信息。                           |
| **ContactSocialProfile**         | 社交账号信息。                           |
| **ContactInstantMessageAddress** | 即时通讯信息。                           |

***

## 创建联系人

```ts
try {
  const contact = await Contact.createContact({
    givenName: 'John',
    familyName: 'Doe',
    phoneNumbers: [{ label: 'mobile', value: '+1234567890' }],
    emailAddresses: [{ label: 'work', value: 'john.doe@example.com' }]
  })
  console.log('联系人创建成功:', contact)
} catch (error) {
  console.error('创建联系人失败:', error)
}
```

说明：

- `givenName` 或 `familyName` 至少填写一项
- 可指定 `containerIdentifier`，否则加入默认容器
- 建议捕获异常，避免因权限或参数问题导致脚本崩溃

***

## 更新联系人

```ts
try {
  const updated = await Contact.updateContact({
    identifier: contact.identifier,
    phoneNumbers: [{ label: 'home', value: '+9876543210' }]
  })
  console.log('联系人更新成功:', updated)
} catch (error) {
  console.error('更新联系人失败:', error)
}
```

更新说明：

- 必须传入 `identifier`
- 仅修改提供的字段，其他信息不变

***

## 查询联系人

### 通过唯一标识符查询

```ts
try {
  const contact = await Contact.fetchContact(contactId, { fetchImageData: true })
  console.log('联系人信息:', contact)
} catch (error) {
  console.error('查询联系人失败:', error)
}
```

### 查询所有联系人

```ts
try {
  const contacts = await Contact.fetchAllContacts({ fetchImageData: false })
  console.log('联系人列表:', contacts)
} catch (error) {
  console.error('获取联系人列表失败:', error)
}
```

### 查询指定容器或组内的联系人

```ts
try {
  const contacts = await Contact.fetchContactsInContainer(containerId)
  console.log('容器内联系人:', contacts)
} catch (error) {
  console.error('查询容器内联系人失败:', error)
}

try {
  const groupContacts = await Contact.fetchContactsInGroup(groupId)
  console.log('组内联系人:', groupContacts)
} catch (error) {
  console.error('查询组内联系人失败:', error)
}
```

***

## 删除联系人

```ts
try {
  await Contact.deleteContact(contactId)
  console.log('联系人已删除')
} catch (error) {
  console.error('删除联系人失败:', error)
}
```

***

## 容器管理

### 获取所有容器

```ts
try {
  const containers = await Contact.fetchContainers()
  console.log('联系人容器:', containers)
} catch (error) {
  console.error('获取容器失败:', error)
}
```

### 获取默认容器

```ts
try {
  const defaultContainerId = await Contact.defaultContainerIdentifier
  console.log('默认容器ID:', defaultContainerId)
} catch (error) {
  console.error('获取默认容器失败:', error)
}
```

***

## 联系人组管理

### 创建联系人组

```ts
try {
  const group = await Contact.createGroup('Friends', defaultContainerId)
  console.log('联系人组创建成功:', group)
} catch (error) {
  console.error('创建联系人组失败:', error)
}
```

### 获取联系人组

```ts
try {
  const groups = await Contact.fetchGroups()
  console.log('联系人组列表:', groups)
} catch (error) {
  console.error('获取联系人组失败:', error)
}
```

### 删除联系人组

```ts
try {
  await Contact.deleteGroup(groupId)
  console.log('联系人组已删除')
} catch (error) {
  console.error('删除联系人组失败:', error)
}
```

***

## 联系人与组的关系管理

### 添加联系人到指定组

```ts
try {
  await Contact.addContactToGroup(contactId, groupId)
  console.log('联系人已添加到组')
} catch (error) {
  console.error('添加联系人到组失败:', error)
}
```

### 从组中移除联系人

```ts
try {
  await Contact.removeContactFromGroup(contactId, groupId)
  console.log('联系人已从组中移除')
} catch (error) {
  console.error('从组中移除联系人失败:', error)
}
```

***

## ContactInfo 数据结构示例

```json
{
  "identifier": "XXXX-XXXX",
  "givenName": "John",
  "familyName": "Doe",
  "phoneNumbers": [{ "label": "mobile", "value": "+1234567890" }],
  "emailAddresses": [{ "label": "work", "value": "john@example.com" }],
  "postalAddresses": [{
    "label": "home",
    "street": "123 Apple St.",
    "city": "Cupertino",
    "state": "CA",
    "postalCode": "95014",
    "country": "USA",
    "isoCountryCode": "US"
  }]
}
```

***

## 注意事项

- 所有 API 操作都可能因权限、数据错误等原因失败，建议统一加上 `try-catch`
- 访问联系人前，请确保获取用户授权
- `imageData` 建议按需加载，避免性能问题
- 更新和删除操作必须确保 `identifier` 正确有效

***

## 完整示例：创建并查询联系人

```ts
try {
  const contact = await Contact.createContact({
    givenName: 'Alice',
    familyName: 'Smith',
    phoneNumbers: [{ label: 'mobile', value: '+19876543210' }]
  })
  console.log('联系人创建成功:', contact)

  const fetched = await Contact.fetchContact(contact.identifier)
  console.log('查询到联系人:', fetched.givenName)
} catch (error) {
  console.error('操作失败:', error)
}
```



---
url: /v2/zh/guide/Device Capabilities/Contact/index_example.md
---

# 示例

```tsx
import { Script } from "scripting"

async function run() {
  console.present().then(() => {
    Script.exit()
  })

  console.log("Start to fetch contacts")
  try {
    const contacts = await Contact.fetchAllContacts()

    const first = contacts.at(0)

    if (!first) {
      console.log("No contacts found")
    } else {
      console.log("There are " + contacts.length + " contacts")

      const name = [
        first.givenName,
        first.familyName
      ].join(" ")
      
      console.log("First contact name: " + name)
    }
  } catch (e) {
    console.error(e)
  }
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/Device/index.md
---

# 设备

`Device` 命名空间提供当前运行设备的基础信息、系统环境、屏幕与电池状态、语言与地区设置，以及部分与设备能力相关的方法（如唤醒锁、网络接口信息）。

该 API 常用于：

- 设备差异化逻辑（iPhone / iPad / Mac）
- UI 布局与适配
- 多语言与本地化判断
- 网络调试与诊断
- 防止脚本执行期间设备休眠

***

## 设备与系统信息

### `Device.model: string`

设备型号名称，例如 `"iPhone"`、`"iPad"`。

***

### `Device.systemName: string`

当前操作系统名称，例如 `"iOS"`、`"iPadOS"`、`"macOS"`。

***

### `Device.systemVersion: string`

当前操作系统版本号，例如 `"17.2"`。

***

### `Device.isiPhone: boolean`

当前设备是否为 iPhone。

***

### `Device.isiPad: boolean`

当前设备是否为 iPad。

***

### `Device.isiOSAppOnMac: boolean`

当前进程是否为 **iPhone / iPad App 运行在 Mac 上**（Mac Catalyst / Apple Silicon Mac）。

***

## 屏幕信息

### `Device.screen`

当前主屏幕的信息。

```ts
{
  width: number
  height: number
  scale: number
}
```

字段说明：

- `width`：屏幕逻辑宽度（pt）
- `height`：屏幕逻辑高度（pt）
- `scale`：屏幕缩放因子（如 2 / 3）

常用于布局计算、画布尺寸、截图或渲染比例控制。

***

## 方向与姿态

### `Device.isPortrait: boolean`

当前设备是否处于竖屏方向。

***

### `Device.isLandscape: boolean`

当前设备是否处于横屏方向。

***

### `Device.isFlat: boolean`

设备是否平放（例如放在桌面上）。

该值通常基于设备姿态传感器，用于高级交互或方向判断。

***

## 外观与主题

### `Device.colorScheme: ColorScheme`

当前系统外观模式。

可能的值通常包括：

- `light`
- `dark`

可用于根据系统外观自动调整 UI 主题或样式。

***

## 电池信息

### `Device.batteryState`

当前电池状态：

```ts
"full" | "charging" | "unplugged" | "unknown"
```

说明：

- `full`：电池已充满
- `charging`：正在充电
- `unplugged`：未连接电源
- `unknown`：状态不可用

***

### `Device.batteryLevel: number`

当前电量百分比，取值范围：

- `0.0` \~ `1.0`
- 当电量不可用时，可能返回 `-1`

***

## 语言与地区设置

### `Device.systemLocale: string`

系统当前使用的 Locale，例如：

```text
"en_US"
```

***

### `Device.preferredLanguages: string[]`

用户偏好的语言列表（按优先级排序），例如：

```ts
["en-US", "zh-Hans-CN"]
```

推荐用于多语言内容选择。

***

### `Device.systemLocales: string[]` （已废弃）

用户偏好的 Locale 列表。

> 已废弃，请使用 `Device.preferredLanguages`。

***

### `Device.systemLanguageTag: string`

当前语言的 BCP-47 语言标签，例如：

```text
"en-US"
```

***

### `Device.systemLanguageCode: string`

当前语言代码，例如：

```text
"en"
```

***

### `Device.systemCountryCode: string | undefined`

当前国家 / 地区代码，例如：

```text
"US"
```

如果系统未设置国家信息，可能为 `undefined`。

***

### `Device.systemScriptCode: string | undefined`

当前语言的书写系统代码，例如：

```text
"Hans"   // zh_CN_Hans
```

常用于区分简体 / 繁体等书写系统。

***

## 唤醒锁（Wake Lock）

唤醒锁用于防止设备在脚本运行期间自动休眠。

### `Device.isWakeLockEnabled: Promise<boolean>`

获取当前是否启用了唤醒锁。

```ts
const enabled = await Device.isWakeLockEnabled
```

***

### `Device.setWakeLockEnabled(enabled: boolean): void`

启用或关闭唤醒锁。

```ts
Device.setWakeLockEnabled(true)
```

说明：

- 仅在 **Scripting App** 中可用
- 启用后可防止屏幕自动熄灭或设备进入休眠
- 建议在不需要时及时关闭，以节省电量

***

## 网络接口信息

### `Device.NetworkInterface`

网络接口对象结构：

```ts
type NetworkInterface = {
  address: string
  netmask: string | null
  family: 'IPv4' | 'IPv6'
  mac: string | null
  isInternal: boolean
  cidr: string | null
}
```

字段说明：

- `address`：IP 地址
- `netmask`：子网掩码
- `family`：地址类型（IPv4 / IPv6）
- `mac`：MAC 地址（部分系统可能为 null）
- `isInternal`：是否为内部接口（如回环接口）
- `cidr`：CIDR 表示法（如 `192.168.1.10/24`）

***

### `Device.networkInterfaces(): Record<string, NetworkInterface[]>`

获取设备当前的网络接口信息。

返回值结构：

```ts
{
  [interfaceName: string]: NetworkInterface[]
}
```

示例：

```ts
const interfaces = Device.networkInterfaces()

for (const name in interfaces) {
  for (const info of interfaces[name]) {
    console.log(name, info.address, info.family)
  }
}
```

常见用途：

- 获取本地 IP 地址
- 区分 Wi-Fi / 蜂窝网络 / 回环接口
- 网络调试与诊断
- 模拟 Node.js `os.networkInterfaces()` 行为

***

## 使用建议

- 语言与地区相关逻辑优先使用 `preferredLanguages`
- 唤醒锁应在任务完成后及时关闭
- 网络接口信息可能因系统权限或网络状态变化而不同
- 不要假设某个接口名称一定存在（如 `en0`）



---
url: /v2/zh/guide/Device Capabilities/Device/index_example.md
---

# 示例

```tsx
import { Button, Device, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

 function Example() {
  const dismiss = Navigation.useDismiss()

  const details: {
    name: string
    value: string | boolean | number
  }[] = [
      {
        name: "Device.isiPhone",
        value: Device.isiPhone
      },
      {
        name: "Device.isiPad",
        value: Device.isiPad,
      },
      {
        name: "Device.systemVersion",
        value: Device.systemVersion,
      },
      {
        name: "Device.systemName",
        value: Device.systemName,
      },
      {
        name: "Device.isPortrait",
        value: Device.isPortrait,
      },
      {
        name: "Device.isLandscape",
        value: Device.isLandscape,
      },
      {
        name: "Device.isFlat",
        value: Device.isFlat,
      },
      {
        name: "Device.batteryLevel",
        value: Device.batteryLevel,
      },
      {
        name: "Device.batteryState",
        value: Device.batteryState,
      }
    ]

  return <NavigationStack>
    <List
      navigationTitle={"Device"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      {details.map(item =>
        <VStack
          badge={item.value.toString()}
          alignment={"leading"}
        >
          <Text font={"headline"}>{item.name}</Text>
          <Text font={"caption"}>{typeof item.value}</Text>
        </VStack>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/DocumentPicker.md
---

# 文档选择器

`DocumentPicker` 类为 iOS 的文档选择器提供接口，允许用户在 Files App 中选择文件或目录，或者将文件导出到 Files App。这对于需要访问用户文件、共享内容或将资源有序保存在指定目录中的脚本非常有用。

***

## 类型定义

### `PickFilesOption`

用于配置 `pickFiles` 文件选择功能的选项。

- **`initialDirectory`** (可选)
  - **类型**: `string`
  - **描述**: 指定文档选择器初次显示的目录。

- **`types`** (可选)
  - **类型**: `string[]`
  - **描述**: 要在文档选择器中显示的统一类型标识符（UTI）数组。更多信息可参考 [Uniform Type Identifiers](https://developer.apple.com/documentation/uniformtypeidentifiers/uttype-swift.struct)。

- **`shouldShowFileExtensions`** (可选)
  - **类型**: `boolean`
  - **描述**: 是否显示文件扩展名。默认为 `true`。

- **`allowsMultipleSelection`** (可选)
  - **类型**: `boolean`
  - **描述**: 是否允许选择多个文件。默认为 `false`。

***

### `ExportFilesOptions`

用于通过 `exportFiles` 导出文件的选项。

- **`initialDirectory`** (可选)
  - **类型**: `string`
  - **描述**: 指定文档选择器初次显示的目录。

- **`files`**
  - **类型**: `Array<{ data: Data; name: string }>`
  - **描述**: 要导出的文件数组。数组中的每个文件对象必须包含：
    - **`data`**: 文件的 `Data` 数据对象。
    - **`name`**: 文件名。

***

## 类方法

### `DocumentPicker.pickFiles(options?: PickFilesOption): Promise<string[]>`

允许用户从 Files App 中选择文件。

#### 参数

- **`options`** (可选): `PickFilesOption`
  - 用于文件选择的配置选项。

#### 返回值

- 一个 Promise，当用户完成选择后，返回文件路径数组（`string[]`）。

#### 示例

```typescript
async function run() {
  const imageFilePath = await DocumentPicker.pickFiles()
  if (imageFilePath != null) {
    // 处理用户选择的文件路径
  }
}
run()
```

***

### `DocumentPicker.pickDirectory(initialDirectory?: string): Promise<string | null>`

允许用户从 Files App 中选择一个目录。

#### 参数

- **`initialDirectory`** (可选): `string`
  - 文档选择器初次显示的目录。

#### 返回值

- 一个 Promise，解析后返回用户所选目录的路径（`string`），如果用户取消选择，则返回 `null`。

#### 示例

```typescript
const selectedDirectory = await DocumentPicker.pickDirectory()
if (selectedDirectory == null) {
  // 用户取消了选择
}
```

***

### `DocumentPicker.exportFiles(options: ExportFilesOptions): Promise<string[]>`

将文件导出到 Files App。

#### 参数

- **`options`**: `ExportFilesOptions`
  - 用于配置文件导出的选项，包括文件数据和文件名。

#### 返回值

- 一个 Promise，解析后返回导出的文件路径数组（`string[]`）。

#### 示例

```typescript
async function run() {
  const textContent = "Hello Scripting!"
  const result = await DocumentPicker.exportFiles({
    files: [
      {
        data: Data.fromString(textContent)!,
        name: 'greeting.txt',
      }
    ]
  });

  if (result.length > 0) {
    console.log('导出的文件: ', result)
  }
}
run()
```

***

### `DocumentPicker.stopAcessingSecurityScopedResources(): void`

放弃对安全范围资源（Security-Scoped Resources）的访问，例如通过文档选择器访问到的文件或目录。当不再需要访问这些资源时，请调用此方法以确保您的应用能够高效地管理资源。

```typescript
DocumentPicker.stopAcessingSecurityScopedResources()
```



---
url: /v2/zh/guide/Device Capabilities/EventAlarm.md
---

# 事件闹钟

`EventAlarm` 用于为 **日历事件（CalendarEvent）** 和 **提醒事项（Reminder）** 设置提醒规则。
通过该类，开发者可以创建：

- 基于绝对时间触发的提醒
- 基于事件开始时间的相对提醒
- 基于地理围栏（Geofence）触发的提醒

此类为 Scripting Calendar/Reminder API 的基础能力，用于构建灵活的提醒行为。

***

## 一、创建 Alarm

### 1. `EventAlarm.fromAbsoluteDate(date: Date): EventAlarm`

创建一个基于绝对时间触发的提醒。

- 不依赖事件的开始时间
- 在系统时间到达指定时刻时触发

示例：

```ts
const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-01-01T09:00:00"))
```

***

### 2. `EventAlarm.fromRelativeOffset(offset: DurationInSeconds): EventAlarm`

创建一个以「事件开始时间」为基准的提醒。

`offset`（秒）含义如下：

- 负数：事件开始前触发
- 正数：事件开始后触发

示例（事件开始前 10 分钟提醒）：

```ts
const alarm = EventAlarm.fromRelativeOffset(-600)
```

***

## 二、属性说明

### 1. `absoluteDate: Date | null`

提醒的绝对触发时间。

行为规则：

- 如果为相对提醒设置 `absoluteDate`，提醒会自动转换为绝对提醒，同时 `relativeOffset` 会被清除。
- 如果为 `null`，表示提醒可能为相对提醒或位置提醒。

***

### 2. `relativeOffset: number`

事件开始时间的偏移量（秒）。

行为规则：

- 若为绝对提醒设置该属性，则提醒会转换为相对提醒，且 `absoluteDate` 会被置空。
- 相对提醒永远以 CalendarEvent 或 Reminder 的开始时间为基准。

示例：

```ts
alarm.relativeOffset = -300  // 提前 5 分钟触发
```

***

### 3. `structuredLocation: EventStructuredLocation | null`

位置提醒的触发地点。

`EventStructuredLocation` 包含：

- `title: string | null`：地点名称
- `geoLocation: LocationInfo | null`：经纬度位置
- `radius: number`：地理围栏触发半径（米）

示例：

```ts
alarm.structuredLocation = {
  title: "公司",
  geoLocation: { latitude: 37.332, longitude: -122.030 },
  radius: 100
}
```

***

### 4. `proximity: AlarmProximity`

位置提醒的触发方式。

支持的值：

| 值       | 含义         |
| ------- | ---------- |
| `none`  | 默认，不使用位置触发 |
| `enter` | 进入该地点范围时触发 |
| `leave` | 离开该地点范围时触发 |

示例：

```ts
alarm.proximity = AlarmProximity.enter
```

***

## 三、EventAlarm 在不同 API 中的使用方式

### 1. 在 CalendarEvent 中使用

```ts
const event = new CalendarEvent()
event.title = "会议"
event.startDate = ...
event.endDate = ...

const alarm = EventAlarm.fromRelativeOffset(-900)
event.addAlarm(alarm)

await event.save()
```

***

### 2. 在 Reminder 中使用

`Reminder` 与 `CalendarEvent` 均支持添加 `EventAlarm`：

```ts
const reminder = new Reminder()
reminder.title = "交电费"

const alarm = EventAlarm.fromAbsoluteDate(new Date("2025-02-01T10:00:00"))
reminder.addAlarm(alarm)

await reminder.save()
```

位置提醒同样适用于 `Reminder`。

***

## 四、使用建议

1. **绝对提醒适合作为固定时间提醒**
   如生日、账单日等。

2. **相对提醒适用于基于事件开始时间的通知**
   如会议开始前十分钟提醒。

3. **地理围栏提醒适用于“到达某地时执行某事”**
   如到家提醒拿快递。

4. 使用位置提醒时，应确保用户授予定位权限。



---
url: /v2/zh/guide/Device Capabilities/FontPicker.md
---

# FontPicker（字体选择器）

`FontPicker` 命名空间提供了在系统中选择字体的能力。
它会调用系统字体选择器，让用户从可用字体列表中选取字体，并返回所选字体的 **PostScript 名称**。

***

## 概述

在某些场景中（如自定义编辑器、文本渲染、样式设置等），需要用户选择字体。
`FontPicker` 提供了一个简洁的接口，可在脚本中异步调用系统字体选择器并获取结果。

***

## 方法

### `pickFont(): Promise<string | null>`

打开系统字体选择器，允许用户选择字体。
返回一个 Promise，当用户选择完成或取消时解析为结果。

**返回值：**

- `string`：所选字体的 **PostScript 名称**（例如 `"Helvetica-Bold"`、`"KaitiSC-Regular"` 等）。
- `null`：用户取消选择时返回。

***

## 示例

```ts
const fontPostscriptName = await FontPicker.pickFont()
if (fontPostscriptName == null) {
  // 用户取消了字体选择
  console.log("Font selection canceled")
} else {
  console.log("Selected font:", fontPostscriptName)
}
```

示例输出：

```
Selected font: HelveticaNeue-Bold
```

***

## 使用说明

- 返回的字体名称可直接用于需要指定字体的场景，如文本渲染或 UI 显示。
- 若用户取消选择，返回值为 `null`，调用方应当进行相应处理。
- 字体选择器展示的字体取决于系统中已安装的字体，包括系统预装与用户导入字体。

***

## 小结

| 方法           | 返回值                       | 说明                                    |
| ------------ | ------------------------- | ------------------------------------- |
| `pickFont()` | `Promise<string \| null>` | 打开系统字体选择器，返回字体的 PostScript 名称或 `null` |



---
url: /v2/zh/guide/Device Capabilities/HapticFeedback.md
---

# 触觉反馈

```tsx
import { Button, List, Navigation, NavigationStack, Script, } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"HapticFeedback"}
    >
      <Button
        title={"HapticFeedback.vibrate"}
        action={() => {
          HapticFeedback.vibrate()
        }}
      />

      <Button
        title={"HapticFeedback.lightImpact"}
        action={() => {
          HapticFeedback.lightImpact()
        }}
      />

      <Button
        title={"HapticFeedback.mediumImpact"}
        action={() => {
          HapticFeedback.mediumImpact()
        }}
      />

      <Button
        title={"HapticFeedback.heavyImpact"}
        action={() => {
          HapticFeedback.heavyImpact()
        }}
      />

      <Button
        title={"HapticFeedback.softImpact"}
        action={() => {
          HapticFeedback.softImpact()
        }}
      />

      <Button
        title={"HapticFeedback.rigidImpact"}
        action={() => {
          HapticFeedback.rigidImpact()
        }}
      />

      <Button
        title={"HapticFeedback.selection"}
        action={() => {
          HapticFeedback.selection()
        }}
      />

      <Button
        title={"HapticFeedback.notificationSuccess"}
        action={() => {
          HapticFeedback.notificationSuccess()
        }}
      />

      <Button
        title={"HapticFeedback.notificationError"}
        action={() => {
          HapticFeedback.notificationError()
        }}
      />

      <Button
        title={"HapticFeedback.notificationWarning"}
        action={() => {
          HapticFeedback.notificationWarning()
        }}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/Health/HealthActivitySummary.md
---

# 健康活动摘要（HealthActivitySummary）

`HealthActivitySummary` 类用于访问用户每日健康活动的汇总数据，包括活跃能量消耗、锻炼时间、站立小时数等。该类支持不同的移动模式（如消耗能量或移动时间），可用于显示活动圆环的进度或生成自定义的健康日报表。

***

## 使用场景

- 展示每日 Apple 活动圆环（移动、锻炼、站立）进度
- 比较用户每日活动与其设定的目标
- 构建自定义健康看板或健身追踪 UI
- 提供趋势分析或活动达成提醒功能

***

## 类：`HealthActivitySummary`

### 属性

| 属性名                | 类型                       | 描述                                                                  |
| ------------------ | ------------------------ | ------------------------------------------------------------------- |
| `dateComponents`   | `DateComponents`         | 当前活动摘要所对应的日期信息。                                                     |
| `activityMoveMode` | `HealthActivityMoveMode` | 表示该摘要使用的移动模式，可能为 `activeEnergy`（活跃能量）或 `appleMoveTime`（Apple 移动时间）。 |

***

### 方法

以下方法都返回指定单位下的数值（`HealthUnit`），表示当前日期的实际数据或目标值：

#### `activeEnergyBurned(unit: HealthUnit): number`

返回当天的活跃能量消耗（例如千卡），适用于 `activeEnergy` 移动模式。

#### `activeEnergyBurnedGoal(unit: HealthUnit): number`

返回当天的活跃能量目标值（例如千卡），仅在 `activityMoveMode` 为 `activeEnergy` 时有效。

***

#### `appleMoveTime(unit: HealthUnit): number`

返回 Apple Watch 记录的当天移动时间（单位通常为分钟），适用于 `appleMoveTime` 移动模式。

#### `appleMoveTimeGoal(unit: HealthUnit): number`

返回当天的移动时间目标，仅在 `activityMoveMode` 为 `appleMoveTime` 时有效。

***

#### `appleExerciseTime(unit: HealthUnit): number`

返回当天的锻炼时间总长，通常以分钟为单位。

#### `appleExerciseTimeGoal(unit: HealthUnit): number`

返回当天的锻炼时间目标。

***

#### `appleStandHours(unit: HealthUnit): number`

返回当天站立小时数（即每小时至少活动1分钟的小时数）。

#### `appleStandHoursGoal(unit: HealthUnit): number`

返回当天的站立目标小时数（通常为12小时）。

***

## 示例用法

```ts
async function showTodaySummary() {
  const startDate = new Date()
  startDate.setHours(0, 0, 0, 0)

  const start = DateComponents.fromDate(startDate)
  const end = DateComponents.fromDate(startDate)
  end.date += 1

  const summaries = await Health.queryActivitySummaries({
    start, // today
    end,
  })

  if (summaries.length === 0) {
    console.log('今天暂无活动摘要')
    return
  }

  const summary = summaries[0]

  console.log('日期:', summary.dateComponents)
  console.log('移动模式:', summary.activityMoveMode)

  const kcal = summary.activeEnergyBurned(HealthUnit.kilocalorie())
  const kcalGoal = summary.activeEnergyBurnedGoal(HealthUnit.kilocalorie())

  console.log(`活跃能量消耗: ${kcal} / ${kcalGoal} 千卡`)
  console.log(`锻炼时间: ${summary.appleExerciseTime(HealthUnit.minute())} 分钟`)
  console.log(`站立小时数: ${summary.appleStandHours(HealthUnit.count())} 小时`)
}
```

***

## 注意事项

- `HealthActivitySummary` 表示单日的活动摘要，若需趋势分析需查询多个摘要。
- 不同用户可能启用了不同的移动目标模式：基于能量或移动时间。
- `HealthUnit` 必须匹配目标字段类型。例如时间应使用 `minute()` 或 `second()`，计数使用 `count()`。
- 可搭配 `Health.queryActivitySummaries()` 方法查询指定日期范围内的摘要数组。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthCategorySample.md
---

# 健康分类数据（HealthCategorySample）

`HealthCategorySample` 表示一条基于分类的健康事件记录，例如睡眠分析、月经流量、排卵测试结果等。每条样本通常具有一个时间区间以及一个类别值，适用于记录健康相关事件的状态或发生情况。

***

## 适用场景

- 记录用户在某段时间内发生的健康事件（如睡觉、排卵、饮酒等）
- 存储和显示事件类型及其状态
- 手动添加健康事件数据
- 跟踪时间段型的健康行为

***

## 属性说明

| 属性名            | 类型                            | 说明                                           |
| -------------- | ----------------------------- | -------------------------------------------- |
| `uuid`         | `string`                      | 唯一标识该健康样本的 UUID。                             |
| `categoryType` | `HealthCategoryType`          | 样本的分类类型，例如 `sleepAnalysis`、`sexualActivity`。 |
| `startDate`    | `Date`                        | 事件开始时间。                                      |
| `endDate`      | `Date`                        | 事件结束时间。                                      |
| `value`        | `number`                      | 分类值，使用相应的 `HealthCategoryValue*` 枚举类型。       |
| `metadata`     | `Record<string, any> \| null` | 可选的元数据，可包含事件来源、自定义标签等。                       |

***

## 方法说明

### `static create(options): HealthCategorySample | null`

创建一条新的 `HealthCategorySample` 健康分类样本。

#### 参数说明

```ts
{
  type: HealthCategoryType               // 分类类型，例如 'sleepAnalysis'
  startDate: Date                        // 事件起始时间
  endDate: Date                          // 事件结束时间
  value: HealthCategoryValueXxx          // 分类值，根据类型不同需传入不同枚举
  metadata?: Record<string, any> | null  // 可选元数据
}
```

#### 返回值

- 创建成功时返回一个 `HealthCategorySample` 实例；
- 如果参数无效（例如类型与值不匹配），返回 `null`。

***

## 使用示例

### 示例 1：创建一条睡眠记录

```ts
const sample = HealthCategorySample.create({
  type: 'sleepAnalysis',
  startDate: new Date('2025-07-01T23:00:00'),
  endDate: new Date('2025-07-02T06:00:00'),
  value: HealthCategoryValueSleepAnalysis.asleep,
  metadata: { source: 'manual entry' }
})

if (sample) {
  console.log(`已创建睡眠样本：从 ${sample.startDate} 到 ${sample.endDate}`)
}
```

***

### 示例 2：记录一次性行为事件

```ts
const event = HealthCategorySample.create({
  type: 'sexualActivity',
  startDate: new Date('2025-07-03T22:30:00'),
  endDate: new Date('2025-07-03T22:40:00'),
  value: HealthCategoryValuePresence.present
})
```

***

### 示例 3：记录一次排卵测试结果

```ts
const result = HealthCategorySample.create({
  type: 'ovulationTestResult',
  startDate: new Date('2025-07-05T08:00:00'),
  endDate: new Date('2025-07-05T08:05:00'),
  value: HealthCategoryValueOvulationTestResult.positive
})
```

***

## 值的使用说明

`value` 参数必须使用对应类型的枚举值，示例如下：

| 类型 (`type`)                       | 所需枚举类型                                               |
| --------------------------------- | ---------------------------------------------------- |
| `sleepAnalysis`                   | `HealthCategoryValueSleepAnalysis`                   |
| `sexualActivity`                  | `HealthCategoryValuePresence`                        |
| `menstrualFlow`                   | `HealthCategoryValueSeverity`                        |
| `ovulationTestResult`             | `HealthCategoryValueOvulationTestResult`             |
| `appleStandHour`                  | `HealthCategoryValueAppleStandHour`                  |
| `environmentalAudioExposureEvent` | `HealthCategoryValueEnvironmentalAudioExposureEvent` |

如果类型与值不匹配，将导致创建失败返回 `null`。

***

## 常见使用场景

| 类型                    | 值枚举类型                                    | 示例用途      |
| --------------------- | ---------------------------------------- | --------- |
| `sleepAnalysis`       | `HealthCategoryValueSleepAnalysis`       | 睡眠记录      |
| `sexualActivity`      | `HealthCategoryValuePresence`            | 性行为记录     |
| `menstrualFlow`       | `HealthCategoryValueSeverity`            | 月经记录      |
| `pregnancyTestResult` | `HealthCategoryValuePregnancyTestResult` | 排卵或怀孕测试结果 |
| `appleStandHour`      | `HealthCategoryValueAppleStandHour`      | 久坐提醒记录    |

***

## 相关方法

- `Health.queryCategorySamples()`：用于查询分类健康样本的 API。
- `HealthCategoryType`：定义所有支持的分类类型。
- `HealthCategoryValue*`：不同类型的分类值枚举定义。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthCategoryType.md
---

# 健康分类数据（HealthCategoryType）

`HealthCategoryType` 用于表示离散型的健康状态或事件。它们通常为“是否发生”的记录（如：是否怀孕、是否进行正念训练、是否存在某种症状），适用于症状追踪、睡眠分析、生殖健康记录、环境暴露监测等场景。

***

## 1. Apple 系统事件与健康警示

| 标识符                               | 用途说明                     |
| --------------------------------- | ------------------------ |
| `appleStandHour`                  | 是否在当前小时内站立过（Apple Watch） |
| `environmentalAudioExposureEvent` | 环境噪音过高事件（例如超过 80 分贝）     |
| `headphoneAudioExposureEvent`     | 耳机音量暴露过高事件               |
| `highHeartRateEvent`              | 静息状态下心率异常升高              |
| `lowHeartRateEvent`               | 心率低于正常值                  |
| `irregularHeartRhythmEvent`       | 心律不齐检测（如房颤）              |
| `lowCardioFitnessEvent`           | 心肺适能过低事件                 |
| `appleWalkingSteadinessEvent`     | 步态稳定性过低，可能存在跌倒风险         |

***

## 2. 正念与健康行为记录

| 标识符                  | 用途说明                     |
| -------------------- | ------------------------ |
| `mindfulSession`     | 正念冥想记录                   |
| `handwashingEvent`   | 洗手行为记录（Apple Watch 自动识别） |
| `toothbrushingEvent` | 刷牙行为记录（如连接智能牙刷）          |

***

## 3. 生殖与月经周期健康

| 标识符                                | 用途说明            |
| ---------------------------------- | --------------- |
| `menstrualFlow`                    | 经期流量记录          |
| `intermenstrualBleeding`           | 经期之间的异常出血       |
| `prolongedMenstrualPeriods`        | 经期持续时间异常延长      |
| `infrequentMenstrualCycles`        | 经期频率过低          |
| `irregularMenstrualCycles`         | 经期时间不规律         |
| `persistentIntermenstrualBleeding` | 经间出血持续时间过长      |
| `bleedingDuringPregnancy`          | 怀孕期间出血          |
| `bleedingAfterPregnancy`           | 分娩后出血           |
| `pregnancy`                        | 是否怀孕            |
| `lactation`                        | 是否哺乳/泌乳         |
| `sexualActivity`                   | 性行为记录           |
| `ovulationTestResult`              | 排卵测试结果（阳性/阴性）   |
| `pregnancyTestResult`              | 验孕测试结果          |
| `progesteroneTestResult`           | 孕酮水平检测结果        |
| `contraceptive`                    | 使用的避孕方式         |
| `cervicalMucusQuality`             | 宫颈黏液质地（用于排卵期追踪） |

***

## 4. 睡眠与呼吸相关事件

| 标识符               | 用途说明               |
| ----------------- | ------------------ |
| `sleepAnalysis`   | 睡眠阶段记录（如：在床、入睡、清醒） |
| `sleepApneaEvent` | 睡眠呼吸暂停事件           |

***

## 5. 症状与身体状况

| 标识符                                  | 用途说明        |
| ------------------------------------ | ----------- |
| `abdominalCramps`                    | 腹部或经期腹痛     |
| `acne`                               | 青春痘严重程度     |
| `appetiteChanges`                    | 食欲变化（增加或减少） |
| `bladderIncontinence`                | 尿失禁         |
| `bloating`                           | 腹胀感         |
| `breastPain`                         | 乳房疼痛或不适     |
| `chestTightnessOrPain`               | 胸口紧绷或疼痛     |
| `chills`                             | 发冷、寒颤       |
| `constipation`                       | 便秘          |
| `coughing`                           | 咳嗽          |
| `diarrhea`                           | 腹泻          |
| `dizziness`                          | 头晕          |
| `drySkin`                            | 皮肤干燥        |
| `fainting`                           | 昏厥          |
| `fatigue`                            | 疲惫、乏力       |
| `fever`                              | 发烧          |
| `generalizedBodyAche`                | 全身酸痛        |
| `hairLoss`                           | 脱发          |
| `headache`                           | 头痛          |
| `heartburn`                          | 胃灼热、胃酸倒流    |
| `hotFlashes`                         | 潮热（如更年期症状）  |
| `lossOfSmell`                        | 嗅觉丧失        |
| `lossOfTaste`                        | 味觉丧失        |
| `lowerBackPain`                      | 下背部疼痛       |
| `memoryLapse`                        | 记忆模糊、短暂性遗忘  |
| `moodChanges`                        | 情绪波动        |
| `nausea`                             | 恶心感         |
| `nightSweats`                        | 夜间出汗        |
| `pelvicPain`                         | 骨盆区域疼痛      |
| `rapidPoundingOrFlutteringHeartbeat` | 心悸、心跳过快     |
| `runnyNose`                          | 流鼻涕         |
| `shortnessOfBreath`                  | 呼吸困难        |
| `sinusCongestion`                    | 鼻窦阻塞        |
| `skippedHeartbeat`                   | 心跳中断或跳拍     |
| `sleepChanges`                       | 睡眠质量或习惯变化   |
| `soreThroat`                         | 喉咙痛         |
| `vaginalDryness`                     | 阴道干涩        |
| `vomiting`                           | 呕吐          |
| `wheezing`                           | 呼吸时发出喘鸣声    |

***

## 应用场景举例

- **生殖健康应用**：可使用如 `menstrualFlow`、`ovulationTestResult`、`pregnancy`、`lactation` 等类型追踪月经、排卵、孕期及哺乳情况。
- **日常行为与习惯追踪**：通过 `mindfulSession`、`handwashingEvent`、`toothbrushingEvent` 引导用户建立良好生活习惯。
- **睡眠与心率监测**：结合 `sleepAnalysis`、`sleepApneaEvent` 与心律相关类型，为用户提供全面夜间与心血管健康评估。
- **症状记录与疾病管理**：适用于日记类、康复类 App，记录如 `fatigue`、`nausea`、`fever` 等症状，便于观察病情趋势。

***

## 示例：写入睡眠阶段记录

```ts
const sample = HealthCategorySample.create({
  type: "sleepAnalysis",
  startDate: new Date("2025-07-03T22:30:00"),
  endDate: new Date("2025-07-04T06:30:00"),
  value: HealthCategoryValueSleepAnalysis.asleepDeep
})

await Health.saveCategorySample(sample)
```

***

## 示例：查询冥想记录

```ts
const results = await Health.queryCategorySamples({
  type: "mindfulSession",
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-05")
})

for (const session of results) {
  console.log("开始：", session.startDate)
  console.log("结束：", session.endDate)
}
```

***

## 注意事项

- `value` 值必须使用与类型匹配的枚举类型，否则 `create()` 会返回 `null`。
- `endDate` 必须大于 `startDate`，即事件需持续至少 1 秒。
- 分类样本适合用于表示有状态变化或事件发生的健康记录。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthCategoryValue Types.md
---

# 健康分类值类型（HealthCategoryValue）

本文档列出了 `HealthCategorySample.create()` 及相关 API 中支持的所有 `HealthCategoryValue` 枚举类型。每个枚举值用于表示特定 `HealthCategoryType` 的分类结果。

***

## 1. `HealthCategoryValuePresence`

**适用类型：**

- `mindfulSession`（正念训练）
- `intermenstrualBleeding`（经间出血）
- `sexualActivity`（性行为）
- `pregnancy`（怀孕）
- `lactation`（哺乳）

**说明：** 用于表示事件是否发生。

| 值            | 含义    |
| ------------ | ----- |
| `present`    | 事件已发生 |
| `notPresent` | 事件未发生 |

***

## 2. `HealthCategoryValueSeverity`

**适用类型：**

- `menstrualFlow`（月经流量）
- `acneSeverity`（痤疮严重程度）
- `hairLossSeverity`（脱发严重程度）
- `abdominalCramps`（腹痛）
- `headache`（头痛）
- `nausea`（恶心）

**说明：** 表示症状的严重程度。

| 值             | 含义   |
| ------------- | ---- |
| `unspecified` | 未指定  |
| `notPresent`  | 无此症状 |
| `mild`        | 轻度   |
| `moderate`    | 中度   |
| `severe`      | 重度   |

***

## 3. `HealthCategoryValueSleepAnalysis`

**适用类型：**

- `sleepAnalysis`（睡眠分析）

**说明：** 描述某时间段内的睡眠状态。

| 值                   | 含义          |
| ------------------- | ----------- |
| `inBed`             | 在床上（不一定在睡觉） |
| `asleepUnspecified` | 睡着（阶段未知）    |
| `awake`             | 醒着          |
| `asleepCore`        | 核心睡眠        |
| `asleepDeep`        | 深度睡眠        |
| `asleepREM`         | 快速眼动睡眠      |

***

## 4. `HealthCategoryValueOvulationTestResult`

**适用类型：**

- `ovulationTestResult`（排卵测试）

| 值                         | 含义           |
| ------------------------- | ------------ |
| `negative`                | 未检测到 LH 激增   |
| `luteinizingHormoneSurge` | LH 激增，可能即将排卵 |
| `indeterminate`           | 结果不明确        |
| `estrogenSurge`           | 检测到雌激素激增     |

***

## 5. `HealthCategoryValuePregnancyTestResult`

**适用类型：**

- `pregnancyTestResult`（怀孕测试）

| 值               | 含义    |
| --------------- | ----- |
| `negative`      | 阴性    |
| `positive`      | 阳性    |
| `indeterminate` | 结果不明确 |

***

## 6. `HealthCategoryValueProgesteroneTestResult`

**适用类型：**

- `progesteroneTestResult`（孕酮测试）

| 值               | 含义    |
| --------------- | ----- |
| `negative`      | 阴性    |
| `positive`      | 阳性    |
| `indeterminate` | 结果不明确 |

***

## 7. `HealthCategoryValueCervicalMucusQuality`

**适用类型：**

- `cervicalMucusQuality`（宫颈黏液质量）

| 值          | 含义  |
| ---------- | --- |
| `dry`      | 干燥  |
| `sticky`   | 黏稠  |
| `creamy`   | 乳霜状 |
| `watery`   | 水样  |
| `eggWhite` | 蛋清状 |

***

## 8. `HealthCategoryValueContraceptive`

**适用类型：**

- `contraceptive`（避孕方式）

| 值                    | 含义         |
| -------------------- | ---------- |
| `unspecified`        | 未指定        |
| `implant`            | 植入型避孕棒     |
| `injection`          | 注射型避孕      |
| `intrauterineDevice` | 宫内节育器（IUD） |
| `intravaginalRing`   | 阴道环        |
| `oral`               | 口服避孕药      |
| `patch`              | 皮肤贴片       |

***

## 9. `HealthCategoryValueVaginalBleeding`（仅 iOS 18 及以上支持）

**适用类型：**

- `vaginalBleeding`（阴道出血）

| 值             | 含义   |
| ------------- | ---- |
| `unspecified` | 未指定  |
| `light`       | 轻度出血 |
| `medium`      | 中度出血 |
| `heavy`       | 重度出血 |
| `none`        | 无出血  |

***

## 10. `HealthCategoryValueAppetiteChanges`

**适用类型：**

- `appetiteChanges`（食欲变化）

| 值             | 含义   |
| ------------- | ---- |
| `unspecified` | 未指定  |
| `noChange`    | 无变化  |
| `decreased`   | 食欲减退 |
| `increased`   | 食欲增加 |

***

## 11. `HealthCategoryValueAppleStandHour`

**适用类型：**

- `appleStandHour`（Apple 久坐提醒）

| 值       | 含义       |
| ------- | -------- |
| `stood` | 用户起身活动过  |
| `idle`  | 用户一直保持静止 |

***

## 12. `HealthCategoryValueAppleWalkingSteadinessEvent`

**适用类型：**

- `appleWalkingSteadinessEvent`（步态稳定性事件）

| 值                | 含义         |
| ---------------- | ---------- |
| `initialLow`     | 初次检测到低稳定性  |
| `initialVeryLow` | 初次检测到极低稳定性 |
| `repeatLow`      | 重复检测到低稳定性  |
| `repeatVeryLow`  | 重复检测到极低稳定性 |

***

## 13. `HealthCategoryValueEnvironmentalAudioExposureEvent`

**适用类型：**

- `environmentalAudioExposureEvent`（环境音暴露事件）

| 值                | 含义       |
| ---------------- | -------- |
| `momentaryLimit` | 瞬间超过暴露限制 |

***

## 14. `HealthCategoryValueHeadphoneAudioExposureEvent`

**适用类型：**

- `headphoneAudioExposureEvent`（耳机音量暴露事件）

| 值               | 含义              |
| --------------- | --------------- |
| `sevenDayLimit` | 超过推荐的 7 天音量暴露上限 |

***

## 15. `HealthCategoryValueLowCardioFitnessEvent`

**适用类型：**

- `lowCardioFitnessEvent`（心肺适能不足事件）

| 值            | 含义           |
| ------------ | ------------ |
| `lowFitness` | 检测到较低的心肺适能水平 |

***

## 使用示例

```ts
const sample = HealthCategorySample.create({
  type: "menstrualFlow",
  startDate: new Date("2025-07-03T10:00:00"),
  endDate: new Date("2025-07-03T12:00:00"),
  value: HealthCategoryValueSeverity.moderate
})

await Health.saveCategorySample(sample)
```

***

## 注意事项

- `value` 的值必须与 `type` 对应的枚举类型一致，类型不符会导致错误。
- 请确保已获得 HealthKit 权限后再调用读取或保存方法。
- 所有枚举值最终会映射为 Apple HealthKit 的 `HKCategoryValue` 存储。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthCharacteristicType.md
---

# 健康特征类型（HealthCharacteristicType）

本文档介绍与 HealthKit 中“个人健康档案”及“活动摘要”相关的枚举类型，主要用于获取或表示用户的静态健康特征信息（如性别、血型、皮肤类型、轮椅使用情况）以及运动模式设定。

***

## 1. `HealthBiologicalSex`

表示用户的生物性别（Biological Sex）。

| 枚举值      | 描述   |
| -------- | ---- |
| `notSet` | 未设置  |
| `female` | 女性   |
| `male`   | 男性   |
| `other`  | 其他性别 |

***

## 2. `HealthBloodType`

表示用户的血型信息。

| 枚举值          | 描述         |
| ------------ | ---------- |
| `notSet`     | 未设置        |
| `aPositive`  | A 型 Rh 阳性  |
| `aNegative`  | A 型 Rh 阴性  |
| `bPositive`  | B 型 Rh 阳性  |
| `bNegative`  | B 型 Rh 阴性  |
| `abPositive` | AB 型 Rh 阳性 |
| `abNegative` | AB 型 Rh 阴性 |
| `oPositive`  | O 型 Rh 阳性  |
| `oNegative`  | O 型 Rh 阴性  |

***

## 3. `HealthFitzpatrickSkinType`

表示 Fitzpatrick 皮肤类型，用于评估个体对阳光暴露的反应。

| 枚举值      | 类型     | 描述              |
| -------- | ------ | --------------- |
| `notSet` | 未设置    | 无皮肤类型信息         |
| `I`      | 类型 I   | 非常白皙，极易晒伤，几乎不晒黑 |
| `II`     | 类型 II  | 白皙，容易晒伤，难以晒黑    |
| `III`    | 类型 III | 中等肤色，有时晒伤，逐渐晒黑  |
| `IV`     | 类型 IV  | 深肤色，罕见晒伤，容易晒黑   |
| `V`      | 类型 V   | 深棕色皮肤，很少晒伤，晒黑明显 |
| `VI`     | 类型 VI  | 深黑色皮肤，从不晒伤      |

***

## 4. `HealthWheelchairUse`

表示用户是否使用轮椅。

| 枚举值      | 描述    |
| -------- | ----- |
| `notSet` | 未设置   |
| `no`     | 不使用轮椅 |
| `yes`    | 使用轮椅  |

***

## 5. `HealthActivityMoveMode`

表示用户 Apple 健康活动摘要的“移动环”目标计算模式。

| 枚举值             | 描述                   |
| --------------- | -------------------- |
| `activeEnergy`  | 传统模式：根据“主动消耗的卡路里”计算  |
| `appleMoveTime` | 时间模式：根据“活动时间”计算目标完成度 |

***

## 示例代码

```ts
// 获取用户是否使用轮椅
const wheelchair = await Health.wheelchairUse()
if (wheelchair === HealthWheelchairUse.yes) {
  console.log("用户使用轮椅")
}

// 获取用户皮肤类型
const skinType = await Health.fitzpatrickSkinType()
switch (skinType) {
  case HealthFitzpatrickSkinType.III:
    console.log("中等肤色，逐渐晒黑")
    break
}

// 获取用户活动模式
const mode = await Health.activityMoveMode()
if (mode === HealthActivityMoveMode.appleMoveTime) {
  console.log("用户使用 Apple Move Time 模式")
}
```



---
url: /v2/zh/guide/Device Capabilities/Health/HealthCorrelation.md
---

# 健康关联数据（HealthCorrelation）

`HealthCorrelation` 类表示一组彼此相关的健康样本。它提供接口用于访问和创建健康关联记录，这些记录将多个健康数据类型组合成一个整体，例如将饮食摄入与血压读数关联，或将排卵测试结果与月经流量数据相关联。

***

## 适用场景

- 将血压的收缩压和舒张压值组合为一条记录
- 将食物摄入与营养成分相关联
- 将多个月经追踪事件合并为一个周期相关事件

***

## 属性说明

| 属性名                         | 类型                                                                                                                   | 描述                                     |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| `uuid`                      | `string`                                                                                                             | 该关联样本的唯一标识符。                           |
| `correlationType`           | `HealthCorrelationType`                                                                                              | 关联的类型，例如 `"bloodPressure"` 或 `"food"`。 |
| `startDate`                 | `Date`                                                                                                               | 该关联事件的起始时间。                            |
| `endDate`                   | `Date`                                                                                                               | 该关联事件的结束时间。                            |
| `metadata`                  | `Record<string, any> \| null`                                                                                        | 可选元数据，例如用户的注释。                         |
| `samples`                   | `(HealthQuantitySample \| HealthCumulativeQuantitySample \| HealthDiscreteQuantitySample \| HealthCategorySample)[]` | 此关联包含的所有健康样本。                          |
| `quantitySamples`           | `HealthQuantitySample[]`                                                                                             | 所有基于数量类型的样本（包含累积和离散类型）。                |
| `cumulativeQuantitySamples` | `HealthCumulativeQuantitySample[]`                                                                                   | 仅包含累积数量样本。                             |
| `discreteQuantitySamples`   | `HealthDiscreteQuantitySample[]`                                                                                     | 仅包含离散数量样本。                             |
| `categorySamples`           | `HealthCategorySample[]`                                                                                             | 所有基于类别的健康样本。                           |

***

## 静态方法

### `HealthCorrelation.create(options): HealthCorrelation | null`

创建一个新的健康数据关联。

#### 参数

| 参数名         | 类型                                                 | 是否必填 | 描述                                        |
| ----------- | -------------------------------------------------- | ---- | ----------------------------------------- |
| `type`      | `HealthCorrelationType`                            | 是    | 要创建的关联类型，例如 `"bloodPressure"` 或 `"food"`。 |
| `startDate` | `Date`                                             | 是    | 关联的开始时间。                                  |
| `endDate`   | `Date`                                             | 是    | 关联的结束时间。                                  |
| `metadata`  | `Record<string, any> \| null`                      | 否    | 可选元数据，例如附加说明或标记。                          |
| `objects`   | `(HealthQuantitySample \| HealthCategorySample)[]` | 是    | 要包含在该关联中的健康样本。                            |

#### 返回值

- 如果参数合法，返回新的 `HealthCorrelation` 实例；
- 如果类型与样本不兼容或参数无效，则返回 `null`。

***

## 使用示例

### 示例 1：创建一条血压关联记录

```ts
const systolic = HealthQuantitySample.create({
  type: "bloodPressureSystolic",
  startDate: new Date("2025-07-04T08:00:00"),
  endDate: new Date("2025-07-04T08:01:00"),
  value: 120,
  unit: HealthUnit.millimeterOfMercury()
})

const diastolic = HealthQuantitySample.create({
  type: "bloodPressureDiastolic",
  startDate: new Date("2025-07-04T08:00:00"),
  endDate: new Date("2025-07-04T08:01:00"),
  value: 80,
  unit: HealthUnit.millimeterOfMercury()
})

const correlation = HealthCorrelation.create({
  type: "bloodPressure",
  startDate: systolic.startDate,
  endDate: systolic.endDate,
  objects: [systolic, diastolic]
})

if (correlation) {
  // 保存记录...
}
```

***

### 示例 2：遍历关联中的样本

```ts
for (const sample of correlation.quantitySamples) {
  const value = sample.quantityValue(HealthUnit.millimeterOfMercury())
  console.log(`${sample.quantityType}: ${value}`)
}
```

***

## 注意事项

- `objects` 参数中的样本类型必须符合该关联类型所支持的数据类型。
- 当前支持的关联类型包括 `"bloodPressure"` 和 `"food"`。
- 使用此类可以在视图中更完整地展示一次健康事件的相关信息，或用于分析多个数据之间的关系。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthHeartbeatSeriesSample.md
---

# 健康心跳序列数据（HealthHeartbeatSeriesSample）

`HealthHeartbeatSeriesSample` 类用于访问 **心跳序列样本（heartbeat series samples）**，它表示一段时间内记录的一系列心跳间隔（RR 间期），通常用于分析心律，识别心律不齐等情况。

该类的实例由公共接口 `Health.queryHeartbeatSeriesSamples()` 返回。

***

## 使用场景

- **监测运动过程中的心律变化**
- **识别异常心律（如房颤）**
- **记录休息或睡眠期间的心跳模式**
- **生成健康数据分析与研究报告**

***

## 类：`HealthHeartbeatSeriesSample`

### 属性说明

| 属性名          | 类型                            | 描述                                           |
| ------------ | ----------------------------- | -------------------------------------------- |
| `uuid`       | `string`                      | 此样本的唯一标识符                                    |
| `sampleType` | `string`                      | 样本类型，通常为 `"HKHeartbeatSeriesTypeIdentifier"` |
| `startDate`  | `Date`                        | 该系列数据的开始时间                                   |
| `endDate`    | `Date`                        | 该系列数据的结束时间                                   |
| `count`      | `number`                      | 序列中包含的心跳次数（即 RR 间期数量）                        |
| `metadata`   | `Record<string, any> \| null` | 可选的元数据，如记录设备、来源信息等                           |

> 注意：目前此类不暴露具体的 RR 间期数据，仅表示整体序列信息。

***

## 方法：`Health.queryHeartbeatSeriesSamples(options?)`

### 方法定义

```ts
function queryHeartbeatSeriesSamples(
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "count"
      order?: "forward" | "reverse"
    }>
    requestPermissions?: HealthQuantityType[]
  }
): Promise<HealthHeartbeatSeriesSample[]>
```

### 参数说明

- `startDate` _(可选)_：筛选起始时间之后的样本
- `endDate` _(可选)_：筛选截止时间之前的样本
- `limit` _(可选)_：最多返回的样本数量
- `strictStartDate` _(可选)_：是否仅返回开始时间等于 `startDate` 的样本
- `strictEndDate` _(可选)_：是否仅返回结束时间等于 `endDate` 的样本
- `sortDescriptors` _(可选)_：设置排序字段，如 `startDate`、`endDate` 或 `count`，可指定顺序为 `"forward"` 或 `"reverse"`
- `requestPermissions`: _(可选)_`: 设置需要请求授权的数据类型，默认只请求了 `heartbeat`, `heartRateVariabilitySDNN`and`heartRate\` 等类型，如果需要访问更新相关数据必须要设置对应数据的类型授权

### 返回值

一个 Promise 对象，解析为 `HealthHeartbeatSeriesSample` 实例数组，结果按指定排序返回。

***

## 使用示例

```ts
async function fetchHeartbeatSeries() {
  const samples = await Health.queryHeartbeatSeriesSamples({
    startDate: new Date('2024-01-01'),
    endDate: new Date(),
    sortDescriptors: [
      { key: 'startDate', order: 'reverse' }
    ],
    limit: 5,
  })

  for (const sample of samples) {
    console.log('UUID:', sample.uuid)
    console.log('开始时间:', sample.startDate)
    console.log('结束时间:', sample.endDate)
    console.log('心跳次数:', sample.count)
    console.log('元数据:', sample.metadata)
  }
}
```

***

## 注意事项

- 如果用户未授权读取心跳序列数据，将返回空数组。
- 心跳序列通常由 Apple Watch 等设备记录，表示某段时间内的连续心跳间隔数据。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthKit Permission Behavior.md
---

# HealthKit 权限行为

在使用 Scripting 提供的 Health 模块访问 iOS 健康数据时，开发者需要了解 iOS HealthKit 特有的授权机制，以及 Scripting API 的行为设计。本说明文档将帮助你正确处理无权限时的情况，并提供开发建议。

***

## iOS HealthKit 授权机制特性

1. **无法主动查询授权状态**
   iOS 不提供 API 用于判断某个健康数据类型是否已授权或被拒绝。授权状态不可直接获知。

2. **授权弹窗仅在首次请求时弹出**
   系统只会在数据类型的授权状态为 `notDetermined` 时自动弹出授权弹窗。一旦用户做出决定（允许或拒绝），后续请求不会再次触发弹窗。

3. **无权限不会返回系统错误**
   如果请求了未被授权的数据，HealthKit 不会抛出错误。部分接口会返回空数据，部分接口则通过 `Promise.reject` 报错。

***

## Scripting 中的权限处理逻辑

### 自动请求权限

当你调用任意需要健康数据权限的方法时，Scripting 会根据接口涉及的数据类型，自动触发系统授权弹窗（如果该类型尚未请求过权限）。

例如：

```ts
await Health.dateOfBirth()
await Health.bloodType()
await Health.queryQuantitySamples("stepCount", { startDate: ..., endDate: ... })
```

***

## 不同方法的行为对比

| 方法                              | 无权限时行为     | 是否触发 `Promise.reject` |
| ------------------------------- | ---------- | --------------------- |
| `Health.queryQuantitySamples()` | 返回空数组 `[]` | 否                     |
| `Health.queryCategorySamples()` | 返回空数组 `[]` | 否                     |
| `Health.dateOfBirth()`          | 无返回值       | 是                     |
| `Health.bloodType()` 等档案方法      | 无返回值       | 是                     |

***

## 示例代码

### 示例 1：读取样本数据（无权限返回空数组）

```ts
const samples = await Health.queryQuantitySamples('stepCount')

if (samples.length === 0) {
  console.log("未返回步数数据，可能未授权或无记录")
}
```

### 示例 2：读取用户档案（无权限时 Promise 会 reject）

```ts
try {
  const dob = await Health.dateOfBirth()
  console.log(`出生日期：${dob.year}-${dob.month}-${dob.day}`)
} catch (err) {
  console.warn("未能读取出生日期，用户可能未授权")
}
```

***

## 多接口同时调用时的权限合并

当你同时调用多个需要健康权限的方法（例如通过 `Promise.all()`），Scripting 会自动合并这些接口所需的权限，并在**同一个系统弹窗中**请求授权。这样可以避免多次弹窗打断用户体验。

```ts
try {
  const [dob, blood] = await Promise.all([
    Health.dateOfBirth(),
    Health.bloodType()
  ])
  console.log(dob, blood)
} catch (err) {
  console.warn("用户可能拒绝了部分或全部权限")
}
```

***

## 开发建议与提示

| 场景                      | 建议处理方式                           |
| ----------------------- | -------------------------------- |
| 首次请求健康数据                | 在 UI 中预告权限用途，引导用户理解授权目的          |
| 接口返回空数组                 | 判断数据长度，提示“可能未授权或无数据记录”           |
| 接口发生异常（如 `dateOfBirth`） | 使用 `try...catch` 捕获异常并提示用户手动检查权限 |

***

## 如何开启授权

前往「健康」App，依次打开「数据访问与设备 > Scripting」，确认是否已授予相关权限。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthQuantitySample.md
---

`HealthQuantitySample` 表示一条健康数量类型的数据样本，例如一次心率测量、记录的步数或摄入的热量。它包含了关于该数据的类型、数值、时间区间、单位和可选的元数据信息。

该类是两个更具体子类的基类：

- `HealthCumulativeQuantitySample`（累计型样本）
- `HealthDiscreteQuantitySample`（离散型样本）

***

## 基本信息

此类用于：

- 读取单条健康数据记录
- 写入新的健康数据记录
- 按单位转换样本数值

***

## 属性说明

| 属性名            | 类型                            | 描述          |
| -------------- | ----------------------------- | ----------- |
| `uuid`         | `string`                      | 样本的唯一标识符    |
| `quantityType` | `HealthQuantityType`          | 健康指标的类型     |
| `startDate`    | `Date`                        | 测量开始时间      |
| `endDate`      | `Date`                        | 测量结束时间      |
| `count`        | `number`                      | 样本数量（通常为 1） |
| `metadata`     | `Record<string, any> \| null` | 可选的元数据      |

***

## 方法说明

### `quantityValue(unit: HealthUnit): number`

以指定单位返回该样本的数值。

**参数：**

- `unit`: 单位对象（如 `HealthUnit.kilocalorie()`）

**返回：**

- 转换后的数值（number）

**示例：**

```ts
const bpm = sample.quantityValue(HealthUnit.count().divided(HealthUnit.minute()))
console.log(`心率: ${bpm} 次/分钟`)
```

***

## 静态方法

### `HealthQuantitySample.create(options): HealthQuantitySample | null`

创建一条新的健康样本数据。

**参数结构：**

```ts
{
  type: HealthQuantityType
  startDate: Date
  endDate: Date
  value: number
  unit: HealthUnit
  metadata?: Record<string, any> | null
}
```

**返回：**

- 成功则返回 `HealthQuantitySample` 实例，否则为 `null`

**示例：**

```ts
const sample = HealthQuantitySample.create({
  type: 'stepCount',
  startDate: new Date('2025-07-01T09:00:00'),
  endDate: new Date('2025-07-01T09:01:00'),
  value: 200,
  unit: HealthUnit.count(),
  metadata: { source: 'manualEntry' }
})
```

***

# 子类：HealthCumulativeQuantitySample

`HealthCumulativeQuantitySample` 表示累计型的健康数据，例如总步数、总距离或总能量消耗等。

## 新增属性

| 属性名                       | 类型        | 描述          |
| ------------------------- | --------- | ----------- |
| `hasUndeterminedDuration` | `boolean` | 是否为不确定时长的样本 |

## 新增方法

### `sumQuantity(unit: HealthUnit): number`

以指定单位返回该样本的累计值。

**示例：**

```ts
const totalKcal = cumulativeSample.sumQuantity(HealthUnit.kilocalorie())
console.log(`总活动能量: ${totalKcal} 千卡`)
```

### `quantityValue(unit: HealthUnit): number`

返回值同 `sumQuantity()`，用于兼容统一接口。

***

# 子类：HealthDiscreteQuantitySample

`HealthDiscreteQuantitySample` 表示一系列离散时间点上的测量值，例如心率、步数或温度变化等。

## 新增属性

| 属性名                              | 类型                           | 描述            |
| -------------------------------- | ---------------------------- | ------------- |
| `mostRecentQuantityDateInterval` | `HealthDateInterval \| null` | 最近一次数值对应的时间范围 |

## 新增方法

| 方法名                        | 描述              |
| -------------------------- | --------------- |
| `averageQuantity(unit)`    | 返回平均值           |
| `maximumQuantity(unit)`    | 返回最大值           |
| `minimumQuantity(unit)`    | 返回最小值           |
| `mostRecentQuantity(unit)` | 返回最近一次记录的值（若存在） |

**示例：**

```ts
const avg = discreteSample.averageQuantity(HealthUnit.count())
const max = discreteSample.maximumQuantity(HealthUnit.count())
const recent = discreteSample.mostRecentQuantity(HealthUnit.count())
console.log(`平均: ${avg}, 最大: ${max}, 最近: ${recent}`)
```

***

## 使用场景对比

| 场景               | 推荐使用的类                           | 示例          |
| ---------------- | -------------------------------- | ----------- |
| 记录或读取单条测量数据      | `HealthQuantitySample`           | 手动输入体重      |
| 处理总量（如总步数、总能量）   | `HealthCumulativeQuantitySample` | 1 小时内的总步数   |
| 进行统计分析（最小值/最大值等） | `HealthDiscreteQuantitySample`   | 心率记录的最大/平均值 |

***

## 相关类型

- `HealthUnit`: 表示测量单位（如 kg、bpm、kcal 等）
- `HealthQuantityType`: 指定测量的数据类型（如步数、心率等）
- `HealthDateInterval`: 表示一个时间区间（start + end + duration）



---
url: /v2/zh/guide/Device Capabilities/Health/HealthQuantityType.md
---

# 健康数量型数据（HealthQuantityType）

`HealthQuantityType` 用于指定你希望读取或写入的健康数据类型。每个标识符代表一种可度量的健康指标，涵盖身体测量、运动、营养、生理信号、环境暴露等多个维度。

***

## 1. 身体测量

| 类型标识符                           | 用途说明                     |
| ------------------------------- | ------------------------ |
| `bodyMass`                      | 体重（kg 或磅）                |
| `bodyMassIndex`                 | 身体质量指数（BMI）              |
| `height`                        | 身高                       |
| `bodyFatPercentage`             | 体脂百分比                    |
| `leanBodyMass`                  | 去脂体重（不包括脂肪、骨骼、器官）        |
| `waistCircumference`            | 腰围，常用于代谢健康分析             |
| `appleSleepingWristTemperature` | 睡眠期间的手腕皮肤温度（Apple Watch） |
| `bodyTemperature`               | 核心体温                     |
| `basalBodyTemperature`          | 基础体温，常用于生理周期追踪           |

***

## 2. 活动与运动

| 类型标识符                         | 用途说明              |
| ----------------------------- | ----------------- |
| `stepCount`                   | 步数                |
| `distanceWalkingRunning`      | 步行与跑步距离           |
| `flightsClimbed`              | 登楼层数              |
| `activeEnergyBurned`          | 主动能量消耗（卡路里）       |
| `basalEnergyBurned`           | 基础代谢能量消耗          |
| `appleExerciseTime`           | Apple 定义的锻炼时间     |
| `appleMoveTime`               | 活动时间（Move 环）      |
| `appleStandTime`              | 站立时间（Apple Watch） |
| `pushCount`                   | 轮椅推进次数            |
| `distanceWheelchair`          | 轮椅行进距离            |
| `nikeFuel`                    | Nike 活动得分（已弃用）    |
| `estimatedWorkoutEffortScore` | 锻炼努力估算分值          |
| `workoutEffortScore`          | 实际锻炼努力分值          |
| `physicalEffort`              | 锻炼期间的身体努力强度       |

***

## 3. 运动专项指标

| 类型标识符                             | 用途说明        |
| --------------------------------- | ----------- |
| `cyclingSpeed`                    | 骑行速度        |
| `cyclingPower`                    | 骑行输出功率      |
| `cyclingCadence`                  | 骑行踏频        |
| `cyclingFunctionalThresholdPower` | 功能性阈值功率（骑行） |
| `distanceCycling`                 | 骑行距离        |
| `distanceRowing`                  | 划船距离        |
| `rowingSpeed`                     | 划船速度        |
| `distanceSwimming`                | 游泳距离        |
| `swimmingStrokeCount`             | 游泳划水次数      |
| `distancePaddleSports`            | 划桨类运动距离     |
| `paddleSportsSpeed`               | 划桨运动速度      |
| `distanceSkatingSports`           | 滑冰运动距离      |
| `distanceDownhillSnowSports`      | 高山滑雪运动距离    |
| `distanceCrossCountrySkiing`      | 越野滑雪距离      |
| `crossCountrySkiingSpeed`         | 越野滑雪速度      |

***

## 4. 步态与跑步分析

| 类型标识符                            | 用途说明            |
| -------------------------------- | --------------- |
| `runningSpeed`                   | 跑步速度            |
| `runningPower`                   | 跑步功率            |
| `runningStrideLength`            | 步幅长度            |
| `runningVerticalOscillation`     | 垂直振幅（跑步中身体上下波动） |
| `runningGroundContactTime`       | 跑步着地接触时间        |
| `walkingStepLength`              | 步行步长            |
| `walkingSpeed`                   | 步行速度            |
| `walkingAsymmetryPercentage`     | 步态不对称百分比        |
| `walkingDoubleSupportPercentage` | 双脚同时着地的步行时间百分比  |
| `appleWalkingSteadiness`         | 苹果步态稳定性指标       |
| `walkingHeartRateAverage`        | 步行平均心率          |
| `sixMinuteWalkTestDistance`      | 六分钟步行测试距离       |
| `stairAscentSpeed`               | 上楼速度            |
| `stairDescentSpeed`              | 下楼速度            |

***

## 5. 心率与生命体征

| 类型标识符                        | 用途说明           |
| ---------------------------- | -------------- |
| `heartRate`                  | 心率（bpm）        |
| `restingHeartRate`           | 静息心率           |
| `walkingHeartRateAverage`    | 步行平均心率         |
| `heartRateVariabilitySDNN`   | 心率变异性（标准差）     |
| `heartRateRecoveryOneMinute` | 运动后 1 分钟心率恢复值  |
| `peripheralPerfusionIndex`   | 外周灌注指数         |
| `atrialFibrillationBurden`   | 房颤负荷（AFib 百分比） |
| `vo2Max`                     | 最大摄氧量，衡量有氧能力   |
| `bloodPressureSystolic`      | 收缩压            |
| `bloodPressureDiastolic`     | 舒张压            |
| `oxygenSaturation`           | 血氧饱和度          |
| `bloodGlucose`               | 血糖浓度           |
| `insulinDelivery`            | 胰岛素输送量         |
| `inhalerUsage`               | 吸入器使用次数        |
| `respiratoryRate`            | 呼吸频率（次/分钟）     |
| `forcedExpiratoryVolume1`    | 第1秒用力呼气量       |
| `forcedVitalCapacity`        | 用力肺活量          |
| `peakExpiratoryFlowRate`     | 呼气峰流速          |

***

## 6. 声音与环境暴露

| 类型标识符                         | 用途说明          |
| ----------------------------- | ------------- |
| `environmentalAudioExposure`  | 环境噪音暴露（分贝）    |
| `environmentalSoundReduction` | 降噪程度（耳机）      |
| `headphoneAudioExposure`      | 耳机音量暴露（时间与分贝） |
| `uvExposure`                  | 紫外线暴露水平       |
| `timeInDaylight`              | 曝晒在日光下的时间     |
| `underwaterDepth`             | 水下深度          |
| `waterTemperature`            | 水温（如游泳、潜水）    |

***

## 7. 营养摄入（饮食追踪）

| 类型标识符                       | 用途说明        |
| --------------------------- | ----------- |
| `dietaryEnergyConsumed`     | 摄入能量（卡路里）   |
| `dietaryProtein`            | 蛋白质摄入量      |
| `dietaryCarbohydrates`      | 碳水化合物摄入量    |
| `dietaryFatTotal`           | 总脂肪摄入量      |
| `dietaryFatSaturated`       | 饱和脂肪        |
| `dietaryFatMonounsaturated` | 单不饱和脂肪      |
| `dietaryFatPolyunsaturated` | 多不饱和脂肪      |
| `dietarySugar`              | 糖分摄入        |
| `dietaryFiber`              | 膳食纤维        |
| `dietaryWater`              | 水分摄入        |
| `dietaryCaffeine`           | 咖啡因摄入       |
| `dietaryCholesterol`        | 胆固醇摄入       |
| `dietarySodium`             | 钠摄入         |
| `dietaryPotassium`          | 钾摄入         |
| `dietaryCalcium`            | 钙摄入         |
| `dietaryIron`               | 铁摄入         |
| `dietaryMagnesium`          | 镁摄入         |
| `dietaryZinc`               | 锌摄入         |
| `dietaryIodine`             | 碘摄入         |
| `dietaryVitaminA`           | 维生素 A       |
| `dietaryVitaminB6`          | 维生素 B6      |
| `dietaryVitaminB12`         | 维生素 B12     |
| `dietaryVitaminC`           | 维生素 C       |
| `dietaryVitaminD`           | 维生素 D       |
| `dietaryVitaminE`           | 维生素 E       |
| `dietaryVitaminK`           | 维生素 K       |
| `dietaryThiamin`            | 维生素 B1（硫胺素） |
| `dietaryRiboflavin`         | 维生素 B2（核黄素） |
| `dietaryNiacin`             | 维生素 B3（烟酸）  |
| `dietaryPantothenicAcid`    | 泛酸（维生素 B5）  |
| `dietaryFolate`             | 叶酸          |
| `dietaryCopper`             | 铜摄入         |
| `dietarySelenium`           | 硒摄入         |
| `dietaryChromium`           | 铬摄入         |
| `dietaryManganese`          | 锰摄入         |
| `dietaryMolybdenum`         | 钼摄入         |
| `dietaryPhosphorus`         | 磷摄入         |
| `dietaryBiotin`             | 生物素         |

***

## 8. 生活方式与其他

| 类型标识符                                | 用途说明              |
| ------------------------------------ | ----------------- |
| `bloodAlcoholContent`                | 血液酒精含量            |
| `numberOfAlcoholicBeverages`         | 饮酒次数              |
| `numberOfTimesFallen`                | 跌倒次数（Apple Watch） |
| `appleSleepingBreathingDisturbances` | 睡眠期间呼吸干扰次数        |

***

## 使用示例

### 查询步数样本：

```ts
const samples = await Health.queryQuantitySamples({
  type: "stepCount",
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02"),
  limit: 20
})

for (const sample of samples) {
  const value = sample.quantity?.valueForUnit(HealthUnit.count())
  console.log("步数：", value)
}
```

### 写入体重数据：

```ts
const sample = HealthQuantitySample.create({
  type: "bodyMass",
  unit: HealthUnit.gramUnit(HealthUnitPrefix.kilo),
  value: 70.0,
  startDate: new Date("2025-07-01 00:00:00"),
  endDate: new Date("2025-07-02 00:00:00"),
})

await Health.saveQuantitySample(sample)
```

### 读取锻炼中的平均心率：

```ts
const stat = workout.allStatistics["heartRate"]
const avg = stat?.averageQuantity(HealthUnit.count().divided(HealthUnit.minute()))
```



---
url: /v2/zh/guide/Device Capabilities/Health/HealthStatistics.md
---

`HealthStatistics` 类提供了对特定健康数量类型在指定时间范围内的**统计数据访问**。通过此类，你可以获取以下汇总信息：

- 总持续时间（duration）
- 平均值（average）
- 总和（sum）
- 最小值和最大值（min/max）
- 最近一次的值及其时间范围

该类适用于生成每日、每周或任意自定义区间的健康数据统计信息。

***

## 概览

- 每个 `HealthStatistics` 实例表示一个 `HealthQuantityType` 的统计数据。
- 所有统计信息都基于一个时间段内的样本数据。
- 可选地，你可以通过 `HealthSource` 过滤样本来源，只计算特定来源的统计结果。

***

## 属性说明

| 属性名            | 类型                       | 描述                              |
| -------------- | ------------------------ | ------------------------------- |
| `quantityType` | `HealthQuantityType`     | 当前统计数据所针对的健康数量类型（如 `stepCount`） |
| `startDate`    | `Date`                   | 当前统计数据所涵盖时间范围的开始时间              |
| `endDate`      | `Date`                   | 当前统计数据所涵盖时间范围的结束时间              |
| `sources`      | `HealthSource[] \| null` | 提供当前统计数据的所有健康数据来源（如设备、应用等）      |

***

## 方法说明

### `duration(unit: HealthUnit, source?: HealthSource): number | null`

返回符合条件的所有样本的总持续时间。

- `unit`: 使用的时间单位（如秒、分钟）
- `source`: （可选）只统计指定来源的样本

无匹配样本时返回 `null`。

***

### `averageQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回所有样本的**平均值**。

***

### `sumQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回所有样本的数值总和。

***

### `minimumQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回样本中的最小数值。

***

### `maximumQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回样本中的最大数值。

***

### `mostRecentQuantity(unit: HealthUnit, source?: HealthSource): number | null`

返回指定范围内最近记录的一条样本的值。

***

### `mostRecentQuantityDateInterval(source?: HealthSource): HealthDateInterval | null`

返回最近一条样本的时间区间（开始和结束时间）。

***

## 示例代码

```ts
const stats = await Health.queryStatistics({
  type: "stepCount",
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02")
})

const totalSteps = stats.sumQuantity(HealthUnit.count())
const average = stats.averageQuantity(HealthUnit.count())
const mostRecent = stats.mostRecentQuantity(HealthUnit.count())
const recentInterval = stats.mostRecentQuantityDateInterval()

console.log("步数统计：")
console.log("总步数：", totalSteps)
console.log("平均步数：", average)
console.log("最近记录：", mostRecent)
console.log("记录时间区间：", recentInterval)
```

***

# `HealthSource` 类

`HealthSource` 表示一个健康数据的来源，如某个 app 或设备（例如 iPhone、Apple Watch 等）。

***

## 属性说明

| 属性名                | 类型       | 描述                                         |
| ------------------ | -------- | ------------------------------------------ |
| `bundleIdentifier` | `string` | 来源的 bundle ID，例如 `"com.apple.Health"`      |
| `name`             | `string` | 来源的可读名称，例如 `"Apple Watch"` 或 `"Scripting"` |

***

## 静态方法

### `HealthSource.forCurrentApp(): HealthSource`

返回当前应用（Scripting）对应的 `HealthSource` 对象，可用于筛选由当前应用写入的健康数据。

***

## 示例：按来源过滤统计结果

```ts
const stats = await Health.queryStatistics("heartRate"， {
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02")
})

const currentAppSource = HealthSource.forCurrentApp()
const averageHR = stats.averageQuantity(HealthUnit.countPerMinute(), currentAppSource)

console.log("当前 App 的心率数据：", averageHR)
```

***

## 总结

- `HealthStatistics` 可用于获取健康数据的统计汇总，支持单位转换和数据来源过滤。
- 搭配 `HealthSource` 可以精确控制数据分析的来源，适用于可视化分析和报表功能。
- 常见场景包括：展示日均步数、记录最近一次体重、分析指定设备或 app 的活跃时间等。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthStatisticsCollection.md
---

# 健康统计集合（HealthStatisticsCollection）

`HealthStatisticsCollection` 类用于表示按时间分组的健康统计数据集合，如每日、每周或每月的汇总统计。集合中的每一项代表一个时间区间，并对应一个 `HealthStatistics` 实例，包含该时间段内的统计信息。

该类特别适用于：

- 绘制健康数据的**时间趋势图**
- 生成**按日/周/月分组的报告**
- 按日期区间访问统计数据

***

## 总览

每一个 `HealthStatisticsCollection`：

- 是通过按时间查询健康数据获得的
- 基于 anchorDate 和 intervalComponents（如每日、每周）进行时间对齐
- 可选支持按来源（如设备、App）聚合

***

## 方法说明

### `sources(): HealthSource[]`

返回一个数组，包含所有为此集合提供数据的 `HealthSource`（数据来源）。

每个 `HealthSource` 表示一个设备或 App（如 Apple Watch、iPhone、第三方健康应用等）。

#### 示例：

```ts
const sources = collection.sources()
sources.forEach(source => {
  console.log("来源：", source.name, source.bundleIdentifier)
})
```

***

### `statistics(): HealthStatistics[]`

返回此集合中所有时间区间的统计数据，每一项为一个 `HealthStatistics` 实例。

这些统计数据是根据查询时提供的 anchorDate 和 intervalComponents 进行时间对齐的。

#### 示例：

```ts
const allStats = collection.statistics()
allStats.forEach(stat => {
  const value = stat.sumQuantity(HealthUnit.count())
  console.log(`从 ${stat.startDate} 到 ${stat.endDate}：共计 ${value} 步`)
})
```

***

### `statisticsFor(date: Date): HealthStatistics | null`

根据指定的日期查找该日期所在的时间区间对应的 `HealthStatistics` 实例。

如果该日期不属于任何时间区间，将返回 `null`。

#### 示例：

```ts
const stat = collection.statisticsFor(new Date("2025-07-01"))
if (stat) {
  const value = stat.averageQuantity(HealthUnit.count())
  console.log("7月1日的平均值：", value)
} else {
  console.log("7月1日无数据")
}
```

***

## 使用场景

当你需要：

- 将健康数据**按日/周/月分组展示**
- **分析健康趋势**
- 为用户生成**历史数据图表或报告**

时，推荐使用 `HealthStatisticsCollection`。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthUnit.md
---

# 健康单位（HealthUnit）

`HealthUnit` 类用于表示 HealthKit 中各种度量单位。你可以使用它来构建基本单位（如公斤、米、升等）、带前缀的单位（如毫克、千米等），并支持进行乘法、除法、次方等单位组合运算。

## 枚举：HealthMetricPrefix

表示公制单位前缀：

| 枚举值     | 前缀符号 | 示例         |
| ------- | ---- | ---------- |
| `none`  | -    | gram()     |
| `milli` | m    | milligram  |
| `centi` | c    | centimeter |
| `kilo`  | k    | kilometer  |
| `mega`  | M    | megajoule  |
| `micro` | μ    | microliter |
| `nano`  | n    | nanometer  |

完整枚举见 API 定义。

***

## 1. 创建单位

### 使用静态方法创建基本单位

```ts
const weight = HealthUnit.gram()
const length = HealthUnit.meter()
const energy = HealthUnit.kilocalorie()
```

### 创建带前缀的单位

```ts
const mg = HealthUnit.gramUnit(HealthMetricPrefix.milli)
const km = HealthUnit.meterUnit(HealthMetricPrefix.kilo)
const mL = HealthUnit.literUnit(HealthMetricPrefix.milli)
```

### 从字符串构建单位

```ts
const unit = HealthUnit.fromString('kg')
```

***

## 2. 单位运算

### 单位乘法

用于构建复合单位，例如能量密度、速度单位等。

```ts
const meter = HealthUnit.meter()
const second = HealthUnit.second()
const speedUnit = meter.divided(second)  // 表示 m/s
```

### 单位除法

```ts
const bpm = HealthUnit.count().divided(HealthUnit.minute()) // 次/分钟
```

### 单位乘方

```ts
const m2 = HealthUnit.meter().raisedToPower(HealthMetricPrefix.none) // 平方米
```

### 倒数单位

```ts
const perLiter = HealthUnit.liter().reciprocal() // 表示每升 (1/L)
```

***

## 3. 单位属性

| 属性名          | 类型        | 说明                |
| ------------ | --------- | ----------------- |
| `unitString` | `string`  | 单位的字符串表示，如 `"kg"` |
| `isNull`     | `boolean` | 表示该单位是否为空或无效      |

***

## 4. 与 HealthQuantitySample 联合使用

配合 `HealthUnit`，你可以创建或读取 `HealthQuantitySample` 实例的值。

### 创建样本示例

```ts
const unit = HealthUnit.kilocalorie()

const sample = HealthQuantitySample.create({
  type: 'activeEnergyBurned',
  startDate: new Date('2025-07-04T10:00:00'),
  endDate: new Date('2025-07-04T10:30:00'),
  value: 150,
  unit: unit,
})
```

### 读取样本值（使用自定义单位）

```ts
const valueInJoules = sample.quantityValue(HealthUnit.joule())
```

***

## 5. 常用单位参考

| 类别  | 示例方法                             |
| --- | -------------------------------- |
| 重量  | `gram()`, `ounce()`, `pound()`   |
| 长度  | `meter()`, `inch()`, `mile()`    |
| 体积  | `liter()`, `fluidOunceUS()`      |
| 时间  | `second()`, `minute()`, `hour()` |
| 能量  | `kilocalorie()`, `joule()`       |
| 电压  | `volt()`, `voltUnit(prefix)`     |
| 温度  | `degreeCelsius()`, `kelvin()`    |
| 无量纲 | `percent()`, `count()`           |
| 光照  | `lux()`, `luxUnit(prefix)`       |

***

## 6. 示例：构建复合单位样本

```ts
// 构建一个速率单位 (steps / minute)
const stepsPerMinute = HealthUnit.count().divided(HealthUnit.minute())

const stepSample = HealthQuantitySample.create({
  type: 'stepCount',
  startDate: new Date(),
  endDate: new Date(),
  value: 120,
  unit: stepsPerMinute,
})
```

***

## 7. 示例：单位字符串解析和检查

```ts
const unit = HealthUnit.fromString('g/mL')
console.log(unit.unitString) // 输出: g/mL
console.log(unit.isNull)     // false
```

***

## 8. `Health.preferredUnits()` 方法

用于获取系统或用户在健康应用中为一个或多个 `HealthQuantityType` 设置的**首选显示单位**。此方法可帮助你在界面中展示符合用户习惯的健康数据（例如体重显示为公斤或磅）。

***

### 方法签名

```ts
function preferredUnits(
  quantityTypes: HealthQuantityType[]
): Promise<Record<HealthQuantityType, HealthUnit>>
```

***

### 参数

| 参数名             | 类型                     | 说明                                    |
| --------------- | ---------------------- | ------------------------------------- |
| `quantityTypes` | `HealthQuantityType[]` | 健康数量类型数组，例如 `"bodyMass"`、`"height"` 等 |

***

### 返回值

返回一个 `Promise`，解析后是一个对象 (`Record`)，每个键为 `HealthQuantityType`，对应的值为该类型的 `HealthUnit`（单位），代表用户设置的首选单位。

***

### 错误处理

如果无法获取首选单位，则会抛出异常。

***

### 示例代码

```ts
const types: HealthQuantityType[] = ["bodyMass", "height", "dietaryEnergyConsumed"]

const preferred = await Health.preferredUnits(types)

const bodyMassUnit = preferred["bodyMass"]         // 可能为 kilogram 或 pound
const heightUnit = preferred["height"]             // 可能为 meter 或 inch
const energyUnit = preferred["dietaryEnergyConsumed"] // 可能为 kilocalorie

console.log("用户首选单位：")
console.log("体重：", bodyMassUnit)
console.log("身高：", heightUnit)
console.log("能量摄入：", energyUnit)
```

***

### 使用提示

- 首选单位可能因用户的区域设置或设备偏好而异。
- 若要提供符合用户期望的健康数据展示，建议在界面展示前调用此方法。
- 如果某些类型不被支持，返回的结果中可能会省略对应的键。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthWorkout.md
---

# 健康锻炼数据（HealthWorkout）

`HealthWorkout` 类提供了访问和分析 Apple 健康应用中锻炼数据的接口。每个锻炼实例代表一次完整的锻炼会话，包括活动类型、开始与结束时间、持续时长，以及相关的事件与统计数据。

***

## 使用场景

- 获取用户的锻炼历史记录
- 分析锻炼类型与锻炼时间
- 结合锻炼期间采集的健康数据（如心率、卡路里、距离等）进行评估
- 可视化锻炼过程中的事件（如暂停、恢复、圈数、分段）
- 获取锻炼期间的统计指标，如平均心率或总能量消耗

***

## 属性说明

| 属性名                   | 类型                                                     | 描述                         |
| --------------------- | ------------------------------------------------------ | -------------------------- |
| `uuid`                | `string`                                               | 此锻炼实例的唯一标识符                |
| `workoutActivityType` | `HealthWorkoutActivityType`                            | 此次锻炼的活动类型，如跑步、骑行、游泳、瑜伽等    |
| `startDate`           | `Date`                                                 | 锻炼的开始时间                    |
| `endDate`             | `Date`                                                 | 锻炼的结束时间                    |
| `duration`            | `number`                                               | 锻炼的总时长，单位为秒                |
| `metadata`            | `Record<string, any> \| null`                          | 可选的元数据，如记录来源、设备信息或用户自定义标签等 |
| `workoutEvents`       | `HealthWorkoutEvent[] \| null`                         | 相关锻炼事件，如暂停、恢复、圈数等          |
| `allStatistics`       | `Record<HealthQuantityType, HealthStatistics \| null>` | 每种健康指标对应的统计数据，例如心率、步数、卡路里等 |

***

## 相关类型说明

### `HealthWorkoutActivityType`

表示此次锻炼的具体类型，例如：

- `running`（跑步）
- `walking`（步行）
- `cycling`（骑行）
- `swimming`（游泳）
- `yoga`（瑜伽）
- 等其他 Apple Health 支持的活动类型（参考 `HealthWorkoutActivityType` 文档）

### `HealthWorkoutEvent`

锻炼过程中记录的事件类型，例如：

- 暂停 (`pause`)
- 恢复 (`resume`)
- 运动暂停/恢复 (`motionPaused` / `motionResumed`)
- 圈数标记 (`lap`)
- 分段标记 (`segment`)

### `HealthStatistics`

统计锻炼期间采集到的健康数据，可用的方法包括：

- `averageQuantity()`：平均值
- `sumQuantity()`：总和
- `maximumQuantity()`：最大值
- `minimumQuantity()`：最小值
- `mostRecentQuantity()`：最近一次的值

***

## 示例代码

```ts
function showWorkout(workout: HealthWorkout) {
  console.log(`锻炼 ID: ${workout.uuid}`)
  console.log(`活动类型: ${workout.workoutActivityType}`)
  console.log(`开始时间: ${workout.startDate.toISOString()}`)
  console.log(`结束时间: ${workout.endDate.toISOString()}`)
  console.log(`持续时长: ${(workout.duration / 60).toFixed(1)} 分钟`)

  if (workout.metadata) {
    console.log(`元数据: ${JSON.stringify(workout.metadata)}`)
  }

  if (workout.workoutEvents) {
    for (const event of workout.workoutEvents) {
      console.log(`事件: ${HealthWorkoutEventType[event.type]} 时间: ${event.dateInterval.start.toISOString()}`)
    }
  }

  const stats = workout.allStatistics["heartRate"]
  if (stats) {
    console.log(`平均心率: ${stats.averageQuantity("count/min")} bpm`)
  }
}
```

***

## 补充说明

- `HealthWorkout` 实例通常由类似 `Health.queryWorkouts()` 的方法获取（取决于框架支持的 API）。
- `allStatistics` 属性可快速访问锻炼期间的聚合数据，避免手动查询每个样本。
- `workoutEvents` 可用于还原锻炼过程中的行为轨迹，例如暂停与恢复的时间点。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthWorkoutActivityType.md
---

# 健康锻炼活动类型（HealthWorkoutActivityType）

此枚举定义了所有支持的锻炼活动类型，常用于创建或读取 HealthKit 中的健身记录。

| 枚举值                             | 说明                                       |
| ------------------------------- | ---------------------------------------- |
| `americanFootball`              | 美式足球，常用于高强度的团队对抗训练。                      |
| `archery`                       | 射箭，主要记录手部稳定性与站立时间。                       |
| `australianFootball`            | 澳式足球，类似橄榄球的对抗性运动。                        |
| `badminton`                     | 羽毛球，适合记录轻中强度的有氧运动。                       |
| `baseball`                      | 棒球，包括打击与投球等动作训练。                         |
| `basketball`                    | 篮球，包含有氧、爆发力与跳跃运动。                        |
| `bowling`                       | 保龄球，记录站立、手臂动作与步行。                        |
| `boxing`                        | 拳击，可用于训练或比赛中的身体运动记录。                     |
| `climbing`                      | 攀岩，包括室内外的垂直或攀爬活动。                        |
| `cricket`                       | 板球，一种团队对抗型球类运动。                          |
| `crossTraining`                 | 混合训练，如交叉训练营（CrossFit）。                   |
| `curling`                       | 冰壶运动，滑冰与战术性投掷结合。                         |
| `cycling`                       | 骑自行车，包含室内或户外骑行。                          |
| `dance`                         | 舞蹈类锻炼，含各种风格（如现代舞、街舞）。                    |
| `danceInspiredTraining`         | 灵感舞动训练，如 Zumba、舞动健身。                     |
| `elliptical`                    | 椭圆机训练，常用于有氧耐力锻炼。                         |
| `equestrianSports`              | 马术类活动，如骑马。                               |
| `fencing`                       | 击剑，记录快速的刺击与步伐移动。                         |
| `fishing`                       | 钓鱼，主要用于记录久坐或站立的时长。                       |
| `functionalStrengthTraining`    | 功能性力量训练，例如壶铃、高强度训练。                      |
| `golf`                          | 高尔夫，包括走动与挥杆动作。                           |
| `gymnastics`                    | 体操，包括自由体、平衡木等训练。                         |
| `handball`                      | 手球，一种快速节奏的团队球类运动。                        |
| `hiking`                        | 徒步，适用于山地或自然步道行走。                         |
| `hockey`                        | 冰球或草地曲棍球等。                               |
| `hunting`                       | 狩猎，记录长时间步行和瞄准姿态。                         |
| `lacrosse`                      | 长曲棍球，结合了跑动与投掷。                           |
| `martialArts`                   | 武术，包括空手道、跆拳道等。                           |
| `mindAndBody`                   | 身心结合锻炼，如冥想或气功。                           |
| `mixedMetabolicCardioTraining`  | 混合代谢性有氧训练，通常包含冲刺与恢复交替。                   |
| `paddleSports`                  | 桨类运动，如皮划艇、独木舟。                           |
| `play`                          | 户外活动、自由玩耍等非正式锻炼。                         |
| `preparationAndRecovery`        | 热身或恢复训练，如伸展或泡沫轴。                         |
| `racquetball`                   | 壁球，室内高速球类运动。                             |
| `rowing`                        | 划船运动，含室内划船机或水上划艇。                        |
| `rugby`                         | 英式橄榄球，高对抗强度运动。                           |
| `running`                       | 跑步，含慢跑、快跑、竞赛等。                           |
| `sailing`                       | 帆船运动，结合操作与核心稳定训练。                        |
| `skatingSports`                 | 滑冰运动，如溜冰、滑板。                             |
| `snowSports`                    | 雪上运动，如滑雪、滑雪板。                            |
| `soccer`                        | 足球，广泛应用的有氧和技巧运动。                         |
| `softball`                      | 垒球，类似棒球但球更大。                             |
| `squash`                        | 壁球，快速反应和体能需求高。                           |
| `stairClimbing`                 | 爬楼梯，含楼梯机或实际楼梯。                           |
| `surfingSports`                 | 冲浪类运动，如海浪板。                              |
| `swimming`                      | 游泳，包括蛙泳、自由泳等。                            |
| `tableTennis`                   | 乒乓球，适合反应与协调训练。                           |
| `tennis`                        | 网球，记录对打和挥拍等动作。                           |
| `trackAndField`                 | 田径类项目，如短跑、跳高等。                           |
| `traditionalStrengthTraining`   | 传统力量训练，如举重、哑铃训练。                         |
| `volleyball`                    | 排球，包含场上移动与击球。                            |
| `walking`                       | 步行，适合日常轻强度记录。                            |
| `waterFitness`                  | 水中有氧，如水中舞蹈或操课。                           |
| `waterPolo`                     | 水球，结合游泳与团队战术。                            |
| `waterSports`                   | 各类水上运动，如风筝冲浪、摩托艇。                        |
| `wrestling`                     | 摔跤，包含格斗和摔投动作。                            |
| `yoga`                          | 瑜伽，注重拉伸、呼吸与冥想。                           |
| `barre`                         | 芭蕾塑形，结合舞蹈和力量训练。                          |
| `coreTraining`                  | 核心训练，如平板支撑、卷腹等。                          |
| `crossCountrySkiing`            | 越野滑雪，适合冬季耐力训练。                           |
| `downhillSkiing`                | 高速滑雪，记录滑行与肌群负荷。                          |
| `flexibility`                   | 柔韧性训练，主要用于伸展放松。                          |
| `highIntensityIntervalTraining` | 高强度间歇训练（HIIT）。                           |
| `jumpRope`                      | 跳绳，快速有氧训练。                               |
| `kickboxing`                    | 踢拳训练，结合力量与耐力。                            |
| `pilates`                       | 普拉提，强调核心控制和姿态。                           |
| `snowboarding`                  | 单板滑雪，雪地运动的一种。                            |
| `stairs`                        | 楼梯行走，类似 stair climber 训练机。               |
| `stepTraining`                  | 有氧踏板训练。                                  |
| `wheelchairWalkPace`            | 轮椅行走训练。                                  |
| `wheelchairRunPace`             | 轮椅快跑训练。                                  |
| `taiChi`                        | 太极，柔和节奏，注重呼吸与动静结合。                       |
| `mixedCardio`                   | 混合有氧训练，如跑步与单车交替。                         |
| `handCycling`                   | 手动脚踏车运动。                                 |
| `discSports`                    | 飞盘类运动，如极限飞盘。                             |
| `fitnessGaming`                 | 健身游戏，如 Apple Fitness+、Nintendo Ring Fit。 |
| `cardioDance`                   | 有氧舞蹈，节奏快速、锻炼心肺。                          |
| `socialDance`                   | 社交舞，如交谊舞、探戈。                             |
| `pickleball`                    | 匹克球，结合羽毛球和网球特点。                          |
| `cooldown`                      | 放松运动，帮助心率恢复与身体降温。                        |
| `swimBikeRun`                   | 铁人三项中的综合活动。                              |
| `transition`                    | 比赛中的过渡阶段（如游泳到骑行的切换）。                     |
| `underwaterDiving`              | 潜水运动，如自由潜或水肺潜水。                          |
| `other`                         | 其他无法归类的运动项目。                             |

***

如需在创建 `HealthWorkout` 实例时指定活动类型，可使用：

```ts
const workoutType = HealthWorkoutActivityType.running
```

本枚举与 Apple HealthKit 的 `HKWorkoutActivityType` 保持一致，确保系统对锻炼类型的识别与记录。若需在自定义健身记录中支持更多类型，请参考 [Apple 官方文档](https://developer.apple.com/documentation/healthkit/hkworkoutactivitytype)。



---
url: /v2/zh/guide/Device Capabilities/Health/HealthWorkoutEvent.md
---

# 健康锻炼事件（HealthWorkoutEvent）

`HealthWorkoutEvent` 类用于访问 Apple 健康中记录的锻炼事件。每个事件表示一次锻炼过程中的特定动作或时刻，例如暂停、继续、圈数记录、标记、或自动运动检测。

***

## 使用场景

- 分析锻炼流程：判断用户何时暂停或恢复锻炼。
- 统计锻炼中活跃与静止的时间段。
- 记录跑步、游泳等项目中的圈数。
- 用于可视化锻炼记录和事件时间轴。

***

## 枚举：`HealthWorkoutEventType`

定义了各种类型的锻炼事件。

| 值   | 名称                     | 描述                       |
| --- | ---------------------- | ------------------------ |
| `1` | `pause`                | 用户手动暂停了锻炼。               |
| `2` | `resume`               | 用户在暂停后恢复了锻炼。             |
| `3` | `lap`                  | 表示一圈锻炼结束，常用于跑步、游泳等。      |
| `4` | `marker`               | 一个用户或系统添加的标记点。           |
| `5` | `motionPaused`         | 因无动作被系统自动暂停。             |
| `6` | `motionResumed`        | 系统因检测到动作自动恢复锻炼。          |
| `7` | `segment`              | 表示一个新的锻炼分段开始，常用于间歇训练等场景。 |
| `8` | `pauseOrResumeRequest` | 系统提出的暂停或继续请求，但不一定实际执行。   |

***

## 类：`HealthWorkoutEvent`

### 属性说明

| 属性名            | 类型                            | 描述                                            |
| -------------- | ----------------------------- | --------------------------------------------- |
| `type`         | `HealthWorkoutEventType`      | 当前事件的类型，例如暂停、圈数、自动恢复等。                        |
| `dateInterval` | `HealthDateInterval`          | 该事件发生的时间区间，包含 `start`、`end` 和 `duration`（秒数）。 |
| `metadata`     | `Record<string, any> \| null` | 可选的附加信息，例如记录来源、设备等。                           |

> 说明：`HealthDateInterval` 是一个对象，包含：
>
> - `start: Date`：事件开始时间
> - `end: Date`：事件结束时间
> - `duration: number`：事件持续时间（单位为秒）

***

## 示例代码

### 记录锻炼事件日志

```ts
function logWorkoutEvent(event: HealthWorkoutEvent) {
  const { type, dateInterval, metadata } = event
  const start = dateInterval.start.toISOString()
  const end = dateInterval.end.toISOString()
  const duration = dateInterval.duration

  console.log(`事件类型：${HealthWorkoutEventType[type]}`)
  console.log(`开始时间：${start}`)
  console.log(`结束时间：${end}`)
  console.log(`持续时长（秒）：${duration}`)

  if (metadata) {
    console.log(`元数据：${JSON.stringify(metadata)}`)
  }
}
```

***

## 说明与提示

- `HealthWorkoutEvent` 实例通常包含在 `HealthWorkout` 中的 `events` 数组内。
- 可结合多个事件分析锻炼的完整时序、自动暂停/恢复、间歇训练分段等信息。
- 在无操作或锻炼设备脱离身体时，系统会自动生成 motionPaused / motionResumed 事件。



---
url: /v2/zh/guide/Device Capabilities/Health/Query Statistics Collection.md
---

# 查询统计数据集合（HealthStatisticsCollection）

`Health.queryStatisticsCollection()` 方法用于按时间区间查询指定 `HealthQuantityType` 类型的**聚合统计数据**，例如每天、每周或每月的步数、心率等。它返回一个 `HealthStatisticsCollection` 实例，其中包含多个按时间间隔对齐的 `HealthStatistics` 对象。

此方法非常适合：

- 分析健康趋势
- 构建图表
- 生成历史报告

***

## 方法签名

```ts
function queryStatisticsCollection(
  quantityType: HealthQuantityType,
  options: {
    startDate?: Date
    endDate?: Date
    strictStartDate?: boolean
    strictEndDate?: boolean
    statisticsOptions?: HealthStatisticsOptions | Array<HealthStatisticsOptions>
    anchorDate: Date
    intervalComponents: DateComponents
  }
): Promise<HealthStatisticsCollection>
```

***

## 参数说明

| 参数名称                         | 类型                                | 必填  | 说明                                                                                                                                           |
| ---------------------------- | --------------------------------- | --- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `quantityType`               | `HealthQuantityType`              | Yes | 要查询的健康数据类型，如 `"stepCount"`、`"heartRate"` 等                                                                                                   |
| `options.startDate`          | `Date`                            | No  | 查询范围的起始日期，查询结果不包含此日期之前的数据                                                                                                                    |
| `options.endDate`            | `Date`                            | No  | 查询范围的结束日期，查询结果不包含此日期之后的数据                                                                                                                    |
| `options.strictStartDate`    | `boolean`                         | No  | 若为 `true`，仅包含精确从 `startDate` 开始的区间                                                                                                           |
| `options.strictEndDate`      | `boolean`                         | No  | 若为 `true`，仅包含精确在 `endDate` 结束的区间                                                                                                             |
| `options.statisticsOptions`  | `HealthStatisticsOptions[]` 或单个选项 | No  | 指定要计算的统计类型，可包含： `"cumulativeSum"`, `"discreteAverage"`, `"discreteMin"`, `"discreteMax"`, `"mostRecent"`, `"duration"`, `"separateBySource"` |
| `options.anchorDate`         | `Date`                            | Yes | 用于对齐时间间隔的锚点日期，通常设为当天零点                                                                                                                       |
| `options.intervalComponents` | `DateComponents`                  | Yes | 定义时间间隔，例如每日、每周等。通过 `new DateComponents({ day: 1 })`、`new DateComponents({ weekOfYear: 1 })` 等方式创建                                            |

***

## 返回值

返回一个 `Promise`，解析为 `HealthStatisticsCollection` 对象。该集合按时间间隔组织，每个区间包含一个 `HealthStatistics` 实例。

***

## 示例：获取过去 7 天每日步数统计

```ts
const now = new Date()
const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)

const collection = await Health.queryStatisticsCollection("stepCount", {
  startDate: sevenDaysAgo,
  endDate: now,
  anchorDate: new Date(), // 通常为当天零点
  intervalComponents: new DateComponents({ day: 1 }),
  statisticsOptions: ["cumulativeSum"]
})

const stats = collection.statistics()
for (const stat of stats) {
  const steps = stat.sumQuantity(HealthUnit.count())
  console.log(`从 ${stat.startDate.toDateString()} 开始：${steps} 步`)
}
```

***

## 注意事项

- 如果某个时间区间没有任何样本数据，该区间对应的 `HealthStatistics` 对象可能会返回 `null`。
- 所有统计数据基于 `anchorDate` 对齐，区间由 `intervalComponents` 定义。
- 如果只需查询整个时间范围的汇总统计（不按时间拆分），可使用 `Health.queryStatistics()` 方法代替。



---
url: /v2/zh/guide/Device Capabilities/Health/Query Statistics.md
---

# 查询统计数据（HealthStatistics）

`queryStatistics` 方法用于查询某个健康数量类型在指定时间范围内的**聚合统计数据**，包括：

- 总和（sum）
- 平均值（average）
- 最小值、最大值
- 最近一条记录
- 总持续时间（duration）

你也可以选择**按来源（设备或应用）分开统计**。

此方法非常适合生成**每日、每周或历史健康数据的摘要**。

***

## 方法签名

```ts
function queryStatistics(
  quantityType: HealthQuantityType,
  options?: {
    startDate?: Date
    endDate?: Date
    strictStartDate?: boolean
    strictEndDate?: boolean
    statisticsOptions?: HealthStatisticsOptions | Array<HealthStatisticsOptions>
  }
): Promise<HealthStatistics | null>
```

***

## 参数说明

### `quantityType: HealthQuantityType`（必填）

要查询的健康数量类型，例如：

- `"stepCount"`（步数）
- `"heartRate"`（心率）
- `"bodyMass"`（体重）
- `"activeEnergyBurned"`（活动能量消耗）

请使用支持的 `HealthQuantityType` 值。

***

### `options`（可选）

用于配置查询范围和结果的选项对象：

| 参数名                 | 类型                              | 说明                                  |
| ------------------- | ------------------------------- | ----------------------------------- |
| `startDate`         | `Date`                          | 查询起始时间                              |
| `endDate`           | `Date`                          | 查询结束时间                              |
| `strictStartDate`   | `boolean`                       | 若为 `true`，仅包含从 `startDate` 精确开始的统计项 |
| `strictEndDate`     | `boolean`                       | 若为 `true`，仅包含在 `endDate` 精确结束的统计项   |
| `statisticsOptions` | `HealthStatisticsOptions` 或数组形式 | 指定要包含哪些统计指标（详见下方）                   |

***

## 可用的 `HealthStatisticsOptions`

| 选项名                  | 描述                |
| -------------------- | ----------------- |
| `"cumulativeSum"`    | 总和（适用于步数、卡路里等累计值） |
| `"discreteAverage"`  | 平均值（适用于心率等离散值）    |
| `"discreteMin"`      | 最小值               |
| `"discreteMax"`      | 最大值               |
| `"mostRecent"`       | 最近一条记录的值          |
| `"duration"`         | 所有样本的总持续时间        |
| `"separateBySource"` | 按来源（设备或 App）分开统计  |

***

## 返回值

返回一个 `Promise`，解析为 `HealthStatistics` 对象，或在没有数据时返回 `null`。

你可以通过 `HealthStatistics` 提供的方法来获取聚合值，例如：

- `sumQuantity(...)`
- `averageQuantity(...)`
- `mostRecentQuantity(...)`
- `duration(...)`

***

## 示例：查询每日步数汇总

```ts
const stats = await Health.queryStatistics("stepCount", {
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02"),
  statisticsOptions: ["cumulativeSum", "mostRecent", "duration"]
})

if (stats) {
  const steps = stats.sumQuantity(HealthUnit.count())
  const last = stats.mostRecentQuantity(HealthUnit.count())
  const time = stats.duration(HealthUnit.second())

  console.log("步数：", steps)
  console.log("最近一次记录：", last)
  console.log("总持续时间（秒）：", time)
} else {
  console.log("未找到步数数据")
}
```

***

## 示例：仅查询当前 App 写入的心率平均值

```ts
const stats = await Health.queryStatistics("heartRate", {
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-02"),
  statisticsOptions: ["discreteAverage"]
})

const source = HealthSource.forCurrentApp()
const averageHR = stats?.averageQuantity(HealthUnit.countPerMinute(), source)

console.log("当前 App 的心率平均值：", averageHR)
```

***

## 注意事项

- 如果未指定 `statisticsOptions`，某些字段（如总和、平均值等）可能为 `null`。
- 若需访问原始样本数据，请使用 `Health.queryQuantitySamples()` 方法。
- 可用的统计类型与数据类型相关，例如心率支持 `discreteAverage`，而步数支持 `cumulativeSum`。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Activity Summaries.md
---

# 读取活动摘要（HealthActivitySummary）

Scripting 应用通过全局函数 `Health.queryActivitySummaries()` 提供对 Apple Health 每日活动摘要数据的访问。这些摘要包含 Apple Watch 追踪的 **移动（Move）**、**锻炼（Exercise）** 和 **站立（Stand）** 目标，以及完成情况和历史趋势。

此 API 非常适合在应用中展示每日活动环或分析长期健身趋势。

***

## 什么是活动摘要？

`HealthActivitySummary` 提供一天 Apple Watch 活动的概览：

- **移动（活跃能量消耗）**

  - `activeEnergyBurned(unit: HealthUnit): number`
  - `activeEnergyBurnedGoal(unit: HealthUnit): number`

- **锻炼（分钟）**

  - `appleExerciseTime(unit: HealthUnit): number`
  - `appleExerciseTimeGoal(unit: HealthUnit): number`

- **站立（小时）**

  - `appleStandHours(unit: HealthUnit): number`
  - `appleStandHoursGoal(unit: HealthUnit): number`

- **日期信息**

  - `dateComponents: DateComponents` —— 包含 `year`、`month`、`day` 的 `DateComponents` 对象

***

## API 概览

```ts
Health.queryActivitySummaries(
  options?: {
    start: DateComponents
    end: DateComponents
  }
): Promise<HealthActivitySummary[]>
```

***

## 参数

| 参数      | 类型               | 说明                       |
| ------- | ---------------- | ------------------------ |
| `start` | `DateComponents` | 查询范围的起始日期，仅返回在该日期或之后的摘要。 |
| `end`   | `DateComponents` | 查询范围的结束日期，仅返回在该日期或之前的摘要。 |

> 如果同时省略 `options`，则返回所有可用摘要（受系统限制）。
> 返回的摘要按日期升序排序。

***

## 示例：读取最近 7 天的活动摘要

```ts
async function fetchLastWeek() {
  // 构建日期范围
  const today = new Date()
  const sevenDaysAgo = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() - 6
  )

  const startComponents = DateComponents.fromDate(sevenDaysAgo)
  const endComponents = DateComponents.fromDate(today)

  // 查询活动摘要
  const summaries = await Health.queryActivitySummaries({
    start: startComponents,
    end: endComponents,
  })

  // 遍历并打印每天数据
  for (const summary of summaries) {
    const date = summary.dateComponents.date
    console.log(`日期: ${date?.toDateString()}`)

    const kcal = summary.activeEnergyBurned(HealthUnit.kilocalorie())
    const kcalGoal = summary.activeEnergyBurnedGoal(HealthUnit.kilocalorie())
    const exerciseMin = summary.appleExerciseTime(HealthUnit.minute())
    const standHrs = summary.appleStandHours(HealthUnit.count())

    console.log(` 移动:    ${kcal} / ${kcalGoal} kcal`)
    console.log(` 锻炼:    ${exerciseMin} 分钟`)
    console.log(` 站立:    ${standHrs} 小时`)
    console.log('---')
  }
}

fetchLastWeek()
```

***

## 注意事项

- `DateComponents` 至少需包含 `year`、`month`、`day`，其他字段（如小时、分钟）在日摘要中会被忽略。
- 各项指标方法均返回所指定单位下的原始 `number` 值。
- 使用 `HealthUnit` 工厂方法（如 `kilocalorie()`、`minute()`、`count()`）来指定单位。
- 如果某些日期没有数据（例如 Apple Watch 未佩戴或未同步），则该日期的摘要可能会被省略。

***

## 总结

1. 调用 `Health.queryActivitySummaries({ start, end })` 并传入 `DateComponents` 指定查询范围。
2. 获取按日期升序排列的 `HealthActivitySummary[]`。
3. 调用摘要实例的方法读取移动、锻炼和站立的实际值及目标值。
4. 在 UI 或分析中展示或统计这些数字。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Category Samples.md
---

# 读取分类数据（HealthCategorySample）

Scripting 应用支持通过全局函数 `Health.queryCategorySamples()` 访问 HealthKit 中的**分类健康数据**。分类样本表示某一健康事件或状态的记录，通常包括起止时间和一个离散的状态值，例如：睡眠分析、冥想记录、经期流量、排卵测试结果等。

本文将介绍如何查询、解析并使用这些分类数据。

***

## 什么是 Category Sample？

**Category Sample（分类样本）** 包含以下信息：

- `type`：样本的分类类型（如 `"sleepAnalysis"`、`"mindfulSession"`）
- `startDate` / `endDate`：事件发生的起止时间
- `value`：表示事件状态的整数值，需使用对应的枚举进行解释
- `metadata`：可选的附加信息

常见示例：

- `"sleepAnalysis"` 对应的值可以是 `asleepCore`、`awake`、`inBed`
- `"menstrualFlow"` 对应的值可以是 `mild`、`moderate`、`severe`

***

## API 用法

```ts
Health.queryCategorySamples(
  categoryType: HealthCategoryType,
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "value"
      order?: "forward" | "reverse"
    }>
  }
): Promise<HealthCategorySample[]>
```

***

## 参数说明

| 参数名                                 | 描述                                            |
| ----------------------------------- | --------------------------------------------- |
| `categoryType`                      | 要查询的分类数据类型（如 `"sleepAnalysis"`）               |
| `startDate` / `endDate`             | 筛选结果的时间范围                                     |
| `limit`                             | 返回的最大样本数量                                     |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间                                    |
| `sortDescriptors`                   | 可选排序规则，例如按 `startDate`、`endDate` 或 `value` 排序 |

***

## 示例：读取睡眠分析数据

```ts
const results = await Health.queryCategorySamples("sleepAnalysis", {
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-05T00:00:00"),
  sortDescriptors: [{ key: "startDate", order: "forward" }]
})

for (const sample of results) {
  console.log("开始时间：", sample.startDate)
  console.log("结束时间：", sample.endDate)
  console.log("睡眠状态值：", sample.value) // 需要使用枚举解释该值
}
```

你可以使用对应的枚举来解释 `value` 值：

```ts
switch (sample.value) {
  case HealthCategoryValueSleepAnalysis.awake:
    console.log("清醒")
    break
  case HealthCategoryValueSleepAnalysis.asleepCore:
    console.log("核心睡眠")
    break
  case HealthCategoryValueSleepAnalysis.asleepDeep:
    console.log("深度睡眠")
    break
  case HealthCategoryValueSleepAnalysis.inBed:
    console.log("在床上")
    break
  // 可根据需要继续扩展其他状态
}
```

***

## 示例：读取冥想记录

```ts
const sessions = await Health.queryCategorySamples("mindfulSession", {
  startDate: new Date(Date.now() - 7 * 86400 * 1000) // 最近 7 天
})

console.log(`共找到 ${sessions.length} 条冥想记录`)
```

***

## 注意事项

- 所有返回结果都是 `HealthCategorySample` 实例
- `.value` 是一个整数，需要使用对应类型的枚举进行解释
- `.metadata` 字段为可选，可提供附加信息（如来源、标签等）
- 分类数据适用于建模事件型健康记录，例如睡眠、冥想、生理周期、症状等

***

## 小结

要读取分类样本数据：

1. 调用 `Health.queryCategorySamples(categoryType, options)`
2. 设置时间范围、数量限制、排序方式等参数
3. 使用 `.value` 配合相应枚举来解释数据含义

该 API 提供了对基于事件的健康数据的结构化访问方式，适用于日志展示、趋势分析等场景。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Characteristic Data.md
---

# 读取特征数据

HealthKit 中的 **特征数据** 指的是用户个人的静态属性，如出生日期、生物性别、血型、皮肤类型、是否使用轮椅，以及活动移动模式等。这些信息通常由用户在“健康”App 中设置，属于只读数据。

Scripting 提供了一系列 **全局异步 API** 来读取这些数据。

***

## 支持读取的特征

| 特征名称              | API 调用方式                             | 返回类型                           |
| ----------------- | ------------------------------------ | ------------------------------ |
| 出生日期              | `await Health.dateOfBirth()`         | `DateComponents`               |
| 生物性别              | `await Health.biologicalSex()`       | `HealthBiologicalSex` 枚举       |
| 血型                | `await Health.bloodType()`           | `HealthBloodType` 枚举           |
| 皮肤类型（Fitzpatrick） | `await Health.fitzpatrickSkinType()` | `HealthFitzpatrickSkinType` 枚举 |
| 是否使用轮椅            | `await Health.wheelchairUse()`       | `HealthWheelchairUse` 枚举       |
| 活动移动模式            | `await Health.activityMoveMode()`    | `HealthActivityMoveMode` 枚举    |

***

## 1. 读取出生日期

```ts
const birthDate = await Health.dateOfBirth()
console.log(`出生日期：${birthDate.year}年${birthDate.month}月${birthDate.day}日`)
```

返回值为 `DateComponents` 对象，例如：

```ts
{
  year: 1989,
  month: 7,
  day: 4
}
```

***

## 2. 读取生物性别

```ts
const sex = await Health.biologicalSex()

switch (sex) {
  case HealthBiologicalSex.female:
    console.log("女性")
    break
  case HealthBiologicalSex.male:
    console.log("男性")
    break
  case HealthBiologicalSex.other:
    console.log("其他")
    break
  case HealthBiologicalSex.notSet:
    console.log("未设置")
    break
}
```

***

## 3. 读取血型

```ts
const blood = await Health.bloodType()

switch (blood) {
  case HealthBloodType.aPositive:
    console.log("A型阳性")
    break
  case HealthBloodType.oNegative:
    console.log("O型阴性")
    break
  // 可补充更多类型
  default:
    console.log("未设置")
}
```

***

## 4. 读取皮肤类型（Fitzpatrick）

```ts
const skinType = await Health.fitzpatrickSkinType()

switch (skinType) {
  case HealthFitzpatrickSkinType.I:
    console.log("类型 I：非常白")
    break
  case HealthFitzpatrickSkinType.VI:
    console.log("类型 VI：深褐色至黑色")
    break
  default:
    console.log("未设置")
}
```

***

## 5. 判断是否使用轮椅

```ts
const wheelchair = await Health.wheelchairUse()

if (wheelchair === HealthWheelchairUse.yes) {
  console.log("用户使用轮椅")
} else if (wheelchair === HealthWheelchairUse.no) {
  console.log("用户不使用轮椅")
} else {
  console.log("未设置")
}
```

***

## 6. 读取活动移动模式

```ts
const mode = await Health.activityMoveMode()

if (mode === HealthActivityMoveMode.activeEnergy) {
  console.log("通过活跃能量追踪活动")
} else if (mode === HealthActivityMoveMode.appleMoveTime) {
  console.log("通过 Apple Move Time 追踪活动")
}
```

***

## 错误处理

如果：

- 用户未设置该特征；
- 没有获取权限；
- 设备不支持 HealthKit；

调用 API 时可能抛出异常。建议使用 `try/catch` 进行捕获：

```ts
try {
  const sex = await Health.biologicalSex()
  console.log(sex)
} catch (err) {
  console.error("读取生物性别失败：", err)
}
```

***

## 总结

你可以通过以下全局 API 读取用户的静态健康特征：

```ts
await Health.dateOfBirth()
await Health.biologicalSex()
await Health.bloodType()
await Health.fitzpatrickSkinType()
await Health.wheelchairUse()
await Health.activityMoveMode()
```

这些值来源于用户在健康 App 中的个人设置，通常不会频繁变化。请注意处理未设置或读取失败的情况。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Correlation Data.md
---

# 读取关联数据（HealthCorrelation）

Scripting 应用支持通过全局 API `Health.queryCorrelations()` 查询 HealthKit 中的**相关健康数据**。相关数据用于表示一组相互关联的健康样本，例如：

- 一次血压测量（包含收缩压和舒张压）
- 一次食物摄入记录（包含热量、蛋白质、碳水等）

本文将介绍如何读取相关数据并提取其中的样本信息。

***

## 什么是 Correlation（相关数据）？

Correlation 是将多个健康样本组合成单个事件的数据结构。支持的类型包括：

- `"bloodPressure"`：包含两个数量样本：`bloodPressureSystolic`（收缩压）和 `bloodPressureDiastolic`（舒张压）
- `"food"`：可包含多个营养类样本，如 `dietaryEnergyConsumed`（摄入热量）、`dietaryProtein`（蛋白质）、`dietaryCarbohydrates`（碳水化合物）等

每个 Correlation 包含以下信息：

- 类型（如 `"bloodPressure"`、`"food"`）
- 开始/结束时间
- 元数据（可选）
- 相关的多个样本（QuantitySample 或 CategorySample）

***

## API 用法

```ts
Health.queryCorrelations(
  correlationType: HealthCorrelationType,
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate"
      order?: "forward" | "reverse"
    }>
  }
): Promise<HealthCorrelation[]>
```

***

## 参数说明

| 参数名                                 | 描述                                     |
| ----------------------------------- | -------------------------------------- |
| `correlationType`                   | `"bloodPressure"` 或 `"food"`           |
| `startDate` / `endDate`             | 查询的时间范围                                |
| `limit`                             | 返回的最大条数                                |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间                             |
| `sortDescriptors`                   | 可选的排序规则，支持按 `startDate` 或 `endDate` 排序 |

***

## 示例：读取血压记录

```ts
const correlations = await Health.queryCorrelations("bloodPressure", {
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-02T00:00:00"),
  limit: 5,
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const correlation of correlations) {
  console.log("开始时间：", correlation.startDate)
  console.log("结束时间：", correlation.endDate)

  const systolic = correlation.quantitySamples.find(
    s => s.quantityType === "bloodPressureSystolic"
  )

  const diastolic = correlation.quantitySamples.find(
    s => s.quantityType === "bloodPressureDiastolic"
  )

  if (systolic && diastolic) {
    const sys = systolic.quantityValue(HealthUnit.millimeterOfMercury())
    const dia = diastolic.quantityValue(HealthUnit.millimeterOfMercury())
    console.log(`血压：${sys}/${dia} mmHg`)
  }
}
```

***

## 示例：读取食物摄入记录

```ts
const correlations = await Health.queryCorrelations("food", {
  startDate: new Date(Date.now() - 86400 * 1000), // 最近 24 小时
  limit: 10
})

for (const correlation of correlations) {
  console.log("记录时间：", correlation.startDate)

  for (const sample of correlation.quantitySamples) {
    const unit = sample.quantityType.includes("Energy")
      ? HealthUnit.kilocalorie()
      : HealthUnit.gram()

    const value = sample.quantityValue(unit)
    console.log(`${sample.quantityType}：${value}`)
  }
}
```

***

## 如何访问样本

每个 `HealthCorrelation` 实例中包含以下数组：

- `quantitySamples`：所有数量样本（可含 cumulative / discrete 类型）
- `cumulativeQuantitySamples`：仅累积样本
- `discreteQuantitySamples`：仅离散样本
- `categorySamples`：分类样本（某些类型支持）

你可以通过 `.quantityType` 和 `.quantityValue(unit)` 读取每个样本的具体数值。

***

## 错误处理

```ts
try {
  const results = await Health.queryCorrelations("bloodPressure")
  console.log("共返回", results.length, "条记录")
} catch (err) {
  console.error("查询失败：", err)
}
```

***

## 小结

读取 HealthKit 中的 Correlation 数据的步骤如下：

1. 使用 `Health.queryCorrelations(type, options)` 进行查询；
2. 遍历返回的 `HealthCorrelation` 列表；
3. 使用 `.quantitySamples` 访问每个相关样本；
4. 使用 `.quantityValue(unit)` 获取数值。

该方法适用于读取复合型健康数据（如血压或饮食记录），适合用于统计分析或健康日志记录。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Heartbeat Series Samples.md
---

# 读取心跳序列数据（HealthHeartbeatSeriesSample）

Scripting 应用通过全局函数 `Health.queryHeartbeatSeriesSamples()` 提供对 Apple Health 中**心跳序列数据**的访问。该数据代表 Apple Watch 在锻炼或静息状态下记录的一系列连续心跳间隔（R-R 间隔），可用于分析心律稳定性与频率变化。

每条记录提供该心跳序列的**持续时间、心跳数量**及**元数据**，但**不包含原始的每次间隔时间值**。

***

## 什么是 Heartbeat Series Sample？

每个 `HealthHeartbeatSeriesSample` 对象包含以下字段：

- `uuid`：该样本的唯一标识符
- `sampleType`：样本类型（恒为 `"heartbeatSeries"`）
- `startDate` / `endDate`：记录该序列的时间范围
- `count`：该序列中记录的心跳次数
- `metadata`：可选的附加信息（如记录来源设备、应用等）

> 注意：此接口仅返回摘要信息，不包含每一次心跳的具体间隔值。

***

## API 用法

```ts
Health.queryHeartbeatSeriesSamples(
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate"
      order?: "forward" | "reverse"
    }>
    requestPermissions?: HealthQuantityType[]
  }
): Promise<HealthHeartbeatSeriesSample[]>
```

***

## 参数说明

| 参数名                                 | 描述                                                                     |
| ----------------------------------- | ---------------------------------------------------------------------- |
| `startDate` / `endDate`             | 可选时间范围，用于筛选样本                                                          |
| `limit`                             | 限制返回的最大样本数量                                                            |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间边界                                                           |
| `sortDescriptors`                   | 可选排序方式（如按 `startDate` 或 `endDate` 排序）                                  |
| `requestPermissions`                | 可选请求更多数据类型权限，默认只请求`heartRate`、`heartbeat` 和 `heartRateVariabilitySDNN` |

***

## 示例：读取最近的心跳序列记录

```ts
const results = await Health.queryHeartbeatSeriesSamples({
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-05T00:00:00"),
  limit: 10,
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const sample of results) {
  console.log("UUID:", sample.uuid)
  console.log("开始时间：", sample.startDate)
  console.log("结束时间：", sample.endDate)
  console.log("心跳次数：", sample.count)
  console.log("元数据：", sample.metadata)
  console.log("---")
}
```

***

## 数据说明与限制

- **无法获取每一次心跳的具体间隔时间**，仅可看到总次数和时间范围。

- 如需计算平均心率（BPM），可通过以下方式估算：

  ```ts
  const duration = (sample.endDate.getTime() - sample.startDate.getTime()) / 1000
  const avgBPM = (sample.count / duration) * 60
  ```

- 该 API 不包含间隔异常（如缺失数据、节律中断）信息。

***

## 小结

读取心跳序列数据的流程如下：

1. 使用 `Health.queryHeartbeatSeriesSamples()` 方法进行查询；
2. 可按时间范围、排序或限制数量进行过滤；
3. 遍历返回的 `HealthHeartbeatSeriesSample` 数组；
4. 每个对象包含 `startDate`、`endDate`、`count` 和 `metadata`；
5. 可通过持续时间与总次数计算平均心率。

此 API 适用于分析 Apple Watch 记录的心跳追踪频率，可结合锻炼或其他健康数据进行综合评估。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Quantity Samples.md
---

# 读取数量型数据（HealthQuantitySample）

Scripting 应用支持通过全局 API `Health.queryQuantitySamples()` 查询 HealthKit 中的**数量型健康数据**，例如步数、心率、体重、卡路里、距离等。

本文将介绍如何使用该 API 查询数据样本并解析结果。

***

## 什么是 Quantity Sample？

**Quantity Sample（数量型样本）** 表示某一时间点或时间段内的数值型健康数据。常见类型包括：

- `stepCount`（步数）
- `heartRate`（心率）
- `bodyMass`（体重）
- `activeEnergyBurned`（活动能量消耗）
- `distanceWalkingRunning`（步行/跑步距离）

数据样本可能是：

- **离散数据**（单次测量）
- **累积数据**（时间段内累加值）

***

## API 简介

```ts
Health.queryQuantitySamples(
  quantityType: HealthQuantityType,
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "count"
      order?: "forward" | "reverse"
    }>
  }
): Promise<Array<HealthQuantitySample | HealthCumulativeQuantitySample | HealthDiscreteQuantitySample>>
```

***

## 参数说明

| 参数名                                 | 类型        | 描述                                            |
| ----------------------------------- | --------- | --------------------------------------------- |
| `quantityType`                      | `string`  | 要查询的数据类型，如 `"stepCount"`、`"heartRate"`        |
| `startDate` / `endDate`             | `Date`    | 查询的时间范围                                       |
| `limit`                             | `number`  | 限制返回的最大样本数量                                   |
| `strictStartDate` / `strictEndDate` | `boolean` | 是否严格匹配开始/结束时间                                 |
| `sortDescriptors`                   | `Array`   | 对结果进行排序，可按 `startDate`、`endDate` 或 `count` 排序 |

***

## 示例：读取步数数据

```ts
const results = await Health.queryQuantitySamples("stepCount", {
  startDate: new Date("2025-07-01T00:00:00"),
  endDate: new Date("2025-07-02T00:00:00"),
  limit: 10,
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const sample of results) {
  const value = sample.quantityValue(HealthUnit.count())
  console.log(`步数：${value} 时间：${sample.startDate} ~ ${sample.endDate}`)
}
```

***

## 示例：读取心率数据（单位为 bpm）

```ts
const results = await Health.queryQuantitySamples("heartRate", {
  startDate: new Date(Date.now() - 3600 * 1000) // 最近一小时
})

for (const sample of results) {
  const bpm = sample.quantityValue(
    HealthUnit.count().divided(HealthUnit.minute())
  )
  console.log(`心率：${bpm} bpm 时间：${sample.startDate}`)
}
```

***

## 判断样本类型

返回的样本可能属于以下三种之一：

- `HealthQuantitySample`（基础类）
- `HealthCumulativeQuantitySample`：可调用 `.sumQuantity(unit)`
- `HealthDiscreteQuantitySample`：可调用 `.averageQuantity(unit)`、`.maximumQuantity(unit)` 等

你可以使用 `in` 操作符判断：

```ts
if ("averageQuantity" in sample) {
  const avg = sample.averageQuantity(HealthUnit.count())
  console.log("平均值：", avg)
}
```

***

## 常见类型与推荐单位

| 数据类型                       | 推荐单位                                              |
| -------------------------- | ------------------------------------------------- |
| `"stepCount"`              | `HealthUnit.count()`                              |
| `"heartRate"`              | `HealthUnit.count().divided(HealthUnit.minute())` |
| `"bodyMass"`               | `HealthUnit.gram(HealthMetricPrefix.kilo)`        |
| `"activeEnergyBurned"`     | `HealthUnit.kilocalorie()`                        |
| `"distanceWalkingRunning"` | `HealthUnit.meter()`                              |

***

## 错误处理示例

```ts
try {
  const results = await Health.queryQuantitySamples("stepCount")
  console.log("共返回样本数量：", results.length)
} catch (err) {
  console.error("查询失败：", err)
}
```

***

## 小结

读取数量型样本的流程如下：

1. 调用 `Health.queryQuantitySamples(类型, 查询参数)`
2. 遍历返回结果
3. 使用 `.quantityValue(unit)` 或 `.sumQuantity(unit)` 等方法获取数值

该 API 提供了对时间序列健康数据的强大访问能力，适用于统计、图表和趋势分析等应用场景。



---
url: /v2/zh/guide/Device Capabilities/Health/Reading Workout Samples.md
---

# 读取锻炼数据（HealthWorkout）

Scripting 应用支持通过全局函数 `Health.queryWorkouts()` 从 HealthKit 查询**锻炼记录**。Workout 表示一次完整的身体活动，如跑步、步行、游泳、骑行、力量训练等。

每条锻炼记录包含活动类型、起止时间、持续时间、相关事件以及详细的统计信息（如心率、步数、距离、能量消耗等）。

***

## 什么是 Workout？

每条 `HealthWorkout` 锻炼记录包含以下内容：

- `startDate` / `endDate`：锻炼的起止时间
- `duration`：持续时间（单位：秒）
- `workoutActivityType`：锻炼类型（枚举值，如跑步、步行、瑜伽等）
- `metadata`：可选的附加信息
- `workoutEvents`：可选的事件数组（如暂停、继续、圈数等）
- `allStatistics`：一个包含所有健康指标统计的字典，例如心率、距离、卡路里等

***

## API 用法

```ts
Health.queryWorkouts(
  options?: {
    startDate?: Date
    endDate?: Date
    limit?: number
    strictStartDate?: boolean
    strictEndDate?: boolean
    sortDescriptors?: Array<{
      key: "startDate" | "endDate" | "duration"
      order?: "forward" | "reverse"
    }>
    requestPermissions?: HealthQuantityType[]
  }
): Promise<HealthWorkout[]>
```

***

## 参数说明

| 参数名                                 | 描述                                          |
| ----------------------------------- | ------------------------------------------- |
| `startDate` / `endDate`             | 用于筛选锻炼记录的时间范围（可选）                           |
| `limit`                             | 最大返回条数（可选）                                  |
| `strictStartDate` / `strictEndDate` | 是否严格匹配起止时间                                  |
| `sortDescriptors`                   | 按 `startDate`、`endDate` 或 `duration` 排序（可选） |
| `requestPermissions`                | 申请更多数据类型的权限（可选）                             |

***

## 示例：读取最近的锻炼记录

```ts
const workouts = await Health.queryWorkouts({
  startDate: new Date("2025-07-01"),
  endDate: new Date("2025-07-05"),
  sortDescriptors: [{ key: "startDate", order: "reverse" }]
})

for (const workout of workouts) {
  console.log("锻炼类型：", workout.workoutActivityType)
  console.log("开始时间：", workout.startDate)
  console.log("结束时间：", workout.endDate)
  console.log("持续时间（分钟）：", workout.duration / 60)

  const heartRate = workout.allStatistics["heartRate"]
  const energy = workout.allStatistics["activeEnergyBurned"]

  if (heartRate) {
    const avgHR = heartRate.averageQuantity(HealthUnit.count().divided(HealthUnit.minute()))
    console.log("平均心率：", avgHR)
  }

  if (energy) {
    const kcal = energy.sumQuantity(HealthUnit.kilocalorie())
    console.log("消耗能量（千卡）：", kcal)
  }

  console.log("---")
}
```

***

## 如何读取统计指标

每条锻炼记录的 `allStatistics` 字典包含该锻炼过程中的各种指标统计，例如：

```ts
const stat = workout.allStatistics["heartRate"]
const avg = stat?.averageQuantity(HealthUnit.count().divided(HealthUnit.minute()))
const max = stat?.maximumQuantity(HealthUnit.count().divided(HealthUnit.minute()))
```

常见可用指标包括：

- `"heartRate"`：心率
- `"activeEnergyBurned"`：活跃能量消耗
- `"distanceWalkingRunning"`：步行/跑步距离
- `"stepCount"`：步数

***

## Workout Events（可选事件）

如果记录了事件（如暂停、继续、圈数等），可通过 `workout.workoutEvents` 获取：

```ts
for (const event of workout.workoutEvents || []) {
  console.log("事件类型：", event.type)
  console.log("从：", event.dateInterval.start)
  console.log("到：", event.dateInterval.end)
}
```

事件类型包括：暂停（pause）、继续（resume）、圈数（lap）、分段（segment）等。

***

## 注意事项

- 每条记录都是 `HealthWorkout` 实例
- `workoutActivityType` 是一个枚举，可转换为文本或图标
- 如果 `allStatistics` 中缺少某些指标，说明设备或应用在当时未记录该数据
- 可结合分类数据（如睡眠）或数量数据（如心率）进行完整的活动分析

***

## 小结

读取 Workout 数据的步骤如下：

1. 调用 `Health.queryWorkouts(options)` 获取锻炼记录数组；
2. 可通过时间范围、数量限制、排序方式进行筛选；
3. 通过属性获取锻炼类型、时长等基本信息；
4. 使用 `allStatistics` 获取详细的健康指标；
5. 可选读取 `workoutEvents` 获取锻炼过程中的事件记录。

该 API 非常适用于展示锻炼历史、生成健身日报或绘制活动趋势图等场景。



---
url: /v2/zh/guide/Device Capabilities/Health/Writing Health Category Samples.md
---

# 写入分类数据（HealthCategorySample）

Scripting 应用支持将分类健康数据（如睡眠状态、冥想记录、月经流量、排卵测试结果等）写入 Apple HealthKit。你可以通过 `HealthCategorySample` 类创建分类数据样本，并使用 `Health.saveCategorySample()` 方法将其保存到健康数据库中。

***

## 使用前提

- 确保设备支持 HealthKit：

  ```ts
  if (!Health.isHealthDataAvailable) {
    throw new Error("此设备不支持健康数据。")
  }
  ```

- 确保脚本具备目标分类数据类型的写入权限。Scripting 会在首次保存时自动请求授权。

***

## 一、创建 `HealthCategorySample` 实例

使用 `HealthCategorySample.create()` 方法创建分类数据样本。

### 参数说明

| 参数          | 类型                        | 描述                                                                   |
| ----------- | ------------------------- | -------------------------------------------------------------------- |
| `type`      | `HealthCategoryType`      | 要写入的分类类型，例如 `"sleepAnalysis"`、`"mindfulSession"`、`"menstrualFlow"` 等 |
| `startDate` | `Date`                    | 分类事件的开始时间                                                            |
| `endDate`   | `Date`                    | 分类事件的结束时间                                                            |
| `value`     | 对应的枚举值                    | 表示该分类状态的枚举值，需根据具体类型使用相应枚举                                            |
| `metadata`  | `Record<string, any>`（可选） | 可选的元数据，用于标记数据来源或附加信息                                                 |

### 枚举值说明

- 不同类型的分类数据需要传入不同的枚举类型：

  - 对于 `"sleepAnalysis"`，应使用 `HealthCategoryValueSleepAnalysis` 枚举，如：

    - `HealthCategoryValueSleepAnalysis.asleepCore`
    - `HealthCategoryValueSleepAnalysis.awake`

  - 对于 `"menstrualFlow"`，应使用 `HealthCategoryValueSeverity` 枚举，如：

    - `HealthCategoryValueSeverity.mild`、`moderate`、`severe`

  请参考具体分类类型所支持的枚举列表。

***

### 示例代码

```ts
const sample = HealthCategorySample.create({
  type: "sleepAnalysis",
  startDate: new Date("2025-07-03T23:00:00"),
  endDate: new Date("2025-07-04T07:00:00"),
  value: HealthCategoryValueSleepAnalysis.asleepCore,
  metadata: {
    source: "ScriptingApp"
  }
})

if (!sample) {
  throw new Error("创建 HealthCategorySample 失败")
}
```

***

## 二、保存样本到 HealthKit

使用 `Health.saveCategorySample()` 方法将创建的样本写入 HealthKit：

```ts
await Health.saveCategorySample(sample)
```

如果保存失败（如权限不足），该方法将抛出错误。

***

## 完整示例

```ts
async function writeSleepData() {
  const sample = HealthCategorySample.create({
    type: "sleepAnalysis",
    startDate: new Date("2025-07-03T23:00:00"),
    endDate: new Date("2025-07-04T07:00:00"),
    value: HealthCategoryValueSleepAnalysis.asleepCore,
  })

  if (!sample) {
    console.error("创建样本失败")
    return
  }

  try {
    await Health.saveCategorySample(sample)
    console.log("睡眠数据写入成功")
  } catch (err) {
    console.error("保存失败：", err)
  }
}

writeSleepData()
```

***

## 注意事项

- `value` 参数必须是指定 `type` 类型对应的合法枚举值，否则创建将失败。
- `startDate` 与 `endDate` 应表示事件的发生时间段，例如一次睡眠或一次冥想。
- `metadata` 是可选的，适用于添加数据来源或标识用途。



---
url: /v2/zh/guide/Device Capabilities/Health/Writing Health Correlation Data.md
---

# 写入关联数据（HealthCorrelation）

Scripting 应用允许你使用全局 API `HealthCorrelation.create()` 和 `Health.saveCorrelation()` 向 Apple HealthKit 写入**相关健康数据**。相关数据表示多个健康样本之间的逻辑关联，例如：

- 一次血压测量同时包含收缩压和舒张压；
- 一次进食记录同时包含卡路里、蛋白质、碳水等多种营养成分。

本文档将说明如何创建和保存相关样本。

***

## 什么是 Correlation（相关数据）？

Correlation 是一种将多个健康样本聚合为一个事件的机制，目前支持以下类型：

- `"bloodPressure"`：包含 `"bloodPressureSystolic"`（收缩压）和 `"bloodPressureDiastolic"`（舒张压）两个样本
- `"food"`：可以包含热量、蛋白质、脂肪、碳水化合物等营养成分的样本

***

## 一、创建关联的 QuantitySample

在创建相关数据前，需要先创建各个组成的 `HealthQuantitySample` 实例。

### 示例：血压测量数据

```ts
const systolic = HealthQuantitySample.create({
  type: "bloodPressureSystolic",
  startDate: new Date(),
  endDate: new Date(),
  value: 120,
  unit: HealthUnit.millimeterOfMercury()
})

const diastolic = HealthQuantitySample.create({
  type: "bloodPressureDiastolic",
  startDate: new Date(),
  endDate: new Date(),
  value: 80,
  unit: HealthUnit.millimeterOfMercury()
})
```

请确保创建成功（返回值不为 `null`）后再继续。

***

## 二、创建 Correlation 实例

使用 `HealthCorrelation.create()` 创建相关数据对象。

### 参数说明

| 参数          | 类型                                                      | 描述           |   |
| ----------- | ------------------------------------------------------- | ------------ | - |
| `type`      | `"bloodPressure"` 或 `"food"`                            | 相关类型         |   |
| `startDate` | `Date`                                                  | 事件开始时间       |   |
| `endDate`   | `Date`                                                  | 事件结束时间       |   |
| `objects`   | `(HealthQuantitySample      \| HealthCategorySample)[]` | 包含的健康样本数组    |   |
| `metadata`  | `Record<string, any>`（可选）                               | 附加元数据（如来源说明） |   |

### 示例

```ts
const correlation = HealthCorrelation.create({
  type: "bloodPressure",
  startDate: systolic.startDate,
  endDate: systolic.endDate,
  objects: [systolic, diastolic],
  metadata: {
    source: "ScriptingApp"
  }
})

if (!correlation) {
  throw new Error("创建 Correlation 失败")
}
```

***

## 三、保存到 HealthKit

使用 `Health.saveCorrelation()` 将创建的相关数据写入 HealthKit：

```ts
await Health.saveCorrelation(correlation)
```

***

## 完整示例：写入一次血压记录

```ts
async function writeBloodPressure() {
  const systolic = HealthQuantitySample.create({
    type: "bloodPressureSystolic",
    startDate: new Date(),
    endDate: new Date(),
    value: 120,
    unit: HealthUnit.millimeterOfMercury()
  })

  const diastolic = HealthQuantitySample.create({
    type: "bloodPressureDiastolic",
    startDate: new Date(),
    endDate: new Date(),
    value: 80,
    unit: HealthUnit.millimeterOfMercury()
  })

  if (!systolic || !diastolic) {
    console.error("样本创建失败")
    return
  }

  const correlation = HealthCorrelation.create({
    type: "bloodPressure",
    startDate: systolic.startDate,
    endDate: systolic.endDate,
    objects: [systolic, diastolic],
    metadata: {
      note: "手动记录"
    }
  })

  if (!correlation) {
    console.error("Correlation 创建失败")
    return
  }

  try {
    await Health.saveCorrelation(correlation)
    console.log("血压数据写入成功")
  } catch (err) {
    console.error("保存失败：", err)
  }
}

writeBloodPressure()
```

***

## 注意事项

- 所有样本的时间范围（startDate / endDate）应一致或合理重叠；
- `"bloodPressure"` 类型必须包含 **收缩压** 和 **舒张压** 两个样本；
- `"food"` 类型可包含多个营养成分样本，如：

  - `"dietaryEnergyConsumed"` → `HealthUnit.kilocalorie()`
  - `"dietaryProtein"` → `HealthUnit.gram()`
  - `"dietaryCarbohydrates"` → `HealthUnit.gram()`
- 如果传入的参数不合法或缺少必要样本，`HealthCorrelation.create()` 将返回 `null`。



---
url: /v2/zh/guide/Device Capabilities/Health/Writing Health Quantity Samples.md
---

# 写入数量型数据（HealthQuantitySample）

Scripting 应用支持将数量型健康数据（例如步数、心率、体重、卡路里等）写入 Apple 的 HealthKit。你可以使用 `HealthQuantitySample` 类创建数据样本，并通过 `Health.saveQuantitySample()` 方法保存到健康数据库中。

## 使用前提

- 确保设备支持 HealthKit：

  ```ts
  if (!Health.isHealthDataAvailable) {
    throw new Error("此设备不支持健康数据。")
  }
  ```

- 脚本需要具备对目标数据类型的写入权限。当你调用保存 API 时，Scripting 会自动检查并请求所需权限。

***

## 一、创建 `HealthQuantitySample` 实例

使用 `HealthQuantitySample.create()` 方法创建一个数量型数据样本。

### 参数说明

| 参数          | 类型                       | 描述                                                                     |
| ----------- | ------------------------ | ---------------------------------------------------------------------- |
| `type`      | `HealthQuantityType`     | 要写入的数据类型，如 `"stepCount"`（步数）、`"heartRate"`（心率）、`"bodyMass"`（体重）等       |
| `startDate` | `Date`                   | 样本的开始时间                                                                |
| `endDate`   | `Date`                   | 样本的结束时间                                                                |
| `value`     | `number`                 | 健康数据的数值                                                                |
| `unit`      | `HealthUnit`             | 数据单位，如 `HealthUnit.count()`、`HealthUnit.gram(HealthMetrixPrefix.kilo)` |
| `metadata`  | `Record<string, any>` 可选 | 元数据，例如来源信息                                                             |

### 示例

```ts
const sample = HealthQuantitySample.create({
  type: "stepCount",
  startDate: new Date("2025-07-03T08:00:00"),
  endDate: new Date("2025-07-03T09:00:00"),
  value: 1200,
  unit: HealthUnit.count(),
  metadata: {
    source: "ScriptingApp"
  }
})

if (!sample) {
  throw new Error("创建 HealthQuantitySample 失败")
}
```

***

## 二、保存样本到 HealthKit

创建完样本后，调用 `Health.saveQuantitySample()` 将其写入健康数据：

```ts
await Health.saveQuantitySample(sample)
```

如果写入失败（例如权限不足），此方法将抛出错误。

***

## 完整示例

```ts
async function writeStepCount() {
  const sample = HealthQuantitySample.create({
    type: "stepCount",
    startDate: new Date("2025-07-03T08:00:00"),
    endDate: new Date("2025-07-03T09:00:00"),
    value: 1200,
    unit: HealthUnit.count(),
  })

  if (!sample) {
    console.error("创建样本失败")
    return
  }

  try {
    await Health.saveQuantitySample(sample)
    console.log("步数数据写入成功")
  } catch (err) {
    console.error("写入失败：", err)
  }
}

writeStepCount()
```

***

## 注意事项

- 请确保 `unit` 与 `type` 类型匹配，例如：

  - `"stepCount"` → `HealthUnit.count()`
  - `"bodyMass"` → `HealthUnit.gram(HealthMetrixPrefix.kilo)`
  - `"heartRate"` → `HealthUnit.count().divided(HealthUnit.minute())`
- 对于累计类数据（如步数、距离），`startDate` 和 `endDate` 应表示数据的记录时间段。



---
url: /v2/zh/guide/Device Capabilities/Keychain.md
---

# 钥匙串

`Keychain` 提供对系统钥匙串（Keychain）的安全访问接口，用于在 **Scripting 脚本环境中安全、持久地存储敏感数据**，典型用途包括：

- 登录凭证
- Token
- 许可证信息
- 订阅状态
- 加密密钥
- 用户隐私数据

所有数据均使用系统级 Keychain 安全机制存储，具备高安全性与持久性。

***

## 一、Keychain 的脚本作用域隔离规则

在 Scripting 中，`Keychain` 采用 **按脚本隔离（Per-Script Sandbox）** 的安全模型：

### 1. 作用域规则

- **每一个脚本拥有独立的 Keychain 作用域**

- 每个脚本 **只能访问自己写入的 Keychain 数据**

- 不同脚本之间：

- 即使 Key 名相同

- 即使 `synchronizable: true`

- 也 **无法互相读取或覆盖数据**

- 脚本被视为独立安全单元

***

### 2. 该规则的安全意义

该设计确保：

- 不同脚本之间的数据完全隔离
- 防止第三方脚本窃取用户隐私数据
- 防止恶意脚本读取登录态、订阅状态、授权信息
- 提供比系统 Keychain 更细粒度的安全隔离层

***

### 3. 脚本卸载对 Keychain 的影响

- 当脚本被删除后：

  - 该脚本作用域下的 Keychain 数据将被系统回收
- 其他脚本的数据不会受到任何影响

***

## 二、API 命名空间

```ts
namespace Keychain
```

***

## 三、支持的数据类型

`Keychain` 支持以下三种数据类型：

| 类型    | 写入        | 读取        |
| ----- | --------- | --------- |
| 字符串   | `set`     | `get`     |
| 布尔值   | `setBool` | `getBool` |
| 二进制数据 | `setData` | `getData` |

***

## 四、KeychainAccessibility 可访问性策略

```ts
type KeychainAccessibility =
  | 'passcode'
  | 'unlocked'
  | 'unlocked_this_device'
  | 'first_unlock'
  | 'first_unlock_this_device'
```

| 值                          | 说明                  |
| -------------------------- | ------------------- |
| `passcode`                 | 仅在设备设置锁屏密码时可访问，不会迁移 |
| `unlocked`                 | 仅在设备解锁状态下可访问        |
| `unlocked_this_device`     | 仅限本设备访问，不会迁移        |
| `first_unlock`             | 重启后首次解锁即可访问         |
| `first_unlock_this_device` | 重启后首次解锁即可访问，不会迁移    |

默认值：

```ts
accessibility: "unlocked"
```

***

## 五、iCloud 同步（synchronizable）

```ts
synchronizable?: boolean
```

| 值       | 说明                 |
| ------- | ------------------ |
| `true`  | 在同一 Apple ID 设备间同步 |
| `false` | 仅存储在本设备            |

默认值：

```ts
synchronizable: false
```

***

## 六、写入数据

### 1. 写入字符串

```ts
Keychain.set(key: string, value: string, options?): boolean
```

```ts
Keychain.set("token", "abcdef")
```

```ts
Keychain.set("token", "abcdef", {
  accessibility: "first_unlock",
  synchronizable: true
})
```

***

### 2. 写入布尔值

```ts
Keychain.setBool(key: string, value: boolean, options?): boolean
```

```ts
Keychain.setBool("is_login", true)
```

***

### 3. 写入二进制数据

```ts
Keychain.setData(key: string, value: Data, options?): boolean
```

```ts
Keychain.setData("avatar", imageData)
```

***

### 4. 覆盖规则

- Key 已存在时会自动覆盖
- 成功返回 `true`
- 失败返回 `false`

***

## 七、读取数据

### 字符串

```ts
Keychain.get(key: string, options?): string | null
```

### 布尔值

```ts
Keychain.getBool(key: string, options?): boolean | null
```

### 二进制数据

```ts
Keychain.getData(key: string, options?): Data | null
```

***

## 八、删除数据

```ts
Keychain.remove(key: string, options?): boolean
```

- Key 存在：删除并返回 `true`
- Key 不存在：安全返回 `true`

***

## 九、是否存在

```ts
Keychain.contains(key: string, options?): boolean
```

***

## 十、获取所有 Key

```ts
Keychain.keys(options?): string[]
```

***

## 十一、清空 Keychain

```ts
Keychain.clear(options?): boolean
```

- 仅清空当前脚本作用域内的数据
- 不影响其他脚本
- 不影响 App 自身或其他 App 的系统 Keychain 数据

***

## 十二、synchronizable 的读写一致性规则

如果某 Key 使用：

```ts
synchronizable: true
```

则后续所有操作必须带相同参数：

```ts
Keychain.set("token", "abc", { synchronizable: true })

Keychain.get("token") // 读取不到
Keychain.get("token", { synchronizable: true }) // 可读取
```

***

## 十三、安全性与使用建议

### 适合存储的数据

- 登录 Token
- 订阅与授权状态
- 用户唯一标识
- 加密密钥

### 不建议存储

- 大体积文件
- 高频变化的缓存数据
- 可公开的普通配置

***

## 十四、典型使用示例

```ts
// 写入
Keychain.set("token", "abcdef")
Keychain.setBool("is_login", true)
Keychain.setData("avatar", avatarData)

// 读取
const token = Keychain.get("token")
const isLogin = Keychain.getBool("is_login")
const avatar = Keychain.getData("avatar")

// 删除
Keychain.remove("token")

// 判断是否存在
Keychain.contains("token")

// 获取所有 Key
Keychain.keys()

// 清空
Keychain.clear()
```



---
url: /v2/zh/guide/Device Capabilities/LocalAuth.md
---

# 本地认证

`LocalAuth` API 是一个 iOS 本地认证框架的封装，用于在 Scripting 应用的脚本中启用生物识别或密码认证。本文档介绍了如何高效使用 `LocalAuth` API。

## 概览

`LocalAuth` 模块提供了检查认证可用性和执行用户认证的方法和属性。它支持的生物识别包括 Face ID、Touch ID 和 Optic ID，并提供密码作为备选方案。

***

## 属性

### `LocalAuth.isAvailable`

- **类型：** `boolean`
- **描述：** 表示是否可以使用任何可用的认证策略进行认证。
- **示例：**
  ```tsx
  if (LocalAuth.isAvailable) {
    console.log("认证功能可用。")
  } else {
    console.log("认证功能不可用。")
  }
  ```

### `LocalAuth.isBiometricsAvailable`

- **类型：** `boolean`
- **描述：** 表示是否可以使用生物识别认证。
- **示例：**
  ```tsx
  if (LocalAuth.isBiometricsAvailable) {
    console.log("生物识别认证可用。")
  } else {
    console.log("生物识别认证不可用。")
  }
  ```

### `LocalAuth.biometryType`

- **类型：** `LocalAuthBiometryType`
- **描述：** 指定设备支持的生物识别认证类型。可能的值包括：
  - `"faceID"`
  - `"touchID"`
  - `"opticID"`
  - `"none"`
  - `"unknown"`
- **示例：**
  ```tsx
  const biometry = LocalAuth.biometryType
  console.log(`生物识别类型：${biometry}`)
  ```

***

## 方法

### `LocalAuth.authenticate(reason: string, useBiometrics?: boolean): Promise<boolean>`

- **描述：** 使用可用的生物识别或备选方法（如密码）对用户进行认证。返回一个 Promise，当认证成功时解析为 `true`，认证失败时解析为 `false`。
- **参数：**
  - `reason`（string）：向用户提示认证时显示的消息。此消息不能为空。例如：`'请认证以访问 MyScript。'`
  - `useBiometrics`（boolean，可选）：默认值为 `true`。如果为 `true`，则方法使用生物识别认证；否则，允许使用生物识别或备选方法（如密码）。
- **示例：**
  ```tsx
  async function authenticateUser() {
    const reason = "请认证以访问 MyScript。"
    const result = await LocalAuth.authenticate(reason, true)
    if (result) {
      console.log("认证成功。")
    } else {
      console.log("认证失败。")
    }
  }

  authenticateUser()
  ```

***

## 使用示例

### 检查生物识别可用性

```tsx
if (LocalAuth.isBiometricsAvailable) {
  console.log("设备支持生物识别认证。")
  console.log(`生物识别类型：${LocalAuth.biometryType}`)
} else {
  console.log("设备不支持生物识别认证。")
}
```

### 使用生物识别认证

```tsx
async function accessSecureData() {
  const authenticated = await LocalAuth.authenticate(
    "请认证以访问安全数据。"
  )
  if (authenticated) {
    console.log("访问已授权。")
  } else {
    console.log("访问被拒绝。")
  }
}

accessSecureData()
```

### 回退到密码认证

```tsx
async function authenticateWithFallback() {
  const authenticated = await LocalAuth.authenticate(
    "请认证以继续。",
    false // 允许生物识别或密码认证
  )
  console.log(authenticated ? "认证成功" : "认证失败")
}

authenticateWithFallback()
```

***

## 注意事项

- 始终在 `reason` 参数中提供有意义的消息，帮助用户理解为什么需要认证。
- 在调用 `LocalAuth.authenticate` 之前，使用 `LocalAuth.isAvailable` 和 `LocalAuth.isBiometricsAvailable` 检查认证选项的可用性。
- 优雅地处理认证成功和失败的情况，为用户提供无缝体验。



---
url: /v2/zh/guide/Device Capabilities/Location.md
---

# 定位

全局 `Location` API 提供对设备地理位置信息的访问能力，包括一次性定位、逆地理编码、用户手动选点、定位精度控制、以及用于小组件的权限检测等功能。

***

## 功能概览

你可以通过该 API 实现以下功能：

- 获取设备当前位置（支持缓存）
- 用户通过地图界面手动选择位置
- 将经纬度转换为可读的地址（逆地理编码）
- 设置定位精度（耗电量和等待时间可控）
- 检查小组件是否获得定位权限

> **注意：** 该 API 为全局 API，无需额外导入。

***

## 接口文档

### `Location.isAuthorizedForWidgetUpdates(): Promise<boolean>`

检查小组件是否拥有获取定位更新的权限。

```ts
const isAuthorized = await Location.isAuthorizedForWidgetUpdates()
if (!isAuthorized) {
  console.log("小组件没有获取定位的权限")
}
```

***

### `Location.setAccuracy(accuracy: LocationAccuracy): Promise<void>`

设置期望的定位精度。精度越高，耗电和等待时间也可能增加。

#### 可选值

| 精度值                 | 描述      |
| ------------------- | ------- |
| `"best"`            | 最高可用精度  |
| `"tenMeters"`       | 10 米以内  |
| `"hundredMeters"`   | 100 米以内 |
| `"kilometer"`       | 1 公里以内  |
| `"threeKilometers"` | 3 公里以内  |

```ts
await Location.setAccuracy("hundredMeters")
```

***

### `Location.requestCurrent(options?: { forceRequest?: boolean }): Promise<LocationInfo | null>`

请求一次设备当前的位置信息。

默认情况下，如果存在缓存位置（例如启动时从系统获取到的位置），将立即返回该缓存值。如果未缓存，则会触发新的定位请求。

你可以通过传入 `{ forceRequest: true }` 强制跳过缓存，始终发起新请求。

#### 参数

| 参数名            | 类型        | 是否必填 | 描述                          |
| -------------- | --------- | ---- | --------------------------- |
| `forceRequest` | `boolean` | 否    | 若为 `true`，将忽略缓存，始终发起新的定位请求。 |

```ts
const location = await Location.requestCurrent({ forceRequest: true })
if (location) {
  console.log("纬度:", location.latitude)
  console.log("经度:", location.longitude)
  console.log("时间戳:", location.timestamp)
}
```

***

### `Location.pickFromMap(): Promise<LocationInfo | null>`

打开内置地图界面，允许用户手动选择一个位置。

```ts
const selected = await Location.pickFromMap()
if (selected) {
  console.log("用户选择的位置:", selected.latitude, selected.longitude)
}
```

***

### `Location.reverseGeocode(options): Promise<LocationPlacemark[] | null>`

将经纬度转换为人类可读的地理信息（如街道、城市、国家等）。

#### 参数

| 字段          | 类型       | 是否必填 | 描述                             |
| ----------- | -------- | ---- | ------------------------------ |
| `latitude`  | `number` | 是    | 纬度（单位：度）                       |
| `longitude` | `number` | 是    | 经度（单位：度）                       |
| `locale`    | `string` | 否    | 可选语言区域（如 `"zh-CN"`），默认使用设备语言设置 |

```ts
const placemarks = await Location.reverseGeocode({
  latitude: 31.2304,
  longitude: 121.4737,
  locale: "zh-CN"
})

if (placemarks?.length) {
  const place = placemarks[0]
  console.log("城市:", place.locality)
  console.log("国家:", place.country)
}
```

***

## 类型定义

### `LocationAccuracy`

表示定位精度选项：

```ts
type LocationAccuracy =
  | "best"
  | "tenMeters"
  | "hundredMeters"
  | "kilometer"
  | "threeKilometers"
```

***

### `LocationInfo`

表示一个带有时间戳的地理坐标点：

```ts
type LocationInfo = {
  /**
   * 纬度，单位：度
   */
  latitude: number
  /**
   * 经度，单位：度
   */
  longitude: number
  /**
   * 获取该位置的时间戳（单位：毫秒）
   */
  timestamp: number
}
```

***

### `LocationPlacemark`

表示一个可读的地理位置，通常由逆地理编码返回，包含详细的地址结构信息：

```ts
type LocationPlacemark = {
  location?: LocationInfo
  region?: string
  timeZone?: string
  name?: string
  thoroughfare?: string
  subThoroughfare?: string
  locality?: string
  subLocality?: string
  administrativeArea?: string
  subAdministrativeArea?: string
  postalCode?: string
  isoCountryCode?: string
  country?: string
  inlandWater?: string
  ocean?: string
  areasOfInterest?: string[]
}
```

#### 字段说明

| 字段                      | 类型             | 描述                                |
| ----------------------- | -------------- | --------------------------------- |
| `location`              | `LocationInfo` | 坐标点信息（通常等于请求的经纬度）                 |
| `region`                | `string`       | 区域名，如省/州                          |
| `timeZone`              | `string`       | 时区标识（如 `"Asia/Shanghai"`）         |
| `name`                  | `string`       | 地点名称，如建筑物、地标等                     |
| `thoroughfare`          | `string`       | 街道名称，如 `"中关村大街"`                  |
| `subThoroughfare`       | `string`       | 详细地址，如门牌号                         |
| `locality`              | `string`       | 城市或镇                              |
| `subLocality`           | `string`       | 区、街道等子区域                          |
| `administrativeArea`    | `string`       | 省份、州或其他一级行政区域                     |
| `subAdministrativeArea` | `string`       | 县、区等次级行政区域                        |
| `postalCode`            | `string`       | 邮政编码                              |
| `isoCountryCode`        | `string`       | 国家代码（ISO 3166-1 alpha-2，如 `"CN"`） |
| `country`               | `string`       | 国家全名，如 `"中国"`                     |
| `inlandWater`           | `string`       | 附近的内陆水体名称，如湖泊、河流                  |
| `ocean`                 | `string`       | 附近的海洋名称                           |
| `areasOfInterest`       | `string[]`     | 附近的兴趣点/地标数组，如 `"东方明珠"`            |

***

## 示例用法

### 逆地理编码

```ts
const placemarks = await Location.reverseGeocode({
  latitude: 39.9042,
  longitude: 116.4074,
  locale: "zh-CN"
})

if (placemarks?.length) {
  const place = placemarks[0]
  console.log("国家:", place.country)
  console.log("城市:", place.locality)
  console.log("街道:", place.thoroughfare, place.subThoroughfare)
  console.log("地标名称:", place.name)
  console.log("邮编:", place.postalCode)
  console.log("兴趣点:", place.areasOfInterest?.join(", "))
}
```

***

### 地址格式化工具

```ts
function formatAddress(p: LocationPlacemark): string {
  return [
    p.country,
    p.administrativeArea,
    p.locality,
    p.subLocality,
    p.thoroughfare,
    p.subThoroughfare
  ].filter(Boolean).join(", ")
}
```

***

## 最佳实践与使用建议

- 使用 `areasOfInterest` 和 `name` 显示更友好的位置信息（如地标名）
- 使用 `postalCode`、`locality`、`administrativeArea` 自动填写表单或记录标签
- 使用 `timestamp` 判断位置数据是否新鲜
- 使用 `timeZone` 进行本地时间转换或事件提醒
- 在调用 `requestCurrent` 前使用 `setAccuracy` 控制精度
- 对小组件使用 `isAuthorizedForWidgetUpdates()` 检查权限

***

## 说明

- 逆地理编码可能返回多个结果，通常第一个最相关
- 若获取失败，API 将返回 `null`
- 若未强制刷新，系统会优先使用缓存位置，响应更快
- 小组件受限于系统权限机制，务必检测权限状态



---
url: /v2/zh/guide/Device Capabilities/MediaComposer/MediaComposer Example.md
---

# MediaComposer 示例

本示例演示如何使用 `MediaComposer` 将 **视频 + 图片 + 音频** 组合成一个最终视频文件，并导出到脚本目录中。

示例流程包括：

1. 选择音频文件
2. 选择一张图片
3. 选择一个视频
4. 构建视频时间线（Video + Image）
5. 在指定时间点插入音频
6. 导出合成后的视频

***

## 示例代码

```tsx
import { Path, Script } from "scripting"

console.present().then(() => Script.exit())

async function run() {
  try {

    const audioPath = (await DocumentPicker.pickFiles({
      types: ["public.audio"]
    })).at(0)

    if (audioPath == null) {
      console.error("no audio")
      return
    }

    console.log("Audio Picked")

    const imageResult = (await Photos.pick({
      filter: PHPickerFilter.images()
    })).at(0)

    const imagePath = await imageResult?.itemProvider.loadFilePath("public.image")

    if (!imagePath) {
      console.log("No image")
      return
    }

    console.log("Image picked")

    const videoResult = (await Photos.pick({
      filter: PHPickerFilter.videos()
    })).at(0)

    const videoPath = await videoResult?.itemProvider.loadFilePath("public.movie")

    if (videoPath == null) {
      console.log("No video")
      return
    }

    console.log("Video Picked")

    console.log("Start composing...")

    const exportPath = Path.join(
      Script.directory,
      "dest.mp4"
    )

    const exportResult = await MediaComposer.composeAndExport({
      exportPath,
      timeline: {
        videoItems: [{
          videoPath: videoPath
        }, {
          imagePath: imagePath,
          duration: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }],
        audioClips: [{
          path: audioPath,
          at: MediaTime.make({
            seconds: 5,
            preferredTimescale: 600
          })
        }]
      }
    })

    console.log(
      "Result:",
      exportResult.exportPath,
      "\n",
      exportResult.duration.getSeconds()
    )

  } catch (e) {
    console.error(e)
  }
}

run()
```

***

## 时间线解析

### 视频 / 图片时间线（videoItems）

```ts
videoItems: [
  { videoPath },
  {
    imagePath,
    duration: MediaTime.make({
      seconds: 5,
      preferredTimescale: 600
    })
  }
]
```

- 第一个 `VideoItem` 是完整视频
- 第二个 `VideoItem` 是一张图片，显示 5 秒
- 所有 `videoItems` **按顺序依次拼接**
- 最终视频总时长 = 视频时长 + 图片 5 秒

***

### 音频时间线（audioClips）

```ts
audioClips: [{
  path: audioPath,
  at: MediaTime.make({
    seconds: 5,
    preferredTimescale: 600
  })
}]
```

- 音频在最终视频的 **第 5 秒开始播放**
- 不指定 `at` 时，音频会顺序接在前一个外部音频之后
- 音频不会影响最终视频时长

***

## 导出结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- `exportPath`：导出文件的完整路径
- `duration`：最终视频时长（仅由 `videoItems` 决定）

***

## 常见错误与边界情况

### 1. ImageClip 未指定 duration

```ts
{
  imagePath: "...",
  //  缺少 duration
}
```

**问题：**

- ImageClip 没有天然时长
- 不指定 `duration` 会导致合成失败

**解决方案：**

- 必须显式提供 `MediaTime`

***

### 2. 使用浮点秒数而非 MediaTime

```ts
// 错误
at: 5
```

**正确做法：**

```ts
at: MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

MediaComposer 中 **所有时间必须使用 MediaTime**。

***

### 3. 混合不同 timescale 导致精度问题

**问题：**

- 不同音视频资源使用不同 timescale
- 在剪辑、拼接、淡入淡出时可能出现边界误差

**建议：**

- 在脚本中统一使用 `preferredTimescale: 600`
- 对外部时间先做 `convertScale`

***

### 4. 音频超出视频范围

**行为说明：**

- 音频即使超过视频末尾，也不会延长最终视频
- 超出部分会被自动截断

***

### 5. 同时存在视频原音与外部音频但音量异常

**原因：**

- 默认情况下，外部音频与视频原音会同时混合
- 未配置 ducking 时，可能出现人声被盖住的问题

***

## 音频 Ducking 行为说明

### 什么是 Ducking

Ducking 指的是：

> 当视频原音（如人声）存在时，自动降低外部音频（如背景音乐）的音量

***

### Ducking 配置

```ts
exportOptions: {
  ducking: {
    enabled: true,
    duckedVolume: 0.25,
    attackSeconds: 0.15,
    releaseSeconds: 0.25
  }
}
```

#### 参数说明

- **enabled**
  是否启用 ducking，默认 `true`

- **duckedVolume**
  被压低后的外部音频音量（0…1）

- **attackSeconds**
  在视频原音开始前，音量下降的过渡时间

- **releaseSeconds**
  在视频原音结束后，音量恢复的过渡时间

***

### Ducking 生效条件

Ducking 仅在以下条件同时满足时生效：

1. `VideoClip.keepOriginalAudio === true`
2. 存在外部 `audioClips`
3. `exportOptions.ducking.enabled !== false`

***

## 音频混音规则总结

1. **视频原音**

   - 只有在 `keepOriginalAudio: true` 时才参与混音

2. **外部音频**

   - 可指定时间点或顺序拼接
   - 可设置 `volume`、`fade`、`loopToFitVideoDuration`

3. **最终混音顺序**

   - 所有音频会被混合到单一音轨
   - 不会改变视频时长
   - Ducking 在混音阶段自动应用



---
url: /v2/zh/guide/Device Capabilities/MediaComposer/MediaTime.md
---

# MediaTime

`MediaTime` 用于表示音视频处理中的**精确时间点或时间长度**，是 Scripting 中 MediaComposer 时间系统的基础类型。
它在语义上对应于底层媒体框架中的“带时间基准的时间值”（如 AVFoundation 的 `CMTime`），但对脚本侧提供了更安全、可读、可计算的抽象。

`MediaTime` 既可以表示**确定的数值时间**，也可以表示**无效、无限或不确定时间**，并支持严格的时间运算与比较。

***

## 核心特性

- 使用 **value + timescale** 或 **seconds + preferredTimescale** 精确构造时间
- 支持时间缩放（convertScale）及多种舍入策略
- 支持加减运算与大小比较
- 明确区分有效时间、无效时间、无限时间和不确定时间
- 适用于时间线计算、剪辑、对齐、放置（at）、淡入淡出等所有时间相关场景

***

## 时间精度模型

`MediaTime` 的底层模型基于以下概念：

- **value**：整数时间值
- **timescale**：每秒的时间单位数
  例如：

  - `value = 300`, `timescale = 600` 表示 0.5 秒
  - `value = 18000`, `timescale = 600` 表示 30 秒

通过 timescale，`MediaTime` 可以精确表达帧级或采样级时间，而不依赖浮点数。

***

## 只读属性

### secondes

```ts
readonly secondes: number
```

当前时间对应的秒数（浮点数形式）。
这是一个**派生值**，主要用于展示或调试，不建议用于时间计算。

***

### isValid

```ts
readonly isValid: boolean
```

表示该时间是否是一个有效、可用于计算的时间值。
当时间为 `invalid`、`indefinite` 或无穷大时，该值为 `false`。

***

### isPositiveInfinity / isNegativeInfinity

```ts
readonly isPositiveInfinity: boolean
readonly isNegativeInfinity: boolean
```

表示该时间是否为正无穷或负无穷。
常用于内部边界标记或时间线计算中的极值判断。

***

### isIndefinite

```ts
readonly isIndefinite: boolean
```

表示该时间是否为“不确定时间”。
通常用于尚未解析出真实时长的媒体资源。

***

### isNumeric

```ts
readonly isNumeric: boolean
```

表示该时间是否是一个可参与数值计算的时间。
只有在该值为 `true` 时，才应进行加减或比较操作。

***

### hasBeenRounded

```ts
readonly hasBeenRounded: boolean
```

表示该时间是否在构造或转换过程中发生过舍入。
对于帧精度或采样精度要求较高的场景，该属性可用于调试或验证。

***

## 时间转换

### convertScale

```ts
convertScale(newTimescale: number, method: MediaTimeRoundingMethod): MediaTime
```

将当前时间转换为新的 timescale，并使用指定的舍入策略。

**典型用途：**

- 对齐视频帧时间（如 600、90000）
- 对齐音频采样时间（如 44100、48000）
- 避免不同时间基准混用导致的误差

***

## 时间值获取

### getSeconds

```ts
getSeconds(): number
```

返回当前时间对应的秒数（浮点数）。
该方法等价于读取 `secondes`，但在语义上更明确。

***

## 时间运算

### plus / minus

```ts
plus(other: MediaItem): MediaItem
minus(other: MediaItem): MediaItem
```

执行时间加法或减法运算，返回新的 `MediaTime`。

- 运算双方必须为可计算时间
- 不会修改原对象
- 运算结果遵循内部时间基准规则

***

## 时间比较

```ts
lt(other: MediaItem): boolean
gt(other: MediaItem): boolean
lte(other: MediaItem): boolean
gte(other: MediaItem): boolean
eq(other: MediaItem): boolean
neq(other: MediaItem): boolean
```

用于比较两个时间的大小或相等性。

- 支持严格比较
- 对无效或非数值时间的比较结果是确定性的
- 推荐在进行时间线排序、裁剪判断、边界检测时使用

***

## 静态构造方法

### make

```ts
static make(options: {
  value: number
  timescale: number
} | {
  seconds: number
  preferredTimescale: number
}): MediaTime
```

用于创建一个 `MediaTime` 实例。

#### 使用 value + timescale

```ts
MediaTime.make({
  value: 300,
  timescale: 600
})
```

适用于需要精确控制时间单位的场景。

#### 使用 seconds + preferredTimescale

```ts
MediaTime.make({
  seconds: 5,
  preferredTimescale: 600
})
```

适用于脚本层以“秒”为主的时间描述方式。

***

### zero

```ts
static zero(): MediaTime
```

返回一个表示 **0 秒** 的时间。

***

### invalid

```ts
static invalid(): MediaTime
```

返回一个无效时间。
用于显式表示错误、缺失或不可用的时间值。

***

### indefinite

```ts
static indefinite(): MediaTime
```

返回一个不确定时间。
通常用于媒体尚未加载完成、时长未知的状态。

***

### positiveInfinity / negativeInfinity

```ts
static positiveInfinity(): MediaTime
static negativeInfinity(): MediaTime
```

返回正无穷或负无穷时间。
主要用于内部时间线边界控制，不建议在普通脚本逻辑中使用。

***

## 使用建议与注意事项

- **避免直接使用浮点秒数进行时间计算**，应始终使用 `MediaTime`
- 不同媒体资源可能使用不同的 timescale，必要时显式调用 `convertScale`
- 在比较或运算前，建议检查 `isNumeric`
- 在构建时间线（如 `at`、`sourceTimeRange`）时，统一 timescale 可减少误差

***

## 在 MediaComposer 中的典型用途

- 指定音频或视频片段的放置时间（`AudioClip.at`）
- 定义剪辑的起点与时长（`TimeRange`）
- 计算最终导出视频的精确时长
- 控制淡入淡出、对齐、循环等时间行为



---
url: /v2/zh/guide/Device Capabilities/MediaComposer/Quick Start.md
---

# 快速开始

`MediaComposer` 用于在 Scripting 中 **组合视频、图片与音频时间线并导出最终媒体文件**。
它封装了一套稳定的时间线模型，支持视频剪辑、图片片段、音频叠加、淡入淡出、音频 ducking、导出参数控制等高级能力。

该模块适用于：

- 视频与图片混合生成短片
- 给视频添加背景音乐、配音或音效
- 使用图片序列生成视频
- 自动化视频处理与内容生成脚本

***

## 设计概览

MediaComposer 的核心由三部分组成：

1. **时间模型**
   使用 `MediaTime` / `TimeRange` 精确描述时间点与时长

2. **时间线模型**

   - `VideoItem[]`：视频或图片片段（顺序拼接）
   - `AudioClip[]`：音频轨道（可指定时间点或自动顺序放置）

3. **导出系统**
   通过统一的 `composeAndExport` 接口完成渲染与导出

***

## 时间线结构

```ts
timeline: {
  videoItems: VideoItem[]
  audioClips: AudioClip[]
}
```

- **videoItems**
  定义视觉时间线，视频与图片会严格按数组顺序依次排列
- **audioClips**
  定义音频时间线，可自由指定放置时间（`at`），或顺序追加

最终导出的视频时长由 **videoItems 决定**。

***

## VideoItem

```ts
type VideoItem = XOR<VideoClip, ImageClip>
```

`VideoItem` 表示时间线中的一个“视觉片段”，可以是 **视频** 或 **图片**，但不能同时是两者。

***

## VideoClip（视频片段）

```ts
type VideoClip = {
  videoPath: string
  sourceTimeRange?: TimeRange | null
  keepOriginalAudio?: boolean
  fade?: FadeConfig | null
}
```

### videoPath

- 视频文件路径
- 支持本地视频文件

***

### sourceTimeRange

```ts
sourceTimeRange?: TimeRange | null
```

- 指定从源视频中使用的时间范围
- 不提供时，默认使用整个视频

**常见用途：**

- 裁剪视频片段
- 只取某一段作为素材

***

### keepOriginalAudio

```ts
keepOriginalAudio?: boolean
```

- 是否保留视频自带的音频
- 默认值：`false`

**说明：**

- 为 `true` 时，视频原音会参与混音
- 可与外部 `audioClips` 同时存在
- 是否对外部音频进行 ducking 由 `ExportOptions.ducking` 控制

***

### fade

```ts
fade?: FadeConfig | null
```

- 视频片段的淡入淡出配置
- 会覆盖全局视频淡入淡出设置（如果存在）

***

## ImageClip（图片片段）

```ts
type ImageClip = {
  imagePath: string
  duration: MediaTime
  contentMode?: "fit" | "crop"
  backgroundColor?: Color
  fade?: FadeConfig | null
}
```

`ImageClip` 用于将一张静态图片作为视频时间线中的一个片段。

***

### imagePath

- 图片文件路径
- 支持常见图片格式（JPEG / PNG / HEIC 等）

***

### duration

```ts
duration: MediaTime
```

- 图片片段在视频中的显示时长
- 必须显式指定

***

### contentMode

```ts
contentMode?: "fit" | "crop"
```

- 控制图片如何适配渲染尺寸
- 默认值：`fit`

说明：

- `fit`：完整显示图片，可能留黑边
- `crop`：填满画面，超出部分裁剪

***

### backgroundColor

```ts
backgroundColor?: Color
```

- 图片未覆盖区域的背景色
- 通常与 `fit` 模式搭配使用

***

### fade

```ts
fade?: FadeConfig | null
```

- 图片片段的淡入淡出配置
- 支持与视频片段统一使用

***

## AudioClip（音频片段）

```ts
type AudioClip = {
  path: string
  sourceTimeRange?: TimeRange | null
  at?: MediaTime
  volume?: number
  fade?: FadeConfig | null
  loopToFitVideoDuration?: boolean
}
```

音频片段用于在最终视频中添加背景音乐、配音或音效。

***

### path

- 音频文件路径

***

### sourceTimeRange

- 指定使用音频的某一时间段
- 默认使用整个音频文件

***

### at

```ts
at?: MediaTime
```

- 指定音频在最终时间线中的放置时间
- 不指定时：

  - 按顺序接在前一个外部音频片段之后

***

### volume

```ts
volume?: number
```

- 单个音频片段的音量（0…1）
- 默认值：1

***

### fade

- 音频淡入淡出配置
- 常用于背景音乐的自然过渡

***

### loopToFitVideoDuration

```ts
loopToFitVideoDuration?: boolean
```

- 是否循环音频以匹配视频总时长
- 常用于背景音乐

***

## FadeConfig（淡入淡出）

```ts
type FadeConfig = {
  fadeInSeconds?: number
  fadeOutSeconds?: number
}
```

- 单位：秒
- 可用于视频、图片、音频
- 未指定时默认为 0

***

## ExportOptions（导出配置）

```ts
type ExportOptions = {
  renderSize?: Size
  frameRate?: number
  scaleMode?: VideoScaleMode
  globalVideoFade?: FadeConfig | null
  externalAudioBaseVolume?: number
  ducking?: DuckingConfig
  presetName?: ExportPreset
  outputFileType?: ExportFileType
}
```

### 常用说明

- **renderSize**
  最终视频分辨率，默认 1080×1920

- **frameRate**
  渲染帧率，默认 30

- **globalVideoFade**
  全局视频淡入淡出（可被单个 clip 覆盖）

- **ducking**
  当视频存在原音时，自动降低外部音频音量

- **presetName / outputFileType**
  控制编码质量与文件格式

***

## composeAndExport

```ts
function composeAndExport(options: {
  exportPath: string
  timeline: {
    videoItems: VideoItem[]
    audioClips: AudioClip[]
  }
  exportOptions?: ExportOptions
  overwrite?: boolean
}): Promise<{
  exportPath: string
  duration: MediaTime
}>
```

### 参数说明

- **exportPath**
  导出文件路径

- **timeline.videoItems**
  视频 / 图片时间线（顺序执行）

- **timeline.audioClips**
  音频时间线（可自由放置）

- **exportOptions**
  导出配置，可选

- **overwrite**
  是否覆盖已有文件，默认 `true`

***

### 返回结果

```ts
{
  exportPath: string
  duration: MediaTime
}
```

- **exportPath**：最终导出路径
- **duration**：最终视频时长（由 videoItems 决定）

***

## 使用建议与最佳实践

- 始终使用 `MediaTime` 描述时间，避免直接使用浮点秒数
- 图片片段必须显式指定 `duration`
- 音频与视频的时间线是 **独立但最终混合** 的
- 对复杂项目，建议统一 timescale（如 600）
- 背景音乐推荐使用 `loopToFitVideoDuration`

***

## 典型使用场景

- 图片 + 视频混合短片
- 自动生成带背景音乐的视频
- 视频剪辑与配音合成
- 内容创作与自动化视频生成



---
url: /v2/zh/guide/Device Capabilities/MediaPlayer.md
---

# 媒体播放器

`MediaPlayer` API 允许与 **Now Playing Center** 交互，管理 **Now Playing Info**，并响应远程控制事件。以下是使用指南、最佳实践及示例。

***

## 入门指南

`MediaPlayer` API 提供对媒体播放信息的控制及远程命令处理。入门步骤如下：

1. 设置 `nowPlayingInfo`，用于显示当前媒体信息。
2. 使用 `setAvailableCommands()` 配置可用的命令。
3. 注册 `commandHandler`，以响应远程事件。

```typescript
MediaPlayer.nowPlayingInfo = {
  title: "歌曲标题",
  artist: "艺术家",
  playbackRate: 1.0,
  elapsedPlaybackTime: 30,
  playbackDuration: 240
}

MediaPlayer.setAvailableCommands(["play", "pause", "nextTrack", "previousTrack"])

MediaPlayer.commandHandler = (command, event) => {
  console.log(`收到命令: ${command}`)
}
```

***

## API 参考

### `nowPlayingInfo`

`nowPlayingInfo` 对象显示当前播放媒体的元数据。将其设置为 `null` 可清除 Now Playing Info Center。

**属性：**

- **`title`**: `string` （必需）\
  媒体标题。
- **`artist`**: `string` （可选）\
  媒体艺术家或表演者。
- **`albumTitle`**: `string` （可选）\
  专辑标题。
- **`artwork`**: `UIImage` （可选）\
  媒体封面图片。
- **`mediaType`**: `MediaType` （可选）\
  默认值为 `audio`。
- **`playbackRate`**: `number` （可选）\
  当前播放速度，默认为 `0`。
- **`elapsedPlaybackTime`**: `DurationInSeconds` （可选）\
  当前播放时间，默认为 `0`。
- **`playbackDuration`**: `DurationInSeconds` （可选）\
  媒体总时长，默认为 `0`。

***

### 播放状态

`playbackState` 属性指示应用的当前播放状态：

- **`unknown`**: 默认状态，播放状态未定义。
- **`playing`**: 正在播放。
- **`paused`**: 播放已暂停。
- **`stopped`**: 播放已停止。
- **`interrupted`**: 播放被外部事件中断。

```typescript
if (MediaPlayer.playbackState === MediaPlayerPlaybackState.playing) {
    console.log("媒体正在播放")
}
```

***

### 命令与事件处理

#### `setAvailableCommands(commands: MediaPlayerRemoteCommand[])`

指定用户可交互的远程命令。

**示例：**

```typescript
MediaPlayer.setAvailableCommands(["play", "pause", "stop", "nextTrack"])
```

#### `commandHandler`

回调函数，用于处理远程命令。注册此函数以处理命令（如 `play`、`pause` 或 `seekBackward`）。

**示例：**

```typescript
MediaPlayer.commandHandler = (command, event) => {
  switch (command) {
    case "play":
      console.log("收到播放命令")
      break
    case "pause":
      console.log("收到暂停命令")
      break
    default:
      console.log(`未处理的命令: ${command}`)
  }
}
```

**支持的命令：**

- `play`、`pause`、`stop`、`nextTrack`、`previousTrack`
- `seekBackward`、`seekForward`、`skipBackward`、`skipForward`
- `rating`、`like`、`dislike`、`bookmark`
- `changeRepeatMode`、`changeShuffleMode`
- `enableLanguageOption`、`disableLanguageOption`

***

## 常见用例

### 显示 Now Playing 信息

```typescript
MediaPlayer.nowPlayingInfo = {
  title: "播客集数",
  artist: "主持人",
  elapsedPlaybackTime: 120,
  playbackDuration: 1800,
  playbackRate: 1.0
}
```

### 响应播放命令

```typescript
MediaPlayer.setAvailableCommands(["play", "pause", "stop"])

MediaPlayer.commandHandler = (command, event) => {
  if (command === "play") {
    console.log("开始播放")
  } else if (command === "pause") {
    console.log("暂停播放")
  }
}
```

### 处理自定义事件

```typescript
MediaPlayer.commandHandler = (command, event) => {
  if (command === "seekForward") {
    const seekEvent = event as MediaPlayerSeekCommandEvent
    console.log(`Seek 事件类型: ${seekEvent.type}`)
  }
}
```

***

## 最佳实践

1. **保持元数据最新**：在播放状态变化时更新 `nowPlayingInfo`。
2. **处理所有相关命令**：确保支持用户交互（如跳转或快进）。
3. **资源管理**：播放停止时清除 `nowPlayingInfo`，避免显示过期信息。
4. **使用外部设备测试**：通过耳机或车载系统验证命令处理。
5. **提供用户反馈**：在命令响应中提示成功或失败。

***

## 完整示例

以下是 `MediaPlayer` 的完整实现：

```typescript
// 设置 Now Playing 信息
MediaPlayer.nowPlayingInfo = {
  title: "歌曲标题",
  artist: "艺术家",
  albumTitle: "专辑名称",
  playbackRate: 1.0,
  elapsedPlaybackTime: 0,
  playbackDuration: 300
}

// 启用命令
MediaPlayer.setAvailableCommands(["play", "pause", "nextTrack", "previousTrack", "seekForward", "seekBackward"])

// 处理命令
MediaPlayer.commandHandler = (command, event) => {
  switch (command) {
    case "play":
      console.log("开始播放")
      break
    case "pause":
      console.log("暂停播放")
      break
    case "nextTrack":
      console.log("跳到下一曲")
      break
    case "seekForward":
      const seekEvent = event as MediaPlayerSeekCommandEvent
      console.log(`Seek 事件: ${seekEvent.type}`)
      break
    default:
      console.log(`未处理的命令: ${command}`)
  }
}
```



---
url: /v2/zh/guide/Device Capabilities/Notification/index.md
---

# 通知

Scripting App 中的 `Notification` 模块用于安排、管理和展示本地通知，支持多种触发方式、交互操作按钮和富交互界面（自定义 UI）。

***

## 目录

1. [安排通知](#安排通知)
2. [通知触发器](#通知触发器)

   - [TimeIntervalNotificationTrigger](#timeintervalnotificationtrigger)
   - [CalendarNotificationTrigger](#calendarnotificationtrigger)
   - [LocationNotificationTrigger](#locationnotificationtrigger)
3. [通知操作按钮](#通知操作按钮)
4. [富通知（自定义 UI）](#富通知自定义-ui)
5. [通知管理](#通知管理)
6. [通知信息与请求结构](#通知信息与请求结构)
7. [完整示例](#完整示例)

***

## 安排通知

使用 `Notification.schedule` 来安排本地通知。它支持标题、触发器、点击行为、操作按钮、自定义 UI 和其他投递选项：

```ts
await Notification.schedule({
  title: "提醒事项",
  body: "该起身活动了！",
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 1800,
    repeats: true
  }),
  actions: [
    {
      title: "我知道了",
      icon: "checkmark",
      url: Script.createRunURLScheme("确认脚本", { acknowledged: true })
    }
  ],
  tapAction: {
    type: "runScript",
    scriptName: "确认脚本"
  },
  customUI: false
})
```

### 参数说明

| 参数名                 | 类型                                                                                                            | 说明                                          |
| ------------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| `title`             | `string`                                                                                                      | 必填，通知标题。                                    |
| `subtitle`          | `string?`                                                                                                     | 可选，副标题内容。                                   |
| `body`              | `string?`                                                                                                     | 可选，正文内容。                                    |
| `iconImageData`     | `Data` \| `SystemImageIcon` \| `null`                                                                         | 可选，自定义通知图标图片的二进制数据或系统图标名称。                  |
| `badge`             | `number?`                                                                                                     | 可选，应用图标角标数字。                                |
| `silent`            | `boolean?`                                                                                                    | 可选，默认为 `false`。设为 `true` 则不播放声音静默送达。        |
| `interruptionLevel` | `"active"` \| `"passive"` \| `"timeSensitive"`                                                                | 可选，通知的重要级别和投递优先级。                           |
| `userInfo`          | `Record<string, any>?`                                                                                        | 可选，附加的自定义数据。                                |
| `threadIdentifier`  | `string?`                                                                                                     | 可选，用于通知分组的标识符。                              |
| `trigger`           | `TimeIntervalNotificationTrigger` \| `CalendarNotificationTrigger` \| `LocationNotificationTrigger` \| `null` | 可选，定义何时发送通知。                                |
| `actions`           | `NotificationAction[]?`                                                                                       | 可选，通知展开后展示的操作按钮。                            |
| `customUI`          | `boolean?`                                                                                                    | 可选，设为 `true` 可使用 `notification.tsx` 自定义 UI。 |
| `tapAction`         | `"none"` \| `{ type: "runScript", scriptName: string }` \| `{ type: "openURL", url: string }`                 | 可选，定义用户点击通知时执行的操作。                          |

#### SystemImageIcon

```ts
type SystemImageIcon = {
  systemImage: string
  color: Color
}
```

用于定义通知图标的系统图标名称和颜色。

- `systemImage`: 系统图标（SFSymbol）名称
- `color`: 图标颜色

***

### 通知操作按钮（`actions`）

通过 `actions` 参数，你可以为通知添加操作按钮。操作按钮会在通知展开后出现，用户可以点击进行操作。

#### 通知操作按钮类型（`NotificationAction`）

```ts
type NotificationAction = {
    title: string;
    icon?: string;
    url: string;
    destructive?: boolean;
}
```

- `title`: 按钮标题
- `icon`: 按钮图标
- `url`: 点击后打开的 URL
- `destructive`: 是否为破坏性操作

***

### 点击行为（`tapAction`）

通过 `tapAction` 参数，你可以完全控制用户**点击通知**时的行为：

- `"none"`：点击后无任何响应
- `{ type: "runScript", scriptName: string }`：运行指定脚本
- `{ type: "openURL", url: string }`：打开指定 URL，可为 deeplink 或 https 链接

如果不设置 `tapAction`，默认行为是运行**当前脚本**，你可以通过 `Notification.current` 获取通知内容。

***

## 通知触发器

### TimeIntervalNotificationTrigger

在指定秒数后触发通知：

```ts
new TimeIntervalNotificationTrigger({
  timeInterval: 3600,
  repeats: true
})
```

- `timeInterval`: 延迟秒数
- `repeats`: 是否重复触发
- `nextTriggerDate()`: 返回下次预期触发的时间

***

### CalendarNotificationTrigger

根据特定日期和时间触发通知：

```ts
const components = new DateComponents({ hour: 8, minute: 0 })
new CalendarNotificationTrigger({
  dateMatching: components,
  repeats: true
})
```

- 支持设置 `year`、`month`、`day`、`hour` 等
- 适用于每日、每周或特定时间提醒

***

### LocationNotificationTrigger

当进入或离开某个地理区域时触发：

```ts
new LocationNotificationTrigger({
  region: {
    identifier: "公司",
    center: { latitude: 37.7749, longitude: -122.4194 },
    radius: 100,
    notifyOnEntry: true,
    notifyOnExit: false
  },
  repeats: false
})
```

- 支持进入/离开圆形区域的触发

***

## 通知操作按钮

通过 `actions` 参数添加通知操作按钮：

```ts
actions: [
  {
    title: "查看详情",
    url: Script.createRunURLScheme("详情脚本", { fromNotification: true })
  },
  {
    title: "忽略",
    url: Script.createRunURLScheme("忽略脚本", { dismissed: true }),
    destructive: true
  }
]
```

- 使用 `Script.createRunURLScheme(...)` 创建 URL
- 按钮在长按或下拉通知时显示

***

## 富通知（自定义 UI）

你可以使用 TSX 文件定义通知的展开视图：

1. 安排通知时设置 `customUI: true`
2. 在脚本中添加 `notification.tsx` 文件
3. 使用 `Notification.present(<JSX>)` 渲染 UI

### `Notification.present(element: JSX.Element): void`

在 `notification.tsx` 中调用，用于渲染富通知界面。

***

### 示例 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function NotificationView() {
  return (
    <VStack>
      <Text>需要完成你的任务吗？</Text>
      <Button title="已完成" action={() => console.log("任务完成")} />
      <Button title="稍后提醒" action={() => console.log("稍后提醒")} />
    </VStack>
  )
}

Notification.present(<NotificationView />)
```

***

## 通知管理

| 方法名                                    | 说明              |
| -------------------------------------- | --------------- |
| `getAllDelivereds()`                   | 获取所有已送达的通知      |
| `getAllPendings()`                     | 获取所有已安排但尚未送达的通知 |
| `removeAllDelivereds()`                | 移除所有已送达的通知      |
| `removeAllPendings()`                  | 取消所有待发送通知       |
| `removeDelivereds(ids)`                | 移除指定 ID 的已送达通知  |
| `removePendings(ids)`                  | 取消指定 ID 的已安排通知  |
| `getAllDeliveredsOfCurrentScript()`    | 获取当前脚本发送的已送达通知  |
| `getAllPendingsOfCurrentScript()`      | 获取当前脚本安排的待发送通知  |
| `removeAllDeliveredsOfCurrentScript()` | 清除当前脚本的所有已送达通知  |
| `removeAllPendingsOfCurrentScript()`   | 清除当前脚本的所有待发送通知  |
| `setBadgeCount(count)`                 | 设置应用图标的角标数值     |

***

## 通知信息与请求结构

当脚本是通过点击通知启动时，可以通过 `Notification.current` 获取上下文信息：

```ts
if (Notification.current) {
  const { title, userInfo } = Notification.current.request.content
  console.log(`从通知启动：${title}`, userInfo)
}
```

### `NotificationRequest` 字段

| 字段名                        | 说明              |
| -------------------------- | --------------- |
| `identifier`               | 通知请求的唯一标识符      |
| `content.title`            | 通知标题            |
| `content.subtitle`         | 通知副标题           |
| `content.body`             | 通知正文            |
| `content.userInfo`         | 附加信息            |
| `content.threadIdentifier` | 分组标识            |
| `trigger`                  | 触发器对象，控制通知的投递逻辑 |

***

## 完整示例

以下示例展示了通知的完整用法：自定义 UI、交互按钮、点击行为、重复触发等。

### 第一步：安排通知

```ts
await Notification.schedule({
  title: "喝水提醒",
  body: "别忘了喝水哦！",
  interruptionLevel: "timeSensitive",
  iconImageData: UIImage
    .fromSFSymbol("waterbottle")!
    .withTintColor("systemBlue")!
    .toPNGData(),
  customUI: true,
  trigger: new TimeIntervalNotificationTrigger({
    timeInterval: 3600,
    repeats: true
  }),
  tapAction: {
    type: "runScript",
    scriptName: "喝水记录"
  },
  actions: [
    {
      title: "已喝水",
      url: Script.createRunURLScheme("喝水记录", { drank: true }),
    },
    {
      title: "忽略",
      url: Script.createRunURLScheme("喝水记录", { drank: false }),
      destructive: true
    }
  ]
})
```

### 第二步：创建 `notification.tsx`

```tsx
import { Notification, VStack, Text, Button } from 'scripting'

function HydrationUI() {
  return (
    <VStack>
      <Text>你刚刚喝水了吗？</Text>
      <Button title="是的" action={() => console.log("已确认喝水")} />
      <Button title="还没" action={() => console.log("忽略提醒")} />
    </VStack>
  )
}

Notification.present(<HydrationUI />)
```

***

## 总结

Scripting 中的 `Notification` API 提供了强大的本地通知功能：

- 支持时间、日历、位置触发器
- 支持操作按钮及跳转脚本
- 通过 `tapAction` 自定义点击通知的行为
- 使用 `notification.tsx` 创建富交互通知界面
- 提供全面的通知生命周期管理



---
url: /v2/zh/guide/Device Capabilities/Notification/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Notification, Script, Section, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Notification"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
      >
        <Button
          title={"Schedule a Notification with actions"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down",
              actions: [
                {
                  title: "Widget",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "Widget",
                  })
                },
                {
                  title: "LiveActivity",
                  url: Script.createRunURLScheme(Script.name, {
                    doc: "LiveActivity",
                  })
                }
              ]
            })
          }}
        />
      </Section>

      <Section
      >
        <Button
          title={"Schedule a Notification with Rich Content"}
          action={async () => {
            Notification.schedule({
              title: "Notification Testing",
              body: "Long Press or Pull Down to show rich content.",
              customUI: true,
              userInfo: {
                title: "AudioRecorder",
                subtitle: "The interface allows you to record audio data to a file. It provides functionalities to start, stop, pause, and manage audio recordings, with configurable settings for audio quality, sample rate, format, and more.",
              }
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/PDF.md
---

# PDF

Scripting app 提供了 `PDFDocument` 和 `PDFPage` 两个类，封装了 PDFKit 功能，支持加载、修改、提取、保存 PDF 文件，并支持同步或异步的操作方式。

***

## `PDFPage` 类

表示 PDF 文档中的单个页面。提供访问页面文本、数据和相关信息的能力。

### 静态方法

#### `PDFPage.fromImage(image: UIImage): PDFPage | null`

从图像创建一个新的 PDF 页面。

- **参数**：

  - `image`：要转换为 PDF 页的图像。
- **返回**：`PDFPage` 实例，若失败返回 `null`。

***

### 属性

#### `document: PDFDocument | null`

所属的 PDF 文档实例。若该页面尚未添加至文档，则为 `null`。

#### `label: string | null`

页面的标签（如页码、用户可定义标题等）。

#### `numberOfCharacters: number`

页面中提取到的字符数量。

***

### 异步属性（getter）

#### `string: Promise<string | null>`

异步获取页面的文本内容。

- 如果页面是图像或不可解析为文本，则返回 `null`。

#### `data: Promise<Data | null>`

异步获取页面的原始二进制数据。

***

## `PDFDocument` 类

表示完整的 PDF 文档。可读取、修改页面，提取元信息，并进行保存（支持异步和同步写入）。

***

### 静态方法

#### `PDFDocument.fromData(data: Data): PDFDocument | null`

从二进制数据创建文档实例。

- **参数**：

  - `data`：有效的 PDF 数据。
- **返回**：`PDFDocument` 实例，若无效则为 `null`。

#### `PDFDocument.fromFilePath(filePath: string): PDFDocument | null`

从文件路径加载 PDF 文件。

- **参数**：

  - `filePath`：PDF 文件的本地路径。
- **返回**：成功返回 `PDFDocument`，否则为 `null`。

***

### 只读属性

#### `pageCount: number`

文档总页数。

#### `filePath: string | null`

文档源文件路径。若是通过内存创建则为 `null`。

#### `isLocked: boolean`

文档是否被加锁（需要密码解锁）。

#### `isEncrypted: boolean`

文档是否加密。

#### `documentAttributes: object | null`

PDF 的元数据（如作者、标题、创建时间等）。

```ts
{
  author?: string | null
  creationDate?: Date | null
  creator?: string | null
  keywords?: any | null
  modificationDate?: Date | null
  producer?: string | null
  subject?: string | null
  title?: string | null
}
```

##### 示例

```ts
const doc = PDFDocument.fromFilePath("path/to/example.pdf")
const attrs = doc.documentAttributes
console.log(attrs?.title) // 输出："项目报告"
```

***

### 异步属性（getter）

#### `data: Promise<Data | null>`

异步获取整个文档的二进制数据。

#### `string: Promise<string | null>`

异步获取整个文档的文本内容。若为图片型 PDF，可能返回 `null`。

***

### 方法

#### `pageAt(index: number): PDFPage | null`

获取指定索引的页面。

- **参数**：

  - `index`：页面索引（从 0 开始）。
- **返回**：`PDFPage` 实例，索引无效时返回 `null`。

#### `indexOf(page: PDFPage): number`

获取指定页面在文档中的索引。

- **参数**：

  - `page`：页面实例。
- **返回**：索引值，若找不到则为 `-1`。

#### `removePageAt(index: number): void`

移除指定索引的页面。

#### `insertPageAt(page: PDFPage, atIndex: number): void`

在指定索引插入一个页面。

##### 示例

```ts
const doc = PDFDocument.fromFilePath("path/to/document.pdf")
const imagePage = PDFPage.fromImage(image)
doc.insertPageAt(imagePage, 1)
```

#### `exchangePage(atIndex: number, withPageIndex: number): void`

交换两个页面的位置。

***

### 保存方法

#### `writeSync(toFilePath: string, options?): boolean`

将 PDF 同步写入指定路径，支持设置密码和其他选项。

- **参数**：

  - `toFilePath`：输出文件路径。
  - `options`（可选）：

    ```ts
    {
      ownerPassword?: string
      userPassword?: string
      burnInAnnotations?: boolean
      saveTextFromOCR?: boolean
      saveImagesAsJPEG?: boolean
    }
    ```
- **返回**：保存成功返回 `true`，否则为 `false`。

##### 示例

```ts
const doc = PDFDocument.fromFilePath("path/to/input.pdf")
const success = doc.writeSync("path/to/output.pdf", {
  ownerPassword: "admin",
  userPassword: "1234"
})
```

#### `write(toFilePath: string, options?): Promise<boolean>`

异步方式写入 PDF 文件。

- 参数与 `writeSync` 相同。
- **返回值**：`Promise<boolean>` 表示保存是否成功。

***

### 解锁文档

#### `unlock(password: string): boolean`

尝试使用密码解锁文档。

- **参数**：

  - `password`：密码字符串。
- **返回**：若解锁成功，返回 `true`，否则返回 `false`。

***

## 示例代码

```ts
const doc = PDFDocument.fromFilePath("path/to/book.pdf")
if (doc && !doc.isLocked) {
  const firstPage = doc.pageAt(0)
  const text = await firstPage?.string
  console.log("第一页文本：", text)
  
  const success = await doc.write("path/to/book-copy.pdf")
  console.log(success ? "保存成功" : "保存失败")
}
```



---
url: /v2/zh/guide/Device Capabilities/Pasteboard.md
---

# 剪贴板

`Pasteboard` 命名空间提供在 **Scripting app** 中读取、设置与监听系统粘贴板内容变化的完整接口。
相比旧版 `Clipboard`，`Pasteboard` 提供了更强的功能支持，包括：

- 支持多类型数据（文本、图片、URL、二进制数据等）
- 监听粘贴板变化事件
- 设置隐私属性（如过期时间、本地可见性）

> **注意**
> 如果希望能够从其他 App 粘贴内容，请前往：
> **设置 > Scripting > 从其他 App 粘贴 > 允许**

***

## 命名空间：`Pasteboard`

### 类型定义

#### `Item`

表示一个粘贴板项目。
每个项目是一个 `Record<UTType, string | UIImage | Data>` 映射表，其中键为数据类型（`UTType`），值可以是字符串、图片或二进制数据。

常见类型：

- `public.plain-text` → 文本字符串
- `public.url` → URL 字符串
- `public.jpeg` / `public.png` → 图片对象（`UIImage`）
- `public.data` → 二进制数据（`Data`）

**示例**

```ts
const item: Pasteboard.Item = {
  "public.plain-text": "Hello, world!",
  "public.url": "https://example.com"
}
```

***

## 属性（Properties）

### `hasStrings: Promise<boolean>`

判断粘贴板中是否包含文本内容。

**示例**

```ts
if (await Pasteboard.hasStrings) {
  console.log("粘贴板中包含文本")
}
```

***

### `hasImages: Promise<boolean>`

判断粘贴板中是否包含图片。

**示例**

```ts
if (await Pasteboard.hasImages) {
  console.log("粘贴板中包含图片")
}
```

***

### `hasURLs: Promise<boolean>`

判断粘贴板中是否包含 URL。

**示例**

```ts
if (await Pasteboard.hasURLs) {
  console.log("粘贴板中包含 URL 链接")
}
```

***

### `numberOfItems: Promise<number>`

获取当前粘贴板中项目的数量。

**示例**

```ts
const count = await Pasteboard.numberOfItems
console.log(`共有 ${count} 个粘贴板项目`)
```

***

### `changeCount: Promise<number>`

获取自系统启动以来粘贴板内容变化的次数。
每当粘贴板内容发生变化（新增、修改或清空），该计数都会增加。
可用于检测粘贴板是否有更新。

**示例**

```ts
const changeCount = await Pasteboard.changeCount
console.log("粘贴板变化次数：", changeCount)
```

***

## 文本操作

### `getString(): Promise<string | null>`

获取粘贴板中第一个项目的文本字符串。

**示例**

```ts
const text = await Pasteboard.getString()
if (text) console.log("读取到文本：", text)
```

***

### `setString(string: string | null): Promise<void>`

设置粘贴板中第一个项目的文本字符串。

**示例**

```ts
await Pasteboard.setString("Scripting is powerful!")
```

***

### `getStrings(): Promise<string[] | null>`

获取粘贴板中所有项目的文本数组。

**示例**

```ts
const texts = await Pasteboard.getStrings()
console.log(texts)
```

***

### `setStrings(strings: string[] | null): Promise<void>`

设置多个文本字符串到粘贴板。

**示例**

```ts
await Pasteboard.setStrings(["Apple", "Banana", "Cherry"])
```

***

## URL 操作

### `getURL(): Promise<string | null>`

获取粘贴板中第一个 URL 字符串。

**示例**

```ts
const url = await Pasteboard.getURL()
if (url) console.log("链接内容：", url)
```

***

### `setURL(url: string | null): Promise<void>`

设置粘贴板中第一个 URL 字符串。

**示例**

```ts
await Pasteboard.setURL("https://example.com")
```

***

### `getURLs(): Promise<string[] | null>`

获取粘贴板中所有 URL 项目。

**示例**

```ts
const urls = await Pasteboard.getURLs()
console.log(urls)
```

***

### `setURLs(urls: string[] | null): Promise<void>`

设置多个 URL 项目到粘贴板。

**示例**

```ts
await Pasteboard.setURLs([
  "https://apple.com",
  "https://openai.com"
])
```

***

## 图片操作

### `getImage(): Promise<UIImage | null>`

获取粘贴板中第一个图片对象。

**示例**

```ts
const img = await Pasteboard.getImage()
if (img) console.log("读取到图片")
```

***

### `setImage(image: UIImage | null): Promise<void>`

设置粘贴板中第一个图片对象。

**示例**

```ts
await Pasteboard.setImage(myImage)
```

***

### `getImages(): Promise<UIImage[] | null>`

获取粘贴板中所有图片对象。

**示例**

```ts
const images = await Pasteboard.getImages()
console.log(`共读取到 ${images?.length ?? 0} 张图片`)
```

***

### `setImages(images: UIImage[] | null): Promise<void>`

设置多个图片对象到粘贴板。

**示例**

```ts
await Pasteboard.setImages([img1, img2])
```

***

## 粘贴板项目操作

### `addItems(items: Item[]): Promise<void>`

向当前粘贴板追加新项目（不会清除已有内容）。

**示例**

```ts
await Pasteboard.addItems([
  { "public.plain-text": "First" },
  { "public.url": "https://example.com" }
])
```

***

### `setItems(items: Item[], options?: { localOnly?: boolean, expirationDate?: Date }): Promise<void>`

设置粘贴板内容为指定项目，并支持隐私控制选项。

**参数**

- `items`：粘贴板项目数组。
- `options.localOnly`：若为 `true`，不会通过 Handoff 同步到其他设备。
- `options.expirationDate`：设置过期时间，系统会在该时间后自动清除内容。

**示例**

```ts
await Pasteboard.setItems(
  [
    { "public.plain-text": "Sensitive Info" }
  ],
  {
    localOnly: true,
    expirationDate: new Date(Date.now() + 60 * 1000) // 1分钟后过期
  }
)
```

***

### `getItems(): Promise<Item[] | null>`

获取粘贴板中所有项目，每个项目为一个 `Pasteboard.Item` 对象。

**示例**

```ts
const items = await Pasteboard.getItems()
console.log(items)
```

***

## 事件回调（Callbacks）

### `onChanged: ((addedKeys: string[]) => void) | null | undefined`

当粘贴板内容发生变化时触发。
参数 `addedKeys` 为一个字符串数组，包含本次**新增的表示类型**（`UTType`）。

**示例**

```ts
Pasteboard.onChanged = addedKeys => {
  console.log("粘贴板新增内容类型：", addedKeys)
}
```

***

### `onRemoved: ((removedKeys: string[]) => void) | null | undefined`

当粘贴板内容被移除时触发。
参数 `removedKeys` 为一个字符串数组，包含被移除的表示类型（`UTType`）。

**示例**

```ts
Pasteboard.onRemoved = removedKeys => {
  console.log("粘贴板移除的类型：", removedKeys)
}
```

***

## 与旧版 Clipboard API 的区别

旧的 `Clipboard` 命名空间现已**弃用**，仅保留最基本的兼容接口：

- `Clipboard.copyText(text: string)` → 请改用 `Pasteboard.setString()`
- `Clipboard.getText()` → 请改用 `Pasteboard.getString()`



---
url: /v2/zh/guide/Device Capabilities/Photos/index.md
---

# 照片

`Photos` 模块为 Scripting 提供了对系统相册与相机能力的统一访问接口，用于：

- 使用系统相机拍照或录制视频
- 从系统照片库中选择图片、视频或 Live Photo
- 获取最近拍摄的照片
- 将图片或视频保存到系统 Photos 应用

所有 API 均基于 iOS 原生框架（Photos、PHPicker、UIImagePicker 等）封装，并遵循以下设计原则：

- 系统级权限管理
- Promise 异步接口
- 系统 UI 托管，不可自定义
- 媒体数据访问安全、受控

***

## CaptureInfo

```ts
type CaptureInfo = {
  cropRect: {
    x: number
    y: number
    width: number
    height: number
  } | null
  originalImage: UIImage | null
  editedImage: UIImage | null
  imagePath: string | null
  mediaMetadata: Record<string, any> | null
  mediaPath: string | null
  mediaType: string | null
}
```

`CaptureInfo` 描述了一次拍摄操作（照片或视频）的完整返回信息。

### 字段说明

- `cropRect`
  用户在编辑阶段应用的裁剪区域
  若未裁剪则为 `null`

- `originalImage`
  拍摄得到的原始图片（未编辑）

- `editedImage`
  用户编辑后的图片
  仅在 `allowsEditing` 启用且实际编辑后存在

- `imagePath`
  图片在磁盘中的文件路径

- `mediaMetadata`
  媒体的元数据，如 EXIF、方向信息等

- `mediaPath`
  视频文件在磁盘中的路径

- `mediaType`
  媒体的 UTType 字符串标识

***

## availableMediaTypes()

```ts
function availableMediaTypes(): string[] | null
```

返回当前设备相机支持的媒体类型（UTType 字符串数组）。

常用于：

- 判断设备是否支持视频拍摄
- 根据设备能力动态配置拍摄参数

当信息不可获取时返回 `null`。

***

## capture(options)

```ts
function capture(options: {
  mode: "photo" | "video"
  mediaTypes: UTType[]
  allowsEditing?: boolean
  cameraDevice?: "rear" | "front"
  cameraFlashMode?: "auto" | "on" | "off"
  videoMaximumDuration?: DurationInSeconds
  videoQuality?: 
    | "low"
    | "medium"
    | "high"
    | "640x480"
    | "iFrame960x540"
    | "iFrame1280x720"
}): Promise<CaptureInfo | null>
```

展示系统相机界面以进行拍照或视频录制。

### 参数说明

- `mode`
  拍摄模式

  - `"photo"`：拍照
  - `"video"`：录制视频

- `mediaTypes`
  允许拍摄的媒体类型（UTType 数组）

- `allowsEditing`
  是否允许用户在完成拍摄后编辑媒体

- `cameraDevice`
  使用的摄像头
  默认为 `"rear"`

- `cameraFlashMode`
  闪光灯模式
  默认为 `"auto"`

- `videoMaximumDuration`
  视频最长录制时长（秒）

- `videoQuality`
  视频分辨率与编码质量设置

### 行为说明

- 拍摄界面完全由系统管理
- Promise 在用户完成或取消操作后返回
- 权限请求由系统自动处理

***

## pick(options)

```ts
function pick(options?: {
  mode?: "default" | "compact"
  filter?: PHPickerFilter
  limit?: number
}): Promise<PHPickerResult[]>
```

展示系统照片选择器，用于从相册中选择媒体资源。

### 参数说明

- `mode`
  选择器布局模式

  - `default`：网格布局
  - `compact`：线性紧凑布局

- `filter`
  用于限制可选择资源类型的 `PHPickerFilter`

- `limit`
  最大选择数量
  默认为 `1`

### 返回值

返回 `PHPickerResult` 数组。
每个结果必须显式调用对应方法解析为具体资源。

***

## PHPickerFilter

`PHPickerFilter` 用于描述 **Photos.pick** 可选择的资源类型。
它是一个不可实例化的类，仅通过静态方法构建。

### 基础过滤器

- `PHPickerFilter.images()`
  仅允许选择普通图片

- `PHPickerFilter.videos()`
  仅允许选择视频

- `PHPickerFilter.livePhotos()`
  仅允许选择 Live Photo

- `PHPickerFilter.bursts()`
  连拍照片

- `PHPickerFilter.panoramas()`
  全景照片

- `PHPickerFilter.screenshots()`
  屏幕截图

- `PHPickerFilter.screenRecordings()`
  屏幕录制视频

- `PHPickerFilter.depthEffectPhotos()`
  含景深效果的照片（人像）

- `PHPickerFilter.cinematicVideos()`
  电影效果视频

- `PHPickerFilter.slomoVideos()`
  慢动作视频

- `PHPickerFilter.timelapseVideos()`
  延时摄影视频

***

### 组合过滤器

- `PHPickerFilter.all(filters)`
  同时满足所有过滤条件
  相当于逻辑 AND

- `PHPickerFilter.any(filters)`
  满足任意一个过滤条件
  相当于逻辑 OR

- `PHPickerFilter.not(filter)`
  排除指定过滤条件
  相当于逻辑 NOT

### 示例说明

```ts
// 仅允许选择 Live Photo 或普通图片
const filter = PHPickerFilter.any([
  PHPickerFilter.livePhotos(),
  PHPickerFilter.images()
])

await Photos.pick({ filter })
```

***

## PHPickerResult

表示照片选择器返回的单个选择结果。

### itemProvider: ItemProvider

获取结果的 `ItemProvider`对象，是一个Swift 的 `NSItemProvider` 对象的包装。

### livePhoto()

```ts
livePhoto(): Promise<LivePhoto | null>
```

尝试将结果解析为 Live Photo。
若资源不支持 Live Photo，则返回 `null`。

***

### uiImage()

```ts
uiImage(): Promise<UIImage | null>
```

尝试将结果解析为 `UIImage`。
若资源不是图片，则返回 `null`。

***

### imagePath()

```ts
imagePath(): Promise<string | null>
```

尝试将结果解析为图片。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回图片路径。
你应该在使用完成后删除该文件。

#### 示例

```ts
const filePath = await result.imagePath()
```

***

### videoPath()

```ts
videoPath(): Promise<string | null>
```

尝试将结果解析为视频。如果可以加载成功，该文件会被复制到 app group 的沙盒中，返回视频路径。
你应该在使用完成后删除该文件。

***

## getLatestPhotos(count)

```ts
function getLatestPhotos(count: number): Promise<UIImage[] | null>
```

获取相册中最新的若干张照片。

### 行为说明

- 仅返回图片
- 顺序为从最新到最旧
- 无权限时返回 `null`

***

## pickPhotos(count)

```ts
function pickPhotos(count: number): Promise<UIImage[]>
```

旧版便捷 API，用于快速选择固定数量的照片。

直接返回 `UIImage` 数组，不包含路径或元数据。

***

## takePhoto()

```ts
function takePhoto(): Promise<UIImage | null>
```

快速拍照接口。

- 不支持高级配置
- 用户取消时返回 `null`

***

## savePhoto(path, options)

```ts
function savePhoto(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将磁盘中的图片文件保存到系统 Photos 应用。

***

## savePhoto(image, options)

```ts
function savePhoto(
  image: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将图片二进制数据直接写入系统相册，避免创建临时文件。

***

## saveVideo(path, options)

```ts
function saveVideo(
  path: string,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频文件保存到系统 Photos 应用。

***

## saveVideo(video, options)

```ts
function saveVideo(
  video: Data,
  options?: { fileName?: string }
): Promise<boolean>
```

将视频二进制数据直接写入系统相册。

***

## 设计说明

- 所有 API 均为异步 Promise 接口
- 所有 UI 均由系统托管
- Picker 返回的结果为惰性对象，需显式解析
- 保存接口仅返回成功状态，不暴露系统资源标识



---
url: /v2/zh/guide/Device Capabilities/Photos/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Photos"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Get the latest specified number of photos from the Photos app.</Text>
        }
      >
        <Button
          title={"Photos.getLatestPhotos"}
          action={async () => {
            const images = await Photos.getLatestPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Present a photo picker dialog and pick limited number of photos.</Text>
        }
      >

        <Button
          title={"Photos.pickPhotos"}
          action={async () => {
            const images = await Photos.pickPhotos(1)
            const image = images?.[0]

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Take a photo and return a UIImage instance.</Text>
        }
      >
        <Button
          title={"Photos.takePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              Dialog.alert({
                message: `Image size: ${image.width}*${image.height}`
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Save an image to the Photos app. Returns a boolean value indicates that whether the operation is successful.</Text>
        }
      >
        <Button
          title={"Photos.savePhoto"}
          action={async () => {
            const image = await Photos.takePhoto()

            if (image != null) {
              const success = await Photos.savePhoto(Data.fromJPEG(image, 0.5)!)
              Dialog.alert({
                message: "The photo has been saved: " + success
              })
            } else {
              Dialog.alert({
                message: "Canceled"
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/Play Video/AVPlayerView.md
---

# 视频播放组件(AVPlayerView)

`AVPlayerView` 是 Scripting 提供的视频播放组件，基于系统原生 `AVPlayerViewController` 封装。
与 `VideoPlayer` 不同，`AVPlayerView` **完整支持系统级 Picture in Picture（画中画，PiP）**，并允许脚本层监听 PiP 的生命周期变化。

该组件适用于对**原生播放行为、后台播放、PiP、锁屏与控制中心联动**有明确需求的媒体类场景。

***

## 一、何时使用 AVPlayerView

当你的场景满足以下任意条件时，应使用 `AVPlayerView`：

- 需要视频进入系统 PiP 模式
- 需要原生播放控制 UI
- 需要在后台持续播放视频
- 需要与系统 Now Playing / 锁屏 / 控制中心联动
- 需要精确感知 PiP 的开始与结束

如果仅做简单的视频展示且不需要 PiP，`VideoPlayer` 仍然是更轻量的选择。

***

## 二、核心属性详解

### 1. `player`

```ts
player: AVPlayer
```

- 实际执行播放的核心对象
- 由开发者自行创建和管理
- 支持网络视频、本地文件、HLS 等格式

`AVPlayerView` **不会管理播放器的生命周期**，播放器在 PiP 期间必须保持存活。

***

### 2. `pipStatus`

```ts
pipStatus: Observable<PIPStatus>
```

用于监听系统 PiP 的生命周期状态变化。

可能的取值如下：

| 状态                 | 含义            |
| ------------------ | ------------- |
| `willStart`        | PiP 即将开始      |
| `didStart`         | PiP 已开始       |
| `willStop`         | PiP 即将结束      |
| `didStop`          | PiP 已结束       |
| `undefined / null` | 尚未进入 PiP 生命周期 |

该状态完全由系统控制，**只能监听，不应手动修改**。

***

## 三、PiP 相关配置项

### 1. `allowsPictureInPicturePlayback`

```ts
allowsPictureInPicturePlayback?: boolean
```

- 是否允许视频进入 PiP
- 默认值：`true`

若设为 `false`：

- 系统 PiP 按钮不会显示
- 视频无法进入画中画模式

***

### 2. `canStartPictureInPictureAutomaticallyFromInline`

```ts
canStartPictureInPictureAutomaticallyFromInline?: boolean
```

- 当应用从前台切换到后台时，是否自动进入 PiP
- 默认值：`false`

适合以下场景：

- 用户按下 Home 键离开应用
- 希望播放不中断并自动进入 PiP

***

### 3. `updatesNowPlayingInfoCenter`

```ts
updatesNowPlayingInfoCenter?: boolean
```

- 是否自动更新系统 Now Playing 信息
- 默认值：`true`

开启后，视频信息会显示在：

- 锁屏界面
- 控制中心
- 外接播放设备

***

## 四、全屏播放行为

### 1. `entersFullScreenWhenPlaybackBegins`

```ts
entersFullScreenWhenPlaybackBegins?: boolean
```

- 播放开始时是否自动进入全屏
- 默认值：`false`

***

### 2. `exitsFullScreenWhenPlaybackEnds`

```ts
exitsFullScreenWhenPlaybackEnds?: boolean
```

- 播放结束时是否自动退出全屏
- 默认值：`false`

***

## 五、视频显示方式（videoGravity）

```ts
videoGravity?: AVLayerVideoGravity
```

| 值                  | 行为说明           |
| ------------------ | -------------- |
| `resize`           | 拉伸填满，不保持比例     |
| `resizeAspect`     | 保持比例，完整显示（默认）  |
| `resizeAspectFill` | 保持比例，填满区域，可能裁剪 |

***

## 六、完整 DEMO 示例

以下示例演示了：

- 创建并配置 `AVPlayer`
- 正确配置音频会话
- 监听 PiP 生命周期
- 控制播放 / 暂停
- 正确释放资源

```tsx
function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(
    TimeControlStatus.paused
  )
  const pipstatus = useObservable<PIPStatus>()

  console.log(pipstatus.value)

  const player = useMemo(() => {
    const player = new AVPlayer()

    player.setSource(
      "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
    )

    player.onTimeControlStatusChanged = status => {
      setStatus(status)
    }

    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      "playback",
      ["defaultToSpeaker"]
    )

    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="VideoPlayer"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        cancellationAction: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <AVPlayerView
        player={player}
        pipStatus={pipstatus}
        canStartPictureInPictureAutomaticallyFromInline
        updatesNowPlayingInfoCenter
        entersFullScreenWhenPlaybackBegins
      />

      <Button
        title={
          status === TimeControlStatus.paused
            ? "Play"
            : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 七、PiP 生命周期说明

PiP 状态通常按以下顺序变化：

1. `willStart`
2. `didStart`
3. PiP 运行中
4. `willStop`
5. `didStop`

在异常或系统打断情况下，部分状态可能被跳过，因此应以 `didStart` 和 `didStop` 作为最终判断依据。

***

## 八、重要注意事项

### 1. AVPlayerView 使用的是系统级视频 PiP

- 基于系统原生视频 PiP
- 与 Scripting 的自定义 PiP View Modifiers **完全不同**
- 两种 PiP 机制不可混用

***

### 2. PiP 依赖正确的音频会话配置

要保证 PiP 正常工作，必须：

- 激活音频会话
- 使用 `playback` 类别
- 正确配置后台音频能力

否则可能出现 PiP 无法启动或静默失败的情况。

***

### 3. PiP 期间不要销毁 AVPlayer

- PiP 运行中销毁或替换 `AVPlayer`
- 会导致 PiP 异常退出
- 甚至触发系统错误

应在 `pipStatus` 变为 `didStop` 后再释放播放器资源。

***

## 九、推荐实践总结

- 视频 PiP 场景始终使用 `AVPlayerView`
- 将 `pipStatus` 视为只读状态
- PiP 期间保持 `AVPlayer` 生命周期稳定
- 显式配置音频会话
- 避免频繁创建或替换播放器
- 在 PiP 完全结束后再释放资源



---
url: /v2/zh/guide/Device Capabilities/Play Video/VideoPlayer/index.md
---

# 视频播放器

该视图使用强大的 `AVPlayer` 作为后端，配合简单且可定制的前端 UI，用于播放视频和音频内容。通过这种方式，你可以轻松加载媒体、控制播放、处理事件，甚至添加自定义的覆盖（overlay）界面。

***

## 概述

`VideoPlayer` 依赖一个 `AVPlayer` 实例，你需要预先将媒体加载到 `AVPlayer`，然后就能通过它来控制播放（播放、暂停、停止）并响应各种事件，例如视频准备就绪或播放结束。`overlay` 属性允许你在视频内容之上添加交互式 UI 元素（但位于系统自带的播放控制按钮下方）。

**要点概述**：

- 通过传入的 `AVPlayer` 实例来控制播放。
- 使用 `overlay` 在视频上方添加自定义 UI 元素。
- 监听 `onReadyToPlay`、`onEnded`、`onError` 等事件来响应媒体播放过程中的各种状态。

***

## 基本用法

首先，创建并配置一个 `AVPlayer` 实例：

```tsx
const player = new AVPlayer()

// 设置媒体源：可以是本地文件路径或远程 URL
player.setSource("https://example.com/video.mp4")

// 当媒体准备就绪时开始播放
player.onReadyToPlay = () => {
  console.log("媒体已就绪，开始播放。")
  player.play()
}

// 处理播放状态的变化
player.onTimeControlStatusChanged = (status) => {
  console.log("播放状态改变:", status)
}

// 当播放结束时
player.onEnded = () => {
  console.log("播放结束。")
}

// 处理错误
player.onError = (message) => {
  console.error("播放错误:", message)
}

// 配置播放属性
player.volume = 1.0          // 音量全开
player.rate = 1.0            // 正常播放速度
player.numberOfLoops = 0     // 不循环
```

然后，在你的 UI 中使用 `VideoPlayer` 视图：

```tsx
<VideoPlayer
  player={player}
  overlay={
    <HStack padding>
      <Button title="暂停" action={() => player.pause()} />
      <Button title="播放" action={() => player.play()} />
    </HStack>
  }
/>
```

这样就会在视频上展示你自定义的按钮控件，默认显示在底部左侧。

***

## 使用场景示例

假设你想要一个带有自定义控件并能自动重播的视频：

```tsx
function VideoPlayerView() {
  const player = useMemo(() => new AVPlayer(), [])

  useEffect(() => {
    player.setSource(
      Path.join(
        Script.directory,
        "localvideo.mp4"
      )
    )
    player.onReadyToPlay = () => player.play()
    player.onEnded = () => player.play() // 视频结束后自动重播

    // 设置 shared audio session.
    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      'playback',
      ['mixWithOthers']
    )

    return () => {
      // 当该视图要被销毁时，释放 AVPlayer 实例
      player.dispose()
    }
  }, [])

  return <VideoPlayer
    player={player}
    overlay={
      <HStack padding>
        <Button title="暂停" action={() => player.pause()} />
        <Button title="继续" action={() => player.play()} />
      </HStack>
    }
    frame={{
      height: 300
    }}
  />
}
```

该示例：

- 在视频准备就绪时立即加载并播放本地文件。
- 视频播放结束后自动重播。
- 在视频底部右侧提供自定义的暂停/继续按钮作为叠加控件（overlay）。

***

## 总结

`VideoPlayer` 组件在 `AVPlayer` 实例的支持下，为你的应用带来细致入微的视频播放控制。无论是调整音量、播放速度、处理缓冲状态或错误，亦或是在视频之上叠加自定义 UI 控件，`VideoPlayer` 组件和 `AVPlayer` 类都能为你提供丰富且交互性强的多媒体体验。



---
url: /v2/zh/guide/Device Capabilities/Play Video/VideoPlayer/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, useEffect, useMemo, useState, VideoPlayer, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(TimeControlStatus.paused)

  const player = useMemo(() => {
    const player = new AVPlayer()
    player.setSource("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4")
    player.onTimeControlStatusChanged = (status) => {
      setStatus(status)
    }
    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      'playback',
      ['mixWithOthers']
    )
    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle={"VideoPlayer"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <VideoPlayer
        player={player}
        frame={{
          height: 300
        }}
      />
      <Button
        title={status === TimeControlStatus.paused
          ? "Play"
          : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack >
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/QRCode.md
---

# 二维码

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text } from "scripting"

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"QRCode"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        footer={
          <Text>Open the QRCode scan page and scan.</Text>
        }
      >
        <Button
          title={"QRCode.scan"}
          action={async () => {
            const result = await QRCode.scan()
            if (result) {
              Dialog.alert({
                message: "Result: " + result
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Parse QRCode file to a string.</Text>
        }
      >
        <Button
          title={"QRCode.parse"}
          action={async () => {
            const result = await DocumentPicker.pickFiles({
              allowsMultipleSelection: false
            })
            if (result.length) {
              const code = await QRCode.parse(result[0])
              Dialog.alert({
                message: "Parse reuslt: " + code
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/QuickLook.md
---

# 快速查看

在 Scripting 应用中，**QuickLook API** 提供了一种简单的方法，用于在脚本中预览文本、图片或文件。这是对 iOS QuickLook 功能的封装，允许您快速显示多种内容类型的预览。

每个方法都会返回一个 Promise，该 Promise 会在 QuickLook 视图被关闭时解析，从而使您可以轻松地链式调用操作或处理预览后的逻辑。

***

## **API 参考**

### `QuickLook.previewText(text: string): Promise<void>`

显示文本字符串的预览。

#### **参数**

- `text` (string)：要在预览中显示的文本内容。
- `fullscreen` (boolean?): 是否以全屏模式预览。默认为false.

#### **返回值**

- `Promise<void>`：在预览关闭后解析。

#### **示例**

```tsx
await QuickLook.previewText("你好，世界！这是一个 QuickLook 预览示例。")
console.log("文本预览已关闭")
```

***

### `QuickLook.previewImage(image: UIImage): Promise<void>`

显示图片的预览。

#### **参数**

- `image` (UIImage)：要在预览中显示的图片。
- `fullscreen` (boolean?): 是否以全屏模式预览。默认为false.

#### **返回值**

- `Promise<void>`：在预览关闭后解析。

#### **示例**

```tsx
// 假设 `myImage` 是一个 UIImage 实例
await QuickLook.previewImage(myImage, true)
console.log("图片预览已关闭")
```

***

### `QuickLook.previewURLs(urls: string[]): Promise<void>`

显示一个或多个文件（位于指定的文件 URL 路径）的预览。

#### **参数**

- `urls` (string\[])：文件 URL 字符串数组。每个字符串应指向一个有效的文件路径或可以通过 QuickLook 预览的远程文件。
- `fullscreen` (boolean?): 是否以全屏模式预览。默认为false.

#### **返回值**

- `Promise<void>`：在预览关闭后解析。

#### **示例**

```tsx
const fileURLs = [
  "/path/to/file1.pdf",
  "/path/to/file2.jpg",
]

await QuickLook.previewURLs(fileURLs)
console.log("文件预览已关闭")
```

***

## **使用说明**

- **UI 阻塞**：这些方法会显示一个模态 QuickLook 视图。在用户关闭预览之前，后续代码（`await` 之后的部分）将暂停执行。
- **错误处理**：使用 `try...catch` 来处理错误，例如无效的文件路径或不支持的内容类型。
- **支持的文件类型**：支持的文件类型取决于 iOS 的 QuickLook 功能，包括常见的文件类型，例如 PDF、图片、文本文件等。

***

## **示例使用场景**

### 按顺序预览文本、图片和文件

```tsx
// 预览文本
await QuickLook.previewText("QuickLook 预览示例")

// 预览图片
const myImage = UIImage.fromFile("/path/to/image.png")
await QuickLook.previewImage(myImage)

// 预览文件
const fileURLs = [
  "/path/to/file1.pdf",
  "/path/to/file2.jpg",
]
await QuickLook.previewURLs(fileURLs)

console.log("所有预览已完成")
```

通过这个 API，您可以将 QuickLook 预览无缝集成到脚本中，以最小的努力提升用户体验。

***



---
url: /v2/zh/guide/Device Capabilities/Recurrence.md
---

# 重复规则

这些与重复相关的类型和类（`RecurrenceFrequency`、`RecurrenceDayOfWeek`、`RecurrenceWeekday`、`RecurrenceEnd` 以及 `RecurrenceRule`）允许你在 Scripting 中为事件和提醒定义并管理重复模式。通过这些类型和类，你可以设置重复间隔、指定重复的特定日期或月份，以及定义结束条件。

## 重复类型和类

### 1. `RecurrenceFrequency`

`RecurrenceFrequency` 用于定义事件或提醒的重复频率。可选值如下：

- `daily`: 每天重复。
- `weekly`: 每周重复。
- `monthly`: 每月重复。
- `yearly`: 每年重复。

此类型通常作为 `RecurrenceRule` 类中的一个属性，用来指定重复发生的频率。

**使用示例：**

```ts
const frequency: RecurrenceFrequency = "weekly"
```

### 2. `RecurrenceWeekday`

`RecurrenceWeekday` 是一个枚举类型，表示一周中的某一天。它可以让你在周重复模式下指定事件重复的具体星期几。可用值包括：

- `"sunday"`, `"monday"`, `"tuesday"`, `"wednesday"`, `"thursday"`, `"friday"`, `"saturday"`

**使用示例：**

```ts
const weekday: RecurrenceWeekday = "monday"
```

### 3. `RecurrenceDayOfWeek`

`RecurrenceDayOfWeek` 允许你指定某个特定的工作日（weekday），并可选地配合 `weekNumber` 一起使用。\
在更复杂的周重复模式中，如果你想指定某个月的某个特定星期几（例如，每月的第二个星期二），就可以用到这个类型。

`RecurrenceDayOfWeek` 可以是以下两种形式之一：

- 一个简单的 `RecurrenceWeekday`（例如 `"monday"`），或
- 一个对象，包含：
  - `weekday`: 一个 `RecurrenceWeekday`（如 `"monday"`）
  - `weekNumber`: 一个数字，用来表示该星期几在当月或当年出现的次序（正数代表从头数，负数代表从尾数）。例如，`1` 表示第一个出现的星期几，`-1` 表示最后一个出现的星期几。

**使用示例：**

```ts
const dayOfWeek: RecurrenceDayOfWeek = { weekday: "tuesday", weekNumber: 2 }
```

### 4. `RecurrenceEnd`

`RecurrenceEnd` 用于定义重复规则何时结束。它提供了两种结束重复的方式：

- `fromCount(count: number)`: 在重复了指定次数后结束。
- `fromDate(date: Date)`: 在某个特定日期结束。

这在需要限制事件或提醒的重复次数或日期时非常有用。

#### RecurrenceEnd 方法

- **fromCount(count)**: 基于重复次数创建结束条件。
  ```ts
  const endByCount = RecurrenceEnd.fromCount(10)
  ```

- **fromDate(date)**: 基于具体日期创建结束条件。
  ```ts
  const endByDate = RecurrenceEnd.fromDate(new Date("2024-12-31"))
  ```

### 5. `RecurrenceRule`

`RecurrenceRule` 用来定义事件或提醒的完整重复模式，包括重复频率、间隔、指定的日期、月份，以及可选的结束条件等。

#### RecurrenceRule 属性

- **identifier**: `string` – 该重复规则的唯一标识符。
- **frequency**: `RecurrenceFrequency` – 重复的频率（`daily`, `weekly`, `monthly`, `yearly`）。
- **interval**: `number` – 重复间的间隔（例如，每 2 周一次），必须大于 0。
- **recurrenceEnd**: `RecurrenceEnd (可选)` – 指定重复何时结束。
- **firstDayOfTheWeek**: `number` – 用来表示一周的起始日。
- **daysOfTheWeek**: `RecurrenceDayOfWeek[] (可选)` – 指定一周中的哪些天需要重复。
- **daysOfTheMonth**: `number[] (可选)` – 指定一个月中哪些日期需要重复（1 到 31 或 -1 到 -31）。
- **daysOfTheYear**: `number[] (可选)` – 指定一年中的哪些天需要重复。
- **weeksOfTheYear**: `number[] (可选)` – 指定一年中的哪些周需要重复。
- **monthsOfTheYear**: `number[] (可选)` – 指定一年中的哪些月份需要重复。
- **setPositions**: `number[] (可选)` – 用于在频率周期内筛选特定序号位置的重复。

#### RecurrenceRule 方法

- **create(options)**: 使用指定的选项创建一个 `RecurrenceRule` 实例。
  - **Options**:
    - **frequency**: 重复的频率（如 `daily`、`weekly`）。
    - **interval**: 重复的间隔（如每 2 天）。
    - **daysOfTheWeek**: `RecurrenceDayOfWeek` 数组。
    - **daysOfTheMonth**: 月中某些特定日期的数组。
    - **monthsOfTheYear**: 一年中某些特定月份的数组。
    - **weeksOfTheYear**: 一年中某些特定周的数组。
    - **daysOfTheYear**: 一年中某些特定天的数组。
    - **setPositions**: 指定用于筛选重复位置的序号数组。
    - **end**: 指定何时结束重复的规则。

**示例：**

```ts
const rule = RecurrenceRule.create({
  frequency: "monthly",
  interval: 1,
  daysOfTheWeek: [{ weekday: "monday", weekNumber: 1 }],
  end: RecurrenceEnd.fromCount(10)
})
```

## 综合运用

要使用这些类型来创建带有重复模式的事件或提醒，可以按照以下步骤：

1. **定义重复频率**：设置 `RecurrenceFrequency` 来指定事件或提醒的重复频率。
2. **指定日期或月份**：使用 `RecurrenceWeekday`、`RecurrenceDayOfWeek`、`daysOfTheMonth` 等来确定具体的重复日期。
3. **设置间隔**：通过 `interval` 控制基于频率的重复间隔。
4. **定义结束条件**（可选）：使用 `RecurrenceEnd` 指定重复何时终止。
5. **创建规则**：通过 `RecurrenceRule.create()` 并传入相关配置选项，生成最终的重复规则。

### 示例：每月的第二个星期二开会，持续 6 个月

```ts
const recurrenceRule = RecurrenceRule.create({
  frequency: "monthly",
  interval: 1,
  daysOfTheWeek: [{ weekday: "tuesday", weekNumber: 2 }],
  end: RecurrenceEnd.fromCount(6)
})

// 将 recurrenceRule 添加到你的事件或提醒中
event.addRecurrenceRule(recurrenceRule)
await event.save()
```

此示例中，`RecurrenceRule` 定义了每个月的第二个星期二重复一次的会议，共重复六次后停止。



---
url: /v2/zh/guide/Device Capabilities/Reminder.md
---

`Reminder` API 用于在 iOS 日历系统中创建、编辑和管理提醒事项。
它支持通过 `DateComponents` 设置截止日期、管理完成状态、设置优先级、添加备注、配置重复规则，以及使用提醒的各种相关属性，例如闹钟（EventAlarm）、参与者信息、状态检测属性等。

***

## 类：`Reminder`

`Reminder` 类用于操作单个提醒事项，包括读取与修改其属性、管理重复规则与闹钟，以及执行保存或删除操作。

***

# 一、属性说明

### identifier: string

唯一标识符，由系统分配（只读）。

### calendar: Calendar

提醒所属的日历。必须为有效的日历对象。

### title: string

提醒的标题或摘要。

### notes: string | null

备注信息，用于补充提醒内容。

***

## 完成状态相关属性

### isCompleted: boolean

记录提醒是否已完成。

- 设置为 `true` 时，会自动将 `completionDate` 设为当前时间。
- 设置为 `false` 时，会将 `completionDate` 设为 `null`。

说明：如果在其他设备完成了提醒，系统可能出现 `isCompleted = true` 但 `completionDate = null` 的情况。

### completionDate: Date | null

提醒被完成的时间。

- 设置为某个日期时，会自动令 `isCompleted = true`。
- 设置为 `null` 会将提醒标记为未完成。

***

## 截止时间相关属性

### dueDateComponents: DateComponents | null

表示提醒的截止时间，使用 `DateComponents` 可只设置日期部分或同时包含时间部分。

可使用 `DateComponents.isValidDate` 检查是否为有效日期组合。

### dueDate: Date | null

（已被替代的旧字段）

请使用 `dueDateComponents?.date` 获取实际日期。

### dueDateIncludesTime: boolean

（遗留字段）

可通过以下判断是否包含时间字段：
`dueDateComponents?.hour != null && dueDateComponents?.minute != null`

***

## 优先级

### priority: number

提醒的优先级，数值越大表示越重要或紧急。

***

## 重复规则

### recurrenceRules: RecurrenceRule\[] | null

重复规则数组。

### hasRecurrenceRules: boolean

是否存在重复规则（只读）。

***

## 闹钟（Alarm）相关

### alarms: EventAlarm\[] | null

提醒绑定的提醒闹钟列表。

支持：

- 绝对时间闹钟
- 相对截止时间的闹钟（基于事件开始时间时使用）
- 地理围栏位置提醒

### hasAlarm: boolean

是否包含闹钟。

***

## 参与者相关

### attendees: EventParticipant\[] | null

提醒可包含参与者对象（只读）。

说明：并非所有来源的提醒都支持参与者。

### hasAttendees: boolean

指示是否存在参与者。

***

## 状态标识属性

### hasNotes: boolean

是否包含备注信息。

### hasChanges: boolean

当前实例或其内部对象是否含有尚未保存的更改。

***

# 二、实例方法

### addAlarm(alarm: EventAlarm): void

为提醒添加一个闹钟。

### removAlarm(alarm: EventAlarm): void

移除提醒中的某个闹钟。
（方法名称为 `removAlarm`）

***

### addRecurrenceRule(rule: RecurrenceRule): void

向提醒添加一条重复规则。

### removeRecurrenceRule(rule: RecurrenceRule): void

移除指定的重复规则。

***

### `save(): Promise<void>`

保存提醒的修改。若为新建提醒，将自动添加到所属日历。

### `remove(): Promise<void>`

从日历中删除该提醒事项。

***

# 三、静态方法

### `Reminder.getAll(calendars?: Calendar[]): Promise<Reminder[]>`

获取所有提醒，可选指定日历列表。

***

### `Reminder.getIncompletes(options?): Promise<Reminder[]>`

获取未完成的提醒事项，可按截止时间与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含截止时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含截止时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

说明：
该方法不会展开重复提醒实例，仅返回基础提醒条目。

***

### `Reminder.getCompleteds(options?): Promise<Reminder[]>`

获取已完成的提醒事项，可按完成日期范围与日历过滤。

选项说明：

- `startDate?: Date`
  仅包含完成时间在该日期之后的提醒。

- `endDate?: Date`
  仅包含完成时间在该日期之前的提醒。

- `calendars?: Calendar[]`
  可选指定要查询的日历。

***

# 四、示例

## 使用 DateComponents 设置提醒

```ts
const reminder = new Reminder()
reminder.title = "准备会议资料"
reminder.notes = "周一会议前完成"

reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
  hour: 9,
  minute: 30,
})

reminder.priority = 2
await reminder.save()
```

***

## 创建仅包含日期的提醒（无时间）

```ts
reminder.dueDateComponents = new DateComponents({
  year: 2025,
  month: 10,
  day: 6,
})
```

***

## 从 Date 创建 DateComponents

```ts
const now = new Date()
reminder.dueDateComponents = DateComponents.fromDate(now)
```

***

## 获取提醒事项

```ts
const reminders = await Reminder.getAll()
for (const r of reminders) {
  console.log(`提醒：${r.title}`)
}
```

***

## 获取未完成的提醒

```ts
const incompletes = await Reminder.getIncompletes({
  startDate: new Date("2025-01-01"),
  endDate: new Date("2025-01-31"),
})
```

***

## 标记提醒完成

```ts
reminder.isCompleted = true
await reminder.save()
```

***

## 删除提醒

```ts
await reminder.remove()
```

***

# 五、补充说明

### 日期管理

建议使用 `dueDateComponents` 统一处理截止时间相关逻辑。
支持：

- 仅日期
- 完整日期与时间
- 部分字段指定（如只指定小时与分钟）

可使用 `.isValidDate` 判断组件组合是否有效。

***

### 重复提醒

查询方法不展开重复实例，而是返回提醒对象本身。
可通过 `addRecurrenceRule` 与 `removeRecurrenceRule` 管理重复模式。

***

### 闹钟（EventAlarm）

Reminder 与 CalendarEvent 均可使用 `EventAlarm`。
闹钟可基于绝对时间、相对时间或地理位置触发。

***

### 参与者字段

部分提醒来源不一定支持参与者，因此 `attendees` 可能为 `null`。



---
url: /v2/zh/guide/Device Capabilities/Safari/index.md
---

# Safari

`Safari` 模块提供用于打开和展示网页的函数，可通过系统默认浏览器外部打开，或在 Scripting 应用内通过内嵌 Safari 视图打开网页，实现沉浸式或外部浏览的无缝切换。

***

## 模块：`Safari`

该模块包含两个函数：

***

### ▸ `Safari.openURL(url: string): Promise<boolean>`

使用系统默认方式打开指定的 URL。根据 URL 的 scheme 类型，可能会启动 Safari、其他浏览器或对应的第三方应用。

#### 参数

- **`url`** (`string`): 要打开的 URL。支持以 `http://`、`https://` 开头的网址，也支持如 `mailto:`、`tel:`、`appname://` 等自定义 URL scheme。

#### 返回值

- 返回一个 `Promise<boolean>`，当 URL 成功打开时为 `true`，如果打开失败（例如无效的 scheme 或未安装支持的应用）则为 `false`。

#### 示例

```ts
const success = await Safari.openURL('mailto:hello@example.com')
if (!success) {
  console.error('打开 URL 失败')
}
```

***

### ▸ `Safari.present(url: string, fullscreen?: boolean): Promise<void>`

在 Scripting 应用内使用内嵌 Safari 视图展示网页。该网页以模态窗口方式呈现。返回的 Promise 会在用户关闭该视图后才完成。

#### 参数

- **`url`** (`string`): 要展示的网页地址。
- **`fullscreen`** (`boolean`, 可选): 是否以全屏方式展示，默认为 `true`。

#### 返回值

- 一个 `Promise<void>`，在用户关闭网页视图后完成。

#### 示例

默认全屏展示网站：

```ts
await Safari.present('https://developer.apple.com')

// 视图关闭后执行
console.log('网页视图已关闭。')
```

非全屏展示（例如嵌入界面中的子页面）：

```ts
await Safari.present('https://news.ycombinator.com', false)

// 视图关闭后执行
console.log('网页视图已关闭。')
```

***

## 使用场景

- 跳转到外部链接，例如帮助文档、认证页面或 App Store。
- 在应用内展示在线内容，如博客文章、数据面板等。
- 通过自定义 URL scheme 启动第三方应用。

***

## 注意事项

- 请确保传入的是完整有效的 URL。
- 若希望用户停留在应用中，请使用 `present()`。
- 若需跳转到外部浏览器或打开其他 app，请使用 `openURL()`。



---
url: /v2/zh/guide/Device Capabilities/Safari/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, } from "scripting"

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Safari"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Button
        title={"Open URL in system default browser"}
        action={() => {
          Safari.openURL("https://github.com")
        }}
      />

      <Button
        title={"Open URL in-app browser"}
        action={async () => {
          await Safari.present("https://github.com", false)
          console.log("Dismissed")
        }}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/Send Mail.md
---

# 发送邮件

`MailUI` 模块允许你的脚本调用系统的邮件撰写视图，预填收件人、主题、正文和附件，并由用户发送邮件。它还提供一个属性用于检测设备是否支持发送邮件。

原 `Mail` API 已废弃。

***

## `MailUI.isAvailable: boolean`

如果当前设备已配置邮箱账户，并支持通过系统的 Mail 应用发送邮件，返回 `true`。

```ts
if (!MailUI.isAvailable) {
  console.log("当前设备不支持发送邮件。")
}
```

***

## `MailUI.present(options): Promise<"cancelled" | "sent" | "failed" | "saved">`

展示系统级的邮件撰写界面，预填内容并等待用户操作。用户可编辑内容后选择发送、取消或保存草稿。

### 参数说明

| 参数名                            | 类型             | 是否必填 | 说明                         |
| ------------------------------ | -------------- | ---- | -------------------------- |
| `toRecipients`                 | `string[]`     | 是    | 邮件主收件人列表，填写在“收件人”字段        |
| `ccRecipients`                 | `string[]`     | 否    | 抄送收件人列表，填写在“抄送”字段          |
| `bccRecipients`                | `string[]`     | 否    | 密送收件人列表，填写在“密送”字段          |
| `preferredSendingEmailAddress` | `string`       | 否    | 指定用于发送邮件的发件邮箱（如果配置了多个邮箱账户） |
| `subject`                      | `string`       | 否    | 邮件主题内容                     |
| `body`                         | `string`       | 否    | 邮件正文内容                     |
| `attachments`                  | `Attachment[]` | 否    | 附件数组，添加文件至邮件中              |

### 附件对象结构

每个附件应包含以下字段：

| 字段名        | 类型       | 是否必填 | 说明                                               |
| ---------- | -------- | ---- | ------------------------------------------------ |
| `data`     | `Data`   | 是    | 要附加的二进制数据内容                                      |
| `mimeType` | `string` | 是    | 附件的 MIME 类型，例如 `"image/png"`、`"application/pdf"` |
| `fileName` | `string` | 是    | 附件在邮件中显示的文件名                                     |

***

### 返回值

此方法返回一个 `Promise`，其结果为下列字符串之一：

- `"sent"`：邮件已成功发送；
- `"cancelled"`：用户取消了发送操作；
- `"failed"`：发送失败（如无邮箱账户配置或发送错误）；
- `"saved"`：邮件已保存为草稿。

***

### 抛出异常

当满足以下条件时，此方法会抛出异常：

- 当前设备不支持发送邮件（`MailUI.isAvailable` 为 `false`）；
- 参数格式错误或缺少必填项；

***

## 示例：发送简单邮件

```ts
if (MailUI.isAvailable) {
  const result = await MailUI.present({
    toRecipients: ["user@example.com"],
    subject: "来自脚本的问候",
    body: "这封邮件由 Scripting 脚本发送。"
  })

  console.log("发送结果：", result) // 可能为 sent、cancelled、failed 或 saved
}
```

***

## 示例：发送带附件的邮件

```ts
const fileData = Data.fromString("这是附件的内容。")

if (MailUI.isAvailable) {
  const result = await MailUI.present({
    toRecipients: ["user@example.com"],
    subject: "附加文件",
    body: "请查收附件。",
    attachments: [
      {
        data: fileData,
        mimeType: "text/plain",
        fileName: "说明.txt"
      }
    ]
  })

  if (result === "sent") {
    console.log("邮件已成功发送。")
  } else {
    console.log("邮件未发送，状态：", result)
  }
}
```

***

## 注意事项

- 邮件撰写界面必须在具有用户交互的上下文中调用，不能在后台脚本中使用；
- 邮件发送行为由用户最终确认；
- 此 API 需要设备上已正确配置 Mail 应用的邮箱账户。



---
url: /v2/zh/guide/Device Capabilities/Send Message.md
---

# 发送信息

`MessageUI` 命名空间提供了一组 API，用于检测设备的短信发送能力，并展示系统级的短信撰写界面。你可以通过脚本向一个或多个联系人发送短信或彩信，还可以添加主题和附件（如果设备支持）。

## 可用性属性

### `MessageUI.isAvailable: boolean`

如果设备支持发送纯文本短信，返回 `true`。

```ts
if (!MessageUI.isAvailable) {
  console.log("此设备无法发送短信")
}
```

### `MessageUI.canSendSubject: boolean`

如果设备支持添加“主题”字段，返回 `true`。

### `MessageUI.canSendAttachments: boolean`

如果设备支持在短信中添加“附件”，返回 `true`。

***

## `MessageUI.present(options): Promise<"cancelled" | "sent" | "failed">`

展示系统的短信撰写界面，并在用户操作完成后返回结果。

### 参数

| 参数名           | 类型             | 是否必填 | 说明                                           |
| ------------- | -------------- | ---- | -------------------------------------------- |
| `recipients`  | `string[]`     | 是    | 收件人电话号码数组                                    |
| `body`        | `string`       | 是    | 短信正文内容                                       |
| `subject`     | `string`       | 否    | 可选的主题内容，仅在 `canSendSubject` 为 `true` 时有效     |
| `attachments` | `Attachment[]` | 否    | 可选的附件列表，仅在 `canSendAttachments` 为 `true` 时有效 |

### 附件对象结构

| 字段名        | 类型       | 是否必填 | 说明                                               |
| ---------- | -------- | ---- | ------------------------------------------------ |
| `data`     | `Data`   | 是    | 要附加的二进制数据                                        |
| `type`     | `UTType` | 是    | 附件的统一类型标识符，例如 `"public.image"`、`"public.text"` 等 |
| `fileName` | `string` | 是    | 附件在消息中显示的文件名                                     |

***

### 返回值

返回一个 `Promise`，其结果为以下字符串之一：

- `"sent"`：用户已成功发送短信；
- `"cancelled"`：用户取消了发送；
- `"failed"`：系统发送失败（如网络或权限问题）。

***

## 示例：发送普通短信

```ts
if (MessageUI.isAvailable) {
  const result = await MessageUI.present({
    recipients: ["1234567890"],
    body: "你好，这是一条脚本发送的短信！"
  })

  console.log("发送结果：", result) // 可能为 sent、cancelled 或 failed
}
```

***

## 示例：发送带主题和附件的短信

```ts
const fileData = Data.fromString("这是文档的内容")

if (MessageUI.isAvailable && MessageUI.canSendAttachments) {
  const result = await MessageUI.present({
    recipients: ["1234567890"],
    body: "请查收附件文件。",
    subject: "你请求的文件",
    attachments: [
      {
        data: fileData,
        type: "public.text",
        fileName: "说明.txt"
      }
    ]
  })

  if (result === "sent") {
    console.log("短信发送成功")
  } else {
    console.log("短信未发送，原因：", result)
  }
}
```

***

## 注意事项

- 如果设备不支持主题或附件功能，相关选项会被自动忽略。
- 撰写界面由系统提供，用户必须手动发送或取消。
- 该 API 只能在前台交互式脚本中使用，不能在后台任务中调用。



---
url: /v2/zh/guide/Device Capabilities/ShareSheet.md
---

# 分享内容

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"ShareSheet"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        footer={
          <Text>Present a ShareSheet UI.</Text>
        }
      >
        <Button
          title={"ShareSheet.present"}
          action={async () => {
            // const image = await Photos.getLatestPhotos(1)
            // await ShareSheet.present([image])
            if (await ShareSheet.present(["Hello Scripting!"])) {
              Dialog.alert({
                message: "Share successfully."
              })
            } else {
              Dialog.alert({
                message: "Cancelled"
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/SharedAudioSession.md
---

# SharedAudioSession

通过 `SharedAudioSession`，你可以在脚本中方便地管理和操作共享音频会话（audio session）。音频会话充当脚本、Scripting 应用、操作系统和底层音频硬件之间的中介，允许你有效地配置和控制音频的行为。

***

## 功能简介

- 获取和设置音频会话的类别（category）、模式（mode）和选项（options）。
- 配置音频输入和输出的首选采样率（sample rate）。
- 处理音频中断事件。
- 查询设备所支持的类别和模式。
- 根据具体的应用场景（如视频录制、语音聊天、后台播放等）来定制音频行为。

***

## 方法和属性

### 1. **会话类别与选项**

#### `category`

获取当前音频会话的类别（Category）。

```typescript
const category = await SharedAudioSession.category
console.log(category) // 示例输出：'playback'
```

#### `categoryOptions`

获取当前音频会话类别的选项（Options）。

```typescript
const options = await SharedAudioSession.categoryOptions
console.log(options) // 示例输出：['mixWithOthers', 'allowAirPlay']
```

#### `setCategory(category: AudioSessionCategory, options: AudioSessionCategoryOptions[])`

设置音频会话的类别并指定其选项。

```typescript
await SharedAudioSession.setCategory('playback', ['mixWithOthers'])
```

***

### 2. **会话模式**

#### `mode`

获取当前音频会话模式（Mode）。

```typescript
const mode = await SharedAudioSession.mode
console.log(mode) // 示例输出：'videoChat'
```

#### `setMode(mode: AudioSessionMode)`

设置音频会话模式。

```typescript
await SharedAudioSession.setMode('voiceChat')
```

***

### 3. **采样率 (Sample Rate)**

#### `preferredSampleRate`

获取当前首选采样率（单位为 Hz）。

```typescript
const sampleRate = await SharedAudioSession.preferredSampleRate
console.log(sampleRate) // 示例输出：44100
```

#### `setPreferredSampleRate(sampleRate: number)`

设置音频输入和输出的首选采样率。

```typescript
await SharedAudioSession.setPreferredSampleRate(48000)
```

***

### 4. **音频中断处理**

#### `addInterruptionListener(listener: AudioSessionInterruptionListener)`

监听音频中断事件。

```typescript
SharedAudioSession.addInterruptionListener((type) => {
  if (type === 'began') {
    console.log('音频中断开始')
  } else if (type === 'ended') {
    console.log('音频中断结束')
  }
})
```

#### `removeInterruptionListener(listener: AudioSessionInterruptionListener)`

移除音频中断监听器。

```typescript
SharedAudioSession.removeInterruptionListener(myListener)
```

***

### 5. **设备功能查询**

#### `availableCategories`

获取设备上可用的音频会话类别列表。

```typescript
const categories = await SharedAudioSession.availableCategories
console.log(categories) // 示例输出：['playback', 'record', 'soloAmbient']
```

#### `availableModes`

获取设备上可用的音频会话模式列表。

```typescript
const modes = await SharedAudioSession.availableModes
console.log(modes) // 示例输出：['default', 'videoChat', 'voiceChat']
```

***

### 6. **其他属性**

#### `isOtherAudioPlaying`

检查设备上是否有其他音频正在播放。

```typescript
const isPlaying = await SharedAudioSession.isOtherAudioPlaying
console.log(isPlaying) // 示例输出：true
```

#### `secondaryAudioShouldBeSilencedHint`

检查次要音频是否应该被静音。

```typescript
const shouldSilence = await SharedAudioSession.secondaryAudioShouldBeSilencedHint
console.log(shouldSilence) // 示例输出：false
```

#### `allowHapticsAndSystemSoundsDuringRecording`

检查录音期间是否允许触觉反馈和系统声音。

```typescript
const allowHaptics = await SharedAudioSession.allowHapticsAndSystemSoundsDuringRecording
console.log(allowHaptics) // 示例输出：true
```

#### `prefersNoInterruptionsFromSystemAlerts`

检查音频会话是否偏好不被系统警报打断。

```typescript
const prefersNoInterruptions = await SharedAudioSession.prefersNoInterruptionsFromSystemAlerts
console.log(prefersNoInterruptions) // 示例输出：false
```

***

### 7. **会话激活**

#### `setActive(active: boolean, options?: AudioSessionSetActiveOptions[])`

激活或停用共享音频会话，可指定激活选项。

```typescript
await SharedAudioSession.setActive(
  true,
  ['notifyOthersOnDeactivation']
)
```

***

### 8. **系统设置**

#### `setAllowHapticsAndSystemSoundsDuringRecording(value: boolean)`

启用或禁用在录音期间允许触觉反馈和系统声音。

```typescript
await SharedAudioSession.setAllowHapticsAndSystemSoundsDuringRecording(true)
```

#### `setPrefersNoInterruptionsFromSystemAlerts(value: boolean)`

设置是否偏好不被系统警报打断。

```typescript
await SharedAudioSession.setPrefersNoInterruptionsFromSystemAlerts(true)
```

***

### 9. **系统输出音量**

#### `outputVolume: number`

获取当前系统输出音量（范围为 0 到 1）。

#### outputVolume 监听事件

类型类型

```ts
type AudioSessionOutputVolumeListener = (newValue: number, oldValue: number) => void
```

##### `addOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

添加系统输出音量监听器。

##### `removeOutputVolumeListener(listener: AudioSessionOutputVolumeListener): void`

移除系统输出音量监听器。

***

## 枚举（Enumerations）

### **AudioSessionSetActiveOptions**

定义激活选项：

- `'notifyOthersOnDeactivation'`

### **AudioSessionCategory**

定义音频会话的类别：

- `'ambient'`
- `'multiRoute'`
- `'playAndRecord'`
- `'playback'`
- `'record'`
- `'soloAmbient'`

### **AudioSessionCategoryOptions**

定义类别的可选行为：

- `'mixWithOthers'`
- `'duckOthers'`
- `'interruptSpokenAudioAndMixWithOthers'`
- `'allowBluetooth'`
- `'allowBluetoothA2DP'`
- `'allowAirPlay'`
- `'defaultToSpeaker'`
- `'overrideMutedMicrophoneInterruption'`

### **AudioSessionMode**

指定会话模式：

- `'default'`
- `'gameChat'`
- `'measurement'`
- `'moviePlayback'`
- `'spokenAudio'`
- `'videoChat'`
- `'videoRecording'`
- `'voiceChat'`
- `'voicePrompt'`

### **AudioSessionInterruptionType**

指定中断类型：

- `'began'`
- `'ended'`
- `'unknown'`

***

通过此接口，你可以在 Scripting 应用中对音频会话进行深度管理，非常适合构建对音频依赖较高的脚本，如音乐播放器和视频会议工具等。



---
url: /v2/zh/guide/Device Capabilities/Speech/index.md
---

# 语音合成

该接口为文本转语音（TTS）功能提供了高级 API，方便进行语音合成、播放控制以及语音合成相关设置的管理。下面详细介绍 `Speech` API 的方法、属性以及用法示例。

***

## 功能概述

- **文本转语音**：将文本转换为语音，可自定义语速、音调和音量等选项。
- **语音管理**：根据语言或语音标识符来选择系统中的可用语音。
- **Markdown 支持**：将文本作为 Markdown 解析以进行基本格式化。
- **音频会话管理**：与其他音频源无缝衔接，控制音频会话。
- **事件监听器**：对语音合成过程中的生命周期事件做出响应。

***

## 类型定义

### `SpeechBoundary`

指定何时暂停或停止语音：

- `'immediate'`: 立即暂停或停止。
- `'word'`: 在完成当前单词后暂停或停止。

***

### `SpeechSynthesisVoice`

表示语音合成使用的语音：

- `identifier`: 语音的唯一标识符。
- `name`: 语音的显示名称。
- `language`: BCP 47 格式的语言和区域代码。
- `quality`: 语音品质（`'default'`、`'premium'`、`'enhanced'`）。
- `gender`: 语音性别（`'male'`、`'female'`、`'unspecified'`）。

***

### `SpeechProgressDetails`

语音合成过程中有关进度的详细信息：

- `text`: 正在朗读的完整文本。
- `start`: 当前单词在文本中的起始索引。
- `end`: 当前单词在文本中的结束索引。
- `word`: 当前正在朗读的单词。

***

### `SpeechSynthesisOptions`

自定义语音合成的选项：

- `isMarkdown`（可选）: 将文本视为 Markdown 解析。
- `pitch`, `rate`, `volume`: 用于覆盖全局 `Speech` 设置中的音调、语速和音量。
- `preUtteranceDelay`, `postUtteranceDelay`: 控制每句开始前与结束后的延迟。
- `voiceIdentifier`, `voiceLanguage`: 用于覆盖全局语音设置。

***

## 静态属性

### 全局语音设置

- `pitch`: 默认音调（范围：`0.5`～`2.0`；默认值：`1.0`）。
- `rate`: 语速（范围：`Speech.minSpeechRate` ～ `Speech.maxSpeechRate`；默认值：`Speech.defaultSpeechRate`）。
- `volume`: 默认音量（范围：`0.0`～`1.0`；默认值：`1.0`）。
- `preUtteranceDelay`, `postUtteranceDelay`: 全局的发音前后延迟。

### 语音和语言

- `speechVoices`: 获取所有可用语音。
- `currentLanguageCode`: 设备的当前语言代码。

### 音频会话

- `usesApplicationAudioSession`: 指定是否由应用来管理音频会话。

***

## 方法

### 语音播放与合成

- **`speak(text: string, options?: SpeechSynthesisOptions): Promise<void>`**\
  将文本添加到语音队列进行合成和朗读。

- **`synthesizeToFile(text: string, filePath: string, options?: SpeechSynthesisOptions): Promise<void>`**\
  将文本合成为音频文件并保存在文档目录下的指定文件路径。

### 播放控制

- **`pause(at?: SpeechBoundary): Promise<boolean>`**\
  在指定的边界点暂停语音。默认在 `'immediate'` 处暂停。

- **`resume(): Promise<boolean>`**\
  从暂停状态恢复朗读。

- **`stop(at?: SpeechBoundary): Promise<boolean>`**\
  在指定边界点停止朗读。默认在 `'immediate'` 处停止。

### 状态管理

- **`isSpeaking`**: 检查当前合成器是否正在朗读或处于暂停状态。
- **`isPaused`**: 检查当前合成器是否处于暂停状态。

### 语音管理

- **`setVoiceByIdentifier(identifier: string): Promise<boolean>`**\
  根据语音标识符来设置语音。

- **`setVoiceByLanguage(language: string): Promise<boolean>`**\
  根据语言代码来设置语音。

***

## 事件监听器

### 支持的事件

- **`start`**: 语音合成开始。
- **`pause`**: 语音暂停。
- **`continue`**: 语音从暂停状态继续。
- **`finish`**: 语音朗读完成。
- **`cancel`**: 语音合成被取消。
- **`progress`**: 提供合成进度的详细信息（`SpeechProgressDetails`）。

### 监听器管理

- **`addListener(event: string, listener: Function): void`**\
  添加事件监听器。

- **`removeListener(event: string, listener: Function): void`**\
  移除事件监听器。

***

## 示例

### 配置 `SharedAudioSession`

```ts
await SharedAudioSession.setActive(true)
await SharedAudioSession.setCategory(
  "playback",
  ["mixWithOthers"]
)
```

### 播放文本

```ts
await Speech.speak("Hello, world!")
```

### 使用自定义选项朗读文本

```ts
await Speech.speak("Welcome to **Scripting**", {
  isMarkdown: true,
  pitch: 1.5,
  rate: 0.8,
  voiceLanguage: "en-US",
})
```

### 将文本合成为文件

```ts
import { Path } from "scripting"

const filePath = Path.join(FileManager.documentDirectory, "output.caf")
await Speech.synthesizeToFile("Saving to file.", filePath, { rate: 1.0 })
```

### 控制播放

```ts
await Speech.speak("Pausing example...")
await Speech.pause("word")
await Speech.resume()
await Speech.stop() // 默认在 "immediate" 处停止。
```

### 添加进度监听器

```ts
Speech.addListener("progress", (details) => {
  console.log(`正在朗读: ${details.word}`)
});
await Speech.speak("Event listening example.")
Speech.removeListener("progress", listener)
```

通过这些 API，你可以在脚本中实现功能强大的语音合成操作，包括基础的文本转语音、播放控制以及事件回调，为开发者提供灵活且丰富的 TTS 功能。



---
url: /v2/zh/guide/Device Capabilities/Speech/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Path, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Speech Example"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Activate the SharedAudioSeesion, and speak a text.</Text>
        }
      >
        <Button
          title={"Speak a text"}
          action={async () => {
            console.present()
            if (await Speech.isSpeaking) {
              await Speech.stop('immediate')
              console.log("Stopped.")
              return
            }

            await SharedAudioSession.setActive(true)
            await SharedAudioSession.setCategory('playback', ['mixWithOthers'])

            const listener = () => {
              console.log("Speak completed!")
              Speech.removeListener('finish', listener)
            }

            Speech.addListener('finish', listener)

            await Speech.speak('Hi there, welcome to Scripting! I wish this app is helpful to you.', {
              voiceLanguage: 'en-US',
            })

            console.log("Started, tap the run button to stop.")
          }}
        />
      </Section>
      <Section
        footer={
          <Text>Synthesize text to the file stored in local documents directory.</Text>
        }
      >
        <Button
          title={"synthesize to File"}
          action={async () => {
            console.present()
            const filePath = Path.join(FileManager.documentsDirectory, 'greeting.caf')
            const listener = () => {
              if (FileManager.existsSync(filePath)) {
                console.log("Audio file is saved to " + filePath + ". Start to play it.")

                let player = new AVPlayer()
                player.setSource(filePath)
                player.onReadyToPlay = () => {
                  player.play()
                }
                player.onEnded = () => {
                  player.dispose()
                }
              } else {
                console.log("Failed to save audio file.")
              }
              Speech.removeListener('finish', listener)
            }

            Speech.addListener('finish', listener)

            await Speech.synthesizeToFile(
              'Hi there, welcome to Scripting! I wish this app is helpful to you.',
              filePath, {
              voiceLanguage: 'en-US',
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/SpeechRecognition/index.md
---

# 语音识别

该接口可用于执行语音识别，包括实时语音识别和音频文件的识别，能适应多种使用场景的需求。

***

## 功能概览

- **实时识别**：从麦克风捕获实时音频并转录为文本。
- **文件识别**：分析和转录已录制的音频文件。
- **多语言支持**：指定识别的语言区域，用于识别不同语言。
- **中间结果**：获取渐进式的转录结果，包括部分结果和最终结果。
- **自定义回调**：通过事件监听器处理转录结果和音量变化等。

***

## 类型定义

### `RecognitionTaskHint`

用于指定语音识别任务的类型提示：

- `'confirmation'`：适合诸如“yes”，“no”或“maybe”之类的指令。
- `'dictation'`：类似键盘输入的语音听写。
- `'search'`：识别搜索关键词。
- `'unspecified'`：通用的语音识别。

***

### `SpeechRecognitionResult`

表示语音识别的结果：

- `isFinal`: 表示该转录结果是否完整且最终。
- `text`: 转录内容，为置信度最高的可展示文本。

***

## 静态属性

### 支持的语言区域

- `supportedLocales`: 返回该语音识别器支持的语言区域列表，如 `"en-US"`、`"fr-FR"` 或 `"zh-CN"` 等。

### 识别状态

- `isRecognizing`: 指示当前是否有识别请求在进行中。

***

## 方法

### 开始实时识别

**`start(options: object): Promise<boolean>`**\
从设备麦克风开始进行语音识别。

#### Options 参数

- `locale`: 识别所用的语言区域字符串（可选）。
- `partialResults`: 是否返回中间结果（默认为 `true`）。
- `addsPunctuation`: 是否自动添加标点符号（默认为 `false`）。
- `requestOnDeviceRecognition`: 是否将音频数据留在本地进行识别（默认为 `false`）。
- `taskHint`: 指定识别任务类型（`'confirmation'`, `'dictation'`, `'search'`, `'unspecified'`）。
- `useDefaultAudioSessionSettings`: 是否使用默认的音频会话设置（默认为 `true`）。
- `onResult`: 用于处理识别结果的回调函数（参数类型为 `SpeechRecognitionResult`）。
- `onSoundLevelChanged`: 音量变化时触发的回调函数（可选）。

#### 使用示例

```ts
await SpeechRecognition.start({
  locale: "en-US",
  partialResults: true,
  addsPunctuation: true,
  onResult: (result) => {
    console.log("Transcription:", result.text)
  },
  onSoundLevelChanged: (level) => {
    console.log("Sound Level:", level)
  }
})
```

***

### 识别音频文件

**`recognizeFile(options: object): Promise<boolean>`**\
对已录制的音频文件进行识别。

#### Options 参数

- `filePath`: 音频文件的路径。
- `locale`: 识别所用的语言区域字符串（可选）。
- `partialResults`: 是否返回中间结果（默认为 `false`）。
- `addsPunctuation`: 是否自动添加标点符号（默认为 `false`）。
- `requestOnDeviceRecognition`: 是否将音频数据留在本地进行识别（默认为 `false`）。
- `taskHint`: 指定识别任务类型（`'confirmation'`, `'dictation'`, `'search'`, `'unspecified'`）。
- `onResult`: 用于处理识别结果的回调函数（参数类型为 `SpeechRecognitionResult`）。

#### 使用示例

```ts
await SpeechRecognition.recognizeFile({
  filePath: FileManager.join(FileManager.documentDirectory, "example.wav"),
  locale: "en-US",
  addsPunctuation: true,
  onResult: (result) => {
    console.log("File Transcription:", result.text)
  }
})
```

***

### 停止识别

**`stop(): Promise<void>`**\
停止当前正在进行的语音识别。

#### 使用示例

```ts
await SpeechRecognition.stop()
```

***

## 示例

### 实时识别并查看进度

```ts
await SpeechRecognition.start({
  locale: "en-US",
  onResult: (result) => {
    console.log(result.isFinal ? "Final Result:" : "Partial Result:", result.text)
  },
  onSoundLevelChanged: (level) => {
    console.log("Sound Level:", level)
  }
})
```

### 识别音频文件

```ts
await SpeechRecognition.recognizeFile({
  filePath: FileManager.join(FileManager.documentDirectory, "audio.m4a"),
  partialResults: false,
  onResult: (result) => {
    console.log("File recognition completed. Transcription:", result.text)
  }
})
```

### 停止正在进行的识别

```ts
if (await SpeechRecognition.start({
  // ...
})) {
  // 10 秒后停止识别
  setTimeout(() => {
    await SpeechRecognition.stop()
  }, 10 * 1000)
}
```

***

## 注意事项

- 在使用该 API 前，请先确保已获取必要的麦克风或文件访问权限。
- 可以使用 `supportedLocales` 来确定可用于识别的语言。
- 为了获得最佳效果，请使用 iOS 支持的音频格式（例如 `.wav`, `.m4a`）作为输入。



---
url: /v2/zh/guide/Device Capabilities/SpeechRecognition/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"SpeechRecognition"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Returns the list of locales that are supported by the speech recognizer.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.supportedLocales"}
          action={() => {
            console.clear()
            console.present()
            console.log(JSON.stringify(SpeechRecognition.supportedLocales, null, 2))
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Returns a boolean that indicates whether the recognizer is running.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.isRecognizing"}
          action={() => {
            console.clear()
            console.present()
            console.log(
              "SpeechRecognition.isRecognizing",
              SpeechRecognition.isRecognizing
            )
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Start a speech audio buffer recognition request. Return a boolean value that indicates whether the operation was successfully.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.start"}
          action={async () => {
            console.clear()
            console.present()
            console.log("Speech recognizing is started, it will stop after 5s.")

            if (await SpeechRecognition.start({
              locale: "en-US",
              partialResults: false,
              onResult: result => {
                console.log("Result: " + result.text)
              }
            })) {
              setTimeout(async () => {
                await SpeechRecognition.stop()
                console.log("Stoped")
              }, 5000)
            } else {
              console.error("Failed to start recognizing")
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Start a request to recognize speech in a recorded audio file.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.recognizeFile"}
          action={async () => {
            console.clear()
            console.present()
            console.log("SpeechRecognition is started, it will stop after 5s.")

            let audioFilePathToRecognize = await DocumentPicker.pickFiles({
              types: ["public.audio"]
            })

            if (audioFilePathToRecognize.length === 0) {
              console.log("Please pick a audio file.")
              return
            }

            if (await SpeechRecognition.recognizeFile({
              filePath: audioFilePathToRecognize[0],
              partialResults: true,
              onResult: (result) => {
                console.log("Recognized result: " + result.text)
              }
            })) {
              console.log("Started recognizing file...")
            } else {
              console.error("Failed to start recognizing",)
            }
          }}
        />
      </Section>

      <Section
        footer={
          <Text>Stop speech recognition request. Return a boolean value that indicates whether the operation was successfully.</Text>
        }
      >
        <Button
          title={"SpeechRecognition.stop"}
          action={async () => {
            if (SpeechRecognition.isRecognizing) {
              await SpeechRecognition.stop()
              Dialog.alert({
                message: "SpeechRecognition is stopped."
              })
            } else {
              Dialog.alert({
                message: "No progressing recognition."
              })
            }
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}


async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Device Capabilities/Translation.md
---

# 翻译

`Translation` API 提供了将文本在不同语言之间翻译的能力，支持单条文本和批量文本的翻译，适用于 **iOS 18.0 及以上系统**。

## 概览

此 API 通过 `Translation` 类提供，包含以下功能：

- 共享的全局翻译实例 `Translation.shared`
- 翻译单条文本
- 翻译多条文本（批量翻译）
- 支持自动检测源语言并根据设备偏好选择目标语言

***

## 类：`Translation`

### `Translation.shared: Translation`

提供一个共享的 `Translation` 实例，适用于无界面脚本或需要复用统一翻译主机的场景。

#### 示例

```ts
const translated = await Translation.shared.translate({
  text: "Hello, world!",
  source: "en",
  target: "es"
})

console.log(translated) // 输出: "¡Hola, mundo!"
```

***

### 方法：`translate(options): Promise<string>`

将一段文本从源语言翻译为目标语言。

#### 参数

- `options.text: string`
  要翻译的文本内容。

- `options.source?: string`
  源语言代码，例如 `"en"` 表示英语。如果省略或为 `null`，系统将自动尝试识别源语言，并在不确定时提示用户选择。

- `options.target?: string`
  目标语言代码，例如 `"es"` 表示西班牙语。如果省略或为 `null`，系统将根据设备的 `Device.preferredLanguages` 和源语言自动选择目标语言。

#### 返回值

- `Promise<string>` — 返回一个 Promise，解析为翻译后的文本字符串。

#### 异常

- 翻译失败时会抛出错误（例如网络问题、不支持的语言等）。

#### 示例

```ts
const translated = await Translation.shared.translate({
  text: "Good morning",
  target: "fr"
})

console.log(translated) // 输出: "Bonjour"
```

***

### 方法：`translateBatch(options): Promise<string[]>`

将多个文本条目从源语言翻译为目标语言，支持批量处理。

#### 参数

- `options.texts: string[]`
  要翻译的文本数组。返回的翻译结果与输入顺序一一对应。

- `options.source?: string`
  源语言代码，作用同 `translate` 方法。

- `options.target?: string`
  目标语言代码，作用同 `translate` 方法。

#### 返回值

- `Promise<string[]>` — 返回一个 Promise，解析为翻译后的文本数组。

#### 异常

- 如果翻译过程中出现任何错误，会抛出异常。

#### 示例

```ts
const results = await Translation.shared.translateBatch({
  texts: ["Hello", "Good night", "Thank you"],
  source: "en",
  target: "ja"
})

console.log(results)
// 输出: ["こんにちは", "おやすみなさい", "ありがとう"]
```

***

## 注意事项

- 语言代码应使用 [ISO 639-1](https://zh.wikipedia.org/wiki/ISO_639-1) 标准（如 `"en"` 表示英语，`"zh"` 表示中文，`"de"` 表示德语）。

- API 使用系统级翻译服务，部分情况下可能弹出语言选择提示。

- 在以下场景中应使用 `translationHost` 视图修饰符：
  - **在用户界面中进行翻译操作**
    当你的脚本包含用户界面（例如使用 `<VStack>`、`<List>` 等）并使用自定义的 `Translation` 实例（例如通过 `new Translation()` 创建）执行翻译时，**必须**将 `translationHost` 应用于根视图，以便系统能够弹出权限请求、语言下载提示或源语言选择对话框。

  - **未指定源语言（`source` 为 `null`）**
    如果在翻译请求中省略了 `source` 字段，依赖系统自动检测语言，当检测失败时，`translationHost` 可确保系统能够提示用户手动选择源语言。

  - **可能需要下载语言包**
    如果设备未安装所需的源语言或目标语言，`translationHost` 允许系统向用户弹出下载提示，从而完成翻译任务。

- 如果你使用的是预设绑定的 `Translation.shared` 实例，并且脚本不涉及任何界面（如后台运行的脚本），则**不需要**设置 `translationHost`。



---
url: /v2/zh/guide/Device Capabilities/VideoRecorder.md
---

# 视频录制（VideoRecorder）

`VideoRecorder` 用于在 Scripting 中创建和控制一个可编程的视频录制会话，完整封装了相机选择、音视频采集、编码、暂停/恢复、缩放、对焦、补光灯控制以及最终文件写入流程。

该 API 适用于自定义相机界面、视频采集工具、自动化录制脚本等场景。

***

## 核心能力概览

- 支持前置与后置摄像头
- 支持指定摄像头类型（广角、超广角、长焦等）
- 支持多种帧率（24 / 30 / 60 / 120）
- 支持音频录制的启用与禁用
- 支持多种系统 Session Preset
- 支持多种视频编码格式（HEVC / H.264 / ProRes 等）
- 支持录制过程中的暂停与恢复
- 支持对焦点、曝光点独立控制
- 支持变焦与平滑变焦（ramp）
- 支持补光灯（Torch）控制
- 明确的状态机与状态回调
- 明确的生命周期管理（prepare / reset / dispose）

***

## 类型定义

### CameraPosition

```ts
type CameraPosition = "front" | "back"
```

表示使用的摄像头朝向。

***

### CameraType

```ts
type CameraType =
  | "wide"
  | "ultraWide"
  | "telephoto"
  | "trueDepth"
  | "dual"
  | "dualWide"
  | "triple"
```

表示摄像头的物理类型。
是否支持某一类型取决于设备硬件能力。

***

### VideoRecorderState

```ts
type VideoRecorderState =
  | "idle"
  | "preparing"
  | "ready"
  | "recording"
  | "paused"
  | "finishing"
  | "finished"
  | "failed"
```

#### 状态说明

| 状态          | 含义             |
| ----------- | -------------- |
| `idle`      | 初始状态，尚未配置资源    |
| `preparing` | 正在配置相机会话与音视频管线 |
| `ready`     | 已准备完成，可以开始录制   |
| `recording` | 正在录制           |
| `paused`    | 录制已暂停          |
| `finishing` | 正在结束录制并写入文件    |
| `finished`  | 录制完成           |
| `failed`    | 发生错误，录制失败      |

***

### VideoCaptureSessionPreset

```ts
type VideoCaptureSessionPreset =
  | "high"
  | "medium"
  | "low"
  | "cif352x288"
  | "vga640x480"
  | "iFrame960x540"
  | "iFrame1280x720"
  | "hd1280x720"
  | "hd1920x1080"
  | "hd4K3840x2160"
```

表示捕捉会话的分辨率预设。

***

### VideoCodec

```ts
type VideoCodec =
  | "hevc"
  | "h264"
  | "jpeg"
  | "JPEGXL"
  | "proRes4444"
  | "appleProRes4444XQ"
  | "proRes422"
  | "proRes422HQ"
  | "proRes422LT"
  | "proRes422Proxy"
  | "proResRAW"
  | "proResRAWHQ"
  | "hevcWithAlpha"
```

表示视频编码格式。
具体是否可用取决于设备与系统支持情况。

***

### VideoOrientation

```ts
type VideoOrientation =
  | "portrait"
  | "landscapeLeft"
  | "landscapeRight"
```

表示输出视频的方向。

***

## 构造函数

```ts
new VideoRecorder(settings?)
```

### settings 参数

```ts
{
  camera?: {
    position: CameraPosition
    preferredTypes?: CameraType[]
  }
  frameRate?: number
  audioEnabled?: boolean
  sessionPreset?: VideoCaptureSessionPreset
  videoCodec?: VideoCodec
  videoBitRate?: number
  orientation?: VideoOrientation
  mirrorFrontCamera?: boolean
}
```

#### 参数说明

- **camera**

  - `position`
    使用的摄像头位置，默认 `"back"`
  - `preferredTypes`
    偏好的摄像头类型列表
    如果未提供，内部将根据摄像头位置自动选择合适的类型

- **frameRate**
  目标帧率，支持 24 / 30 / 60 / 120，默认 30
  实际帧率受设备与分辨率限制

- **audioEnabled**
  是否录制音频，默认 `true`

- **sessionPreset**
  捕捉会话分辨率预设，默认 `"high"`

- **videoCodec**
  视频编码格式，默认 `"hevc"`

- **videoBitRate**
  视频平均码率（bit/s），未指定时由系统自动选择

- **orientation**
  输出视频方向，默认 `"portrait"`

- **mirrorFrontCamera**
  前置摄像头是否镜像，默认 `true`
  仅在使用前置摄像头时生效

***

## 只读属性

### minZoomFactor

```ts
readonly minZoomFactor: number
```

当前设备支持的最小变焦倍率。

***

### maxZoomFactor

```ts
readonly maxZoomFactor: number
```

当前设备支持的最大变焦倍率。

***

### currentZoomFactor

```ts
readonly currentZoomFactor: number
```

当前变焦倍率。

***

### displayZoomFactor

```ts
readonly displayZoomFactor: number
```

用户可读的变焦倍率。

***

### hasTorch

```ts
readonly hasTorch: boolean
```

当前摄像头是否支持补光灯。

***

### torchMode

```ts
readonly torchMode: "auto" | "on" | "off"
```

当前补光灯模式。

***

## 状态与回调

### state

```ts
state: VideoRecorderState
```

表示当前录制器所处的状态。

***

### onStateChanged

```ts
onStateChanged?: (
  state: VideoRecorderState,
  details?: string
) => void
```

状态变化回调。

- 当 `state === "failed"`
  `details` 为错误信息描述

- 当 `state === "finished"`
  `details` 为最终视频文件的完整保存路径

***

## 方法说明

### prepare()

```ts
prepare(): Promise<void>
```

准备录制器资源，包括相机会话、输入输出与音视频管线配置。

#### 使用约束

- 必须在 `startRecording` 之前调用
- 成功后状态变为 `ready`
- 失败会进入 `failed` 状态

***

### startRecording(toPath)

```ts
startRecording(toPath: string): void
```

开始录制视频。

#### 参数

- **toPath**
  视频文件保存路径（完整路径）

#### 使用约束

- 仅允许在 `ready` 状态下调用
- 调用后状态变为 `recording`

***

### pauseRecording()

```ts
pauseRecording(): void
```

暂停当前录制。

#### 使用约束

- 仅允许在 `recording` 状态下调用
- 调用后状态变为 `paused`
- 时间线会被正确压缩，不产生空白帧

***

### resumeRecording()

```ts
resumeRecording(): void
```

恢复已暂停的录制。

#### 使用约束

- 仅允许在 `paused` 状态下调用
- 调用后状态回到 `recording`

***

### stopRecording()

```ts
stopRecording(): Promise<void>
```

停止录制并生成最终视频文件。

#### 行为说明

- 状态先进入 `finishing`
- 文件写入完成后进入 `finished`
- 最终文件路径通过 `onStateChanged` 回调返回

***

### reset()

```ts
reset(): Promise<void>
```

重置录制器状态，用于开始新一轮录制。

#### 使用场景

- 已完成一次录制
- 或录制失败后希望复用同一实例

#### 行为说明

- 成功后状态回到 `idle`
- 可再次调用 `prepare`

***

### setTorchMode()

```ts
setTorchMode(mode: "auto" | "off" | "on"): void
```

设置补光灯模式。

***

### setFocusPoint()

```ts
setFocusPoint(point: { x: number; y: number }): void
```

设置对焦点。

- 坐标为归一化值，范围 `0.0 ~ 1.0`
- `(0,0)` 表示画面左上角，`(1,1)` 表示右下角

***

### setExposurePoint()

```ts
setExposurePoint(point: { x: number; y: number }): void
```

设置曝光点，坐标规则与对焦点一致。

***

### resetFocus()

```ts
resetFocus(): void
```

恢复自动对焦模式。

***

### resetExposure()

```ts
resetExposure(): void
```

恢复自动曝光模式。

***

### setZoomFactor()

```ts
setZoomFactor(factor: number): void
```

立即设置变焦倍率。

- 值应位于 `minZoomFactor` 与 `maxZoomFactor` 之间

***

### rampZoomFactor()

```ts
rampZoomFactor(toFactor: number, rate: number): void
```

以平滑方式调整变焦倍率。

- `toFactor` 为目标倍率
- `rate` 为变化速率，单位为每秒的 2 次幂变化

***

### resetZoom()

```ts
resetZoom(): void
```

将变焦倍率恢复为默认值（通常为 1.0）。

***

### dispose()

```ts
dispose(): Promise<void>
```

释放并销毁录制器。

#### 使用约束

- 调用后实例不可再使用
- 会释放相机、音频与底层系统资源
- 建议在页面或脚本生命周期结束时调用

***

## 典型使用流程

```ts
const recorder = new VideoRecorder({
  camera: { position: "back" },
  frameRate: 60,
  videoCodec: "hevc"
})

recorder.onStateChanged = (state, details) => {
  if (state === "finished") {
    console.log("Video saved at:", details)
  }
}

await recorder.prepare()
recorder.startRecording("/path/to/tmp/demo.mov")
```

***

## 使用建议

- 始终监听 `onStateChanged` 以掌握完整状态变化
- 不要在未调用 `prepare` 的情况下开始录制
- 每次完成录制后，如需复用实例，应先调用 `reset`
- 生命周期结束时务必调用 `dispose` 释放资源



---
url: /v2/zh/guide/Device Capabilities/Vision.md
---

# 视觉

`Vision` 模块提供了用于**文本识别**的 API。\
支持从静态图片中识别文本，或者通过相机扫描文档并提取文本内容。

***

## 类型

### `RecognizedText`

表示单个识别到的文本块。

- `content: string`\
  识别到的文本内容。

- `confidence: number`\
  置信度（0.0 到 1.0 之间），1.0 表示最高置信度。

- `boundingBox: { x: number, y: number, width: number, height: number }`\
  文本所在的矩形区域，使用归一化坐标表示。

***

### `RecognizeTextOptions`

文本识别的配置选项。

- `recognitionLevel?: "accurate" | "fast"`\
  识别模式：
  - `"accurate"`（默认）：优先保证准确度。
  - `"fast"`：优先保证速度。

- `recognitionLanguages?: string[]`\
  识别时优先使用的语言数组（ISO 语言编码）。

- `usesLanguageCorrection?: boolean`\
  是否在识别过程中应用语言自动纠错。

- `minimumTextHeight?: number`\
  最小识别文本高度，相对于图片高度（默认 `0.03125`）。

- `customWords?: string[]`\
  补充词汇表（只在启用语言纠错时生效）。

***

## 函数

### `recognizeText(image: UIImage, options?: RecognizeTextOptions): Promise<{ text: string, candidates: RecognizedText[] }>`

对指定图片进行文本识别。

- **参数**：
  - `image`：要识别的 `UIImage` 对象。
  - `options` _(可选)_：文本识别配置。

- **返回**：\
  返回 Promise，包含：
  - `text`：识别出的完整文本。
  - `candidates`：识别出的文本块数组及详细信息。

***

### `scanDocument(options?: RecognizeTextOptions): Promise<string[]>`

使用相机扫描文档并识别文本。

- **参数**：
  - `options` _(可选)_：文本识别配置。

- **返回**：\
  返回 Promise，包含识别到的文档文本数组。\
  如果用户取消，Promise 将抛出错误。

***

## 使用示例

### 识别图片文件中的文本

```tsx
const image = UIImage.fromFile('/路径/图片.png')
if (image) {
  const result = await Vision.recognizeText(image, {
    recognitionLevel: 'accurate',
    recognitionLanguages: ['zh-Hans', 'en'],
    usesLanguageCorrection: true
  })
  console.log('识别到的完整文本：', result.text)

  for (const block of result.candidates) {
    console.log(`文本：${block.content}，置信度：${block.confidence}`)
  }
}
```

***

### 使用相机扫描文档

```tsx
try {
  const documents = await Vision.scanDocument({
    recognitionLevel: 'fast',
    recognitionLanguages: ['zh-Hans']
  })
  console.log('扫描到的文档内容：', documents)
} catch (error) {
  console.error('扫描取消或失败：', error)
}
```



---
url: /v2/zh/guide/Device Capabilities/Weather/index.md
---

# 天气

Scripting 的天气 API 提供对实时天气和天气预报数据的访问，包括当前天气状况、每小时预报和每日预报。用户可以获取指定位置的温度、风速、湿度和降水等天气信息。

## 类型定义

### `UnitType`

表示带有数值、符号和格式化字符串的测量单位。

```ts
type UnitType = {
  value: number
  symbol: string
  formatted: string
}
```

### `UnitTemperature`, `UnitSpeed`, `UnitLength`, `UnitAngle`, `UnitPressure`

这些类型基于 `UnitType`，分别表示温度、速度、长度、角度和气压。

## `WeatherCondition`

字符串枚举，描述各种天气状况，包括：

- `clear`（晴朗）
- `rain`（雨）
- `snow`（雪）
- `thunderstorms`（雷暴）
- `cloudy`（多云）
- `windy`（有风）
- ...

## API 方法

### `Weather.requestCurrent(location: LocationInfo): Promise<CurrentWeather>`

获取指定位置的当前天气状况。

#### 参数

- `location: LocationInfo` – 需要查询天气的位置。

#### 返回值

返回一个 `Promise`，解析为 `CurrentWeather` 对象。

#### 示例

```ts
const location = { latitude: 37.7749, longitude: -122.4194 }
const weather = await Weather.requestCurrent(location)
console.log(`当前温度：${weather.temperature.formatted}`)
```

### `Weather.requestDailyForecast(location: LocationInfo, options?: { startDate: Date, endDate: Date }): Promise<WeatherDailyForecast>`

获取指定位置每日天气预报。你可以选择传入开始日期和结束日期以自定义查询范围。

#### 参数

- `location: LocationInfo` – 查询的位置。
- `options.startDate` – 预报开始日期。
- `options.endDate` – 预报结束日期。

#### 返回值

返回一个 `Promise`，解析为 `WeatherDailyForecast` 对象。

#### 示例

```ts
const forecast = await Weather.requestDailyForecast(location, {
  startDate: new Date(),
  endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000)
})
console.log(`明天天气：${forecast.forecast[1].condition}`)
```

### `Weather.requestHourlyForecast(location: LocationInfo, options?: { startDate: Date, endDate: Date }): Promise<WeatherHourlyForecast>`

获取指定位置每小时的天气预报。你可以选择传入开始日期和结束日期以自定义查询范围。

#### 参数

- `location: LocationInfo` – 查询的位置。
- `options.startDate` – 预报开始时间。
- `options.endDate` – 预报结束时间。

#### 返回值

返回一个 `Promise`，解析为 `WeatherHourlyForecast` 对象。

#### 示例

```ts
const hourlyForecast = await Weather.requestHourlyForecast(location, {
  startDate: new Date(),
  endDate: new Date(Date.now() + 3 * 60 * 60 * 1000)
})
console.log(`下一小时温度：${hourlyForecast.forecast[0].temperature.formatted}`)
```

## `CurrentWeather`

表示当前天气状况。

```ts
type CurrentWeather = {
  temperature: UnitTemperature
  apparentTemperature: UnitTemperature
  humidity: number
  wind: WeatherWind
  condition: WeatherCondition
  date: number
  symbolName: string
}
```

## `WeatherDailyForecast`

表示每日天气预报。

```ts
type WeatherDailyForecast = {
  metadata: WeatherMetadata
  forecast: DayWeather[]
}
```

## `WeatherHourlyForecast`

表示每小时天气预报。

```ts
type WeatherHourlyForecast = {
  metadata: WeatherMetadata
  forecast: HourWeather[]
}
```

## `DayWeather`

表示每日天气详情。

```ts
type DayWeather = {
  highTemperature: UnitTemperature
  lowTemperature: UnitTemperature
  wind: WeatherWind
  condition: WeatherCondition
  date: number
  symbolName: string
}
```

## `HourWeather`

表示每小时天气详情。

```ts
type HourWeather = {
  temperature: UnitTemperature
  humidity: number
  wind: WeatherWind
  condition: WeatherCondition
  date: number
  symbolName: string
}
```

## 使用示例

### 获取并显示当前天气

```ts
async function displayCurrentWeather() {
  const location = { latitude: 37.7749, longitude: -122.4194 }
  const weather = await Weather.requestCurrent(location)
  console.log(`温度：${weather.temperature.formatted}，天气：${weather.condition}`)
}

displayCurrentWeather()
```

### 获取并显示每日天气预报

```ts
async function displayDailyForecast() {
  const location = { latitude: 37.7749, longitude: -122.4194 }
  const forecast = await Weather.requestDailyForecast(location, {
    startDate: new Date(),
    endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  })
  forecast.forecast.forEach(day => {
    console.log(`日期：${new Date(day.date).toDateString()}，天气：${day.condition}`)
  })
}

displayDailyForecast()
```

### 获取并显示每小时天气预报

```ts
async function displayHourlyForecast() {
  const location = { latitude: 37.7749, longitude: -122.4194 }
  const hourlyForecast = await Weather.requestHourlyForecast(location, {
    startDate: new Date(),
    endDate: new Date(Date.now() + 5 * 60 * 60 * 1000)
  })
  hourlyForecast.forecast.forEach(hour => {
    console.log(`时间：${new Date(hour.date).toLocaleTimeString()}，温度：${hour.temperature.formatted}`)
  })
}

displayHourlyForecast()
```



---
url: /v2/zh/guide/Device Capabilities/Weather/index_example.md
---

# 示例

```tsx
import { Script } from "scripting"

console.present().then(() => {
  Script.exit()
})

console.log("Requesting Current Weather...")

async function displayCurrentWeather() {
  let location: LocationInfo | null = null
  try {
    console.log("Requesting location... Please move your device to trigger a location update.")
    location = await Location.requestCurrent()

    if (location) {
      const placemarks = await Location.reverseGeocode(location)
      if (placemarks && placemarks.length) {
        console.log(`Your current location: ${JSON.stringify(placemarks[0], null, 2)}`)
      }
    }
  } catch (e) {
    console.log("Failed to request location", e)
  }

  if (!location) {
    console.error("Please approval the location permission request")
    return
  }

  // Use the WeatherKit
  const weather = await Weather.requestCurrent(
    location
  )

  console.log(
    `The temperature is ${weather.temperature.formatted
    } with ${weather.condition}`
  )
}

displayCurrentWeather()
```



---
url: /v2/zh/guide/Device Capabilities/WebViewController.md
---

# WebView 控制器

`WebViewController` 是一个用于显示和交互网页内容的控制器。它允许你在脚本中加载 HTML、展示 Web 页面、执行 JavaScript 脚本，并与页面中的 JavaScript 进行消息通信。你可以将它作为浏览器使用，也可以嵌入应用功能页面。

***

## 类：`WebViewController`

```ts
const webView = new WebViewController()
```

***

## 属性

### `shouldAllowRequest?: (request) => Promise<boolean>`

一个可选回调，用于决定是否允许或拦截 WebView 发起的请求。每次加载资源之前都会调用此函数，例如导航到新页面或提交表单时。

适用于拦截跳转行为、自定义安全策略或过滤广告等不需要的请求。

#### 参数

回调函数接收一个 `request` 对象，包含以下字段：

- `url: string`
  请求的完整 URL。

- `method: string`
  HTTP 方法，如 `GET`、`POST`。

- `body?: Data | null`
  可选，请求体数据（通常用于 `POST` 请求）。

- `headers: Record<string, string>`
  请求头信息。

- `timeoutInterval: number`
  请求的超时时间（单位为秒）。

- `navigationType: "linkActivated" | "reload" | "backForward" | "formResubmitted" | "formSubmitted" | "other"`
  触发导航的上下文。

#### 返回值

一个 `Promise<boolean>`，用于指示是否允许该请求：

- `true`：允许请求继续
- `false`：阻止该请求

#### 示例

```ts
const webView = new WebViewController()

webView.shouldAllowRequest = async (request) => {
  console.log('拦截到请求：', request.url)

  // 拦截所有访问 example.com 的请求
  if (request.url.includes('example.com')) {
    return false
  }

  return true
}

await webView.loadURL('https://www.wikipedia.org')
await webView.present({ navigationTitle: '已过滤的网页视图' })
```

***

## 方法

### `loadURL(url: string): Promise<boolean>`

加载指定 URL 的网页内容。

- **参数**：

  - `url`：要加载的网页完整地址。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadFile(path: string, allowingReadAccessTo?: string): Promise<boolean>`

加载文件内容作为网页。

- **参数**:

  - `path`：要加载的文件路径。
  - `allowingReadAccessTo`（可选）：允许读取文件的路径，默认为 `path`。
- **返回**：`Promise<boolean>`

### `loadHTML(html: string, baseURL?: string): Promise<boolean>`

加载原始 HTML 字符串内容。

- **参数**：

  - `html`：要渲染的 HTML 字符串。
  - `baseURL`（可选）：用于解析相对路径的基础 URL。
- **返回**：`Promise<boolean>` — 加载成功返回 `true`。

***

### `loadData(data: Data, mimeType: string, encoding: string, baseURL: string): Promise<boolean>`

加载原始数据作为网页内容。

- **参数**：

  - `data`：要加载的二进制内容。
  - `mimeType`：内容的 MIME 类型，例如 `"text/html"`。
  - `encoding`：字符编码，例如 `"utf-8"`。
  - `baseURL`：用于解析相对路径的基础地址。
- **返回**：`Promise<boolean>`

***

### `waitForLoad(): Promise<boolean>`

等待 WebView 加载完成。

- **返回**：`Promise<boolean>`

***

### `getHTML(): Promise<string | null>`

获取当前页面的 HTML 内容。

- **返回**：`Promise<string | null>`

***

### `evaluateJavaScript<T = any>(javascript: string): Promise<T>`

在 WebView 中执行指定的 JavaScript 代码。

- **参数**：

  - `javascript`：要执行的 JavaScript 代码字符串。若希望返回值，必须在代码中使用 `return`。
- **返回**：`Promise<T>` — JavaScript 执行结果将作为 Promise 的值返回。

#### 示例

```ts
const webView = new WebViewController()
await webView.loadURL("https://example.com")
const title = await webView.evaluateJavaScript("return document.title")
console.log(title) // "Example Domain"
webView.dispose()
```

或：

```ts
const webView = new WebViewController()
await webView.loadHTML(`
  <html>
    <body>
      <script>
        window.myValue = 42
      </script>
    </body>
  </html>
`)

await webView.waitForLoad()

const result = await webView.evaluateJavaScript('return window.myValue')
console.log(result) // 42
```

***

### `addScriptMessageHandler<P = any, R = any>(name: string, handler: (params?: P) => R): Promise<void>`

添加一个脚本消息处理器，可在网页中通过 JavaScript 调用，并接收原生代码返回的结果。

- **参数**：

  - `name`：消息处理器名称，必须唯一且非空。
  - `handler`：处理函数，接收来自网页的参数并返回一个值，作为 Promise 的结果回传给网页。
- **返回**：`Promise<void>` — 添加成功后完成。

#### 示例

```ts
let webView = new WebViewController()

await webView.addScriptMessageHandler("sayHi", (greeting: string) => {
  console.log("收到消息", greeting)
  return "你好！"
})

await webView.loadHTML(`
  <html>
    <body>
      <script>
        (async () => {
          const response = await window.webkit.messageHandlers.sayHi.postMessage("Hi!")
          alert(response) // 弹出 "你好！"
        })()
      </script>
    </body>
  </html>
`)
```

***

### `present(options?: { fullscreen?: boolean, navigationTitle?: string }): Promise<void>`

以模态窗口形式展示 WebView。

- **选项**：

  - `fullscreen`：是否以全屏模式展示。
  - `navigationTitle`：导航栏标题（可选）。
- **返回**：`Promise<void>`

***

### `canGoBack(): Promise<boolean>`

判断 WebView 是否可以后退。

***

### `canGoForward(): Promise<boolean>`

判断 WebView 是否可以前进。

***

### `goBack(): Promise<boolean>`

返回上一页。

***

### `goForward(): Promise<boolean>`

前进到下一页。

***

### `reload(): Promise<void>`

重新加载当前网页。

***

### `dismiss(): void`

关闭 WebView 页面（若当前正在展示）。

***

### `dispose(): void`

释放 WebView 实例并清理资源。

- 如果 WebView 正在展示，将先自动关闭。
- **重要**：请务必调用此方法以避免内存泄漏。

***

## 完整示例

```ts
const webView = new WebViewController()

await webView.addScriptMessageHandler('greet', (name) => {
  return `你好，${name}`
})

await webView.loadHTML(`
  <html>
    <body>
      <h1>自定义网页视图</h1>
      <button onclick="sendMessage()">打招呼</button>
      <script>
        async function sendMessage() {
          const response = await window.webkit.messageHandlers.greet.postMessage("Alice")
          alert(response)
        }
      </script>
    </body>
  </html>
`)

await webView.present({ navigationTitle: '网页视图示例' })
webView.dispose()
```



---
url: /v2/zh/guide/Intent/Intent.continueInForeground.md
---

`Intent.continueInForeground` 用于在脚本从 Shortcuts 中后台执行时，**请求系统将流程转移到 Scripting App 的前台继续运行**。
此过程需要用户明确确认。

适用场景包括：

- 需要展示完整 UI（如表单、列表、导航页面）
- 需要用户在 App 内进行交互操作
- 后续步骤无法在后台执行

调用此方法后，系统会弹出确认对话框：

- 用户 **允许** → Scripting App 打开到前台，脚本继续执行
- 用户 **取消** → 当前脚本立即终止
- 此行为完全由系统管理，开发者无需手动处理跳转流程

由于该能力基于 iOS 26 引入的 AppIntents 行为：

**该 API 只能在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function continueInForeground(
  dialog?: Dialog | null,
  options?: {
    alwaysConfirm?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## dialog?: Dialog | null

用于提示用户为什么需要切换到前台继续执行。

`Dialog` 的类型格式支持三种形式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否前往应用继续执行？";
```

或带辅助说明：

```ts
{
  full: "需要在应用中继续执行下一步操作",
  supporting: "接下来的步骤需要完整的 UI 交互。",
  systemImageName: "app"
}
```

若传入 `null`，系统可能不显示提示，仅直接触发系统确认（不推荐）。

***

## `options?: { alwaysConfirm?: boolean }`

用于控制系统是否每次都显示确认提示。

- `alwaysConfirm: false`（默认）
  系统一般会根据上下文自动判断是否需要确认。

- `alwaysConfirm: true`
  每次调用都会提示用户明确确认。

示例：

```ts
{
  alwaysConfirm: true;
}
```

***

# 执行流程

执行 `await Intent.continueInForeground(...)` 时：

1. 快捷指令执行暂停

2. 系统弹出确认对话框

3. 用户选择：

   - **确认** → 打开 Scripting App → 脚本继续
   - **取消** → 脚本立即终止

4. 后续脚本在 Scripting App 前台环境中继续执行

**注意：脚本不会在后台继续运行，必须等待用户操作。**

***

# 典型应用场景

推荐在以下场景调用：

- 需要展示完整的导航界面或交互表单（如示例中的 TextField）
- 需要使用 `Navigation.present` 呈现 UI
- 需要 App 内操作如：

  - 预览文件
  - 编辑长文本
  - 选择复杂数据
  - 多步骤流程

不推荐在以下情况使用：

- 单纯的数据处理，不需要 UI
- 简单操作已经可通过 SnippetIntent 完成

***

# 完整示例代码

以下示例展示如何从 Shortcuts 通过 `continueInForeground` 切换到 Scripting App 前台，然后展示 UI 让用户输入文本，输入结束后再返回 Shortcuts。

```tsx
// intent.tsx
import {
  Button,
  Intent,
  List,
  Navigation,
  NavigationStack,
  Script,
  Section,
  TextField,
  useState,
} from "scripting";

function View() {
  const dismiss = Navigation.useDismiss();
  const [text, setText] = useState("");

  return (
    <NavigationStack>
      <List navigationTitle="Intent Demo">
        <TextField title="Enter a text" value={text} onChanged={setText} />

        <Section>
          <Button
            title="Return Text"
            action={() => {
              dismiss(text);
            }}
            disabled={!/\S+/.test(text)}
          />
        </Section>
      </List>
    </NavigationStack>
  );
}

async function runIntent() {
  // 请求系统将执行流程切换到 Scripting App 前台
  await Intent.continueInForeground("Do you want to open the app and continue?");

  // 在前台呈现交互式 UI，用户填写文本
  const text = await Navigation.present<string | null>(<View />);

  // 可选：返回到快捷指令界面
  Safari.openURL("shortcuts://");

  // 返回结果给 Shortcuts
  Script.exit(Intent.text(text ?? "No text return"));
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**，否则会抛出异常或行为不可用。
- 若脚本依赖用户输入、复杂 UI 或操作，请使用该 API 触发前台模式。
- 对话内容应清晰说明需要用户切换前台的原因，提升用户信任度。
- 若用户拒绝，脚本将终止，开发者无需自行处理取消逻辑。
- 可以与 SnippetIntent 结合，构建完整的后台 UI + 前台 UI 混合流程。



---
url: /v2/zh/guide/Intent/Intent.requestConfirmation.md
---

`Intent.requestConfirmation` 用于在脚本执行过程中，**向用户请求确认某项操作**。
调用后，系统会暂停脚本执行，并展示一个基于 **SnippetIntent 的 UI** 作为确认界面，同时可显示提示对话内容。

确认流程行为：

- 用户 **确认** → Promise resolve，脚本继续执行
- 用户 **取消** → 当前脚本终止执行
- 确认界面通过传入的 **SnippetIntent** 的 UI 定义
- 系统自动管理此流程，无需开发者处理 UI 呈现逻辑

**该 API 仅可在 iOS 26 及以上系统使用。**

***

# API 定义

```ts
function requestConfirmation(
  actionName: ConfirmationActionName,
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>;
```

***

# 参数说明

## actionName: ConfirmationActionName

用于告诉系统“要确认的行为语义是什么”，系统会根据该值生成自然语言文案。例如：

- `"set"` → “确定要设置…？”
- `"buy"` → “确定要购买…？”
- `"toggle"` → “是否切换…？”

可选值如下（与苹果 AppIntents 框架一致）：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" |
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

选择合适的语义有助于提高确认界面的自然体验。

***

## snippetIntent: SnippetIntent

必须是一个 **注册为 SnippetIntent 类型的 AppIntent**：

```ts
AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>;
```

用户在确认界面中看到的内容就是该 SnippetIntent 的 `perform()` 返回的 UI，例如选项列表、内容预览等。

***

## `options?: { dialog?: Dialog; showDialogAsPrompt?: boolean }`

### dialog?: Dialog

用于在确认 UI 上方或系统对话框中显示提示文本。
支持四种格式：

```ts
type Dialog =
  | string
  | { full: string; supporting: string }
  | { full: string; supporting: string; systemImageName: string }
  | { full: string; systemImageName: string };
```

示例：

```ts
"是否继续？";
```

更复杂的：

```ts
{
  full: "确定要设置此颜色吗？",
  supporting: "此操作将更新应用的主题颜色。",
  systemImageName: "paintpalette"
}
```

用途：

- 解释确认动作含义
- 提醒用户可能产生的影响
- 提供更友好的交互上下文

***

### showDialogAsPrompt?: boolean

默认值：`true`
决定系统是否以「提示弹窗」方式显示对话文本。

设为 `false` 时，文本可能以更沉浸的方式显示在 Snippet 卡片内部。

***

# 执行流程

调用 `await Intent.requestConfirmation(...)` 时脚本执行顺序如下：

1. 脚本暂停执行

2. 系统展示确认界面（SnippetIntent UI + 可选 dialog 文案）

3. 用户进行交互：

   - **确认** → Promise resolve，脚本继续
   - **取消** → 脚本终止执行

4. 不需要开发者手动关闭 UI

此流程完全由系统管理。

***

# 使用场景

以下场景推荐使用 `requestConfirmation`：

- 修改重要设置（如主题颜色、隐私设置）
- 对数据执行有副作用的操作（如删除、更新、重置）
- 流程中一步需用户明确授权
- 启动某个需要用户选择的 UI 子流程（如颜色选择器、账号切换器）

不适用场景：

- 简单数据处理，不需要用户确认
- 可以在后台无 UI 完成的操作

***

# 完整示例代码

以下示例展示如何使用 `requestConfirmation` 请求用户确认一次颜色选择，并在确认后继续执行脚本。

假设你已有两个 SnippetIntent：

- `PickColorIntent`：颜色选择 UI
- `ShowResultIntent`：结果展示 UI

## intent.tsx 示例

```tsx
import { Intent, Script } from "scripting";
import { PickColorIntent, ShowResultIntent } from "./app_intents";

async function runIntent() {
  // 第一步：请求用户确认颜色选择
  await Intent.requestConfirmation("set", PickColorIntent(), {
    dialog: {
      full: "确定要设置此颜色吗？",
      supporting: "此操作将更新应用的主题颜色。",
      systemImageName: "paintpalette",
    },
  });

  // 第二步：读取来自 Shortcuts 的输入（如果有）
  const text =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts";

  // 第三步：呈现最终 SnippetIntent
  const snippet = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: text }),
  });

  Script.exit(snippet);
}

runIntent();
```

***

# 注意事项与最佳实践

- **必须运行在 iOS 26+**
  提前检查系统版本或优雅降级。

- **总是提供清晰的 dialog 文案**
  确认行为应让用户理解，不应仅依赖 Snippet UI 本身。

- **用于重要或可逆性较差的操作**
  如修改设置、启动后台任务、提交数据等。

- **与 SnippetIntent 配合使用效果最佳**
  因为确认 UI 直接展示 SnippetIntent 的视图。

- **用户取消时脚本会被系统直接终止**
  不要在后续代码中假设脚本一定会继续执行。



---
url: /v2/zh/guide/Intent/Quick Start.md
---

# 快速开始

Scripting 支持通过 `intent.tsx` 文件创建 iOS Intents，实现脚本与系统分享扩展（Share Sheet）和快捷指令（Shortcuts）的深度集成。你可以接收来自用户的文本、图片、文件和 URL 等输入，并返回结果供调用方使用。通过 UI 展示、数据处理与结果返回，可构建灵活且强大的自动化流程。

***

## 一、创建和配置 Intent

### 1. 创建 Intent 脚本

1. 在 Scripting 中新建一个脚本项目。
2. 添加名为 `intent.tsx` 的文件，并编写处理逻辑和可选的 UI 组件。

### 2. 配置支持的输入类型

点击编辑器顶部标题栏中的项目名称，打开 **Intent 设置页面**，选择该脚本支持的输入类型，如：

- 文本（Text）
- 图片（Image）
- 文件路径（File URL）
- URL

配置后，该脚本就能在分享扩展或 Shortcuts 中处理相应类型的数据。

***

## 二、处理输入数据

在 `intent.tsx` 中，可通过以下 API 访问用户传入的数据：

| 属性名                        | 说明                                       |
| -------------------------- | ---------------------------------------- |
| `Intent.shortcutParameter` | Shortcuts 中传入的单个参数，包含 `.type` 和 `.value` |
| `Intent.textsParameter`    | 文本字符串数组                                  |
| `Intent.urlsParameter`     | URL 字符串数组                                |
| `Intent.imagesParameter`   | 图片数组（UIImage 实例）                         |
| `Intent.fileURLsParameter` | 文件路径数组（本地 URL）                           |

示例：

```ts
if (Intent.shortcutParameter) {
  if (Intent.shortcutParameter.type === "text") {
    console.log(Intent.shortcutParameter.value)
  }
}
```

***

## 三、返回结果

使用 `Script.exit(result)` 结束脚本执行并返回结果给调用方，例如 Shortcuts 或另一个脚本。支持的返回类型包括：

- 文本：`Intent.text(value)`
- 富文本：`Intent.attributedText(value)`
- URL：`Intent.url(value)`
- JSON 数据：`Intent.json(value)`
- 文件路径：`Intent.file(value)` 或 `Intent.fileURL(value)`

示例：

```ts
import { Script, Intent } from "scripting"

Script.exit(Intent.text("处理完成"))
```

***

## 四、展示交互式 UI

你可以使用 `Navigation.present()` 呈现一个自定义界面，展示输入信息或收集用户反馈。在 UI 交互结束后调用 `Script.exit()` 返回结果。

示例：

```ts
import { Intent, Script, Navigation, VStack, Text } from "scripting"

function MyIntentView() {
  return (
    <VStack>
      <Text>{Intent.textsParameter?.[0]}</Text>
    </VStack>
  )
}

async function run() {
  await Navigation.present(<MyIntentView />)
  Script.exit()
}

run()
```

***

## 五、在分享扩展中使用

当脚本项目启用了对应类型的输入支持，Scripting 会自动集成到系统分享菜单：

1. 用户选中内容（如 Safari 中的文字或图片），点击分享按钮。
2. 分享列表中选择 **Scripting**。
3. 显示支持当前输入类型的脚本列表，供用户执行。

***

## 六、与 Shortcuts 集成

你可以在 Shortcuts 应用中调用 Scripting 脚本：

- **运行脚本（Run Script）**：后台执行，无 UI。
- **在 App 中运行脚本（Run Script in App）**：前台执行，支持 UI 展示。

操作步骤：

1. 在 Shortcuts 中添加 “Run Script” 或 “Run Script in App” 操作。
2. 选择目标脚本。
3. 配置参数，执行脚本。

***

## 七、Intent API 参考

### `Intent` 类属性

| 属性                  | 类型                  | 说明                                    |
| ------------------- | ------------------- | ------------------------------------- |
| `shortcutParameter` | `ShortcutParameter` | Shortcuts 传入的参数对象，包含 `type` 和 `value` |
| `textsParameter`    | `string[]`          | 文本输入数组                                |
| `urlsParameter`     | `string[]`          | URL 字符串数组                             |
| `imagesParameter`   | `UIImage[]`         | 图片数组（路径或图片对象）                         |
| `fileURLsParameter` | `string[]`          | 文件路径数组（本地 URL）                        |

### `Intent` 类方法

| 方法                             | 返回类型                        | 示例                                    |
| ------------------------------ | --------------------------- | ------------------------------------- |
| `Intent.text(value)`           | `IntentTextValue`           | `Intent.text("内容")`                   |
| `Intent.attributedText(value)` | `IntentAttributedTextValue` | `Intent.attributedText("富文本")`        |
| `Intent.url(value)`            | `IntentURLValue`            | `Intent.url("https://example.com")`   |
| `Intent.json(value)`           | `IntentJsonValue`           | `Intent.json({ key: "value" })`       |
| `Intent.file(filePath)`        | `IntentFileValue`           | `Intent.file("/path/to/file.txt")`    |
| `Intent.fileURL(filePath)`     | `IntentFileURLValue`        | `Intent.fileURL("/path/to/file.pdf")` |
| `Intent.image(UIImage)`        | `IntentImageValue`          | `Intent.image(uiImage)`               |

***

## 八、最佳实践与注意事项

- 所有脚本应显式调用 `Script.exit()` 以确保内存安全。
- 推荐在 UI 脚本中使用 `await Navigation.present()` 之后再调用 `Script.exit()`。
- 对于大文件或图像，建议使用 “Run Script in App” 模式，以避免系统内存限制导致的崩溃。
- 如果脚本需要共享数据，可通过 URL Scheme 或 `queryParameters` 实现。



---
url: /v2/zh/guide/Intent/SnippetIntent.md
---

SnippetIntent 是一种特殊类型的 AppIntent，可在 Shortcuts 中生成原生的 Snippet UI 卡片。它适用于：

- 多步骤表单式交互
- 从 Shortcuts 中获取用户输入
- 键值选择、确认、展示结果等轻量级交互
- 在 Shortcuts 工作流中内嵌 UI 组件

SnippetIntent 特点如下：

1. 在 Scripting 中必须通过 `AppIntentManager.register` 注册
2. `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
3. `perform()` 必须返回一个 `VirtualNode`（TSX UI）
4. 在脚本中必须以 `Intent.snippetIntent()` 封装后返回
5. Shortcuts 必须使用「Show Snippet Intent」动作才能显示 Snippet UI

***

# 系统要求

**SnippetIntent 只能在 iOS 26 及以上系统运行。**

在 iOS 26 以下环境：

- 无法调用 `Intent.snippetIntent`
- 无法使用 `Intent.requestConfirmation`
- Shortcuts 中不存在「Show Snippet Intent」动作
- SnippetIntent 类型的 AppIntent 不会被 Shortcuts 正常识别

***

# 注册 SnippetIntent（app\_intents.tsx）

在 `app_intents.tsx` 中声明 SnippetIntent：

```tsx
export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})
```

再例如：

```tsx
export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    return <ResultView content={content} />
  }
})
```

要求：

- `protocol` 必须为 `AppIntentProtocol.SnippetIntent`
- `perform()` 必须返回 `VirtualNode`
- 与普通 AppIntent 区别在于返回的是 UI，而非数据

***

# SnippetIntent 返回值封装：Intent.snippetIntent

SnippetIntent 不能直接作为 JS 返回值，必须通过 `Intent.snippetIntent()` 包装成 `IntentSnippetIntentValue`。

```tsx
const snippetValue = Intent.snippetIntent({
  value: Intent.text("Some value returning for Shortcuts"),
  snippetIntent: ShowResultIntent({
    content: "Example Text"
  })
})

Script.exit(snippetValue)
```

### 类型定义

```ts
type SnippetIntentValue = {
  value?: IntentAttributedTextValue | IntentFileURLValue | IntentJsonValue | IntentTextValue | IntentURLValue | IntentFileValue | null
  snippetIntent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>
}

declare class IntentSnippetIntentValue extends IntentValue<
  'SnippetIntent',
  SnippetIntentValue
> {
  value: SnippetIntentValue
  type: 'SnippetIntent'
}
```

封装的返回值可被 Shortcuts 的「Show Snippet Intent」动作识别并展示 UI。

***

# Snippet 确认界面：Intent.requestConfirmation

SnippetIntent 支持在执行逻辑中先请求用户确认某个操作。此能力同样基于 iOS 26。

```ts
Intent.requestConfirmation(
  actionName: ConfirmationActionName,
  intent: AppIntent<any, VirtualNode, AppIntentProtocol.SnippetIntent>,
  options?: {
    dialog?: Dialog;
    showDialogAsPrompt?: boolean;
  }
): Promise<void>
```

### ConfirmationActionName

这些名称会影响 Shortcuts UI 中呈现的文案，例如 “Set …”、“Add …”、“Toggle …” 等。

示例值：

```
"add" | "addData" | "book" | "buy" | "call" | "checkIn" | 
"continue" | "create" | "do" | "download" | "filter" |
"find" | "get" | "go" | "log" | "open" | "order" |
"pay" | "play" | "playSound" | "post" | "request" |
"run" | "search" | "send" | "set" | "share" |
"start" | "startNavigation" | "toggle" | "turnOff" |
"turnOn" | "view"
```

### 示例

```tsx
await Intent.requestConfirmation(
  "set",
  PickColorIntent()
)
```

效果：

- Shortcuts 弹出 PickColorIntent 对应的 Snippet UI
- 用户点击确认后 Promise resolve
- 用户取消时脚本执行终止

***

# Shortcuts 的「Show Snippet Intent」动作（iOS 26+）

Shortcuts 在 iOS 26 新增动作：

**Show Snippet Intent**

用于展示 SnippetIntent 返回的 Snippet UI。

### 与其他动作对比

| Shortcuts 动作                 | 显示界面                 | 支持 SnippetIntent | 场景               |
| ---------------------------- | -------------------- | ---------------- | ---------------- |
| Run Script                   | 无 UI                 | 否                | 纯数据处理            |
| Run Script in App            | Scripting App UI（前台） | 否                | 大型 UI、文件选择等      |
| Show Snippet Intent（iOS 26+） | Snippet 卡片 UI        | 是                | SnippetIntent 场景 |

使用方式：

1. 在 Shortcuts 中添加「Show Snippet Intent」
2. 选择脚本项目（需包含 intent.tsx）
3. 脚本返回 `Intent.snippetIntent(...)`
4. Shortcuts 显示 Snippet UI

***

# IntentMemoryStorage — 跨 AppIntent 状态共享

## 1. 为什么需要 IntentMemoryStorage

由于系统行为，每次 Intent 执行后：

- AppIntent 的 `perform()` 执行完毕后立即销毁上下文
- `intent.tsx` 执行完并调用 `Script.exit()` 后脚本上下文也会完全释放

因此无法依赖 JS 变量在多个 Intent 之间保持状态。

例如：

- PickColorIntent（选择颜色）
- SetColorIntent（设置颜色）
- ShowResultIntent（展示颜色结果）

在这些 Intent 之间共享状态必须依赖持久化存储。

## 2. IntentMemoryStorage 提供轻量级、跨 Intent 的共享存储

API 定义：

```ts
namespace IntentMemoryStorage {
  function get<T>(key: string): T | null
  function set(key: string, value: any): void
  function remove(key: string): void
  function contains(key: string): boolean
  function clear(): void
  function keys(): string[]
}
```

用途：

- 存储小量状态，例如当前颜色、当前步骤、临时选项
- 在多个 AppIntent 之间共享数据
- 生命周期跨 Intent 调用，但随脚本生命周期管理

### 示例：存储用户颜色选择

```ts
IntentMemoryStorage.set("color", "systemBlue")

const color = IntentMemoryStorage.get<Color>("color")
```

### 建议

- 不要存储大型数据（如大图像、长文本）
- 大型数据请使用：

  - `Storage`（持久键值存储）
  - `FileManager` 写入 appGroupDocumentsDirectory

IntentMemoryStorage 适合作为临时状态共享，不适合当作数据库使用。

***

# 完整示例（iOS 26+）

## app\_intents.tsx

```tsx
export const SetColorIntent = AppIntentManager.register({
  name: "SetColorIntent",
  protocol: AppIntentProtocol.AppIntent,
  perform: async (color: Color) => {
    IntentMemoryStorage.set("color", color)
  }
})

export const PickColorIntent = AppIntentManager.register<void>({
  name: "PickColorIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async () => {
    return <PickColorView />
  }
})

export const ShowResultIntent = AppIntentManager.register({
  name: "ShowResultIntent",
  protocol: AppIntentProtocol.SnippetIntent,
  perform: async ({ content }: { content: string }) => {
    const color = IntentMemoryStorage.get<Color>("color") ?? "systemBlue"
    return <ResultView content={content} color={color} />
  }
})
```

## intent.tsx

```tsx
async function runIntent() {

  // 1. 通过 Snippet 请求用户确认颜色
  await Intent.requestConfirmation(
    "set",
    PickColorIntent()
  )

  // 2. 从 Shortcuts 输入中读取文本
  const textContent =
    Intent.shortcutParameter?.type === "text"
      ? Intent.shortcutParameter.value
      : "No text parameter from Shortcuts"

  // 3. 创建 SnippetIntent 返回结果
  const snippetIntentValue = Intent.snippetIntent({
    snippetIntent: ShowResultIntent({ content: textContent })
  })

  Script.exit(snippetIntentValue)
}

runIntent()
```



---
url: /v2/zh/guide/Interactive Widget and LiveActivity.md
---

# 可互动的小组件和灵动岛

**Scripting** 应用支持在 **小组件** 和 **LiveActivity（灵动岛）** 中添加互动的功能，使您可以通过 `Button` 和 `Toggle` 组件创建动态、交互式的 UI。这些控件可以执行 **AppIntent** 来触发操作，从而增强小组件和 LiveActivity 的功能。

***

## 1. AppIntent 简介

### 什么是 AppIntent？

**AppIntent** 定义了一个由控件（如 `Button` 或 `Toggle`）触发的特定操作，用于小组件或 LiveActivity UI。AppIntent 将 UI 组件与可执行逻辑连接起来，实现无缝交互。

### 支持的协议

AppIntent 可以实现以下协议：

- **`AppIntent`**：通用意图，用于触发自定义操作。
- **`AudioPlaybackIntent`**：处理音频播放（如播放、暂停或切换音频状态）。
- **`AudioRecordingIntent`**：管理音频录制状态（需要 iOS 18+，并且在录制期间保持 LiveActivity 活跃）。
- **`LiveActivityIntent`**：修改或管理 LiveActivity 状态。

***

## 2. 注册 AppIntent

在使用 **AppIntent** 之前，必须通过 `AppIntentManager.register` 方法在 `app_intents.tsx` 文件中注册。

### 示例：注册 AppIntent

```typescript
// app_intents.tsx

import { AppIntentManager, AppIntentProtocol } from "scripting"

// 注册不带参数的 AppIntent
const IntentWithoutParams = AppIntentManager.register({
  name: "IntentWithoutParams",
  protocol: AppIntentProtocol.AppIntent,
  perform: async (params: undefined) => {
    // 执行自定义操作
    console.log("Intent 被触发")
    // 可选：刷新小组件
    Widget.reloadAll()
  }
})

// 注册带参数的 AppIntent
const ToggleIntentWithParams = AppIntentManager.register({
  name: "ToggleIntentWithParams",
  protocol: AppIntentProtocol.AudioPlaybackIntent,
  perform: async (audioName: string) => {
    // 根据参数执行操作
    console.log(`切换音频播放状态：${audioName}`)
    Widget.reloadAll()
  }
})
```

***

## 3. 在小组件或 LiveActivity UI 中使用 AppIntent

注册完 AppIntent 后，可以在 `widget.tsx` 或 LiveActivity UI 文件中的 `Button` 和 `Toggle` 等交互组件中链接这些 AppIntent。

### 示例：在小组件中使用 AppIntent

```typescript
// widget.tsx

import { VStack, Button, Toggle } from "scripting"
import { IntentWithoutParams, ToggleIntentWithParams } from "./app_intents"
import { model } from "./model"

function WidgetView() {
  return (
    <VStack>
      <Button
        title="点击我"
        intent={IntentWithoutParams(undefined)} // 触发无参数的 AppIntent
      />
      <Toggle
        title="播放或暂停"
        value={model.checked}
        intent={ToggleIntentWithParams("audio_name")} // 触发带参数的 AppIntent
      />
    </VStack>
  )
}

// 展示小组件
Widget.present(<WidgetView />)
```

***

## 4. API 参考

### `AppIntentManager.register`

注册一个可在小组件或 LiveActivity UI 中使用的 AppIntent。

#### 参数：

- `name` (string)：意图的唯一名称。
- `protocol` (`AppIntentProtocol`)：指定意图类型（如 `AppIntent`、`AudioPlaybackIntent`）。
- `perform` (function)：当触发意图时执行的函数。

#### 返回：

- 一个 `AppIntentFactory` 函数，可用于创建已注册意图的实例。

***

### `Button` 组件

可点击的按钮，用于触发 AppIntent。

#### 属性：

- `title` (string)：按钮的标签。
- `intent` (`AppIntent<any>`)：按钮被点击时执行的 AppIntent。
- `systemImage` (可选)：按钮上显示的 SF Symbol 图标。

***

### `Toggle` 组件

切换开关，切换值时触发 AppIntent。

#### 属性：

- `value` (boolean)：切换状态（开/关）。
- `intent` (`AppIntent<any>`)：切换时执行的 AppIntent。
- `title` (string)：切换的标签。
- `systemImage` (可选)：切换上显示的 SF Symbol 图标。

***

## 5. 注意事项和最佳实践

- 在 `perform` 函数中使用 `Widget.reloadAll()` 可在执行意图后动态更新小组件。
- 将所有 AppIntent 定义在 `app_intents.tsx` 文件中，方便组织和重用。
- 根据意图的功能选择合适的协议（如 `AudioPlaybackIntent`）。



---
url: /v2/zh/guide/LiveActivity.md
---

`LiveActivity` API 允许你的脚本在 iOS 的锁屏界面以及支持的设备上的动态岛中展示实时数据。通过该 API，你可以创建、更新并结束 Live Activity，同时监听其生命周期状态和系统支持情况。

本文件详细介绍 Scripting app 中的 **LiveActivity API**，包括：

- Live Activity 的生命周期与核心概念
- 如何注册 Live Activity UI
- 如何在脚本中启动、更新、结束 Live Activity
- 如何构建 Live Activity UI（包括 Dynamic Island 多种布局）
- 所有类型参数说明
- 完整示例代码与最佳实践

本 API 基于 Apple ActivityKit 能力，并以 TypeScript/TSX 的方式封装，允许开发者使用 React 风格构建 Lock Screen 与 Dynamic Island 界面。

***

# 1. Live Activity 概念理解

Live Activity 展示在以下区域：

- **锁屏界面**
- **iPhone 14 Pro+ 的 Dynamic Island**
- **其他设备的悬浮样式（Banner）**

它能随着应用或脚本运行实时更新内容，如：

- 计时器
- 外卖进度
- 健身、运动状态
- 倒计时、打卡、提醒

**在 Scripting app 中，一个 Live Activity 由两部分组成：**

1. **内容状态（contentState）**
   一个 JSON 可序列化的对象，会随时间改变。
2. **UI Builder**
   通过 TSX 描述不同区域的展示方式。

***

# 2. Live Activity 状态类型

```ts
type LiveActivityState = "active" | "dismissed" | "ended" | "stale";
```

| 状态        | 描述                              |
| --------- | ------------------------------- |
| active    | 正在显示，可以更新内容                     |
| stale     | 已过期，需要更新 staleDate 后才能恢复 active |
| ended     | 活动已结束但仍在锁屏显示（最长 4 小时或自定时间）      |
| dismissed | 已被系统或用户移除，不再可见                  |

***

# 3. LiveActivityDetail 类型

```ts
type LiveActivityDetail = {
  id: string;
  state: LiveActivityState;
};
```

用于描述当前正在运行的所有 Live Activity 信息。

***

# 4. LiveActivity UI 构建类型

## 4.1 LiveActivityUIProps

```ts
type LiveActivityUIProps = {
  content: VirtualNode;
  compactLeading: VirtualNode;
  compactTrailing: VirtualNode;
  minimal: VirtualNode;
  children: VirtualNode | VirtualNode[];
};
```

这些字段对应 Dynamic Island：

- **content**：锁屏和普通设备顶部 Banner 显示
- **compactLeading / compactTrailing**：Dynamic Island 收缩状态左右区域
- **minimal**：最小化的单点显示
- **children**：展开后的多个区域（使用 `LiveActivityUIExpanded*` 包裹）

***

# 5. 注册 Live Activity UI

Live Activity 必须放在单独的文件中，例如 `live_activity.tsx`：

```tsx
import { LiveActivity, LiveActivityUI, LiveActivityUIBuilder } from "scripting";

export type State = {
  mins: number;
};

function ContentView(state: State) {
  return (
    <HStack activityBackgroundTint={{ light: "clear", dark: "clear" }}>
      <Image systemName="waterbottle" foregroundStyle="systemBlue" />
      <Text>{state.mins}分钟后补水</Text>
    </HStack>
  );
}

const builder: LiveActivityUIBuilder<State> = (state) => {
  return (
    <LiveActivityUI
      content={<ContentView {...state} />}
      compactLeading={
        <HStack>
          <Image systemName="clock" />
          <Text>{state.mins}m</Text>
        </HStack>
      }
      compactTrailing={<Image systemName="waterbottle" foregroundStyle="systemBlue" />}
      minimal={<Image systemName="clock" />}>
      <LiveActivityUIExpandedCenter>
        <ContentView {...state} />
      </LiveActivityUIExpandedCenter>
    </LiveActivityUI>
  );
};

export const MyLiveActivity = LiveActivity.register("MyLiveActivity", builder);
```

***

# 6. 在脚本中使用 Live Activity

下面展示如何启动、更新、监听状态并结束 Live Activity。

```tsx
import {
  Button,
  Text,
  VStack,
  Navigation,
  NavigationStack,
  useMemo,
  useState,
  LiveActivityState,
  BackgroundKeeper,
} from "scripting";
import { MyLiveActivity } from "./live_activity";

function Example() {
  const dismiss = Navigation.useDismiss();
  const [state, setState] = useState<LiveActivityState>();

  const activity = useMemo(() => {
    const instance = MyLiveActivity();

    instance.addUpdateListener((s) => {
      setState(s);
      if (s === "dismissed") {
        BackgroundKeeper.stop();
      }
    });

    return instance;
  }, []);

  return (
    <NavigationStack>
      <VStack
        navigationTitle="LiveActivity 示例"
        navigationBarTitleDisplayMode="inline"
        toolbar={{
          cancellationAction: <Button title="完成" action={dismiss} />,
        }}>
        <Text>当前状态：{state ?? "-"}</Text>

        <Button
          title="启动 Live Activity"
          disabled={state != null}
          action={() => {
            let count = 5;
            BackgroundKeeper.keepAlive();

            activity.start({ mins: count });

            function tick() {
              setTimeout(() => {
                count -= 1;

                if (count === 0) {
                  activity.end({ mins: 0 });
                  BackgroundKeeper.stop();
                } else {
                  activity.update({ mins: count });
                  tick();
                }
              }, 60000);
            }
            tick();
          }}
        />
      </VStack>
    </NavigationStack>
  );
}

async function run() {
  await Navigation.present(<Example />);
  Script.exit();
}

run();
```

***

# 7. LiveActivity 类 API 说明

## 7.1 start(contentState, options?)

```ts
start(contentState: T, options?: LiveActivityOptions): Promise<boolean>
```

- 请求系统启动 Live Activity
- contentState 必须可以 JSON 序列化

### LiveActivityOptions

```ts
type LiveActivityOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
};
```

- staleDate：到期变为 stale 的时间戳（ms） 或 Date 对象
- relevanceScore：控制 Dynamic Island 的优先级

***

## 7.2 update(contentState, options?)

```ts
update(contentState: T, options?: LiveActivityUpdateOptions)
```

### LiveActivityUpdateOptions

```ts
type LiveActivityUpdateOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  alert?: {
    title: string;
    body: string;
  };
};
```

可带 Apple Watch 的更新提示。

***

## 7.3 end(contentState, options?)

```ts
end(contentState: T, options?: LiveActivityEndOptions)
```

### LiveActivityEndOptions

```ts
type LiveActivityEndOptions = {
  staleDate?: number | Date;
  relevanceScore?: number;
  dismissTimeInterval?: number;
};
```

dismissTimeInterval（单位秒）:

- 未提供：系统默认最长保留 4 小时
- \<= 0：立即移除
- \> 0：指定多久后移除

***

## 7.4 获取活动状态

```ts
getActivityState(): Promise<LiveActivityState | null>
```

***

## 7.5 监听状态更新

```ts
addUpdateListener(listener);
removeUpdateListener(listener);
```

当 Live Activity 状态变更时回调，例如：

- active → stale
- active → ended
- ended → dismissed

***

## 7.6 静态方法

```ts
static areActivitiesEnabled(): Promise<boolean>
static getAllActivities(): Promise<LiveActivityDetail[]>
static getAllActivitiesIds(): Promise<string[]>
static getActivityState(activityId: string)
static from(activityId, name)
static endAllActivities(options?)
```

***

# 8. Live Activity UI 组件

| 组件                             | 描述         |
| ------------------------------ | ---------- |
| LiveActivityUI                 | 注册 UI 的根结构 |
| LiveActivityUIExpandedCenter   | 展开状态的中间区域  |
| LiveActivityUIExpandedLeading  | 左侧区域       |
| LiveActivityUIExpandedTrailing | 右侧区域       |
| LiveActivityUIExpandedBottom   | 底部区域       |

用于构建 Dynamic Island 展开布局。

***

# 9. 注意事项与最佳实践

## 9.1 必须 JSON 可序列化

contentState 中不能包含：

- 函数
- Date 对象（需转 timestamp）
- class 实例
- 非可序列化对象

## 9.2 Live Activity 必须放在独立文件

例如：

```
live_activity.tsx
```

这与系统对 UI 构建的要求有关。

## 9.3 Scripting 的 Live Activity 与脚本生命周期隔离

即使脚本结束，Live Activity 会继续保持。

若你希望脚本保持运行，可使用：

```ts
BackgroundKeeper.keepAlive();
```

***

# 10. 完整示例（简化版）

```tsx
const activity = MyLiveActivity();

await activity.start({ mins: 10 });

await activity.update({ mins: 5 });

await activity.end({ mins: 0 }, { dismissTimeInterval: 0 });
```

# 11. 注意事项

- Live Activity 的启动是异步的，需要等到 `start` 返回 `true` 时才能调用 `update` 和 `end`
- Live Activity 不能访问 Documents 和 iCloud 目录，只能访问 app group 目录，如果你想要访问文件或者渲染图片，必须把文件或图片保存到 `FileManager.appGroupDocumentsDirectory` 目录中。 比如渲染图片，你保存到 `FileManager.appGroupDocumentsDirectory` 中， 再通过 `<Image filePath={Path.join(FileManager.appGroupDocumentsDirectory, 'example.png')} />` 渲染
- Live Activity 可以访问与 App 共享的 Storage 数据



---
url: /v2/zh/guide/Quick Start.md
---

# 快速开始

欢迎使用 **Scripting**！这是一款可让你使用 **TypeScript** 编写 **React 类似的 TSX 语法**来创建 UI 组件和自定义小组件、灵动岛和使用发通知提醒等能力的应用。通过 Scripting，你可以使用包装过的 SwiftUI 视图来获得在 iOS 上流畅且原生的使用体验，并通过熟悉的编码结构来创建和呈现各种 iOS 工具型 UI 页面。本指南将带你完成项目设置、组件创建以及结合 Hooks 构建动态界面的流程。

### 目录

1. **快速开始**
2. **创建脚本项目**
3. **导入组件**
4. **创建自定义组件**
5. **呈现 UI 视图**
6. **使用 Hooks**
7. **构建复杂的 UI**

***

### 1. 快速开始

在 Scripting 中，你可以通过定义函数式组件的方式来创建简单的 UI 元素。你需要的所有组件和 API 都可以从 `scripting` 包里导入。

### 2. 创建脚本项目

在开始编写代码之前，你需要**创建一个脚本项目**。项目创建完成后，你可以在 `index.tsx` 文件中编写代码。这个文件是定义 UI 组件和逻辑的主要入口。

`index.tsx` 的示例：

```tsx
import { VStack, Text } from "scripting"

// 定义一个自定义视图组件
function View() {
  return (
    <VStack>
      <Text>Hello, Scripting!</Text>
    </VStack>
  )
}
```

***

### 3. 导入视图

SwiftUI 中的所有视图以及部分 API 都进行了包装，并通过 `scripting` 包提供给你使用。以下是部分可用视图的列表：

- **布局视图**: `VStack`, `HStack`, `ZStack`, `Grid`
- **控件**: `Button`, `Picker`, `Toggle`, `Slider`, `ColorPicker`
- **集合**: `List`, `Section`
- **日期和时间**: `DatePicker`
- **文本和标签**: `Text`, `Label`, `TextField`

你可以像这样在项目中导入它们：

```tsx
import { VStack, Text, Button, Picker } from "scripting"
```

***

### 4. 创建自定义组件

在 Scripting 中，函数式组件的工作原理与 React 基本相同，可以使用类似 JSX 的语法来构建可复用组件。

示例：

```tsx
import { VStack, HStack, Text, Button } from "scripting"

function Greeting({
   name
}: {
   name: string 
}) {
  return (
    <HStack>
      <Text>Hello, {name}!</Text>
    </HStack>
  )
}

function MainView() {
  return (
    <VStack>
      <Greeting name="Scripting User" />
      <Button 
        title="Click Me" 
        action={() => console.log("Button Clicked!")}
      />
    </VStack>
  )
}
```

***

### 5. 呈现 UI 视图

若要呈现 UI 视图，可以使用 `Navigation.present` 方法。它能够以模态视图的形式显示自定义组件，并处理该视图的关闭。`Navigation.present` 方法会返回一个在视图被关闭后才会完成的 Promise。为了避免内存泄漏，一定要在视图关闭后调用 `Script.exit()`。

示例：

```tsx
import { VStack, Text, Navigation, Script } from "scripting"

function View() {
  return (
    <VStack>
      <Text>Hello, Scripting!</Text>
    </VStack>
  )
}

// 显示该视图
Navigation.present({ 
  element: <View />
}).then(() => {
  // 视图关闭后清理资源，避免内存泄漏
  Script.exit()
})
```

在上述示例中，`Navigation.present({ element: <View /> })` 会呈现 `View` 组件；当用户关闭此视图后，`Script.exit()` 确保释放相关资源。

***

### 6. 使用 Hooks

Scripting 支持一系列与 React 类似的 Hooks，用于管理组件中的状态、副作用、Memo 化以及上下文。以下是每种 Hook 的使用指南及示例：

***

#### `useState`

`useState` Hook 能够让你在函数式组件中添加本地状态。

```tsx
import { useState, VStack, Text, Button } from "scripting"

function Counter() {
  const [count, setCount] = useState(0)

  return (
    <VStack>
      <Text>Count: {count}</Text>
      <Button
        title="Increment"
        action={() => setCount(count + 1)}
      />
    </VStack>
  )
}
```

在这个示例中，每次点击按钮都会更新 `count` 变量，并触发组件的自动重新渲染。

***

#### `useEffect`

`useEffect` Hook 可以让你在组件中执行副作用操作，比如获取数据或者设置订阅。

```tsx
import { useState, useEffect, VStack, Text } from "scripting"

function TimeDisplay() {
  const [time, setTime] = useState(
    new Date().toLocaleTimeString()
  )

  useEffect(() => {
    let timerId: number

    const startTimer = () => {
      timerId = setTimeout(() => {
        setTime(new Date().toLocaleTimeString())
      }, 1000)
    }

    startTimer()
    
    return () => clearTimeout(timerId) // 组件卸载时清理定时器
  }, [])

  return <Text>Current Time: {time}</Text>
}
```

在此示例中，`useEffect` Hook 会设置一个间隔操作，每秒更新一次 `time` 变量，并在组件卸载时清除该间隔以避免潜在的问题。

***

#### `useReducer`

当你需要在组件中管理更复杂的状态逻辑时，`useReducer` Hook 非常有用。

```tsx
import { useReducer, VStack, Text, Button } from "scripting"

type Action = { 
  type: "increment"
} | {
  type: "decrement"
}
const reducer = (state: number, action: Action) => {
  switch (action.type) {
    case "increment":
      return state + 1
    case "decrement":
      return state - 1
    default:
      return state
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0)

  return (
    <VStack>
      <Text>Count: {count}</Text>
      <Button 
        title="Increment"
        action={() => dispatch({ type: "increment" })}
      />
      <Button
        title="Decrement"
        action={() => dispatch({ type: "decrement" })}
      />
    </VStack>
  )
}
```

`useReducer` Hook 可以通过一个 reducer 函数来帮助你更好地处理复杂的状态变更。

***

#### `useCallback`

`useCallback` Hook 可以让你对函数进行 Memo 化，以避免在每次渲染时都重新创建函数，从而提升性能。

```tsx
import { useState, useCallback, VStack, Text, Button } from "scripting"

function Counter() {
  const [count, setCount] = useState(0)

  const increment = useCallback(() => {
    setCount((prev) => prev + 1)
  }, [])

  return (
    <VStack>
      <Text>Count: {count}</Text>
      <Button 
        title="Increment"
        action={increment}
      />
    </VStack>
  )
}
```

使用 `useCallback`，只有在依赖项改变时才会重新创建 `increment` 函数，从而在大型或频繁更新的组件中提升性能。

***

#### `useMemo`

`useMemo` Hook 允许你对某些值进行 Memo 化，以缓存代价高的计算结果，从而提高性能。

```tsx
import { useState, useMemo, VStack, Text, Button } from "scripting"

function FactorialCounter() {
  const [count, setCount] = useState(1)

  const factorial = useMemo(() => {
    let result = 1
    for (let i = 1; i <= count; i++) result *= i
    return result
  }, [count])

  return (
    <VStack>
      <Text>Factorial of {count} is {factorial}</Text>
      <Button 
        title="Increase"
        action={() => setCount(count + 1)}
      />
    </VStack>
  )
}
```

`useMemo` Hook 仅在 `count` 改变时才重新计算阶乘，从而避免不必要的性能消耗。

***

#### `useContext`

`useContext` Hook 允许你在应用的各组件之间共享状态，而无需进行层层的 props 传递（即“向下传递”）。

```tsx
import { createContext, useContext, VStack, Text, Button } from "scripting"

const CountContext = createContext<number>()

function Display() {
  const count = useContext(CountContext)
  return <Text>Shared Count: {count}</Text>
}

function App() {
  return (
    <CountContext.Provider value={42}>
      <VStack>
        <Display />
      </VStack>
    </CountContext.Provider>
  )
}
```

在此示例中，`useContext` 可以访问 `CountContext`，从而在应用中共享计数值。

***

### 7. 构建复杂的 UI

通过结合已提供的视图、Hooks 和自定义组件，你可以构建出功能完善、结构复杂的 UI。

示例：

```tsx
import { useState, VStack, Text, TextField, List, Section, NavigationStack, Script } from "scripting"

function ToDoApp() {
  const [tasks, setTasks] = useState(["Task 1", "Task 2", "Task 3"])
  const [content, setContent] = useState("")

  return (
    <NavigationStack>
        <List
          navigationTitle="My Tasks"
        >
          <Section>
            {tasks.map((task, index) => (
              <Text key={index}>{task}</Text>
            ))}
          </Section>
          
          <TextField
            title="New Task"
            value={content}
            onSubmit={() => {
              if (content.length === 0) {
                return
              }
              setTasks([...tasks, content])
              setContent("")
            }}
          />
        </List>
    </NavigationStack>
  )
}

async function run() {
  await Navigation.present({
    element: <ToDoApp />
  })

  Script.exit()
}
```

***

如需了解更多详细信息，请查阅完整的 API 文档，该文档包含关于 `scripting` 包的更多示例和使用场景。



---
url: /v2/zh/guide/Script.md
---

# Script

`Script` 模块为 Scripting App 中的脚本执行提供上下文和实用函数。它允许你访问运行时元数据、通过结果终止脚本、以编程方式运行其他脚本，并构造 URL Scheme 启动或打开脚本。

***

## 属性（Properties）

### `name: string`

当前正在运行的脚本名称。

```ts
console.log(Script.name) // 示例: "MyScript"
```

***

### `directory: string`

当前脚本所在的目录路径。

```ts
console.log(Script.directory) // 示例: "/private/var/mobile/Containers/..."
```

***

### `env: string`

表示当前脚本运行的环境类型，用于根据上下文动态调整脚本行为，例如判断是否处于主应用、组件、通知或扩展中。

### 可选值说明：

| 值                  | 说明                                                                                          |
| ------------------ | ------------------------------------------------------------------------------------------- |
| `"index"`          | 主应用环境中运行，入口文件为 `index.tsx`。用于普通应用逻辑和界面展示。                                                   |
| `"widget"`         | 小组件中运行，入口文件为 `widget.tsx`。用于生成主屏幕组件内容。                                                      |
| `"control_widget"` | 控制中心小组件中运行，入口文件为 `control_widget_button.tsx`或`control_widget_toggle.tsx`。用于控制中心小组件的按钮或开关控件。 |
| `"notification"`   | 富通知扩展中运行，入口文件为 `notification.tsx`。用于自定义通知界面。                                                |
| `"intent"`         | 通过快捷指令或分享面板触发的脚本，入口文件为 `intent.tsx`。                                                        |
| `"app_intents"`    | App Intents 扩展中运行，入口文件为 `app_intents.tsx`。用于原生快捷指令集成。                                       |
| `"assistant_tool"` | Assistant Tool 工具模式中运行，入口文件为 `assistant_tool.tsx`。                                          |
| `"keyboard"`       | 自定义键盘扩展中运行，入口文件为 `keyboard.tsx`。用于实现个性化键盘逻辑。                                                |
| `"live_activity"`  | LiveActivity 扩展中运行，入口文件为 `live_activity.tsx`。用于实现实时活动逻辑。                                    |

### 示例：

```ts
if (Script.env === "widget") {
  Widget.present(<MyWidget />)
} else if (Script.env === "index") {
  Navigation.present({ element: <MainPage /> })
}
```

***

### `widgetParameter: string`

从小组件启动脚本时传入的参数。

```ts
if (Script.widgetParameter) {
  console.log("Widget input:", Script.widgetParameter)
}
```

***

### `queryParameters: Record<string, string>`

通过 `run` URL Scheme 传入的键值对参数。

```ts
// URL: scripting://run/MyScript?user=John&id=123
console.log(Script.queryParameters.user) // "John"
console.log(Script.queryParameters.id)   // "123"
```

***

### `metadata: { ... }`

当前脚本的元数据信息。

- `icon`: 脚本图标，可以是系统图标(SFSymbol)名称
- `color`: 脚本颜色，可以是十六进制颜色字符串（如 `#FF0000`）或 CSS 颜色名称（如 `"red"`）
- `localizedName`: 当前系统语言下的脚本本地化名称
- `localizedNames`: 不同语言下的本地化名称，键为语言代码，值为对应的名称
- `description`: 脚本的英文描述
- `localizedDescription`: 当前系统语言下的本地化描述
- `localizedDescriptions`: 不同语言下的本地化描述，键为语言代码，值为对应描述
- `version`: 脚本的版本字符串
- `author`: 作者信息对象：

  - `name`: 作者姓名
  - `email`: 作者电子邮箱
  - `homepage`: 作者个人主页（可选）
- `contributors`: 贡献者信息数组，每项结构同 `author`
- `remoteResource`: 远程资源信息：

  - `url`: 远程资源地址（可以是 zip 文件或 Git 仓库）
  - `autoUpdateInterval`: 自动更新间隔时间（单位：秒），若未设置则不自动更新

```ts
console.log(Script.metadata.localizedName) // 示例: "天气助手"
console.log(Script.metadata.version)       // 示例: "1.2.0"
```

***

## 方法（Methods）

### `Script.exit(result?): void`

终止当前脚本，并可选地返回一个结果。**必须调用该方法来正确释放资源。**

- `result?: any | IntentValue`: 要返回的值，可以是任意类型，也可以是 `IntentValue` 对象（例如返回给快捷指令或其他脚本）

```ts
Script.exit("Done")

// 或返回结构化数据
Script.exit(Intent.json({ status: "ok" }))
```

***

### `Script.run<T>(options): Promise<T | null>`

以编程方式运行另一个脚本，并等待其结果。

- `options.name`: 要运行的脚本名称
- `options.queryParameters`: 可选参数，作为 URL 参数传递
- `options.singleMode`: 若为 `true`，确保同一脚本只能同时运行一个实例

返回目标脚本中 `Script.exit(result)` 返回的值。

```ts
const result = await Script.run({
  name: "ProcessData",
  queryParameters: { input: "abc" }
})

console.log(result)
```

***

### `Script.createRunURLScheme(scriptName, queryParameters?): string`

生成一个 `scripting://run` URL，可用于启动并执行脚本。

```ts
const url = Script.createRunURLScheme("MyScript", { user: "Alice" })
// "scripting://run/MyScript?user=Alice"
```

***

### `Script.createRunSingleURLScheme(scriptName, queryParameters?): string`

生成一个 `scripting://run_single` URL，确保脚本不会并行运行多个实例。

```ts
const url = Script.createRunSingleURLScheme("MyScript", { id: "1" })
// "scripting://run_single/MyScript?id=1"
```

***

### `Script.createOpenURLScheme(scriptName): string`

生成一个 `scripting://open` URL，用于在编辑器中打开脚本。

```ts
const url = Script.createOpenURLScheme("MyScript")
// "scripting://open/MyScript"
```

***

### `Script.createDocumentationURLScheme(title?): string`

生成用于打开 Scripting App 内文档页面的 URL。

- `title`: （可选）若传入标题，将直接打开该文档主题页面。

```ts
const url = Script.createDocumentationURLScheme("Widgets")
// "scripting://doc?title=Widgets"
```

***

### `createImportScriptsURLScheme(urls): string`

根据提供的 URL 数组生成导入脚本的 URL Scheme。

- `urls: string[]`: 要导入的脚本资源 URL 列表（支持 zip 或单文件）

```ts
const urlScheme = Script.createImportScriptsURLScheme([
  "https://github.com/schl3ck/scripting-app-lib",
  "https://example.com/my-script.zip",
])
// "scripting://import_scripts?urls=..."
```

***

### `hasFullAccess(): boolean`

判断用户是否具有完整的 Scripting PRO 访问权限。

返回:`true` 如果用户具有完整的 Scripting PRO 访问权限，否则返回 `false`。

```ts
if (Script.hasFullAccess()) {
  // 有完整的 Scripting PRO 访问权限
  Assistant.requestStructedData(...)
}
```

***

## 注意事项（Notes）

- 请务必调用 `Script.exit()` 正确终止脚本并释放内存资源
- 使用 `Script.run()` 可以实现脚本的模块化和调用链，获取结构化返回值
- URL Scheme 可用于从外部应用（如快捷指令）触发脚本执行
- 对于需要避免并发执行的脚本，建议使用 `singleMode` 或 `run_single` URL Scheme



---
url: /v2/zh/guide/Types/Alignment.md
---

# 对齐

通过 `Alignment`，你可以指定内容在视图框架（frame）中的位置，与 SwiftUI 内置对齐方式的行为相对应。当组件有额外空间或需要在布局中按特定方式对齐时，可使用 `Alignment` 来控制元素在容器中的位置。

***

## 概述

当你使用像 `VStack`、`HStack`、`ZStack` 等需要堆叠、分层或定位多个视图的容器时，`Alignment` 非常有用。\
选择一个对齐方式就意味着告诉布局系统如何将这些视图相互对齐或在其容器中对齐。

举例来说，如果一个 `ZStack` 的对齐方式为 `topLeading`，它会把内容放置在容器的左上方；若对齐方式为 `bottomTrailing`，则会把内容放置在容器的右下方。

***

## 可用的对齐方式

- **基础对齐 (Basic Alignments)**:
  - **`top`**：沿视图顶部对齐。
  - **`center`**：在水平和垂直方向上同时居中。
  - **`bottom`**：沿视图底部对齐。
  - **`leading`**：沿主阅读方向的起始边对齐（在从左到右语言环境下为左侧）。
  - **`trailing`**：沿主阅读方向的末尾边对齐（在从左到右语言环境下为右侧）。

- **复合对齐 (Compound Alignments)**:
  - **`topLeading`**：同时沿顶部和起始边对齐。
  - **`topTrailing`**：同时沿顶部和末尾边对齐。
  - **`bottomLeading`**：同时沿底部和起始边对齐。
  - **`bottomTrailing`**：同时沿底部和末尾边对齐。

- **文本基线对齐 (Text Baseline Alignments)**:
  当视图包含文本时，可以用基线对齐保证文本在同一基线上对齐。以下值可用于使文本在特定基线上对齐：
  - **`centerFirstTextBaseline`**
  - **`centerLastTextBaseline`**
  - **`leadingFirstTextBaseline`**
  - **`leadingLastTextBaseline`**
  - **`trailingFirstTextBaseline`**
  - **`trailingLastTextBaseline`**

***

## 使用示例

### **居中对齐 (Center Alignment)**

```tsx
<ZStack alignment="center">
  <Rectangle fill="gray" frame={{width: 100, height: 100}} />
  <Text font="title">Centered Text</Text>
</ZStack>
```

在此示例中，`Text` 会在 `Rectangle` 中居中显示。

***

### **顶部靠左对齐 (Top Leading Alignment)**

```tsx
<ZStack alignment="topLeading">
  <Rectangle fill="gray" frame={{width: 200, height: 200}} />
  <Text>I'm at the top-left!</Text>
</ZStack>
```

在这里，`Text` 会出现在灰色矩形的左上角。

***

### **基线对齐 (Baseline Alignment)**

```tsx
<HStack alignment="leadingFirstTextBaseline">
  <Text font="largeTitle">Big Title</Text>
  <Text font="title">Smaller Subtitle</Text>
</HStack>
```

此示例中，两个文本的首行基线对齐，即使它们的字号不同，也能让第一行文字在视觉上保持整齐。

***

## 小结

`Alignment` 让你能够细粒度地控制内容在容器内部的定位方式。无论是使用基础的边缘对齐，还是更为高级的文本基线对齐，都能确保你的 UI 元素在视觉上呈现一致且直观的效果。



---
url: /v2/zh/guide/Types/Color.md
---

# 颜色

`Color` API 支持多种颜色格式，包括 HEX 字符串、RGBA 字符串和预定义颜色关键字。它与 SwiftUI 的颜色系统无缝集成，提供鲜艳且可自适应的颜色，用于设计出色的 UI。

***

## `Color` 类型

`Color` 类型可以采用以下三种格式来表示颜色：

1. **HEX 字符串**：标准的十六进制颜色代码。
2. **RGBA 字符串**：类似 CSS 的字符串格式，包含红色、绿色、蓝色以及透明度通道。
3. **关键字颜色**：一组预定义的系统和语义化颜色。

***

### 支持的格式

#### 1. HEX 字符串 (`ColorStringHex`)

- **格式**: `#RRGGBB` 或者 `#RGB`
- **示例**:
  ```tsx
  const primaryColor: Color = "#FF5733"
  const secondaryColor: Color = "#333"
  ```

***

#### 2. RGBA 字符串 (`ColorStringRGBA`)

- **格式**: `rgba(R, G, B, A)`
  - `R`: 红色, 取值范围 0–255
  - `G`: 绿色, 取值范围 0–255
  - `B`: 蓝色, 取值范围 0–255
  - `A`: 透明度, 取值范围 0–1
- **示例**:
  ```tsx
  const transparentBlack: Color = "rgba(0, 0, 0, 0.5)"
  const semiTransparentRed: Color = "rgba(255, 0, 0, 0.8)"
  ```

***

#### 3. 关键字颜色 (`KeywordsColor`)

系统中预定义的颜色，根据当前系统外观（浅色/深色模式）和辅助功能设置进行自适应。这些颜色可以与原生 iOS 应用保持一致的视觉效果。

- **示例**:
  ```tsx
  const systemAccent: Color = "accentColor"
  const systemBackground: Color = "systemBackground"
  const linkColor: Color = "link"
  const customGray: Color = "systemGray4"
  ```

***

### 关键字颜色列表

#### 系统颜色

- `accentColor`
- `systemRed`, `systemGreen`, `systemBlue`, `systemOrange`, `systemYellow`, `systemPink`, `systemPurple`, `systemTeal`, `systemIndigo`, `systemBrown`, `systemMint`, `systemCyan`

#### 语义化颜色

- **标签类 (Labels)**: `label`, `secondaryLabel`, `tertiaryLabel`, `quaternaryLabel`
- **填充颜色 (Fill Colors)**: `systemFill`, `secondarySystemFill`, `tertiarySystemFill`, `quaternarySystemFill`
- **背景色 (Backgrounds)**:
  - `systemBackground`, `secondarySystemBackground`, `tertiarySystemBackground`
  - `systemGroupedBackground`, `secondarySystemGroupedBackground`, `tertiarySystemGroupedBackground`
- **分割线 (Separators)**: `separator`, `opaqueSeparator`

#### 传统颜色 (Legacy Colors)

- `black`, `darkGray`, `lightGray`, `white`, `gray`, `red`, `green`, `blue`, `cyan`, `yellow`, `magenta`, `orange`, `purple`, `brown`, `clear`

***

### 在 TSX 组件中的使用

```tsx
import { View, Text, VStack } from 'scripting'

function MyView() {
  return (
    <VStack background="systemBackground">
      <Text foregroundStyle="accentColor">
        Welcome to the Scripting App!
      </Text>
    </VStack>
  )
}
```

在这个组件中，使用了自适应的系统颜色，以与 iOS 的外观设置保持一致。

***

### 注意事项

- **性能**: 当使用关键字颜色时，应用会根据系统设置（如深色模式）自动更新颜色。
- **校验**: 若颜色字符串不符合预期格式，运行时可能抛出错误。请确保所使用的颜色字符串是有效的。



---
url: /v2/zh/guide/Types/DynamicShapeStyle.md
---

# DynamicShapeStyle

`DynamicShapeStyle` 类型允许为一个形状定义两种不同的样式——一种用于浅色模式，另一种用于深色模式。系统会根据用户设备的当前配色方案（浅色或深色）自动应用适合的样式。

## 概述

动态样式是创建自适应且视觉吸引力用户界面的关键之一。通过使用 `DynamicShapeStyle`，可以确保您的形状与用户首选的配色方案完美融合，为浅色模式和深色模式分别定义样式。

**关键点：**

- 使用 `light` 属性定义 **浅色模式** 的样式。
- 使用 `dark` 属性定义 **深色模式** 的样式。
- 系统会根据用户当前的设置自动应用适当的样式。

## 声明

```tsx
type DynamicShapeStyle = {
    light: ShapeStyle;
    dark: ShapeStyle;
};
```

- **`light: ShapeStyle`**\
  当系统处于浅色模式时应用的样式。

- **`dark: ShapeStyle`**\
  当系统处于深色模式时应用的样式。

### 支持的 `ShapeStyle`

`ShapeStyle` 可以是颜色、渐变或材质，例如：

- **颜色**：如 `"red"`、十六进制值 `"#FF0000"` 或类似 CSS 的 RGBA 字符串 `"rgba(255, 0, 0, 1)"`。
- **渐变**：线性渐变或径向渐变。
- **材质**：系统材质，如 `"regularMaterial"`、`"thickMaterial"`。

## 使用示例

### 使用动态颜色

```tsx
const dynamicStyle: DynamicShapeStyle = {
  light: "blue",
  dark: "gray"
}

<Text
  foregroundStyle={dynamicStyle}
/>
```

在此示例中，形状在浅色模式下显示为 **蓝色**，在深色模式下显示为 **灰色**。

### 使用动态渐变

```tsx
const dynamicStyle: DynamicShapeStyle = {
  light: {
    gradient: [
      { color: "lightblue", location: 0 },
      { color: "white", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  },
  dark: {
    gradient: [
      { color: "darkblue", location: 0 },
      { color: "black", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  }
}

<Circle
  fill={dynamicStyle}
/>
```

在此示例中，形状在浅色模式下使用 **浅蓝到白色渐变**，在深色模式下使用 **深蓝到黑色渐变**。

### 使用材质

```tsx
const dynamicStyle: DynamicShapeStyle = {
  light: "regularMaterial",
  dark: "ultraThickMaterial"
}

<HStack
  background={dynamicStyle}
></HStack>
```

此配置在浅色模式下应用 **普通材质**，在深色模式下应用 **超厚材质**。

## 为什么使用 `DynamicShapeStyle`？

动态样式通过以下方式提升用户体验：

1. **视觉和谐**：形状自适应用户的配色方案，保持美观一致。
2. **可访问性**：针对深色模式调整样式，提升在低光环境中的可读性和易用性。
3. **一致性**：与系统整体的偏好设置保持一致，使应用看起来更加集成。

## 总结

通过使用 `DynamicShapeStyle`，您可以为形状创建灵活且自适应的样式，根据用户的配色方案无缝切换。为浅色和深色模式分别定义样式，确保应用在任何环境下都能提供一致且用户友好的体验。



---
url: /v2/zh/guide/Types/Shape.md
---

# 形状

`Shape` 类型用于定义视图的裁剪形状或背景形状，常用于 `clipShape`、`background`、`border` 等修饰符中，对应 SwiftUI 中的 `Shape` 协议。支持内建关键字形状，也支持自定义圆角矩形（包括统一圆角、椭圆角或每个角独立控制）。

***

## 内建形状

### `'rect'`（矩形）

标准矩形，默认无圆角。如需圆角请使用对象形式配置。

```tsx
clipShape="rect"
```

***

### `'circle'`（圆形）

在视图框架中居中显示的圆形，半径等于视图框架最短边的一半。

```tsx
clipShape="circle"
```

***

### `'capsule'`（胶囊）

填充整个宽度或高度的椭圆形。等效于圆角半径为短边一半的矩形。

```tsx
clipShape="capsule"
```

***

### `'ellipse'`（椭圆）

在视图框架中对齐并填满的椭圆。

```tsx
clipShape="ellipse"
```

***

### `'buttonBorder'`（按钮边框）

一个系统定义的按钮边框形状，具体外观由平台和上下文决定。

```tsx
clipShape="buttonBorder"
```

***

### `'containerRelative'`（继承容器）

继承父级容器定义的形状作为自身形状。如果未定义容器形状，则默认为矩形。

```tsx
clipShape="containerRelative"
```

***

## 自定义矩形形状（圆角矩形）

当你需要更精细地控制圆角半径或不同角的圆角时，可以使用以下三种对象形式：

***

### 统一圆角矩形

```ts
{
  type: 'rect',
  cornerRadius: number,
  style?: RoundedCornerStyle
}
```

- `cornerRadius`: 所有角的统一圆角半径。
- `style`（可选）: 圆角风格，可选 `'circular'` 或 `'continuous'`。

#### 示例：

```tsx
clipShape={{
  type: 'rect',
  cornerRadius: 12,
  style: 'continuous'
}}
```

***

### 椭圆角尺寸（宽高不同）

```ts
{
  type: 'rect',
  cornerSize: {
    width: number
    height: number
  },
  style?: RoundedCornerStyle
}
```

- 使用不同的 `width` 和 `height` 来生成椭圆形圆角。

#### 示例：

```tsx
clipShape={{
  type: 'rect',
  cornerSize: { width: 10, height: 20 }
}}
```

***

### 每个角分别设置圆角半径

```ts
{
  type: 'rect',
  cornerRadii: {
    topLeading: number,
    topTrailing: number,
    bottomLeading: number,
    bottomTrailing: number
  },
  style?: RoundedCornerStyle
}
```

- 分别指定四个角的圆角半径。

#### 示例：

```tsx
clipShape={{
  type: 'rect',
  cornerRadii: {
    topLeading: 10,
    topTrailing: 20,
    bottomLeading: 0,
    bottomTrailing: 30
  }
}}
```

***

## `RoundedCornerStyle`（圆角风格）

可选参数，用于定义圆角的表现风格：

- `"circular"`: 传统的圆形圆角，适合经典 UI。
- `"continuous"`（默认）: 连续平滑的圆角曲线，适用于现代设计风格。

***

## 总结表

| 形状类型                  | 描述说明                                        |
| --------------------- | ------------------------------------------- |
| `'rect'`              | 普通矩形                                        |
| `'circle'`            | 基于最短边生成的居中圆形                                |
| `'capsule'`           | 胶囊形状，适应整个宽或高                                |
| `'ellipse'`           | 填满框架的椭圆                                     |
| `'buttonBorder'`      | 系统决定的按钮边框形状                                 |
| `'containerRelative'` | 继承容器的形状或使用矩形作为默认                            |
| 自定义 `'rect'`          | 通过 cornerRadius、cornerSize 或 cornerRadii 配置 |



---
url: /v2/zh/guide/Types/ShapeStyle.md
---

# 形状样式

`ShapeStyle` 类型定义了如何将颜色、渐变和材质应用于视图的前景或背景，反映了 SwiftUI 中的样式能力。它涵盖了广泛的样式选项，包括纯色、系统材质和复杂的渐变。

## 概览

在使用 `foregroundStyle` 或 `background` 等修饰符时，你可以传入一个 `ShapeStyle` 来确定视觉外观。例如，可以使用纯红色背景、系统模糊材质或线性渐变，这些都可以通过 `ShapeStyle` 表达。

**SwiftUI 示例（仅供参考）：**

```swift
Text("Hello")
    .foregroundStyle(.red)
    .background(
        LinearGradient(
            colors: [.green, .blue],
            startPoint: .top,
            endPoint: .bottom
        )
    )
```

**脚本语言示例（TypeScript/TSX）：**

```tsx
<Text
  foregroundStyle="red"
  background={{
    gradient: [
      { color: 'green', location: 0 },
      { color: 'blue', location: 1 }
    ],
    startPoint: { x: 0.5, y: 0 },
    endPoint: { x: 0.5, y: 1 }
  }}
>
  Hello
</Text>
```

## ShapeStyle 的类型变体

`ShapeStyle` 可以是以下几种之一：

1. **Material（材质）**：系统定义的材质，用于创建层叠效果，通常包含模糊或半透明。
2. **Color（颜色）**：一个纯色，可通过关键字、十六进制或 RGBA 字符串定义。
3. **Gradient（渐变）**：颜色或渐变停点集合，生成平滑的颜色过渡效果。
4. **LinearGradient（线性渐变）**：沿直线方向的颜色渐变。
5. **RadialGradient（径向渐变）**：从中心向外辐射的渐变。
6. **AngularGradient（角向渐变）**：又称“圆锥渐变”，以角度为依据沿中心点展开。
7. **MeshGradient（网格渐变）**：由二维颜色网格定义的复杂渐变。
8. **ColorWithGradientOrOpacity**：带有标准渐变或不透明度调节的基础颜色。

### 材质（Materials）

**Material** 指的是系统模糊效果，如 `regularMaterial`、`thinMaterial` 等，常用于营造 iOS 应用中的“毛玻璃”外观。

**示例：**

```tsx
<HStack background="regularMaterial">
  {/* 内容 */}
</HStack>
```

### 颜色（Colors）

颜色可以通过三种方式定义：

- **关键字颜色**：系统或命名颜色（如 `"systemBlue"`、`"red"`、`"label"`）。
- **十六进制字符串**：类似 CSS 的格式（如 `"#FF0000"` 或 `"#F00"` 表示红色）。
- **RGBA 字符串**：CSS 格式的 rgba（如 `"rgba(255,0,0,1)"` 表示不透明红）。

**示例：**

```tsx
<Text foregroundStyle="blue">蓝色文字</Text>
<HStack background="#00FF00">绿色背景</HStack>
<HStack background="rgba(255,255,255,0.5)">半透明白色背景</HStack>
```

### 渐变（Gradients）

渐变可以是颜色数组或 `GradientStop` 数组，每个 `GradientStop` 包含一个颜色和一个从 0 到 1 的位置值，用于定义过渡位置。

**示例：**

```tsx
<HStack
  background={
    gradient([
      { color: 'red', location: 0 },
      { color: 'orange', location: 0.5 },
      { color: 'yellow', location: 1 }
    ])
  }
>
  {/* 内容 */}
</HStack>
```

### 线性渐变（LinearGradient）

线性渐变沿两点之间的直线进行颜色过渡。你可以指定颜色或渐变停点，以及起点和终点（可使用关键字如 `'top'`、`'bottom'`，或 `{x, y}` 格式的坐标）。

**示例：**

```tsx
<HStack
  background={
    gradient("linear", {
      colors: ['green', 'blue'],
      startPoint: 'top',
      endPoint: 'bottom'
    })
  }
>
  {/* 内容 */}
</HStack>
```

或使用渐变停点与自定义坐标：

```tsx
<HStack
  background={
    gradient("linear", {
      stops: [
        { color: 'green', location: 0 },
        { color: 'blue', location: 1 }
      ],
      startPoint: { x: 0.5, y: 0 },
      endPoint: { x: 0.5, y: 1 }
    })
  }
>
  {/* 内容 */}
</HStack>
```

### 径向渐变（RadialGradient）

径向渐变从一个中心点向外扩展，指定起始和结束半径。

**示例：**

```tsx
<HStack
  background={
    gradient("radial", {
      colors: ['red', 'yellow'],
      center: { x: 0.5, y: 0.5 },
      startRadius: 0,
      endRadius: 100
    })
  }
>
  {/* 内容 */}
</HStack>
```

### 角向渐变（AngularGradient）

角向渐变围绕中心点以角度变化生成颜色过渡，适合用于圆形进度条等效果。

#### 定义方式

```ts
type AngularGradient =
  | { stops: GradientStop[], center: KeywordPoint | Point, startAngle: Angle, endAngle: Angle }
  | { colors: Color[], center: KeywordPoint | Point, startAngle: Angle, endAngle: Angle }
  | { gradient: Gradient, center: KeywordPoint | Point, startAngle: Angle, endAngle: Angle }
  | { stops: GradientStop[], center: KeywordPoint | Point, angle: Angle }
  | { colors: Color[], center: KeywordPoint | Point, angle: Angle }
  | { gradient: Gradient, center: KeywordPoint | Point, angle: Angle }
```

#### 参数说明

- **`colors` 或 `stops`**：定义渐变的颜色或颜色停点。
- **`center`**：以哪个点为中心展开渐变，可用关键字或自定义点。
- **`startAngle` 与 `endAngle`**：渐变覆盖的角度范围。
- **`angle`**：用于简化表示完整角度变化。

#### 示例

```tsx
<Circle
  fill={gradient("angular", {
    colors: ["blue", "purple", "pink"],
    center: "center",
    startAngle: 0,
    endAngle: 360
  })}
/>
```

此示例为圆形应用一个从蓝到粉的角向渐变。

### 网格渐变（MeshGradient）（iOS 18.0+）

`MeshGradient` 是由控制点网格组成的二维渐变，能实现复杂细腻的动态颜色过渡。

#### 定义

```ts
type MeshGradient = {
  width: number
  height: number
  points: Point[]
  colors: Color[]
  background?: Color
  smoothsColors?: boolean
}
```

#### 参数说明

- **`width` 与 `height`**：控制点网格的宽度和高度。
- **`points`**：每个控制点的位置，数量需与 `width × height` 一致。
- **`colors`**：每个点的颜色，数量也需一致。
- **`background`**（可选）：网格外部的背景颜色，默认是透明。
- **`smoothsColors`**（可选）：是否启用平滑颜色插值，默认为 `true`。

> 注：仅支持 **iOS 18.0 及以上版本**

#### 示例

```tsx
<Rectangle
  fill={gradient("mesh", {
    width: 2,
    height: 2,
    points: [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: 1, y: 1 }
    ],
    colors: ["red", "yellow", "blue", "green"]
  })}
/>
```

这个示例定义了一个 2×2 网格，在四个控制点之间进行颜色过渡。

### `gradient()` 工具函数

`gradient()` 是一个辅助函数，用于使代码更具可读性和表达力，支持所有渐变类型。

#### 函数签名

```ts
function gradient(gradient: Gradient): Gradient
function gradient(type: "linear", gradient: LinearGradient): LinearGradient
function gradient(type: "radial", gradient: RadialGradient): RadialGradient
function gradient(type: "angular", gradient: AngularGradient): AngularGradient
function gradient(type: "mesh", gradient: MeshGradient): MeshGradient
```

#### 描述

- 单参数使用：`gradient(Gradient)` 返回原始渐变对象。
- 双参数使用：第一个参数为渐变类型，第二个为其配置项。

#### 示例

```tsx
<Text
  foregroundStyle={
    gradient("linear", {
      colors: ["red", "orange"],
      startPoint: "leading",
      endPoint: "trailing"
    })
  }
>
  Hello World!
</Text>
```

### ColorWithGradientOrOpacity

该类型以基础颜色为起点，可设置 `gradient: true` 来自动应用标准渐变，或通过 `opacity` 设置透明度。

**示例：**

```tsx
<HStack
  background={{
    color: 'blue',
    gradient: true,
    opacity: 0.8
  }}
>
  {/* 内容 */}
</HStack>
```

这将生成一个蓝色的标准渐变，并应用 80% 的不透明度。

## 总结

- 使用 **Material** 实现系统模糊效果。
- 使用 **Color** 进行纯色填充。
- 使用 **各种 Gradient 类型** 实现多色渐变过渡。
- 使用 **ColorWithGradientOrOpacity** 实现颜色透明度调整或标准渐变。

通过选择合适的 `ShapeStyle` 类型，可以轻松地为 UI 元素实现所需的视觉样式，无论是简单的纯色、动态的渐变，还是精致的材质效果。



---
url: /v2/zh/guide/Utilities/App Events.md
---

# App事件

Scripting 提供的 `AppEvents` 模块允许你监听应用程序级别的状态变化事件，例如生命周期（scene phase）变更以及系统外观（light/dark 模式）切换。这些功能非常适合用于构建对运行时环境具有感知能力的响应式脚本或组件。

***

## 场景生命周期

### `ScenePhase`

```ts
type ScenePhase = 'active' | 'inactive' | 'background'
```

表示 App 当前的生命周期状态：

- **`active`**：应用处于前台，正在交互。
- **`inactive`**：应用处于过渡状态，暂时不活跃（如切换页面、弹窗等）。
- **`background`**：应用已进入后台，不再显示在屏幕上。

***

## 颜色外观（Color Scheme）

### `ColorScheme`

```ts
type ColorScheme = 'light' | 'dark'
```

表示当前系统主题外观模式：

- **`light`**：浅色模式。
- **`dark`**：深色模式。

***

## `AppEventListenerManager<T>`

```ts
class AppEventListenerManager<T> {
  addListener(listener: (data: T) => void): void
  removeListener(listener: (data: T) => void): void
}
```

通用事件监听器管理类，用于注册和移除监听器。`scenePhase` 和 `colorScheme` 都基于该类实现。

***

## `AppEvents` 类

```ts
class AppEvents {
  static scenePhase: AppEventListenerManager<ScenePhase>
  static colorScheme: AppEventListenerManager<ColorScheme>
}
```

### `AppEvents.scenePhase`

监听应用生命周期状态的变化，例如进入后台或前台。

#### 示例：

```ts
AppEvents.scenePhase.addListener((phase) => {
  if (phase === 'active') {
    console.log("App 已激活")
  } else if (phase === 'background') {
    console.log("App 已进入后台")
  }
})
```

***

### `AppEvents.colorScheme`

监听系统外观模式的切换事件（浅色 / 深色）。

#### 示例：

```ts
AppEvents.colorScheme.addListener((scheme) => {
  console.log(`当前外观：${scheme}`)
})
```

***

## `useColorScheme()` 钩子函数

```ts
declare function useColorScheme(): ColorScheme
```

### 说明：

`useColorScheme()` 是一个响应式 Hook，用于在组件中实时获取当前的 `ColorScheme`（`'light'` 或 `'dark'`）。当用户更改系统主题时，返回值会自动更新。

### 示例：

```tsx
function ThemedView() {
  const colorScheme = useColorScheme()

  return <Text>
    {colorScheme === 'dark' ? '当前为深色模式' : '当前为浅色模式'}
  </Text>
}
```

***

## 使用说明

- 使用 `AppEvents.scenePhase` 和 `AppEvents.colorScheme` 可观察全局状态变化，适用于数据暂停/恢复、UI调整等。
- 使用 `useColorScheme()` 是在组件中获取并响应系统外观切换的推荐方式。
- 所有通过 `addListener` 注册的事件都应在不再需要时调用 `removeListener` 以避免内存泄漏。



---
url: /v2/zh/guide/Utilities/Archive.md
---

# Archive（归档）

`Archive` 类用于读取、创建与修改压缩归档文件（如 ZIP 格式）。
它支持以同步或异步的方式向归档中添加文件、目录或从归档中提取文件内容。

***

## 概述

`Archive` 提供了灵活的接口来管理压缩包内容，包括：

- 打开已有归档或创建新归档；
- 添加文件、目录或自定义数据；
- 支持异步与同步两种操作模式；
- 提取文件内容到内存或磁盘；
- 删除归档中的条目；
- 支持自定义压缩算法（如 `deflate`）；
- 可通过 `entries()` 获取归档中的所有条目信息。

***

## 静态方法

### `static openForMode(path: string, accessMode: "update" | "read", options?: { pathEncoding?: Encoding }): Archive`

打开一个归档文件。

**参数：**

| 参数名                    | 类型                   | 说明                                               |
| ---------------------- | -------------------- | ------------------------------------------------ |
| `path`                 | `string`             | 要打开的归档文件路径。                                      |
| `accessMode`           | `"update" \| "read"` | 访问模式： - `"read"`：以只读方式打开； - `"update"`：以可修改方式打开。 |
| `options.pathEncoding` | `Encoding`           | 可选，指定归档中文件路径的编码方式，默认为 `"utf-8"`。                 |

**返回值：**
返回一个 `Archive` 对象。

**示例：**

```ts
const archive = Archive.openForMode("/tmp/example.zip", "update")
```

***

## 属性

### `path: string`

归档文件的路径。

**示例：**

```ts
console.log(archive.path)
```

***

### `data: Data | null`

归档的二进制数据内容（如果以内存方式打开）。

***

## 实例方法

### `entries(pathEncoding?: Encoding): ArchiveEntry[]`

获取归档中所有条目的信息。

**参数：**
`pathEncoding` 可选，指定路径的编码方式，默认为 `"utf-8"`。

**返回值：**
返回一个 `ArchiveEntry` 对象的数组，包含所有条目的信息。

***

### `getEntryPaths(encoding?: Encoding): string[]`

获取归档中所有条目的路径。

**参数：**
`encoding` 可选，指定路径的编码方式，默认为 `"utf-8"`。

**返回值：**
返回一个字符串数组，包含所有条目的路径。

***

### `getEntry(path: string): ArchiveEntry | null`

获取归档中指定路径的条目。

**参数：**
`path` 要获取的条目的路径。

**返回值：**
返回一个 `ArchiveEntry` 对象，或 `null` 如果条目不存在。

***

### `contains(path: string): boolean`

判断归档中是否包含指定路径的条目。

**参数：**

`path` 要判断的条目的路径。

**返回值：**
`true` 表示存在，`false` 表示不存在。

**示例：**

```ts
if (archive.contains("README.md")) {
  console.log("Archive contains README.md")
}
```

***

### `addEntry(path: string, toPath: string, options?: { compressionMethod?: "deflate" | "none"; bufferSize?: number }): Promise<void>`

向归档中添加一个现有文件（异步）。

**参数：**

| 参数名                         | 类型          | 说明                      |                    |
| --------------------------- | ----------- | ----------------------- | ------------------ |
| `path`                      | `string`    | 源文件路径。                  |                    |
| `toPath`                    | `string`    | 添加到归档中的目标路径。            |                    |
| `options.compressionMethod` | `"deflate"` | `"none"`                | 压缩方式，默认为 `"none"`。 |
| `options.bufferSize`        | `number`    | 缓冲区大小，默认为 `16*1024` 字节。 |                    |

**示例：**

```ts
await archive.addEntry("/tmp/input.txt", "docs/input.txt", {
  compressionMethod: "deflate"
})
```

***

### `addEntrySync(path: string, toPath: string, options?)`

同步版本，与 `addEntry()` 功能相同。
若添加失败会抛出异常。

***

### `addFileEntry(path: string, uncompressedSize: number, provider: (offset: number, length: number) => Data, options?): Promise<void>`

通过数据提供函数添加文件到归档（异步）。

**参数：**

| 参数名                         | 类型                                         | 说明                           |                    |
| --------------------------- | ------------------------------------------ | ---------------------------- | ------------------ |
| `path`                      | `string`                                   | 要添加的归档路径（文件名）。               |                    |
| `uncompressedSize`          | `number`                                   | 文件未压缩时的大小。                   |                    |
| `provider`                  | `(offset: number, length: number) => Data` | 用于提供文件数据的函数，会被多次调用直到读取完所有数据。 |                    |
| `options.modificationDate`  | `Date`                                     | 修改时间（可选）。                    |                    |
| `options.compressionMethod` | `"deflate"`                                | `"none"`                     | 压缩方式（默认 `"none"`）。 |
| `options.bufferSize`        | `number`                                   | 缓冲区大小，默认 `16*1024` 字节。       |                    |

**示例：**

```ts
const data = Data.fromRawString("abcdefg".repeat(100))
await archive.addFileEntry("fromMemory.txt", data.count, (offset, length) => {
  return data.slice(offset, offset + length)
})
```

***

### `addFileEntrySync(...)`

同步版本，与上方异步方法功能一致。

***

### `addDirectoryEntry(path: string, options?): Promise<void>`

向归档中添加一个目录。

**参数：**

| 参数名                         | 类型          | 说明                   |                    |
| --------------------------- | ----------- | -------------------- | ------------------ |
| `path`                      | `string`    | 要添加的目录路径。            |                    |
| `options.modificationDate`  | `Date`      | 修改日期（可选）。            |                    |
| `options.compressionMethod` | `"deflate"` | `"none"`             | 压缩方式（默认 `"none"`）。 |
| `options.bufferSize`        | `number`    | 缓冲区大小（默认 `16*1024`）。 |                    |

**示例：**

```ts
await archive.addDirectoryEntry("images/")
```

***

### `addDirectoryEntrySync(...)`

同步版本，与 `addDirectoryEntry()` 功能相同。

***

### `removeEntry(path: string, options?): Promise<void>`

从归档中删除指定路径的条目（异步）。

**参数：**

| 参数名                  | 类型       | 说明                   |
| -------------------- | -------- | -------------------- |
| `path`               | `string` | 要删除的条目路径。            |
| `options.bufferSize` | `number` | 缓冲区大小（默认 `16*1024`）。 |

**示例：**

```ts
await archive.removeEntry("old/file.txt")
```

***

### `removeEntrySync(...)`

同步版本，与 `removeEntry()` 功能相同。

***

### `extract(path: string, consumer: (data: Data) => void, options?): Promise<void>`

从归档中提取指定文件，并将其数据通过回调函数分块返回（异步）。

**参数：**

| 参数名                  | 类型                     | 说明                   |
| -------------------- | ---------------------- | -------------------- |
| `path`               | `string`               | 要提取的文件路径。            |
| `consumer`           | `(data: Data) => void` | 数据消费函数，用于处理提取的数据块。   |
| `options.bufferSize` | `number`               | 缓冲区大小（默认 `16*1024`）。 |

**示例：**

```ts
await archive.extract("docs/manual.txt", (chunk) => {
  console.log("Received chunk:", chunk.count)
})
```

***

### `extractSync(...)`

同步版本，与 `extract()` 功能一致。

***

### `extractTo(path: string, to: string, options?): Promise<void>`

将归档中的文件或目录提取到指定磁盘路径（异步）。

**参数：**

| 参数名                                | 类型        | 说明                               |
| ---------------------------------- | --------- | -------------------------------- |
| `path`                             | `string`  | 归档内路径。                           |
| `to`                               | `string`  | 提取到的目标路径。                        |
| `options.bufferSize`               | `number`  | 缓冲区大小（默认 `16*1024`）。             |
| `options.allowUncontainedSymlinks` | `boolean` | 是否允许解压出不在目标目录内的符号链接（默认 `false`）。 |

**示例：**

```ts
await archive.extractTo("docs/", "/tmp/extracted/")
```

***

### `extractToSync(...)`

同步版本，与 `extractTo()` 功能一致。

***

## ArchiveEntry 类型

`ArchiveEntry` 表示归档中的一个条目（文件、目录或符号链接）。

| 属性                 | 类型                                                       | 说明                  |             |       |
| ------------------ | -------------------------------------------------------- | ------------------- | ----------- | ----- |
| `path`             | `string`                                                 | 条目的路径。              |             |       |
| `type`             | `"file"`                                                 | `"directory"`       | `"symlink"` | 条目类型。 |
| `isCompressed`     | `boolean`                                                | 是否为压缩状态。            |             |       |
| `compressedSize`   | `number`                                                 | 压缩后的大小（字节）。         |             |       |
| `uncompressedSize` | `number`                                                 | 原始未压缩大小（字节）。        |             |       |
| `fileAttributes`   | `{ posixPermissions?: number; modificationDate?: Date }` | 文件属性信息（时间戳、类型、大小等）。 |             |       |

**示例：**

```ts
for (const entry of archive.entries()) {
  console.log(`[${entry.type}] ${entry.path} (${entry.uncompressedSize} bytes)`)
}
```

***

## 综合示例

### 创建新压缩包并添加文件

```ts
const archive = Archive.openForMode("/tmp/example.zip", "update")

await archive.addEntry(
  "/tmp/hello.txt",
  "docs/hello.txt",
  { compressionMethod: "deflate" }
)

await archive.addDirectoryEntry("images/")
await archive.addEntry("/tmp/logo.png", "images/logo.png")

console.log("Archive entries:", archive.entries().length)
```

### 提取文件到本地目录

```ts
const archive = Archive.openForMode("/tmp/example.zip", "read")
await archive.extractTo("docs/hello.txt", "/tmp/unpacked/hello.txt")
```



---
url: /v2/zh/guide/Utilities/Crypto.md
---

# 加密

`Crypto` 模块提供了一组加密工具函数，用于数据哈希、HMAC 认证、对称密钥生成，以及 AES-GCM 加解密。该模块支持标准的加密算法，配合 `Data` 类型使用，适用于各种安全处理场景。

***

## 模块概览

`Crypto` 模块支持：

- 使用 MD5、SHA-1、SHA-2 系列算法进行哈希
- 基于密钥的 HMAC 消息认证
- 生成对称密钥（用于加密和 HMAC）
- 使用 AES-GCM 算法进行加密与解密

所有函数的输入与输出均为 `Data` 类型，代表二进制数据。

***

## 函数说明

### `Crypto.generateSymmetricKey(size?: number): Data`

生成一个随机对称密钥。

- **参数：**

  - `size`（可选）：密钥位数，默认是 256 位（即 32 字节）

- **返回值：** 返回一个 `Data` 实例，包含生成的密钥

- **示例：**

  ```ts
  const key = Crypto.generateSymmetricKey() // 默认生成 256 位密钥
  ```

***

## 哈希函数（Hash Functions）

以下函数用于对输入数据进行不可逆哈希，常用于签名或内容校验。

### `Crypto.md5(data: Data): Data`

使用 MD5 算法生成摘要（128 位）。

- **返回值：** 包含 MD5 哈希值的 `Data` 实例

- **示例：**

  ```ts
  const data = Data.fromString("Hello")
  const hash = Crypto.md5(data).toHexString()
  ```

***

### `Crypto.sha1(data: Data): Data`

使用 SHA-1 算法生成摘要（160 位）。

***

### `Crypto.sha256(data: Data): Data`

使用 SHA-256 算法生成摘要（256 位）。

- **示例：**

  ```ts
  const hash = Crypto.sha256(Data.fromString("test")).toHexString()
  ```

***

### `Crypto.sha384(data: Data): Data`

使用 SHA-384 算法生成摘要（384 位）。

***

### `Crypto.sha512(data: Data): Data`

使用 SHA-512 算法生成摘要（512 位）。

***

## HMAC 函数（带密钥的哈希）

以下函数使用密钥对消息进行哈希认证（HMAC），常用于消息完整性校验与身份验证。

- **参数：**

  - `data`: 要加密的消息（`Data`）
  - `key`: 对称密钥（`Data`）

- **返回值：** HMAC 结果为 `Data` 类型

***

### `Crypto.hmacMD5(data: Data, key: Data): Data`

使用 MD5 生成 HMAC。

```ts
const key = Crypto.generateSymmetricKey()
const hmac = Crypto.hmacMD5(Data.fromString("msg"), key).toHexString()
```

***

### `Crypto.hmacSHA1(data: Data, key: Data): Data`

使用 SHA-1 生成 HMAC。

***

### `Crypto.hmacSHA224(data: Data, key: Data): Data`

使用 SHA-224 生成 HMAC。

***

### `Crypto.hmacSHA256(data: Data, key: Data): Data`

使用 SHA-256 生成 HMAC。

***

### `Crypto.hmacSHA384(data: Data, key: Data): Data`

使用 SHA-384 生成 HMAC。

***

### `Crypto.hmacSHA512(data: Data, key: Data): Data`

使用 SHA-512 生成 HMAC。

***

## AES-GCM 加密与解密

### `Crypto.encryptAESGCM(data: Data, key: Data, options?: { iv?: Data, aad?: Data }): Data | null`

使用 AES-GCM 算法对数据进行加密。

- **参数：**

  - `data`: 明文数据（`Data`）
  - `key`: 对称密钥（`Data`）
  - `options`（可选）：

    - `iv`: 初始化向量（`Data`）。如果不指定，将自动生成随机 IV。
    - `aad`: 附加认证数据，不参与加密，但会影响认证标签（可选）

- **返回值：** 加密后的 `Data`，失败时返回 `null`

- **示例：**

  ```ts
  const key = Crypto.generateSymmetricKey()
  const plaintext = Data.fromString("secret message")
  const encrypted = Crypto.encryptAESGCM(plaintext, key)
  ```

***

### `Crypto.decryptAESGCM(data: Data, key: Data, aad?: Data): Data | null`

使用 AES-GCM 解密密文数据。

- **参数：**

  - `data`: 密文数据（`Data`）
  - `key`: 加密时使用的对称密钥（`Data`）
  - `aad`: 加密时使用的附加认证数据（若有）

- **返回值：** 解密后的明文 `Data`，如果解密失败（如认证标签不匹配、密钥错误），返回 `null`

- **示例：**

  ```ts
  const decrypted = Crypto.decryptAESGCM(encrypted, key)
  console.log(decrypted?.toRawString())
  ```

***

## 常见算法摘要

| 函数        | 输出长度  | 用途说明      |
| --------- | ----- | --------- |
| `md5`     | 128 位 | 旧版校验      |
| `sha1`    | 160 位 | 兼容场景      |
| `sha256`  | 256 位 | 推荐的通用加密哈希 |
| `sha384`  | 384 位 | 更强的哈希     |
| `sha512`  | 512 位 | 高安全性需求    |
| `hmacXXX` | 同哈希   | 消息认证      |
| `AES-GCM` | 可变    | 加密+认证     |

***

## 完整示例：加密与解密一段字符串

```ts
const key = Crypto.generateSymmetricKey()
const message = Data.fromString("Encrypt me")
const encrypted = Crypto.encryptAESGCM(message, key)
const decrypted = encrypted ? Crypto.decryptAESGCM(encrypted, key) : null

if (decrypted) {
  console.log("解密结果:", decrypted.toRawString())
}
```

***

## 说明与注意事项

- 所有函数都要求输入为 `Data` 类型
- AES-GCM 支持自动生成随机 IV，也支持传入自定义 IV 和 AAD
- 返回的加密结果包含密文和认证标签，必要时还应保存 IV



---
url: /v2/zh/guide/Utilities/Data.md
---

# 二进制数据（Data）

`Data` 类用于表示二进制数据，提供多种方法用于数据的创建、转换、压缩、解压、拼接、读取等操作。可用于处理图像、文件、音频、编码数据等各种原始字节数据。

***

## CompressionAlgorithm（压缩算法枚举）

该枚举用于指定 `Data` 的压缩或解压算法：

| 枚举值     | 描述                    |
| ------- | --------------------- |
| `lzfse` | LZFSE 压缩算法，快速且高效。     |
| `lz4`   | LZ4 压缩算法，压缩和解压速度极快。   |
| `lzma`  | LZMA 算法，压缩率高，压缩速度较慢。  |
| `zlib`  | Zlib 算法，通用且广泛支持的压缩格式。 |

***

## 实例属性与方法

### `size: number`

当前数据的字节长度（只读属性）。

***

### `resetBytes(startIndex: number, endIndex: number): void`

将数据中指定范围内的字节清零。

- `startIndex`：起始索引（包含）
- `endIndex`：结束索引（不包含）

若索引超出范围将抛出异常。

***

### `advanced(amount: number): Data`

返回一个新的 `Data` 实例，去除前 `amount` 个字节。

***

### `replaceSubrange(startIndex, endIndex, data): void`

将当前数据中指定范围的字节替换为另一个 `Data` 实例的数据。

***

### `compressed(algorithm: CompressionAlgorithm): Data`

使用指定的压缩算法压缩当前数据，返回压缩后的新 `Data` 实例。

如果数据为空或无法压缩将抛出异常。

***

### `decompressed(algorithm: CompressionAlgorithm): Data`

使用指定的算法对当前数据进行解压，返回解压后的 `Data` 实例。

压缩与解压时使用的算法必须一致。

***

### `slice(start?: number, end?: number): Data`

返回数据的子集片段，形成新的 `Data` 实例。

- `start`：起始索引（默认 0）
- `end`：结束索引（默认到末尾）

***

### `append(other: Data): void`

将另一个 `Data` 实例的数据追加到当前数据末尾。

***

### `getBytes(): Uint8Array | null`（已废弃）

请改用 `toUint8Array()`。

***

### `toUint8Array(): Uint8Array | null`

将数据转换为 `Uint8Array`。

***

### `toArrayBuffer(): ArrayBuffer`

将数据转换为 `ArrayBuffer`。

***

### `toBase64String(): string`

将数据编码为 Base64 字符串。

***

### `toHexString(): string`

将数据编码为十六进制字符串。

***

### `toRawString(encoding?: string): string | null`

将数据转换为字符串，支持指定编码（默认 `"utf-8"`），严格解码，无法解码的字符将返回 `null`。

***

### `toDecodedString(encoding?: "utf8" | "ascii"): string`

将数据转换为字符串，支持指定编码（默认 `"utf-8"`）, 宽松解码，会将无法解码的字符替换为 `?`。

***

### `toIntArray(): number[]`

将数据转换为由整数表示的字节数组。

***

## 静态方法

### `Data.fromIntArray(array: number[]): Data`

从整数数组创建 `Data` 实例。

***

### `Data.fromString(str: string, encoding?: string): Data | null`（已废弃）

请使用 `Data.fromRawString()` 代替。

***

### `Data.fromRawString(str: string, encoding?: string): Data | null`

从字符串创建 `Data` 实例，支持指定编码（默认 `"utf-8"`）。

***

### `Data.fromFile(filePath: string): Data | null`

从本地文件路径读取数据，返回 `Data` 实例。

***

### `Data.fromArrayBuffer(buffer: ArrayBuffer): Data | null`

从 `ArrayBuffer` 创建 `Data` 实例。

***

### `Data.fromUint8Array(bytes: Uint8Array): Data | null`

从 `Uint8Array` 创建 `Data` 实例。

***

### `Data.fromBase64String(base64: string): Data | null`

从 Base64 编码字符串创建 `Data` 实例。

***

### `Data.fromHexString(hex: string): Data | null`

从十六进制字符串创建 `Data` 实例。

***

### `Data.fromJPEG(image: UIImage, compressionQuality?: number): Data | null`

将图像转为 JPEG 格式的 `Data` 实例。

- `compressionQuality`：JPEG 压缩质量，范围 0.0 \~ 1.0，默认值为 1.0（最高质量）

***

### `Data.fromPNG(image: UIImage): Data | null`

将图像转为 PNG 格式的 `Data` 实例。

***

### `Data.combine(dataList: Data[]): Data`

将多个 `Data` 实例合并为一个新实例。

如果列表为空或所有数据为空，则返回空数据。



---
url: /v2/zh/guide/Utilities/DateComponents.md
---

# 日期组件

`DateComponents` 类提供了一种灵活的方式，用于表示和操作日期与时间的各个组成部分，例如年、月、日、小时、分钟、秒等。该类基于 Swift 的 `DateComponents` 实现，并与系统当前日历协同工作。

***

## 构造函数

```ts
new DateComponents(options?)
```

### 参数

构造函数可接收一个可选的 `options` 对象，用于初始化各个日期字段：

```ts
const components = new DateComponents({
  year: 2025,
  month: 6,
  day: 24,
  hour: 9,
  minute: 30
})
```

***

## 静态方法

### `DateComponents.fromDate(date: Date): DateComponents`

从给定的 `Date` 对象中提取所有可用的日期组成部分（年、月、日、小时、分钟、秒、纳秒），返回一个新的 `DateComponents` 实例。

#### 参数

- `date` (`Date`)：需要提取信息的日期对象。

#### 返回

- 包含该日期对应的组成部分的 `DateComponents` 实例。

#### 示例

```ts
const now = new Date()
const components = DateComponents.fromDate(now)
console.log(components.year, components.month)
```

***

### `DateComponents.forHourly(date: Date): DateComponents`

为“每小时重复”的需求创建一个日期组件，仅设置 `minute` 字段。

- 设置字段：`minute`

#### 示例

```ts
const components = DateComponents.forHourly(new Date())
// 每小时的指定分钟触发
```

***

### `DateComponents.forDaily(date: Date): DateComponents`

为“每天重复”的需求创建一个日期组件，设置 `hour` 和 `minute` 字段。

- 设置字段：`hour`, `minute`

#### 示例

```ts
const components = DateComponents.forDaily(new Date())
// 每天的同一时间触发
```

***

### `DateComponents.forWeekly(date: Date): DateComponents`

为“每周重复”的需求创建一个日期组件，设置 `weekday`、`hour`、`minute` 字段。

- 设置字段：`weekday`, `hour`, `minute`

#### 示例

```ts
const components = DateComponents.forWeekly(new Date())
// 每周的相同星期几和时间触发
```

***

### `DateComponents.forMonthly(date: Date): DateComponents`

为“每月重复”的需求创建一个日期组件，设置 `day`、`hour`、`minute` 字段。

- 设置字段：`day`, `hour`, `minute`

#### 示例

```ts
const components = DateComponents.forMonthly(new Date())
// 每月的相同日期和时间触发
```

***

## 属性说明

### 只读属性

- **`date?: Date | null`**
  使用当前组件通过系统日历计算得出的 `Date` 对象。如果无效则为 `null`。

- **`isValidDate: boolean`**
  当前组件组合是否构成一个有效日期。

***

### 可设置的字段

以下所有字段均为可选，可设为 `number` 或 `null`：

- `era`：纪元

- `year`：年份

- `yearForWeekOfYear`：与周数关联的年份

- `quarter`：季度（1 到 4）

- `month`：月份（1 到 12）

- `isLeapMonth`：是否为闰月（布尔值）

- `weekOfMonth`：当前月份中的第几周

- `weekOfYear`：当前年份中的第几周

- `weekday`：星期几（1 = 星期日，2 = 星期一，…，7 = 星期六）

- `weekdayOrdinal`：某星期几在当前月中第几次出现

  #### 示例

  ```ts
  const c = new DateComponents()
  c.weekday = 2           // 星期一
  c.weekdayOrdinal = 1    // 本月的第一个星期一
  ```

- `day`：每月中的某一天

- `hour`：小时（0 到 23）

- `minute`：分钟（0 到 59）

- `second`：秒（0 到 59）

- `nanosecond`：纳秒（0 到 999,999,999）

- `dayOfYear`：一年中的第几天（1 到 366）

***

## 使用示例

```ts
const components = new DateComponents({
  year: 2025,
  month: 12,
  day: 25,
  hour: 10,
  minute: 0
})

if (components.isValidDate) {
  console.log("有效日期:", components.date)
}
```

```ts
const daily = DateComponents.forDaily(new Date())
const weekly = DateComponents.forWeekly(new Date())
```

***

## 注意事项

- `date` 和 `isValidDate` 的计算依赖系统当前的日历设置。
- 若未设置足够字段，可能无法构成一个有效日期。
- 推荐使用 `forHourly`、`forDaily`、`forWeekly`、`forMonthly` 方法快速创建周期性日期组件，适用于通知调度、事件提醒等场景。



---
url: /v2/zh/guide/Utilities/DateFormatter.md
---

`DateFormatter` 类用于将 `Date` 类型格式化为字符串，或将字符串解析为 `Date`。
该类封装了 iOS 的 `DateFormatter` 能力，适用于格式化日期、时间、本地化展示、农历日期展示（通过切换日历）、相对日期显示等场景。

***

# 枚举与类型定义

## DateFormatterStyle

用于指定日期或时间的格式化级别。

| 枚举值      | 含义                                |
| -------- | --------------------------------- |
| `none`   | 不显示日期或时间                          |
| `short`  | 短格式，例如 `12/1/25`、`3:20 PM`        |
| `medium` | 中等格式，例如 `Dec 1, 2025`             |
| `long`   | 长格式，例如 `December 1, 2025`         |
| `full`   | 全格式，例如 `Monday, December 1, 2025` |

***

## DateFormatterBehavior

指定格式化器的行为模式。

| 枚举值            | 含义                 |
| -------------- | ------------------ |
| `default`      | 系统默认行为             |
| `behavior10_4` | 兼容旧系统格式化行为（通常无需使用） |

***

## CalendarIdentifier

指定 `DateFormatter` 使用的历法类型。可用于格式化如：

- 公历（gregorian）
- 农历（chinese）
- 佛历（buddhist）
- 日本历（japanese）
- 伊斯兰历（islamic）
  等。

可选值示例：

```
"current" | "gregorian" | "chinese" | "japanese" | "islamic" | "iso8601" | ...
```

其中：

- `"current"` 代表当前系统日历
- `"autoupdatingCurrent"` 表示系统日历变更后自动更新

***

## TimeZoneIdentifier

指定时区。

可选值：

```
"current" | "autoupdatingCurrent" | "gmt" | string
```

当传入普通字符串时，可以使用任意合法时区 ID，例如：

- `"Asia/Shanghai"`
- `"America/Los_Angeles"`
- `"UTC"`

***

# 类：DateFormatter

## 初始化

### `new(): DateFormatter`

创建一个新的日期格式器实例。

***

# 静态方法

## `DateFormatter.localizedString(date, options)`

根据指定的日期格式与时间格式返回本地化后的字符串。

```ts
DateFormatter.localizedString(date: Date, options: {
  dateStyle: DateFormatterStyle
  timeStyle: DateFormatterStyle
}): string
```

适用于快速格式化，无需手动设置 formatter 属性。

***

## `DateFormatter.dateFormat(template, locale?)`

根据日期模板生成本地化后的格式化字符串。

```
static dateFormat(template: string, locale?: string): string | null
```

示例模板：`"yyyyMMdd"`, `"MMM d"`, `"HH:mm"`

如果传入 locale，则按指定语言区域生成；否则使用系统 locale。

***

# 实例方法

## `string(date: Date): string`

将 Date 转换为格式化字符串。

注意：如果设置了 `dateFormat`，则优先使用自定义格式；
否则根据 `dateStyle` 和 `timeStyle` 自动格式化。

***

## `date(string: string): Date | null`

将字符串解析为 Date。
解析能力依赖于当前 dateFormat、locale、calendar 等属性。

***

## `setLocalizedDateFormatFromTemplate(template: string): void`

根据模板生成本地化格式，并自动设置到 `dateFormat` 属性中。

***

# 属性说明

以下为所有可配置属性的功能说明。

## 日期与时间格式属性

### `calendar: CalendarIdentifier`

选择日期格式化使用的历法，如公历、农历、佛历等。

***

### `timeZone: TimeZoneIdentifier`

设置时区，例如 `"Asia/Shanghai"`。

***

### `locale: string`

指定区域语言，例如：

- `"zh_CN"`
- `"en_US"`
- `"ja_JP"`

***

### `dateFormat: string`

手动指定格式化模板。例如：

```
"yyyy-MM-dd HH:mm"
"MMM d, yyyy"
"EEEE"
```

如果设置该属性，则忽略 `dateStyle` 和 `timeStyle`。

***

### `dateStyle/timeStyle: DateFormatterStyle`

分别控制日期和时间格式级别。

***

## 行为属性

### `generatesCalendarDates: boolean`

是否生成历法日期，一般保持默认即可。

***

### `formatterBehavior: DateFormatterBehavior`

控制格式器行为，通常使用默认值。

***

### `isLenient: boolean`

是否宽松解析输入，例如解析模糊格式字符串。
一般保持 `false`，避免误解析。

***

### `twoDigitStartDate: Date | null`

设置双位数年份的起始范围。用于解析如 `"20"` 这样的年份值。

***

### `defaultDate: Date | null`

解析字符串无法获得时间时，使用的默认日期。

***

## 本地化符号与文案属性

以下属性用于自定义本地化符号，如月份名称、星期名称等。
这些属性通常无需手动设置，除非需要覆盖本地化字符串。

举例属性：

- `eraSymbols`
- `monthSymbols`
- `shortMonthSymbols`
- `weekdaySymbols`
- `shortWeekdaySymbols`
- `standaloneMonthSymbols`
- `amSymbol`
- `pmSymbol`
- `quarterSymbols`
- `standaloneQuarterSymbols`
- `veryShortWeekdaySymbols`
- `gregorianStartDate`

这些属性主要作用于需要深度定制本地化展示的场景。

***

## `doesRelativeDateFormatting: boolean`

启用相对日期格式化，例如：

- Today
- Yesterday
- Tomorrow

在中文环境中可显示为：

- 今天
- 昨天
- 明天

通常与 `dateStyle = .medium` 等组合使用。

***

# 示例代码

以下示例展示如何使用 `DateFormatter` 进行多种日期格式化场景。

***

## 示例一：使用 dateStyle 和 timeStyle 进行本地化格式化

```tsx
import { DateFormatter } from "scripting"

const df = new DateFormatter()
df.locale = "zh_CN"
df.dateStyle = DateFormatterStyle.full
df.timeStyle = DateFormatterStyle.short

const result = df.string(new Date())
// 输出示例： "2025年12月12日 星期五 下午3:20"
```

***

## 示例二：自定义日期格式模板

```tsx
const df = new DateFormatter()
df.locale = "en_US"
df.dateFormat = "yyyy-MM-dd HH:mm"

df.timeZone = "Asia/Shanghai"

const str = df.string(new Date())
// 输出示例： "2025-12-12 15:20"
```

***

## 示例三：使用农历格式化（chinese calendar）

```tsx
const df = new DateFormatter()

df.calendar = "chinese"
df.locale = "zh_CN"
df.dateFormat = "yyyy年MM月dd日 EEEE"

const lunar = df.string(new Date())
// 输出示例： "四十三年十月廿二日 星期五"
```

***

## 示例四：解析字符串为日期

```tsx
const df = new DateFormatter()
df.dateFormat = "yyyy/MM/dd HH:mm"

const date = df.date("2025/12/12 08:00")
```

***

## 示例五：使用模板生成本地化格式

```tsx
const df = new DateFormatter()
df.locale = "zh_CN"

// 自动设置为符合中文习惯的格式，例如 "12月12日"
df.setLocalizedDateFormatFromTemplate("MMdd")

const str = df.string(new Date())
```

***

## 示例六：使用静态快速格式化

```tsx
const str = DateFormatter.localizedString(new Date(), {
  dateStyle: DateFormatterStyle.medium,
  timeStyle: DateFormatterStyle.short
})
```



---
url: /v2/zh/guide/Utilities/Encoding.md
---

# 编码

`Encoding` 类型定义了可用于文本与二进制数据之间转换的字符编码集。
常用于以下方法：

- `Data.fromRawString(str, encoding)` — 使用指定编码将字符串转换为二进制数据。
- `Data.toRawString(encoding)` — 使用指定编码将二进制数据解码为字符串。

通过这些编码类型，可以在不同系统、语言和文件格式之间正确地读写文本内容。

***

## 可用编码列表

| 编码名称                    | 说明                                                                       |
| ----------------------- | ------------------------------------------------------------------------ |
| **"utf-8" / "utf8"**    | UTF-8（8位 Unicode 转换格式）。目前最常用的文本编码方式，与 ASCII 兼容，几乎支持所有语言字符。               |
| **"utf-16" / "utf16"**  | UTF-16（16位 Unicode 转换格式），广泛用于 Windows 和 Apple 系统，每个字符通常占 2 个字节。          |
| **"utf-32" / "utf32"**  | UTF-32（32位 Unicode 转换格式），每个字符固定使用 4 个字节，适合直接处理 Unicode 码点。               |
| **"ascii"**             | 美国信息交换标准码（ASCII），仅包含英文字母、数字及基础符号（0–127），为最早的文本编码标准。                      |
| **"iso2022JP"**         | ISO-2022-JP，日本语编码格式，常用于电子邮件或旧系统中，支持 JIS X 0201/0208 字符集。                 |
| **"isoLatin1"**         | ISO-8859-1（Latin-1），覆盖西欧语言，如英语、法语、德语、西班牙语等。                              |
| **"japaneseEUC"**       | EUC-JP（扩展 Unix 编码），另一种日本语编码方式，主要用于 Unix 系统。                              |
| **"macOSRoman"**        | MacRoman 编码，早期 Mac OS 系统使用的本地编码格式，现已较少使用。                                |
| **"nextstep"**          | NeXTSTEP 系统使用的旧编码格式，属于历史遗留类型。                                            |
| **"nonLossyASCII"**     | 无损 ASCII 编码。通过转义序列将任意 Unicode 字符安全地表示为 ASCII，并可无损还原。                     |
| **"shiftJIS"**          | Shift-JIS，日本语编码格式，Windows 日本系统中广泛使用。                                     |
| **"symbol"**            | Symbol 字体编码，用于符号类字体（如数学符号、特殊字符）。                                         |
| **"unicode"**           | Unicode 编码的通用别名（通常等同于 UTF-16）。                                           |
| **"utf16BigEndian"**    | UTF-16 大端序编码（高位字节在前）。                                                    |
| **"utf16LittleEndian"** | UTF-16 小端序编码（低位字节在前）。                                                    |
| **"utf32BigEndian"**    | UTF-32 大端序编码。                                                            |
| **"utf32LittleEndian"** | UTF-32 小端序编码。                                                            |
| **"windowsCP1250"**     | Windows 代码页 1250，用于中欧和东欧语言（如波兰语、捷克语、匈牙利语）。                               |
| **"windowsCP1251"**     | Windows 代码页 1251，用于西里尔文字（如俄语、保加利亚语、塞尔维亚语）。                               |
| **"windowsCP1252"**     | Windows 代码页 1252，用于西欧语言，与 Latin-1 相似，但包含更多符号。                            |
| **"windowsCP1253"**     | Windows 代码页 1253，用于希腊语。                                                  |
| **"windowsCP1254"**     | Windows 代码页 1254，用于土耳其语。                                                 |
| **"gbk"**               | GBK（国家标准扩展码），是简体中文常用的字符编码，向下兼容 GB2312，并扩展了繁体字和日文假名，主要用于中国大陆的 Windows 系统。 |
| **"gb18030"**           | GB18030 是中国国家标准编码，兼容 GBK 和 GB2312，支持完整 Unicode 字符集，是目前中国大陆的强制性编码标准。      |

***

## 示例

### 示例一：UTF-8 编码与解码

```ts
import { Data } from 'scripting'

// 使用 UTF-8 将字符串转换为二进制数据
const text = "こんにちは世界" // 日语“你好，世界”
const utf8Data = Data.fromRawString(text, "utf-8")

// 使用 UTF-8 解码回字符串
const decoded = utf8Data.toRawString("utf-8")

console.log(decoded) // 输出: こんにちは世界
```

***

### 示例二：使用 Shift-JIS 编码

```ts
// 使用 Shift-JIS 编码（日本常用编码）
const sjisData = Data.fromRawString("テスト", "shiftJIS")

// 解码回字符串
const decodedSJIS = sjisData.toRawString("shiftJIS")
console.log(decodedSJIS) // 输出: テスト
```

***

### 示例三：Windows 代码页示例

```ts
// 使用中欧字符示例
const text = "Příliš žluťoučký kůň úpěl ďábelské ódy"
const data = Data.fromRawString(text, "windowsCP1250")
const result = data.toRawString("windowsCP1250")
console.log(result)
```

***

## 注意事项

- 若使用了错误的编码进行解码，字符串中可能出现乱码或替代符号（如 “�”）。
- 推荐默认使用 `"utf-8"`，它是最通用、最兼容的编码格式。
- 旧式编码（如 `"shiftJIS"`、`"iso2022JP"`、`"windowsCP125x"`）主要用于与旧文件或系统兼容的场景。
- 在处理网络数据或文件存储时，确保读写双方使用相同的编码格式，避免出现文字乱码。



---
url: /v2/zh/guide/Utilities/FileEntity.md
---

# FileEntity

`FileEntity` 类提供了文件级的读写操作接口，用于在 `HttpServer` 或其他脚本环境中直接读取、写入、定位和关闭文件。
它支持以多种模式（只读、只写、读写、追加等）打开文件，并能配合 `HttpResponse` 直接返回文件内容给客户端。

***

## 概述

`FileEntity` 允许你在脚本中对文件执行以下操作：

- 打开文件进行读取、写入或读写；
- 按偏移量定位文件读取位置；
- 从文件中读取或写入指定大小的数据；
- 在使用完成后关闭文件；
- 支持以二进制流方式处理文件内容；
- 可直接作为 `HttpResponse.raw()` 的响应体返回。

***

## 实例属性

### `path: string`

文件路径（只读属性），表示该 `FileEntity` 对应的本地文件路径。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/file.txt")
console.log(file.path)
// 输出: "/path/to/file.txt"
```

***

## 实例方法

### `seek(offset: number): boolean`

移动文件指针到指定的偏移位置。
偏移量以字节为单位，返回值表示是否定位成功。

**参数：**

| 参数名      | 类型       | 说明          |
| -------- | -------- | ----------- |
| `offset` | `number` | 要移动到的字节偏移量。 |

**返回值：**

- `true`：定位成功；
- `false`：定位失败。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/data.bin")
file.seek(128)
```

***

### `read(size: number): Data`

从当前文件指针位置开始读取指定字节数的数据。
读取到的内容以 `Data` 对象返回。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `size` | `number` | 要读取的字节数量。 |

**返回值：**

- `Data`：包含所读取的文件数据。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/text.txt")
const data = file.read(100)
console.log(data.toRawString("utf-8"))
file.close()
```

***

### `write(data: Data): void`

将指定的 `Data` 写入到文件的当前位置。

**参数：**

| 参数名    | 类型     | 说明          |
| ------ | ------ | ----------- |
| `data` | `Data` | 要写入文件的数据对象。 |

**异常：**
如果文件未以写模式打开或写入失败，将抛出异常。

**示例：**

```ts
const data = Data.fromRawString("Hello, Scripting!", "utf-8")
const file = FileEntity.openNewForWriting("/tmp/test.txt")
file.write(data)
file.close()
```

***

### `close(): void`

关闭文件并释放资源。
关闭后不应再调用 `read()` 或 `write()`。

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/file.txt")
// ...进行读取操作...
file.close()
```

***

## 静态方法

### `static openForReading(path: string): FileEntity`

以只读模式打开文件。
如果文件不存在或无法读取，将抛出异常。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `path` | `string` | 要打开的文件路径。 |

**示例：**

```ts
const file = FileEntity.openForReading("/path/to/image.png")
```

***

### `static openNewForWriting(path: string): FileEntity`

以写入模式打开文件，若文件已存在会被覆盖。
适合用于创建新文件或清空原文件内容。

**示例：**

```ts
const file = FileEntity.openNewForWriting("/tmp/output.txt")
file.write(Data.fromRawString("New file created"))
file.close()
```

***

### `static openForMode(path: string, mode: string): FileEntity`

以指定模式打开文件。
支持的模式遵循标准 POSIX 文件模式，但建议使用带有二进制标志的形式（例如 `"rb"`, `"r+b"`），以确保跨平台兼容性，因为该接口底层以二进制方式读写文件。

**参数：**

| 模式               | 说明                                          |
| ---------------- | ------------------------------------------- |
| `"r"` / `"rb"`   | 以只读方式打开文件（文件必须存在）。推荐使用 `"rb"`，兼容性更好。        |
| `"w"` / `"wb"`   | 以只写方式打开文件（文件存在则清空，不存在则创建）。推荐使用 `"wb"`。      |
| `"a"` / `"ab"`   | 以追加写入模式打开文件（写入内容将添加到末尾，不存在则创建）。推荐使用 `"ab"`。 |
| `"r+"` / `"r+b"` | 以读写模式打开文件（文件必须存在）。推荐使用 `"r+b"`，支持二进制读写。     |
| `"w+"` / `"w+b"` | 以读写模式打开文件（文件存在则清空，不存在则创建）。推荐使用 `"w+b"`。     |
| `"a+"` / `"a+b"` | 以读写追加模式打开文件（文件不存在则创建）。推荐使用 `"a+b"`。         |

> 💡 **建议：**
> 优先使用带 `b` 后缀的模式（如 `"rb"`, `"r+b"` 等），因为 `FileEntity` 的底层接口以二进制流方式处理数据，这样可避免在不同平台上出现编码或换行符差异问题。

**示例：**

```ts
// 以二进制读写模式打开文件（推荐）
const file = FileEntity.openForMode("/tmp/log.bin", "r+b")

// 写入二进制内容
file.write(Data.fromRawString("append log\n"))

// 定位到文件开头并读取数据
file.seek(0)
const content = file.read(20).toRawString("utf-8")
console.log(content)

file.close()
```

***

## 在 HttpResponse 中使用文件

`FileEntity` 可直接作为 `HttpResponse.raw()` 的响应体，实现文件下载或静态内容响应。

**示例：**

```ts
server.registerHandler("/download", (req) => {
  const file = FileEntity.openForReading(Path.join(Script.directory, "manual.pdf"))
  return HttpResponse.raw(200, "OK", {
    headers: { "Content-Type": "application/pdf" },
    body: file
  })
})
```

客户端访问 `/download` 时将直接下载该文件。

***

## 总结

| 方法                           | 功能            | 使用场景       |
| ---------------------------- | ------------- | ---------- |
| `seek()`                     | 定位文件读取/写入位置   | 分段读取或随机访问  |
| `read()`                     | 从文件中读取数据      | 读取文本或二进制内容 |
| `write()`                    | 写入数据到文件       | 保存日志、导出文件  |
| `close()`                    | 关闭文件          | 释放资源       |
| `openForReading()`           | 以只读方式打开文件     | 读取静态资源     |
| `openNewForWriting()`        | 以写入模式打开文件（覆盖） | 创建新文件      |
| `openForWritingAndReading()` | 以读写模式打开文件     | 文件编辑或流式传输  |
| `openForMode()`              | 以自定义模式打开文件    | 兼容多种操作方式   |



---
url: /v2/zh/guide/Utilities/FileManager.md
---

# 文件管理器

FileManager 模块提供对文件系统的统一访问接口，是脚本与本地文件及 iCloud 文件交互的主要方式。它支持对目录与文件进行读取、写入、拷贝、移动、删除、压缩、解压、符号链接操作，以及 iCloud 文件管理等功能。

***

## 基本属性

### `FileManager.scriptsDirectory: string`

存放脚本文件的目录路径。开发者编写的脚本会存储在该目录中。

### `FileManager.isiCloudEnabled: boolean`

用于判断 iCloud 是否可用。若当前设备未登录 iCloud，或未授权 Scripting 使用 iCloud，该属性返回 `false`。

### `FileManager.iCloudDocumentsDirectory: string`

返回 iCloud 的 `Documents` 目录路径。若 iCloud 未启用，调用该属性会抛出错误。使用前应检查 `FileManager.isiCloudEnabled`。

### `FileManager.appGroupDocumentsDirectory: string`

返回 App Group 的共享 Documents 目录路径。存储于该目录的文件不会显示在系统的“文件”应用中，但 Widget 中运行的脚本可访问这些文件。

### `FileManager.documentsDirectory: string`

返回本地的 `Documents` 目录路径。存储于该目录的文件可在“文件”应用中查看，但 Widget 不可访问。

### `FileManager.temporaryDirectory: string`

返回临时目录路径，用于创建临时文件。系统可能在适当时机自动清除该目录内容。

***

## iCloud 文件管理

### `FileManager.isFileStoredIniCloud(filePath: string): boolean`

判断指定文件是否为存储于 iCloud 的文件。

| 参数       | 类型     | 说明   |
| -------- | ------ | ---- |
| filePath | string | 文件路径 |

### `FileManager.isiCloudFileDownloaded(filePath: string): boolean`

判断指定的 iCloud 文件是否已从云端下载到本地。

### `FileManager.downloadFileFromiCloud(filePath: string): Promise<boolean>`

下载指定的 iCloud 文件。

| 返回值               | 说明     |
| ----------------- | ------ |
| Promise\<boolean> | 下载是否成功 |

示例：

```ts
if (FileManager.isiCloudEnabled) {
  const file = FileManager.iCloudDocumentsDirectory + "/data.json";
  const ok = await FileManager.downloadFileFromiCloud(file);
}
```

### `FileManager.getShareUrlOfiCloudFile(path: string, expiration?: number): string`

生成 iCloud 文件的可分享下载链接。文件必须存在于 iCloud 且已上传。

| 参数         | 类型        | 说明                                                  |
| ---------- | --------- | --------------------------------------------------- |
| path       | string    | 必须以 `FileManager.iCloudDocumentsDirectory` 为前缀的文件路径 |
| expiration | number 可选 | 链接过期时间戳                                             |

使用时需配合 `try-catch` 捕获异常。

***

## 目录与文件操作

支持异步（Promise）与同步（Sync）两种版本。同步方法会阻塞执行线程，在性能敏感场景应优先使用异步版本。

### 创建目录

#### `createDirectory(path: string, recursive?: boolean): Promise<void>`

#### `createDirectorySync(path: string, recursive?: boolean): void`

| 参数        | 类型         | 说明                   |
| --------- | ---------- | -------------------- |
| path      | string     | 目录路径                 |
| recursive | boolean 可选 | 若为 true，则自动创建不存在的父目录 |

### 创建符号链接

#### `createLink(path: string, target: string): Promise<void>`

#### `createLinkSync(path: string, target: string): void`

在 `path` 创建指向 `target` 的符号链接。

### 拷贝文件

#### `copyFile(path: string, newPath: string): Promise<void>`

#### `copyFileSync(path: string, newPath: string): void`

### 读取目录

#### `readDirectory(path: string, recursive?: boolean): Promise<string[]>`

#### `readDirectorySync(path: string, recursive?: boolean): string[]`

列出指定目录下所有内容，可递归。

### 判断文件存在性

#### `exists(path: string): Promise<boolean>`

#### `existsSync(path: string): boolean`

### 文件书签管理

文件书签用于持久访问用户授权的外部文件。

| 方法                      | 说明                    |
| ----------------------- | --------------------- |
| `bookmarkExists(name)`  | 判断书签是否存在              |
| `getAllFileBookmarks()` | 获取所有书签名称与路径           |
| `bookmarkedPath(name)`  | 返回书签对应的路径，不存在时返回 null |

### 判断文件类型

| 方法                                | 返回      | 说明       |
| --------------------------------- | ------- | -------- |
| `isFile / isFileSync`             | boolean | 是否为文件    |
| `isDirectory / isDirectorySync`   | boolean | 是否为目录    |
| `isLink / isLinkSync`             | boolean | 是否为符号链接  |
| `isBinaryFile / isBinaryFileSync` | boolean | 是否为二进制文件 |

***

## 文件读写

支持三种读写格式：字符串、字节数组、Data。

### 读取文件

| 方法                  | 返回类型       | 说明          |
| ------------------- | ---------- | ----------- |
| readAsString / Sync | string     | 指定编码读取文本内容  |
| readAsBytes / Sync  | Uint8Array | 读取为字节数组     |
| readAsData / Sync   | Data       | 读取为 Data 对象 |

### 写入文件

| 方法                   | 数据格式       |
| -------------------- | ---------- |
| writeAsString / Sync | string     |
| writeAsBytes / Sync  | Uint8Array |
| writeAsData / Sync   | Data       |

自动覆盖已有文件。

### 追加内容

| 方法                | 数据格式   |
| ----------------- | ------ |
| appendText / Sync | string |
| appendData / Sync | Data   |

若文件或目录不存在将自动创建。

***

## 文件信息与操作

### `stat(path: string): Promise<FileStat>`

### `statSync(path: string): FileStat`

获取文件信息。若 path 为符号链接，会返回真实文件的状态。

### `rename / renameSync`

移动或重命名文件或目录。

### `remove / removeSync`

删除文件或目录（目录会递归删除）。

***

## 压缩与解压

### `zip(srcPath: string, destPath: string, shouldKeepParent?: boolean): Promise<void>`

### `zipSync(srcPath: string, destPath: string, shouldKeepParent?: boolean): void`

压缩文件或目录为 zip。

### `unzip(srcPath: string, destPath: string): Promise<void>`

### `unzipSync(srcPath: string, destPath: string): void`

解压 zip 文件。

示例：

```ts
const docs = FileManager.documentsDirectory;
await FileManager.zip(docs + "/MyScript", docs + "/MyScript.zip");
await FileManager.unzip(docs + "/MyScript.zip", docs + "/Output");
```

***

## 其他工具方法

### `mimeType(path: string): string`

返回文件的 MIME 类型。

### `destinationOfSymbolicLink(path: string): string`

返回符号链接指向的目标路径。

***

## 类型定义

### `FileStat`

```ts
type FileStat = {
  creationDate: number;
  modificationDate: number;
  type: string; // "file" | "directory" | "link" | "unixDomainSock" | "pipe" | "notFound"
  size: number;
};
```



---
url: /v2/zh/guide/Utilities/HttpServer/HttpRequest.md
---

# HttpRequest（HTTP 请求）

`HttpRequest` 类表示一个由客户端发往服务器的 HTTP 请求对象。它封装了请求的路径、方法、头部、请求体、来源地址以及解析后的参数信息，可在服务器的路由处理函数中使用。

***

## 概述

`HttpRequest` 通常作为参数传入由 `HttpServer.registerHandler()` 注册的处理函数中，用于：

- 读取请求路径、方法、头部与请求体；
- 访问 URL 参数与查询参数；
- 解析表单数据（包括 `application/x-www-form-urlencoded` 与 `multipart/form-data`）；
- 校验身份令牌或自定义 header。

***

## 属性

### `path: string`

请求的路径部分，不包含查询参数。

**示例：**

```ts
console.log(request.path) 
// 输出: "/api/user"
```

***

### `method: string`

请求的 HTTP 方法，例如 `"GET"`, `"POST"`, `"PUT"`, `"DELETE"` 等。

**示例：**

```ts
console.log(request.method)
// 输出: "POST"
```

***

### `headers: Record<string, string>`

包含请求头部的键值对对象。

**示例：**

```ts
console.log(request.headers["content-type"])
// 输出: "application/json"
```

***

### `body: Data`

请求体内容，封装为 `Data` 对象。
可通过 `Data.toRawString("utf-8")` 等方法将其转换为文本。

**示例：**

```ts
const text = request.body.toRawString("utf-8")
console.log("请求体内容:", text)
```

***

### `address: string | null`

请求来源的客户端 IP 地址。
若无法识别来源，则为 `null`。

**示例：**

```ts
console.log("来自地址:", request.address)
```

***

### `params: Record<string, string>`

路径参数对象，用于访问定义在路由路径中的占位符。

**示例：**

```ts
// 路由注册时定义
server.registerHandler("/user/:id", (req) => {
  const userId = req.params["id"]
  return HttpResponse.ok(HttpResponseBody.text(`User ID: ${userId}`))
})
```

访问 `/user/123` 时输出：

```
User ID: 123
```

***

### `queryParams: Array<{ key: string; value: string }>`

URL 查询参数数组，每项包含 `key` 与 `value`。
可用于读取 `?key=value` 形式的参数。

**示例：**

```ts
// 请求 URL: /search?keyword=apple&page=2
for (const param of request.queryParams) {
  console.log(param.key, "=", param.value)
}
// 输出：
// keyword = apple
// page = 2
```

***

## 方法

### `hasTokenForHeader(headerName: string, token: string): boolean`

检查指定请求头中是否包含给定的令牌（通常用于 `Authorization` 或自定义安全验证）。

**参数：**

| 参数名          | 类型       | 说明                 |
| ------------ | -------- | ------------------ |
| `headerName` | `string` | 要检查的请求头名称（不区分大小写）。 |
| `token`      | `string` | 期望匹配的令牌字符串。        |

**返回值：**

- `true`：请求头中包含该令牌；
- `false`：不包含。

**示例：**

```ts
if (!request.hasTokenForHeader("Authorization", "Bearer my-secret-token")) {
  return HttpResponse.unauthorized()
}
```

***

### `parseUrlencodedForm(): Array<{ key: string; value: string }>`

解析 `application/x-www-form-urlencoded` 格式的表单请求体。
通常用于处理 HTML 表单的 POST 请求。

**返回值：**
返回一个数组，每个元素包含 `key` 与 `value`。

**示例：**

```ts
const form = request.parseUrlencodedForm()
for (const field of form) {
  console.log(field.key, "=", field.value)
}
```

假设请求体为：

```
username=thom&password=1234
```

则输出：

```
username = thom
password = 1234
```

***

### `parseMultiPartFormData(): Array<{ name: string | null; filename: string | null; headers: Record<string, string>; data: Data }>`

解析 `multipart/form-data` 格式的表单请求（通常用于文件上传）。

**返回值：**
返回一个数组，每个元素代表一个表单字段或文件项，包含以下属性：

| 属性         | 类型                       | 说明                         |
| ---------- | ------------------------ | -------------------------- |
| `name`     | `string \| null`         | 表单字段名称。                    |
| `filename` | `string \| null`         | 如果是文件上传项，则为文件名；否则为 `null`。 |
| `headers`  | `Record<string, string>` | 文件或字段的头部信息。                |
| `data`     | `Data`                   | 字段或文件内容数据。                 |

**示例：**

```ts
const parts = request.parseMultiPartFormData()
for (const part of parts) {
  if (part.filename) {
    console.log("上传文件:", part.filename)
    FileManager.writeAsDataSync(Path.join(Script.directory, part.filename), part.data)
  } else {
    console.log("字段:", part.name, "=", part.data.toRawString("utf-8"))
  }
}
```

***

## 综合示例

以下示例展示了如何读取请求信息并返回响应：

```ts
server.registerHandler("/upload", (req) => {
  if (req.method === "POST") {
    const parts = req.parseMultiPartFormData()
    for (const part of parts) {
      if (part.filename) {
        console.log("Received file:", part.filename)
      } else {
        console.log("Field:", part.name)
      }
    }
    return HttpResponse.ok(HttpResponseBody.text("Upload successful"))
  } else {
    return HttpResponse.badRequest(HttpResponseBody.text("POST required"))
  }
})
```



---
url: /v2/zh/guide/Utilities/HttpServer/HttpResponse.md
---

# HttpResponse（HTTP 响应）

`HttpResponse` 类表示服务器对客户端请求的响应对象。
它定义了 HTTP 响应的状态码、响应体及头部信息，并提供多种便捷方法生成常见的标准响应（如 `ok`、`notFound`、`internalServerError` 等）。

此类通常与 `HttpResponseBody` 搭配使用，用于在服务器端返回文本、HTML、二进制数据或文件内容。

***

## 概述

`HttpResponse` 的主要功能包括：

- 构造标准 HTTP 响应（200、404、500 等）；
- 返回自定义状态码与原因短语；
- 返回文本、数据、HTML 或文件；
- 设置自定义响应头；
- 支持从 `FileEntity` 或 `Data` 对象直接构建响应体。

***

## 属性

### `statusCode: number`

HTTP 响应状态码。

**示例：**

```ts
const res = HttpResponse.ok(HttpResponseBody.text("OK"))
console.log(res.statusCode)
// 输出: 200
```

***

### `reasonPhrase: string`

状态码对应的原因短语（例如 `"OK"`, `"Not Found"`, `"Internal Server Error"` 等）。

**示例：**

```ts
console.log(res.reasonPhrase)
// 输出: "OK"
```

***

## 方法

### `headers(): Record<string, string>`

返回响应头的键值对对象。

**示例：**

```ts
const res = HttpResponse.ok(HttpResponseBody.text("hello"))
console.log(res.headers())
```

***

### `static ok(body: HttpResponseBody): HttpResponse`

创建一个状态码为 `200 OK` 的响应。

**参数：**

| 参数名    | 类型                 | 说明                                                        |
| ------ | ------------------ | --------------------------------------------------------- |
| `body` | `HttpResponseBody` | 响应体对象，可通过 `HttpResponseBody.text()`、`data()`、`html()` 创建。 |

**示例：**

```ts
return HttpResponse.ok(HttpResponseBody.text("Hello, world!"))
```

***

### `static created(): HttpResponse`

返回 `201 Created` 响应，表示资源已成功创建。

**示例：**

```ts
return HttpResponse.created()
```

***

### `static accepted(): HttpResponse`

返回 `202 Accepted` 响应，表示请求已被接受但尚未处理完成。

**示例：**

```ts
return HttpResponse.accepted()
```

***

### `static movedPermanently(url: string): HttpResponse`

返回 `301 Moved Permanently` 响应，用于永久重定向。

**参数：**

| 参数名   | 类型       | 说明         |
| ----- | -------- | ---------- |
| `url` | `string` | 重定向目标 URL。 |

**示例：**

```ts
return HttpResponse.movedPermanently("https://example.com/new-page")
```

***

### `static movedTemporarily(url: string): HttpResponse`

返回 `302 Moved Temporarily` 响应，用于临时重定向。

**参数：**

| 参数名   | 类型       | 说明         |
| ----- | -------- | ---------- |
| `url` | `string` | 重定向目标 URL。 |

**示例：**

```ts
return HttpResponse.movedTemporarily("https://example.com/login")
```

***

### `static badRequest(body?: HttpResponseBody | null): HttpResponse`

返回 `400 Bad Request` 响应，表示请求格式错误或参数无效。

**参数：**

| 参数名    | 类型                  | 说明         |
| ------ | ------------------- | ---------- |
| `body` | `HttpResponseBody?` | 可选的错误消息内容。 |

**示例：**

```ts
return HttpResponse.badRequest(HttpResponseBody.text("Invalid parameters"))
```

***

### `static unauthorized(): HttpResponse`

返回 `401 Unauthorized` 响应，表示需要身份验证。

**示例：**

```ts
return HttpResponse.unauthorized()
```

***

### `static forbidden(): HttpResponse`

返回 `403 Forbidden` 响应，表示禁止访问。

**示例：**

```ts
return HttpResponse.forbidden()
```

***

### `static notFound(): HttpResponse`

返回 `404 Not Found` 响应，表示请求的资源不存在。

**示例：**

```ts
return HttpResponse.notFound()
```

***

### `static notAcceptable(): HttpResponse`

返回 `406 Not Acceptable` 响应，表示请求的内容类型不被支持。

**示例：**

```ts
return HttpResponse.notAcceptable()
```

***

### `static tooManyRequests(): HttpResponse`

返回 `429 Too Many Requests` 响应，表示请求过于频繁。

**示例：**

```ts
return HttpResponse.tooManyRequests()
```

***

### `static internalServerError(): HttpResponse`

返回 `500 Internal Server Error` 响应，表示服务器内部错误。

**示例：**

```ts
return HttpResponse.internalServerError()
```

***

### `static raw(statusCode: number, phrase: string, options?: { headers?: Record<string, string>; body?: Data | FileEntity } | null): HttpResponse`

创建一个自定义状态码与内容的原始响应。

**参数：**

| 参数名               | 类型                       | 说明                 |
| ----------------- | ------------------------ | ------------------ |
| `statusCode`      | `number`                 | HTTP 状态码。          |
| `phrase`          | `string`                 | 原因短语。              |
| `options.headers` | `Record<string, string>` | 自定义响应头。            |
| `options.body`    | `Data \| FileEntity`     | 响应体，可以是二进制数据或文件对象。 |

**示例：**

```ts
const file = FileEntity.openForReading(Path.join(Script.directory, "image.png"))
return HttpResponse.raw(200, "OK", {
  headers: { "Content-Type": "image/png" },
  body: file
})
```

***

## 与 HttpResponseBody 搭配使用

### `HttpResponseBody.text(text: string)`

返回文本响应体。

```ts
HttpResponse.ok(HttpResponseBody.text("Hello, world"))
```

### `HttpResponseBody.html(html: string)`

返回 HTML 响应体。

```ts
HttpResponse.ok(HttpResponseBody.html("<h1>Welcome</h1>"))
```

### `HttpResponseBody.data(data: Data)`

返回二进制响应体。

```ts
const data = Data.fromRawString("Binary content", "utf-8")
HttpResponse.ok(HttpResponseBody.data(data))
```

***

## 综合示例

### 1. 返回 JSON 响应

```ts
server.registerHandler("/user", (req) => {
  const json = JSON.stringify({ name: "Alice", age: 25 })
  const data = Data.fromRawString(json, "utf-8")
  return HttpResponse.ok(HttpResponseBody.data(data))
})
```

### 2. 返回文件下载

```ts
server.registerHandler("/download", (req) => {
  const file = FileEntity.openForReading(Path.join(Script.directory, "example.zip"))
  return HttpResponse.raw(200, "OK", {
    headers: { "Content-Type": "application/zip" },
    body: file
  })
})
```

### 3. 处理错误响应

```ts
server.registerHandler("/api", (req) => {
  if (req.method !== "POST") {
    return HttpResponse.badRequest(HttpResponseBody.text("POST method required"))
  }
  return HttpResponse.ok(HttpResponseBody.text("Success"))
})
```



---
url: /v2/zh/guide/Utilities/HttpServer/HttpResponseBody.md
---

# HttpResponseBody（HTTP 响应体）

`HttpResponseBody` 类用于构造 HTTP 响应的主体内容。
它可以表示文本内容、HTML 页面、二进制数据或任意自定义数据类型，并与 `HttpResponse` 一起使用，用于向客户端返回响应内容。

***

## 概述

在使用 `HttpServer` 创建自定义 HTTP 服务时，响应主体 (`HttpResponseBody`) 决定了客户端实际接收到的数据内容。
该类提供多种静态工厂方法用于快速生成不同类型的响应内容：

- 文本（`text`）
- HTML（`html`、`htmlBody`）
- 二进制数据（`data`）

***

## 常见用途

- 返回纯文本响应（例如 API 消息）
- 返回 HTML 页面（例如浏览器展示）
- 返回文件或二进制流（例如图片、视频、压缩包）

***

## 静态方法

### `static text(text: string): HttpResponseBody`

创建一个文本类型的响应体。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `text` | `string` | 要返回的文本内容。 |

**示例：**

```ts
const body = HttpResponseBody.text("Hello, world")
return HttpResponse.ok(body)
```

返回结果：

```
HTTP/1.1 200 OK
Content-Type: text/plain

Hello, world
```

***

### `static data(data: Data): HttpResponseBody`

创建一个包含二进制数据的响应体。

**参数：**

| 参数名    | 类型     | 说明           |
| ------ | ------ | ------------ |
| `data` | `Data` | 要返回的二进制数据对象。 |

**示例：**

```ts
const content = Data.fromRawString("Binary content", "utf-8")
return HttpResponse.ok(HttpResponseBody.data(content))
```

此方法常用于返回文件下载、图片或 JSON 数据。

***

### `static html(html: string): HttpResponseBody`

创建一个 HTML 响应体（标准 HTML 文档）。

**参数：**

| 参数名    | 类型       | 说明         |
| ------ | -------- | ---------- |
| `html` | `string` | HTML 文本内容。 |

**示例：**

```ts
const html = `
<html>
  <head><title>Hello</title></head>
  <body><h1>Welcome to Scripting Server</h1></body>
</html>
`
return HttpResponse.ok(HttpResponseBody.html(html))
```

浏览器访问时将直接渲染为网页内容。

***

### `static htmlBody(html: string): HttpResponseBody`

创建一个仅包含 HTML “主体内容”的响应体。
与 `html()` 类似，但在部分实现中可能省略标准 HTML 文档结构（`<html>`、`<body>` 等标签）。
常用于模板渲染或嵌入式 HTML 内容返回。

**参数：**

| 参数名    | 类型       | 说明            |
| ------ | -------- | ------------- |
| `html` | `string` | HTML 片段或主体内容。 |

**示例：**

```ts
return HttpResponse.ok(HttpResponseBody.htmlBody("<h1>Inline HTML Body</h1>"))
```

***

## 使用场景示例

### 1. 返回纯文本响应

```ts
server.registerHandler("/hello", (req) => {
  return HttpResponse.ok(HttpResponseBody.text("Hello from server"))
})
```

### 2. 返回 HTML 页面

```ts
server.registerHandler("/", (req) => {
  const html = `
  <html>
    <head><title>Home</title></head>
    <body>
      <h1>Welcome</h1>
      <p>This is a simple Scripting HTTP server.</p>
    </body>
  </html>`
  return HttpResponse.ok(HttpResponseBody.html(html))
})
```

### 3. 返回二进制文件（如图片）

```ts
server.registerHandler("/image", (req) => {
  const fileData = FileManager.readAsData(Path.join(Script.directory, "logo.png"))
  return HttpResponse.ok(HttpResponseBody.data(fileData))
})
```

### 4. 返回局部 HTML 内容（用于嵌入）

```ts
server.registerHandler("/partial", (req) => {
  return HttpResponse.ok(HttpResponseBody.htmlBody("<div>Partial Content</div>"))
})
```

***

## 总结

| 方法           | 说明           | 典型用途         |
| ------------ | ------------ | ------------ |
| `text()`     | 返回纯文本内容      | API 响应、日志输出  |
| `data()`     | 返回二进制数据      | 文件下载、JSON、图片 |
| `html()`     | 返回完整 HTML 页面 | 网页展示         |
| `htmlBody()` | 返回 HTML 片段   | 模板渲染或局部更新    |



---
url: /v2/zh/guide/Utilities/HttpServer/HttpServer.md
---

# HttpServer（HTTP 服务器）

`HttpServer` 类提供了在本地或局域网中启动一个轻量级 HTTP 服务器的能力，可用于处理 HTTP 请求、静态文件服务、WebSocket 通信等场景。该类在脚本中常用于本地 Web 调试、远程控制、设备通信等。

***

## 概述

`HttpServer` 支持以下功能：

- 处理自定义路径的 HTTP 请求。
- 提供静态文件或目录的访问。
- 注册 WebSocket 服务端，实现实时通信。
- 支持 IPv4 与 IPv6 地址。
- 可选择端口号（支持随机端口）。
- 支持服务器状态查询。

***

## 属性

### `state: HttpServerState`

服务器当前状态。
可能值包括：

| 状态           | 说明       |
| ------------ | -------- |
| `"starting"` | 正在启动服务器。 |
| `"running"`  | 服务器运行中。  |
| `"stopping"` | 正在停止服务器。 |
| `"stopped"`  | 服务器已停止。  |

***

### `port: number | null`

服务器监听的端口号。
如果服务器未运行，则为 `null`。

***

### `isIPv4: boolean`

指示服务器是否在 IPv4 地址上监听。若为 `false`，则可能监听 IPv6 地址。

***

### `listenAddressIPv4: string | null`

IPv4 监听地址，仅当 `forceIPv4` 为 `true` 时使用。

***

### `listenAddressIPv6: string | null`

IPv6 监听地址，仅当 `forceIPv6` 为 `true` 时使用。

***

## 方法

### `registerHandler(path: string, handler: (request: HttpRequest) => HttpResponse): void`

为指定路径注册一个 HTTP 请求处理器。

**参数：**

| 参数        | 类型                                       | 说明                           |
| --------- | ---------------------------------------- | ---------------------------- |
| `path`    | `string`                                 | 请求路径（支持动态参数，例如 `/user/:id`）。 |
| `handler` | `(request: HttpRequest) => HttpResponse` | 处理函数，接收请求对象并返回响应对象。          |

**示例：**

```ts
const server = new HttpServer()

server.registerHandler("/hello", (req) => {
  return HttpResponse.ok(HttpResponseBody.text("Hello, world!"))
})
```

***

### `registerFile(path: string, filePath: string): void`

为指定路径注册一个静态文件响应。

**参数：**

| 参数         | 类型       | 说明        |
| ---------- | -------- | --------- |
| `path`     | `string` | 请求路径。     |
| `filePath` | `string` | 要响应的文件路径。 |

**示例：**

```ts
server.registerFile("/readme", Path.join(Script.directory, "README.md"))
```

当访问 `/readme` 时，服务器将返回该文件的内容。

***

### `registerFilesFromDirectory(path: string, directory: string, options?: { defaults?: string[] }): void`

注册指定目录下的所有文件，使其可通过 HTTP 访问。

**参数：**

| 参数                 | 类型         | 说明                                                             |
| ------------------ | ---------- | -------------------------------------------------------------- |
| `path`             | `string`   | 路径模板，例如 `/static/:file`。                                       |
| `directory`        | `string`   | 目录路径。                                                          |
| `options.defaults` | `string[]` | 默认文件名，若未指定文件则尝试加载此列表中的文件（默认：`["index.html", "default.html"]`）。 |

**示例：**

```ts
server.registerFilesFromDirectory("/static/:file", Path.join(Script.directory, "html"), {
  defaults: ["index.html", "index.htm"]
})
```

当访问 `/static/` 时，会返回该目录下的默认首页文件。

***

### `registerWebsocket(path: string, handlers: WebSocketHandlers): void`

注册 WebSocket 服务端处理程序，用于实时通信。

**参数：**

| 参数         | 类型                  | 说明                |
| ---------- | ------------------- | ----------------- |
| `path`     | `string`            | WebSocket 路径。     |
| `handlers` | `WebSocketHandlers` | WebSocket 事件处理函数。 |

**WebSocketHandlers 类型定义：**

```ts
interface WebSocketHandlers {
  onPong?: (session: WebSocketSession) => void
  onConnected?: (session: WebSocketSession) => void
  onDisconnected?: (session: WebSocketSession) => void
  handleText?: (session: WebSocketSession, text: string) => void
  handleBinary?: (session: WebSocketSession, data: Data) => void
}
```

**示例：**

```ts
const connectedSessions: WebSocketSession[] = []

server.registerWebsocket("/ws", {
  onConnected: (session) => {
    connectedSessions.push(session)
  },
  onDisconnected: (session) => {
    connectedSessions.splice(connectedSessions.indexOf(session), 1)
  },
  handleText: (session, text) => {
    session.writeText("Echo: " + text)
  }
})
```

***

### `start(options?: { port?: number; forceIPv4?: boolean }): string | null`

启动服务器。

**参数：**

| 参数                  | 类型        | 说明                                    |
| ------------------- | --------- | ------------------------------------- |
| `options.port`      | `number`  | 指定监听端口，默认为 `8080`。如果设为 `0`，则自动选择可用端口。 |
| `options.forceIPv4` | `boolean` | 是否强制使用 IPv4 地址，默认 `false`。            |

**返回值：**

- 若启动失败，返回错误消息字符串。
- 若成功，返回 `null`。

**示例：**

```ts
const error = server.start({ port: 8080 })
if (error) {
  console.error("启动失败:", error)
} else {
  console.log("服务器运行在端口:", server.port)
}
```

***

### `stop(): void`

停止服务器并释放资源。

**示例：**

```ts
server.stop()
console.log("服务器已停止")
```

***

## 类型定义

### `HttpServerState`

```ts
type HttpServerState = "starting" | "running" | "stopping" | "stopped"
```

### `WebSocketSession`

表示一个 WebSocket 连接。

**常用方法：**

| 方法                        | 说明       |
| ------------------------- | -------- |
| `writeText(text: string)` | 发送文本消息。  |
| `writeData(data: Data)`   | 发送二进制消息。 |
| `close()`                 | 关闭连接。    |

***

## 综合示例

以下示例展示了一个完整的 HTTP 与 WebSocket 服务器：

```ts
const server = new HttpServer()

// 注册简单的 HTTP 处理
server.registerHandler("/api/hello", (req) => {
  return HttpResponse.ok(HttpResponseBody.text("Hello from Scripting Server"))
})

// 注册静态目录
server.registerFilesFromDirectory("/public/:file", Path.join(Script.directory, "html"))

// 注册 WebSocket 服务
server.registerWebsocket("/chat", {
  onConnected: (session) => {
    console.log("新连接")
    session.writeText("欢迎加入聊天")
  },
  handleText: (session, text) => {
    console.log("收到:", text)
    session.writeText("你说: " + text)
  }
})

// 启动服务器
const error = server.start({ port: 8080 })
if (error) {
  console.error("启动失败:", error)
} else {
  console.log("HTTP服务器已启动，端口:", server.port)
}
```



---
url: /v2/zh/guide/Utilities/HttpServer/WebSocketSession.md
---

# WebSocketSession（WebSocket 会话）

`WebSocketSession` 类表示一个已建立的 WebSocket 连接会话。
它由服务器端的 `HttpServer.registerWebsocket()` 注册的处理函数自动创建，用于与客户端进行双向实时通信。

***

## 概述

通过 `WebSocketSession`，你可以：

- 接收客户端发送的文本或二进制数据；
- 向客户端发送消息（文本或二进制）；
- 处理连接的建立与断开事件；
- 关闭连接会话。

`WebSocketSession` 通常由 WebSocket 事件回调函数接收，如 `onConnected`、`handleText`、`handleBinary` 等。

***

## 使用场景

- 构建实时聊天、协作或通知系统；
- 实现实时状态同步或设备控制；
- 处理自定义协议的二进制数据通信；
- 构建本地 WebSocket 服务，与其他设备或网页通信。

***

## 方法

### `writeText(text: string): void`

向客户端发送一条文本消息。

**参数：**

| 参数名    | 类型       | 说明        |
| ------ | -------- | --------- |
| `text` | `string` | 要发送的文本内容。 |

**示例：**

```ts
server.registerWebsocket("/chat", {
  onConnected: (session) => {
    session.writeText("Welcome to the chat room!")
  },
  handleText: (session, text) => {
    console.log("Client says:", text)
    session.writeText("You said: " + text)
  }
})
```

***

### `writeData(data: Data): void`

向客户端发送一条二进制消息。

**参数：**

| 参数名    | 类型     | 说明           |
| ------ | ------ | ------------ |
| `data` | `Data` | 要发送的二进制数据对象。 |

**示例：**

```ts
server.registerWebsocket("/binary", {
  onConnected: (session) => {
    const msg = Data.fromRawString("Binary hello", "utf-8")
    session.writeData(msg)
  }
})
```

***

### `close(): void`

关闭当前 WebSocket 会话连接。

调用后，连接会断开，且不再触发任何接收事件。

**示例：**

```ts
server.registerWebsocket("/ws", {
  handleText: (session, text) => {
    if (text === "bye") {
      session.writeText("Goodbye!")
      session.close()
    }
  }
})
```

***

## 与 HttpServer.registerWebsocket() 的配合使用

`WebSocketSession` 实例通过 `registerWebsocket()` 注册的事件回调函数获得。

### 注册示例

```ts
const connectedSessions: WebSocketSession[] = []

server.registerWebsocket("/ws", {
  onConnected: (session) => {
    connectedSessions.push(session)
    console.log("Client connected")
    session.writeText("Connection established!")
  },
  handleText: (session, text) => {
    console.log("Received:", text)
    // 广播消息给所有连接的客户端
    for (const s of connectedSessions) {
      s.writeText("Broadcast: " + text)
    }
  },
  handleBinary: (session, data) => {
    console.log("Received binary data:", data.length)
  },
  onDisconnected: (session) => {
    const index = connectedSessions.indexOf(session)
    if (index !== -1) connectedSessions.splice(index, 1)
    console.log("Client disconnected")
  }
})
```

***

## 常用事件回调（由 HttpServer 提供）

| 回调函数             | 触发时机                | 参数                                          | 说明          |
| ---------------- | ------------------- | ------------------------------------------- | ----------- |
| `onConnected`    | 客户端成功建立连接时          | `(session: WebSocketSession)`               | 创建新的会话对象。   |
| `onDisconnected` | 客户端断开连接时            | `(session: WebSocketSession)`               | 会话结束。       |
| `onPong`         | 收到客户端 Ping/Pong 响应时 | `(session: WebSocketSession)`               | 用于检测连接健康状态。 |
| `handleText`     | 收到文本消息时             | `(session: WebSocketSession, text: string)` | 处理文本通信。     |
| `handleBinary`   | 收到二进制数据时            | `(session: WebSocketSession, data: Data)`   | 处理二进制通信。    |

***

## 示例：构建简单的实时聊天室

```ts
const sessions: WebSocketSession[] = []

server.registerWebsocket("/chat", {
  onConnected: (session) => {
    sessions.push(session)
    session.writeText("Welcome! There are " + sessions.length + " users online.")
  },
  handleText: (session, text) => {
    for (const s of sessions) {
      s.writeText(text) // 广播消息
    }
  },
  onDisconnected: (session) => {
    const index = sessions.indexOf(session)
    if (index !== -1) sessions.splice(index, 1)
  }
})
```

客户端通过 JavaScript 连接：

```js
const ws = new WebSocket("ws://localhost:8080/chat")
ws.onmessage = e => console.log("Server:", e.data)
ws.send("Hello everyone!")
```

***

## 类型定义

```ts
class WebSocketSession {
  writeText(text: string): void
  writeData(data: Data): void
  close(): void
}
```

***

## 总结

| 方法            | 说明         | 使用场景          |
| ------------- | ---------- | ------------- |
| `writeText()` | 向客户端发送文本消息 | 聊天、通知、状态同步    |
| `writeData()` | 发送二进制数据    | 文件传输、实时流、设备数据 |
| `close()`     | 关闭连接       | 主动断开连接或清理资源   |



---
url: /v2/zh/guide/Utilities/ItemProvider.md
---

# ItemProvider

`ItemProvider` 用于表示一个**可按需加载的数据提供者**，常见于拖放、文件导入、Photos 选择等场景。
它并不直接包含数据本身，而是描述**可以如何、安全地获取数据**。

`ItemProvider` 支持加载对象、文本、URL、原始数据以及文件路径，并对文件访问施加了明确的安全访问边界。

***

## 核心概念

- `ItemProvider` 描述的是能力，而不是数据
- 所有加载行为都必须遵循系统的安全作用域规则
- 文件类资源只能在受控的回调作用域内访问
- 是否支持原地访问（in-place）由底层系统决定

***

## 属性

### registeredTypes

```ts
readonly registeredTypes: UTType[]
```

表示该 `ItemProvider` 在语义上可以提供的所有类型。

- 包含直接类型以及可推导的父类型
- 用于判断内容大类或调试用途
- 不保证一定存在对应的底层文件表示

***

### registeredInPlaceTypes

```ts
readonly registeredInPlaceTypes: UTType[]
```

表示该 `ItemProvider` 支持原地访问（open-in-place）的类型集合。

- 常见于视频、音频、文档等大文件
- 是否真正原地访问需以加载结果为准

***

## 能力判断方法

### hasItemConforming

```ts
hasItemConforming(type: UTType): boolean
```

判断内容在语义上是否符合指定类型。

- 判断宽松
- 会考虑 UTType 的继承关系
- 适合用于业务分支判断

***

### hasRepresentationConforming

```ts
hasRepresentationConforming(type: UTType): boolean
```

判断是否存在一个真实的、可加载的底层表示符合指定类型。

- 判断严格
- 适合用于文件处理或精确格式要求的场景

***

### hasInPlaceRepresentationConforming

```ts
hasInPlaceRepresentationConforming(type: UTType): boolean
```

判断是否存在支持原地访问的底层表示。

- 常用于大文件加载策略选择

***

## 对象加载能力判断

### canLoadUIImage

```ts
canLoadUIImage(): boolean
```

判断是否可以加载为 `UIImage` 对象。

- 适合 UI 展示
- 不保证原始文件格式或元数据

***

### canLoadLivePhoto

```ts
canLoadLivePhoto(): boolean
```

判断是否可以加载为 `LivePhoto` 对象。

- 用于区分静态图片与 Live Photo
- 返回 `true` 时可调用 `loadLivePhoto`

***

## 加载方法

### loadUIImage

```ts
loadUIImage(): Promise<UIImage | null>
```

加载一个 `UIImage` 对象。

- 适合轻量展示
- 不适合用于文件级处理或资源保真

***

### loadLivePhoto

```ts
loadLivePhoto(): Promise<LivePhoto | null>
```

加载一个 `LivePhoto` 对象。

- 包含图片与配对视频
- 适合展示、保存或进一步处理

***

### loadURL

```ts
loadURL(): Promise<string | null>
```

加载一个 URL 字符串。

- 可能是网页 URL
- 也可能是文件 URL

***

### loadText

```ts
loadText(): Promise<string | null>
```

加载纯文本内容。

- 支持 plain text
- 富文本会被降级为纯文本

***

### loadData

```ts
loadData(type: UTType): Promise<Data | null>
```

加载指定类型的原始二进制数据。

- 数据会整体加载进内存
- 适合 JSON、配置文件、小体积资源
- 不适合视频、音频等大文件

***

## 文件路径加载（安全作用域）

文件路径的加载需要遵循系统的安全限制，所有文件访问都必须在指定的回调作用域内完成。

***

### loadFilePath

```ts
loadFilePath(type: UTType): Promise<string | null>
```

加载指定类型的文件路径，如果文件不存在或无法加载，返回 `null`。如果可以加载，文件会被复制到应用组的临时目录中，并返回文件路径。
如果你不再需要文件，请删除它。

示例：

```ts
const filePath = provider.loadFilePath("public.movie")
```

***

## 创建 ItemProvider

### fromUIImage

```ts
ItemProvider.fromUIImage(image: UIImage): ItemProvider
```

从 `UIImage` 创建 `ItemProvider`。

- 仅提供静态图片能力
- 不包含 Live Photo 或原始资源信息

***

### fromText

```ts
ItemProvider.fromText(text: string): ItemProvider
```

从文本创建 `ItemProvider`。

***

### fromURL

```ts
ItemProvider.fromURL(url: string): ItemProvider | null
```

从 URL 字符串创建 `ItemProvider`。

- URL 不合法时返回 `null`
- 支持网页 URL 与文件 URL

***

### fromFilePath

```ts
ItemProvider.fromFilePath(path: string): ItemProvider
```

从文件路径创建 `ItemProvider`。

- 保留原始文件
- 适合视频、音频、文档等资源
- 支持原地访问能力判断

***

## 使用建议

- 使用 `hasItemConforming` 进行内容类型判断
- 使用对象加载方法进行 UI 展示
- 使用文件路径加载方法处理大文件
- 文件路径只能在 `perform` 回调作用域内访问
- 不应在回调外部延迟访问安全作用域文件



---
url: /v2/zh/guide/Utilities/OAuth2.md
---

# OAuth2

`OAuth2` 类用于在脚本中实现 OAuth 2.0 授权流程。它支持标准的授权码流程、PKCE（Proof Key for Code Exchange）、访问令牌续期及多种配置选项。

***

## 构造函数

```ts
new OAuth2(options: {
  consumerKey: string
  consumerSecret: string
  authorizeUrl: string
  accessTokenUrl?: string
  responseType: string
  contentType?: string
})
```

### 参数说明

| 参数名            | 类型     | 是否必填 | 说明                                                       |
| -------------- | ------ | ---- | -------------------------------------------------------- |
| consumerKey    | string | 是    | 应用的客户端 ID（Client ID）或 Consumer Key。                      |
| consumerSecret | string | 是    | 应用的客户端密钥（Client Secret）。                                 |
| authorizeUrl   | string | 是    | 用于跳转用户授权的地址。                                             |
| accessTokenUrl | string | 否    | 获取访问令牌（Access Token）的地址，若不提供则使用 authorizeUrl。            |
| responseType   | string | 是    | 一般为 `"code"`，表示使用授权码流程。                                  |
| contentType    | string | 否    | 请求令牌时使用的内容类型，默认值为 `"application/x-www-form-urlencoded"`。 |

### 抛出错误

- 当配置参数无效或实例化失败时抛出错误。

***

## 属性

### `accessTokenBasicAuthentification: boolean`

是否使用 Basic 认证方式发送获取访问令牌的请求。默认值为 `false`。

***

### `allowMissingStateCheck: boolean`

是否禁用 `state` 参数校验（CSRF 保护）。**谨慎使用**，默认值为 `false`。

***

### `encodeCallbackURL: boolean`

是否对回调地址进行 URL 编码。某些服务商要求必须编码。默认值为 `true`。

***

### `encodeCallbackURLQuery: boolean`

是否对整个回调地址的查询参数进行编码。部分服务如 Imgur 要求此值为 `false`。默认值为 `true`。

***

## 方法

### `authorize(options): Promise<OAuthCredential>`

发起 OAuth2 授权流程。将打开一个浏览器窗口，供用户登录并授权。

```ts
authorize(options: {
  callbackURL?: string
  scope: string
  state: string
  parameters?: Record<string, any>
  headers?: Record<string, string>
} & ({
  codeVerifier: string
  codeChallenge: string
  codeChallengeMethod: string
} | {
  codeVerifier?: never
  codeChallenge?: never
  codeChallengeMethod?: never
})): Promise<OAuthCredential>
```

#### 参数说明

| 参数名                 | 类型                      | 是否必填 | 说明                                                |
| ------------------- | ----------------------- | ---- | ------------------------------------------------- |
| callbackURL         | string                  | 否    | 授权成功后的回调地址，默认为 `scripting://oauth_callback/脚本名称`。 |
| scope               | string                  | 是    | 空格分隔的权限列表。                                        |
| state               | string                  | 是    | 防止 CSRF 攻击的随机字符串。                                 |
| parameters          | Record\<string, any>    | 否    | 附加的授权请求参数。                                        |
| headers             | Record\<string, string> | 否    | 附加的请求头。                                           |
| codeVerifier        | string                  | 条件必填 | PKCE 流程中使用的随机码。                                   |
| codeChallenge       | string                  | 条件必填 | 由 `codeVerifier` 生成的哈希值。                          |
| codeChallengeMethod | `"plain"` \| `"S256"`   | 条件必填 | PKCE 中的 challenge 加密方法，默认使用 `"S256"`。             |

#### 返回值

- 返回一个包含授权结果的 `OAuthCredential` 对象。

#### 抛出错误

- 若用户拒绝授权或网络错误将抛出异常。

#### 示例

```ts
const oauth = new OAuth2({
  consumerKey: '你的客户端ID',
  consumerSecret: '你的客户端密钥',
  authorizeUrl: 'https://provider.com/oauth/authorize',
  accessTokenUrl: 'https://provider.com/oauth/token',
  responseType: 'code'
})

const credential = await oauth.authorize({
  scope: 'profile email',
  state: 'secure_random_state',
  callbackURL: Script.createOAuthCallbackURLScheme('my_oauth_script')
})

console.log(credential.oauthToken)
```

***

### `renewAccessToken(options): Promise<OAuthCredential>`

使用刷新令牌（refresh token）重新获取访问令牌。

```ts
renewAccessToken(options: {
  refreshToken: string
  parameters?: Record<string, any>
  headers?: Record<string, string>
}): Promise<OAuthCredential>
```

#### 参数说明

| 参数名          | 类型                      | 是否必填 | 说明             |
| ------------ | ----------------------- | ---- | -------------- |
| refreshToken | string                  | 是    | 上一次授权返回的刷新令牌。  |
| parameters   | Record\<string, any>    | 否    | 额外的 POST 请求参数。 |
| headers      | Record\<string, string> | 否    | 自定义请求头。        |

#### 返回值

- 返回新的 `OAuthCredential` 对象。

#### 抛出错误

- 若刷新失败（如刷新令牌已过期），则抛出错误。

#### 示例

```ts
const newCredential = await oauth.renewAccessToken({
  refreshToken: oldCredential.oauthRefreshToken
})

console.log(newCredential.oauthToken)
```

***

## OAuthCredential 类型定义

授权成功后返回的凭证对象包含以下字段：

```ts
type OAuthCredential = {
  oauthToken: string
  oauthTokenSecret: string
  oauthRefreshToken: string
  oauthTokenExpiresAt: number | null
  oauthVerifier: string
  version: string
  signatureMethod: string
}
```

### 字段说明

| 字段名                 | 类型             | 说明                                       |
| ------------------- | -------------- | ---------------------------------------- |
| oauthToken          | string         | 用于访问资源的 Access Token。                    |
| oauthTokenSecret    | string         | 与访问令牌配套使用的 Token Secret，常用于 OAuth1.0 流程。 |
| oauthRefreshToken   | string         | 用于获取新访问令牌的 Refresh Token。                |
| oauthTokenExpiresAt | number \| null | 访问令牌的过期时间（Unix 毫秒时间戳），若无过期则为 `null`。     |
| oauthVerifier       | string         | 在 PKCE 流程中使用的授权码验证器。                     |
| version             | string         | OAuth 协议版本（例如 `"2.0"`）。                  |
| signatureMethod     | string         | 请求签名方式（如 `"HMAC-SHA1"`、`"PLAINTEXT"`）。   |

***

## 使用建议

- 始终使用 `state` 参数防止 CSRF 攻击，除非明确关闭。
- 使用 `Script.createOAuthCallbackURLScheme(name)` 为脚本生成唯一回调地址。
- 若需要长期授权，请妥善保存 `oauthRefreshToken`。
- 对于公用客户端建议启用 PKCE 增强安全性。



---
url: /v2/zh/guide/Utilities/Path.md
---

# 文件路径工具

`Path` API 提供了一些实用函数，用于处理和转换文件与目录路径。它受到 Node.js 的 `path` 模块启发，提供了开发者熟悉的方法来高效地处理路径。

***

## 概述

`Path` API 提供以下功能：

- 规范化路径。
- 判断路径是否为绝对路径。
- 拼接路径段。
- 提取路径组件，例如目录名、基本名和扩展名。
- 将路径解析为结构化对象。

它通过使用当前操作系统适合的路径分隔符，简化了跨平台的路径处理。

***

### 静态方法

#### `Path.normalize(path: string): string`

通过解析 `..` 和 `.` 段，规范化给定的路径。

- **参数：**
  - `path`：要规范化的输入路径。
- **返回值：**
  - 一个规范化的路径字符串。

#### 示例：

```typescript
const normalizedPath = Path.normalize('/foo/bar//baz/asdf/quux/..')
console.log(normalizedPath) // '/foo/bar/baz/asdf'
```

***

#### `Path.isAbsolute(path: string): boolean`

判断给定路径是否为绝对路径。

- **参数：**
  - `path`：输入路径。
- **返回值：**
  - 如果路径是绝对路径，则返回 `true`，否则返回 `false`。

#### 示例：

```typescript
console.log(Path.isAbsolute('/foo/bar')) // true
console.log(Path.isAbsolute('foo/bar'))  // false
```

***

#### `Path.join(...args: string[]): string`

将多个路径段拼接为一个路径，并进行规范化。

- **参数：**
  - `...args`：要拼接的路径段。
- **返回值：**
  - 一个规范化的路径字符串。

#### 示例：

```typescript
const joinedPath = Path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
console.log(joinedPath) // '/foo/bar/baz/asdf'
```

***

#### `Path.dirname(path: string): string`

返回路径的目录名。

- **参数：**
  - `path`：输入路径。
- **返回值：**
  - 目录名。

#### 示例：

```typescript
console.log(Path.dirname('/foo/bar/baz/asdf/quux')) // '/foo/bar/baz/asdf'
```

***

#### `Path.basename(path: string, ext?: string): string`

返回路径的最后一部分，类似于 Unix 的 `basename` 命令。可选地移除文件扩展名。

- **参数：**
  - `path`：输入路径。
  - `ext`（可选）：要移除的文件扩展名。
- **返回值：**
  - 路径的基本名。

#### 示例：

```typescript
console.log(Path.basename('/foo/bar/baz/asdf/quux.html')) // 'quux.html'
console.log(Path.basename('/foo/bar/baz/asdf/quux.html', '.html')) // 'quux'
```

***

#### `Path.extname(path: string): string`

返回路径的扩展名。

- **参数：**
  - `path`：输入路径。
- **返回值：**
  - 文件扩展名；如果没有扩展名，则返回空字符串。

#### 示例：

```typescript
console.log(Path.extname('/foo/bar/baz/asdf/quux.html')) // '.html'
console.log(Path.extname('/foo/bar/baz/asdf/quux'))     // ''
```

***

#### `Path.parse(path: string): { root: string; dir: string; base: string; ext: string; name: string; }`

将路径解析为包含以下属性的对象：

- `root`：路径的根目录。

- `dir`：目录名。

- `base`：包含扩展名的文件名。

- `ext`：文件扩展名。

- `name`：不带扩展名的文件名。

- **参数：**
  - `path`：输入路径。

- **返回值：**
  - 一个包含解析路径属性的对象。

#### 示例：

```typescript
const parsed = Path.parse('/foo/bar/baz/asdf/quux.html')
console.log(parsed)
// {
//   root: '/',
//   dir: '/foo/bar/baz/asdf',
//   base: 'quux.html',
//   ext: '.html',
//   name: 'quux'
// }
```

***

## 常见用例

### 规范化路径

```typescript
const normalizedPath = Path.normalize('./foo/bar/../baz')
console.log(normalizedPath) // './foo/baz'
```

### 检查路径是否为绝对路径

```typescript
console.log(Path.isAbsolute('/absolute/path')) // true
console.log(Path.isAbsolute('relative/path'))  // false
```

### 拼接多个路径段

```typescript
const fullPath = Path.join('/home', 'user', 'documents', 'file.txt')
console.log(fullPath) // '/home/user/documents/file.txt'
```

### 提取文件名和扩展名

```typescript
const fileName = Path.basename('/path/to/file.txt')
const fileExt = Path.extname('/path/to/file.txt')
console.log(fileName) // 'file.txt'
console.log(fileExt)  // '.txt'
```

### 解析路径

```typescript
const pathDetails = Path.parse('/path/to/file.txt')
console.log(pathDetails)
// {
//   root: '/',
//   dir: '/path/to',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file'
// }
```

***

## 最佳实践

1. **使用规范化功能：** 始终规范化路径以确保跨平台的一致性。
2. **避免硬编码分隔符：** 使用类似 `join` 的方法代替直接拼接字符串 `/` 或 `\\`。

***

## 完整示例

```typescript
import { Path } from 'scripting'

function main() {
  const filePath = '/foo/bar/baz/asdf/quux.html'

  console.log("规范化路径:", Path.normalize(filePath))
  console.log("是否为绝对路径:", Path.isAbsolute(filePath))
  console.log("目录名:", Path.dirname(filePath))
  console.log("基本名:", Path.basename(filePath))
  console.log("扩展名:", Path.extname(filePath))

  const parsedPath = Path.parse(filePath)
  console.log("解析路径:", parsedPath)

  const joinedPath = Path.join('/foo', 'bar', 'baz')
  console.log("拼接路径:", joinedPath)
}

main()
```



---
url: /v2/zh/guide/Utilities/Request/FormData.md
---

# 表单数据

`FormData` 类用于构造表单数据（`multipart/form-data`），以便在网络请求中上传文本字段或文件数据。
它的行为与浏览器中的 **Fetch API FormData** 基本一致，但在 **Scripting app** 中进行了扩展以支持 `Data` 类型（原生二进制对象），从而更方便地上传文件或图片。

你可以将 `FormData` 对象直接作为 `fetch()` 请求的 `body` 参数使用。系统会自动生成带有正确边界的 `multipart/form-data` 请求体。

***

## 定义

```ts
class FormData {
  append(name: string, value: string): void
  append(name: string, value: Data, mimeType: string, filename?: string): void
  get(name: string): string | Data | null
  getAll(name: string): any[]
  has(name: string): boolean
  delete(name: string): void
  set(name: string, value: string): void
  set(name: string, value: Data, filename?: string): void
  forEach(callback: (value: any, name: string, parent: FormData) => void): void
  entries(): [string, any][]
  toJson(): Record<string, any>
}
```

***

## 主要用途

- 构造带文本与文件混合的表单请求
- 用于文件上传接口（如图片、音频、文档等）
- 代替 JSON 结构上传二进制文件或表单信息

***

## 方法说明

### `append(name: string, value: string): void`

### `append(name: string, value: Data, mimeType: string, filename?: string): void`

向表单中添加一个字段。
可以用于添加文本字段或文件数据。

#### 参数说明

| 参数           | 类型           | 说明                                            |                               |
| ------------ | ------------ | --------------------------------------------- | ----------------------------- |
| **name**     | `string`     | 字段名称。                                         |                               |
| **value**    | `string`     | `Data`                                        | 字段值，可以是字符串或 `Data` 对象（二进制文件）。 |
| **mimeType** | `string`     | 文件的 MIME 类型（如 `"image/png"`）。仅在传入 `Data` 时需要。 |                               |
| **filename** | `string`（可选） | 文件名，仅在上传文件时使用。                                |                               |

#### 示例

```tsx
const form = new FormData()
form.append("username", "Tom")
form.append("file", Data.fromFile("/path/to/image.png"), "image/png", "avatar.png")
```

***

### `set(name: string, value: string): void`

### `set(name: string, value: Data, filename?: string): void`

设置一个字段的值。
若该字段已存在，则会被覆盖。
与 `append()` 的区别是：`set()` 仅保留一个值，而 `append()` 可重复添加同名字段。

#### 示例

```tsx
const form = new FormData()
form.set("message", "Hello world")
form.set("file", Data.fromFile("/path/to/file.txt"), "text/plain", "note.txt")
```

***

### `get(name: string): string | Data | null`

获取指定字段的值。
如果字段不存在，则返回 `null`。

#### 示例

```tsx
const form = new FormData()
form.append("title", "My Post")
console.log(form.get("title")) // 输出: "My Post"
```

***

### `getAll(name: string): any[]`

获取同名字段的所有值（如果使用了多次 `append()`）。

#### 示例

```tsx
const form = new FormData()
form.append("tag", "swift")
form.append("tag", "ios")
form.append("tag", "scripting")

console.log(form.getAll("tag")) // ["swift", "ios", "scripting"]
```

***

### `has(name: string): boolean`

检查表单中是否存在指定名称的字段。

#### 示例

```tsx
const form = new FormData()
form.append("username", "Tom")

console.log(form.has("username")) // true
console.log(form.has("password")) // false
```

***

### `delete(name: string): void`

删除指定名称的字段及其所有值。

#### 示例

```tsx
const form = new FormData()
form.append("title", "Hello")
form.append("file", Data.fromFile("/path/to/file.txt"), "text/plain")

form.delete("file")
```

***

### `forEach(callback: (value: any, name: string, parent: FormData) => void): void`

遍历所有表单字段，执行回调函数。

#### 示例

```tsx
const form = new FormData()
form.append("user", "Tom")
form.append("age", "25")

form.forEach((value, name) => {
  console.log(`${name}: ${value}`)
})
```

***

### `entries(): [string, any][]`

返回一个由 `[name, value]` 组成的键值对数组。

#### 示例

```tsx
const form = new FormData()
form.append("username", "Tom")
form.append("age", "25")
console.log(form.entries())
// [["username", "Tom"], ["age", "25"]]
```

***

### `toJson(): Record<string, any>`

将表单数据转换为普通的 JavaScript 对象，用于调试或日志输出。
⚠️ 注意：如果表单中包含文件（`Data` 类型），此方法不会输出二进制内容，而是显示为占位符信息。

#### 示例

```tsx
const form = new FormData()
form.append("name", "Tom")
form.append("photo", Data.fromFile("/path/to/avatar.png"), "image/png", "avatar.png")

console.log(form.toJson())
// { name: "Tom", photo: "[Data: image/png]" }
```

***

## 使用示例

### 示例 1：上传文件

```tsx
const form = new FormData()
form.append("file", Data.fromFile("/path/to/image.png"), "image/png", "avatar.png")
form.append("userId", "1234")

const response = await fetch("https://api.example.com/upload", {
  method: "POST",
  body: form,
})

console.log(await response.json())
```

***

### 示例 2：同时上传多个文件

```tsx
const form = new FormData()
form.append("files", Data.fromFile("/path/to/photo1.jpg"), "image/jpeg", "photo1.jpg")
form.append("files", Data.fromFile("/path/to/photo2.jpg"), "image/jpeg", "photo2.jpg")

await fetch("https://api.example.com/multi-upload", {
  method: "POST",
  body: form,
})
```

***

### 示例 3：构造包含文本与文件的复合请求

```tsx
const form = new FormData()
form.append("title", "Travel Memories")
form.append("description", "A collection of my travel photos.")
form.append("cover", Data.fromFile("/path/to/cover.png"), "image/png", "cover.png")

const response = await fetch("https://example.com/uploadPost", {
  method: "POST",
  body: form,
})

console.log(await response.text())
```

***

### 示例 4：遍历并调试表单内容

```tsx
const form = new FormData()
form.append("name", "Alice")
form.append("file", Data.fromFile("/path/to/file.txt"), "text/plain", "file.txt")

form.forEach((value, name) => {
  console.log(`${name}:`, value instanceof Data ? "Binary Data" : value)
})
```

***

## 与其他类的关系

| 类名             | 说明                                                          |
| -------------- | ----------------------------------------------------------- |
| **`fetch()`**  | 可直接使用 `FormData` 实例作为请求体。系统会自动设置请求头为 `multipart/form-data`。 |
| **`Data`**     | 用于表示文件或图片等二进制内容，作为 `FormData` 字段值传入。                        |
| **`Request`**  | 可通过 `RequestInit.body` 设置 `FormData` 实例。                    |
| **`Response`** | 可使用 `response.formData()` 将响应解析为 `FormData`。                |

***

## 注意事项

- **自动设置 Content-Type**：使用 `FormData` 时，`fetch()` 会自动设置正确的 `Content-Type`（带边界）。不要手动覆盖。
- **同名字段**：支持使用 `append()` 为同一字段名添加多个值。
- **文件上传**：上传文件时需传入 MIME 类型，否则默认可能被识别为 `application/octet-stream`。
- **JSON 转换限制**：`toJson()` 仅用于调试显示，不适合用于真实数据传输。

***

## 小结

`FormData` 是 **Scripting 网络请求体系中用于构造 multipart/form-data 请求的核心类**，具备以下特性：

- 支持文本与文件混合上传
- 与 `fetch()` 无缝集成
- 支持 `Data` 类型文件传递
- 提供便利的 `forEach()`、`entries()`、`toJson()` 等辅助方法
- 完全兼容 Web 标准的 FormData 行为



---
url: /v2/zh/guide/Utilities/Request/Headers.md
---

# 请求头（Headers）

`Headers` 类用于管理 HTTP 请求与响应的头部信息。
它与浏览器 Fetch API 中的同名类保持一致，但在 **Scripting** 环境中提供了更友好的接口方法和 JSON 化能力，以方便脚本中对网络请求进行调试与序列化。

`Headers` 对象可以在以下场景中使用：

- 构造请求时，通过 `RequestInit.headers` 设置请求头
- 从 `Response.headers` 中读取响应头
- 在脚本逻辑中动态添加、修改或删除头部字段

***

## 定义

```ts
class Headers {
  constructor(init?: HeadersInit)
  append(name: string, value: string): void
  get(name: string): string | null
  has(name: string): boolean
  set(name: string, value: string): void
  delete(name: string): void
  forEach(callback: (value: string, name: string) => void): void
  keys(): string[]
  values(): string[]
  entries(): [string, string][]
  toJson(): Record<string, string>
}
```

***

## HeadersInit 类型

`Headers` 的构造函数支持多种初始化格式：

```ts
type HeadersInit = [string, string][] | Record<string, string> | Headers
```

你可以使用以下任意形式创建头部对象：

```tsx
new Headers([["Content-Type", "application/json"]])
new Headers({ "Authorization": "Bearer token" })
new Headers(existingHeaders)
```

***

## 构造函数

### `new Headers(init?: HeadersInit)`

创建一个新的 `Headers` 对象。
可选参数 `init` 用于以已有的头部结构初始化实例。

#### 参数说明

| 参数       | 类型            | 说明                               |
| -------- | ------------- | -------------------------------- |
| **init** | `HeadersInit` | 初始头部数据，可为对象、数组或另一个 `Headers` 实例。 |

***

## 方法说明

### `append(name: string, value: string): void`

向头部中添加一个字段。如果该字段已存在，则追加新的值（不会覆盖旧值）。

#### 示例

```tsx
const headers = new Headers()
headers.append("Accept", "application/json")
headers.append("Accept", "text/plain") // 此时 Accept 拥有两个值
```

***

### `set(name: string, value: string): void`

设置一个头部字段。如果该字段已存在，则会覆盖旧值。

#### 示例

```tsx
const headers = new Headers()
headers.set("Content-Type", "application/json")
headers.set("Authorization", "Bearer token-123")
```

***

### `get(name: string): string | null`

获取指定头部字段的值。
若字段不存在，返回 `null`。

#### 示例

```tsx
const headers = new Headers({ "Content-Type": "application/json" })
console.log(headers.get("Content-Type")) // 输出: application/json
```

***

### `has(name: string): boolean`

判断指定字段是否存在。

#### 示例

```tsx
const headers = new Headers({ "Accept": "application/json" })
console.log(headers.has("Accept")) // true
console.log(headers.has("Authorization")) // false
```

***

### `delete(name: string): void`

删除指定的头部字段。

#### 示例

```tsx
const headers = new Headers({ "Accept": "application/json", "Cache-Control": "no-cache" })
headers.delete("Cache-Control")
```

***

### `forEach(callback: (value: string, name: string) => void): void`

遍历所有头部字段并执行回调。

#### 示例

```tsx
const headers = new Headers({
  "Accept": "application/json",
  "User-Agent": "ScriptingApp/1.0"
})

headers.forEach((value, name) => {
  console.log(`${name}: ${value}`)
})
```

***

### `keys(): string[]`

返回所有头部名称的数组。

```tsx
const headers = new Headers({ "Accept": "application/json", "User-Agent": "Scripting" })
console.log(headers.keys()) // ["accept", "user-agent"]
```

> 注意：头部字段名不区分大小写，返回的名称将被标准化为小写。

***

### `values(): string[]`

返回所有头部字段的值数组。

```tsx
const headers = new Headers({ "Accept": "application/json", "User-Agent": "Scripting" })
console.log(headers.values()) // ["application/json", "Scripting"]
```

***

### `entries(): [string, string][]`

以键值对数组形式返回所有头部字段。

#### 示例

```tsx
const headers = new Headers({ "Accept": "application/json", "Cache-Control": "no-cache" })
console.log(headers.entries())
// [["accept", "application/json"], ["cache-control", "no-cache"]]
```

***

### `toJson(): Record<string, string>`

将所有头部字段转换为普通对象格式，方便序列化或调试输出。

#### 示例

```tsx
const headers = new Headers({
  "Content-Type": "application/json",
  "Authorization": "Bearer token"
})

console.log(headers.toJson())
// { "content-type": "application/json", "authorization": "Bearer token" }
```

***

## 使用示例

### 示例 1：在请求中设置自定义 Headers

```tsx
const headers = new Headers()
headers.set("Content-Type", "application/json")
headers.set("Authorization", "Bearer token-xyz")

const response = await fetch("https://api.example.com/user", {
  method: "POST",
  headers,
  body: JSON.stringify({ name: "Tom" })
})
```

***

### 示例 2：读取响应头部信息

```tsx
const response = await fetch("https://example.com/data")
console.log("Content-Type:", response.headers.get("Content-Type"))
console.log("Server:", response.headers.get("Server"))
```

***

### 示例 3：转换为 JSON 用于日志或持久化

```tsx
const response = await fetch("https://example.com/api")
console.log("Response Headers:", response.headers.toJson())
```

***

### 示例 4：判断响应是否包含特定字段

```tsx
const response = await fetch("https://example.com/info")
if (response.headers.has("Set-Cookie")) {
  console.log("响应包含 Cookie 设置")
}
```

***

## 与其他类的关系

| 类名             | 说明                                               |
| -------------- | ------------------------------------------------ |
| **`Request`**  | 通过 `RequestInit.headers` 设置请求头。                  |
| **`Response`** | 可通过 `response.headers` 访问响应头。                    |
| **`fetch()`**  | 请求与响应过程都会使用 `Headers` 实例来封装头部数据。                 |
| **`Cookie`**   | 与 `Set-Cookie` 头对应的解析结果在 `response.cookies` 中访问。 |

***

## 注意事项

- **字段名大小写不敏感**：所有头部名称在内部会被标准化为小写形式。
- **多值字段处理**：使用 `append()` 方法可以为同一字段添加多个值，例如用于 `Accept` 或 `Cookie` 等字段。
- **安全性**：某些系统保留字段（如 `Host`、`Connection`）可能会被 iOS 网络层忽略或重写。
- **序列化输出**：使用 `toJson()` 可便于调试或日志记录，不影响实际请求头发送。

***

## 小结

`Headers` 是 **Scripting 网络请求体系** 中的基础组件之一，提供了灵活的接口来：

- 添加、修改或删除 HTTP 头部
- 以多种方式读取与遍历响应头
- 在脚本环境中实现与 Web 标准一致的行为
- 支持 JSON 化与日志输出



---
url: /v2/zh/guide/Utilities/Request/ReadableStream.md
---

# 可读流

`ReadableStream` 表示一个 **可读的数据流（data stream）**，用于逐步读取数据而不是一次性加载全部内容。
在 **Scripting app** 中，`ReadableStream<Data>` 通常用于：

- 处理网络响应中的流式数据（如 `Response.body`）
- 实现大文件的分块读取或实时下载
- 支持长连接或持续推送的数据（如 SSE、分块 JSON、日志流）

与标准 Web API 一致，Scripting 的 `ReadableStream` 允许异步迭代（`for await...of`）以及通过读取器 (`ReadableStreamDefaultReader`) 手动读取流内容。

***

## 定义

```ts
class ReadableStream<T = any> {
  constructor(underlyingSource?: UnderlyingSource<T>)

  get locked(): boolean
  cancel(reason?: any): Promise<void>
  getReader(): ReadableStreamDefaultReader<T>
  tee(): [ReadableStream<T>, ReadableStream<T>]
}
```

***

## 基本概念

- `ReadableStream` 代表一个“流式可消费的数据源”。
- 它不会立即持有全部数据，而是按需从源（网络、文件、生成器等）获取。
- 每个流只能由一个读取器（reader）读取，一旦被锁定 (`locked = true`)，必须释放或取消后才能再次读取。

***

## 属性说明

### `locked: boolean`

指示当前流是否已被读取器（reader）锁定。
若为 `true`，则其他代码无法再调用 `getReader()` 或消费该流。

#### 示例

```tsx
const reader = response.body.getReader()
console.log(response.body.locked) // true
```

***

## 方法说明

### `getReader(): ReadableStreamDefaultReader<T>`

返回一个 `ReadableStreamDefaultReader` 实例，用于逐步读取流中的数据块（chunk）。
每次调用 `reader.read()` 会返回一个 Promise，解析为 `{ value, done }` 对象。

#### 示例

```tsx
const reader = response.body.getReader()

while (true) {
  const { done, value } = await reader.read()
  if (done) break
  console.log("Received chunk:", value)
}
```

***

### `cancel(reason?: any): Promise<void>`

取消流的读取操作。
传入的 `reason` 可用于描述取消原因。

#### 示例

```tsx
const reader = response.body.getReader()
await response.body.cancel("User aborted reading")
```

***

### `tee(): [ReadableStream<T>, ReadableStream<T>]`

将当前流复制成两个新的流。
每个分支都可独立消费数据，但需注意内存开销。

#### 示例

```tsx
const [stream1, stream2] = response.body.tee()

const reader1 = stream1.getReader()
const reader2 = stream2.getReader()
```

***

## ReadableStreamDefaultReader（读取器）

当通过 `getReader()` 获取读取器后，你可以手动控制数据的读取过程。

### 读取器定义

```ts
interface ReadableStreamDefaultReader<T> {
  read(): Promise<{ value: T; done: boolean }>
  releaseLock(): void
  cancel(reason?: any): Promise<void>
}
```

#### 方法说明：

| 方法                  | 说明                                                           |
| ------------------- | ------------------------------------------------------------ |
| **read()**          | 读取下一个数据块（chunk），返回 `{ value, done }`。当 `done = true` 时，流已结束。 |
| **releaseLock()**   | 释放读取器，使流可被其他消费者重新读取。                                         |
| **cancel(reason?)** | 取消流读取。                                                       |

#### 示例：读取响应流数据

```tsx
const reader = response.body.getReader()

while (true) {
  const { done, value } = await reader.read()
  if (done) break

  // 处理每个 Data 对象（chunk）
  const text = value.toRawString()
  console.log("Chunk:", text)
}

reader.releaseLock()
```

***

## 与 `Response` 的关系

`Response.body` 属性是一个 `ReadableStream<Data>`，可用于流式读取响应内容。

### 示例：实时处理网络响应

```tsx
const response = await fetch("https://example.com/stream")

const reader = response.body.getReader()
while (true) {
  const { done, value } = await reader.read()
  if (done) break
  console.log("Received:", value.toRawString())
}
```

这种方式可在 **响应尚未完全结束时** 实时处理部分数据，非常适合：

- 实时日志输出
- 大文件下载进度控制
- AI/LLM 流式生成内容（如 ChatGPT 的逐字输出）

***

## 与 `Data` 的关系

在 `Scripting` 中，流的每个块（chunk）通常是一个 `Data` 实例。
你可以使用 `Data` 提供的方法（如 `.toRawString()`、`.toUint8Array()`）读取或转换二进制内容。

#### 示例：将流数据保存到文件

```tsx
const reader = response.body.getReader()
const chunks: Data[] = []

while (true) {
  const { done, value } = await reader.read()
  if (done) break
  chunks.push(value)
}

const fileData = Data.combine(chunks)
FileManager.write(fileData, "/local/download.bin")
```

***

## 示例：使用异步迭代器读取流

`ReadableStream` 支持异步迭代 (`for await...of`)，可简化读取逻辑：

```tsx
for await (const chunk of response.body) {
  console.log("Chunk size:", chunk.size)
}
```

此语法会自动处理 `done` 状态，代码更简洁直观。

***

## 使用场景

| 场景           | 示例                            |
| ------------ | ----------------------------- |
| **大文件下载**    | 按块读取网络响应并写入本地文件，避免内存占用过大。     |
| **AI 输出流接收** | 实时接收服务器的推送内容（如 ChatGPT 流式响应）。 |
| **本地流式处理**   | 对本地文件或输入流实现增量读取或实时处理。         |

***

## 注意事项

- **单次锁定**：一个 `ReadableStream` 在被读取器锁定后，不能被多个消费者同时读取。
- **内存管理**：流式处理有助于降低内存占用，但应及时释放或取消读取器以防资源泄漏。
- **错误处理**：读取过程中出现错误（如网络断开）会导致 `read()` Promise 拒绝，应使用 `try...catch` 捕获。
- **Data 类型约定**：在 `Response.body` 中，流的每个块类型为 `Data`，而不是普通字符串或字节数组。

***

## 小结

`ReadableStream` 是 **Scripting 数据流架构的核心组件**，为开发者提供了高效的流式数据读取方式：

- 支持异步逐块读取
- 可与 `fetch()`、`Response`、`Data` 无缝集成
- 适用于实时处理、分块下载、长连接流等高级场景
- 完全兼容 Web 标准的 Streams API



---
url: /v2/zh/guide/Utilities/Request/Request & RequestInit.md
---

`Request` 类表示一次 HTTP 请求的完整配置。
它可作为 `fetch()` 方法的参数使用，也可用于克隆、修改或重试请求。

在 Scripting 中，`Request` 的行为与浏览器 Fetch API 中的同名接口一致，但额外支持了原生扩展功能，包括：

- 支持二进制 `Data` 类型作为请求体
- 支持自定义重定向处理
- 支持请求超时、取消、与调试标签
- 支持允许不安全请求（HTTP 请求）

***

## 类定义

```ts
class Request {
  url: string
  method: string
  headers: Headers
  body?: Data | FormData | string | ArrayBuffer
  allowInsecureRequest?: boolean
  handleRedirect?: (newRequest: RedirectRequest) => Promise<RedirectRequest | null>
  shouldAllowRedirect?: (newRequest: Request) => Promise<boolean> // 已废弃
  timeout?: DurationInSeconds
  signal?: AbortSignal
  cancelToken?: CancelToken // 已废弃
  debugLabel?: string

  constructor(input: string | Request, init?: RequestInit)
  clone(): Request
}
```

***

## 构造函数

### `new Request(input: string | Request, init?: RequestInit)`

创建一个新的 `Request` 实例。
可通过字符串 URL 或现有的 `Request` 对象来构造。

#### 参数

| 参数        | 类型            | 说明                       |                                 |
| --------- | ------------- | ------------------------ | ------------------------------- |
| **input** | `string`      | `Request`                | 要请求的 URL，或一个现有的 Request 对象用于克隆。 |
| **init**  | `RequestInit` | 可选的初始化参数，用于配置请求的行为（见下文）。 |                                 |

***

## 属性

| 属性名                      | 类型                                                                  | 说明                                              |
| ------------------------ | ------------------------------------------------------------------- | ----------------------------------------------- |
| **url**                  | `string`                                                            | 请求的完整 URL。                                      |
| **method**               | `string`                                                            | 请求方法（默认 `"GET"`）。                               |
| **headers**              | `Headers`                                                           | 请求头部对象，可通过 `.get()`、`.set()`、`.append()` 等方法操作。 |
| **body**                 | `Data` \| `FormData` \| `string` \| `ArrayBuffer` \| `undefined`    | 请求体，仅用于非 `GET` 或 `HEAD` 请求。                     |
| **allowInsecureRequest** | `boolean`                                                           | 是否允许使用 HTTP 明文请求（默认 `false`）。                   |
| **handleRedirect**       | `(newRequest: RedirectRequest) => Promise<RedirectRequest \| null>` | 自定义重定向逻辑；返回 `null` 表示阻止重定向。                     |
| **shouldAllowRedirect**  | `(newRequest: Request) => Promise<boolean>`                         | 已废弃。旧版重定向控制回调。                                  |
| **timeout**              | `number`                                                            | 请求超时时间（单位：秒）。超时会自动中止请求。                         |
| **signal**               | `AbortSignal`                                                       | 用于中止请求的信号，由 `AbortController` 创建。               |
| **cancelToken**          | `CancelToken`                                                       | 已废弃。旧版取消机制，请改用 `signal`。                        |
| **debugLabel**           | `string`                                                            | 调试标签，会在日志面板中显示以方便追踪。                            |

***

## 方法

### `clone(): Request`

创建并返回当前请求对象的副本。
克隆后的对象可安全修改其属性（如 headers、body）而不影响原始请求。

#### 示例

```tsx
const req1 = new Request("https://api.example.com/user", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name: "Alice" })
})

const req2 = req1.clone()
console.log(req2.method) // "POST"
```

***

## 使用示例

### 示例 1：创建一个简单的 Request 对象

```tsx
const request = new Request("https://api.example.com/data", {
  method: "GET",
  headers: {
    "Accept": "application/json",
  },
  debugLabel: "Fetch User Data"
})

const response = await fetch(request)
const result = await response.json()
console.log(result)
```

***

### 示例 2：带请求体的 POST 请求

```tsx
const request = new Request("https://api.example.com/upload", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ fileId: "abc123" }),
  timeout: 15,
})

const response = await fetch(request)
console.log(await response.text())
```

***

### 示例 3：克隆并修改请求

```tsx
const base = new Request("https://api.example.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
})

const cloned = base.clone()
cloned.headers.set("Authorization", "Bearer token-123")
cloned.debugLabel = "Authorized Upload"

await fetch(cloned)
```

***

# RequestInit 类型

`RequestInit` 是一个用于配置请求参数的对象类型，常用于 `fetch()` 或 `Request` 构造函数中。
它与浏览器的标准 Fetch API 相同，但 Scripting 扩展了若干字段。

***

## 类型定义

```ts
type RequestInit = {
  method?: string
  headers?: HeadersInit
  body?: Data | FormData | string | ArrayBuffer
  allowInsecureRequest?: boolean
  handleRedirect?: (newRequest: RedirectRequest) => Promise<RedirectRequest | null>
  shouldAllowRedirect?: (newRequest: Request) => Promise<boolean> // 已废弃
  timeout?: DurationInSeconds
  signal?: AbortSignal
  cancelToken?: CancelToken // 已废弃
  debugLabel?: string
}
```

***

## 字段说明

| 字段名                      | 类型                                                                  | 说明                                                                 |   |
| ------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------ | - |
| **method**               | `string`                                                            | HTTP 方法，如 `"GET"`, `"POST"`, `"PUT"`, `"DELETE"`，默认 `"GET"`。       |   |
| **headers**              | `HeadersInit`                                                       | 请求头部信息，可以是：`Headers` 对象、普通对象 `{key: value}`、或 `[key, value][]` 数组。 |   |
| **body**                 | `Data` \| `FormData` \| `string` \| `ArrayBuffer`                   | 请求体，仅在非 `GET` / `HEAD` 请求中使用。                                      |   |
| **allowInsecureRequest** | `boolean`                                                           | 是否允许发送 HTTP 请求。默认 `false`。                                         |   |
| **handleRedirect**       | `(newRequest: RedirectRequest) => Promise<RedirectRequest \| null>` | 自定义重定向回调。返回新的请求对象以继续，返回 `null` 以阻止跳转。                              |   |
| **shouldAllowRedirect**  | `(newRequest: Request) => Promise<boolean>`                         | 已废弃。旧的布尔型重定向控制回调。                                                  |   |
| **timeout**              | `number`                                                            | 请求超时时间（秒），超时后会自动中止请求。                                              |   |
| **signal**               | `AbortSignal`                                                       | 中止信号，可由 `AbortController` 触发，用于主动取消请求。                             |   |
| **cancelToken**          | `CancelToken`                                                       | 已废弃。旧版取消机制，请使用 `signal` 替代。                                        |   |
| **debugLabel**           | `string`                                                            | 调试标签，在日志面板中显示，用于标识请求。                                              |   |

***

## 与 `fetch()` 的关系

`RequestInit` 是 `fetch()` 的第二个参数，用于定义请求配置：

```tsx
const response = await fetch("https://example.com/data", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ id: 123 }),
  timeout: 10,
  debugLabel: "Upload JSON",
})
```

***

## 与其他类的关系

| 类名                                    | 用途                                           |
| ------------------------------------- | -------------------------------------------- |
| **`Headers`**                         | 管理请求头部的集合，可与 `headers` 字段一起使用。               |
| **`Data`**                            | 表示二进制数据，可作为请求体（body）上传文件或原始字节数据。             |
| **`FormData`**                        | 用于构造 multipart/form-data 表单请求。               |
| **`AbortController` / `AbortSignal`** | 用于在请求过程中主动取消网络操作。                            |
| **`CancelToken`**                     | 旧版取消机制，仅为兼容保留。                               |
| **`RedirectRequest`**                 | 当发生重定向时传入 `handleRedirect` 回调的参数，包含新请求的详细信息。 |

***

## 示例

### 示例 1：使用自定义重定向回调

```tsx
const response = await fetch("https://example.com/start", {
  handleRedirect: async (newRequest) => {
    console.log("收到重定向:", newRequest.url)
    if (newRequest.url.includes("blocked")) return null
    return newRequest
  },
})
```

***

### 示例 2：允许不安全请求

```tsx
const response = await fetch("http://insecure.example.com/data", {
  allowInsecureRequest: true,
})
console.log(await response.text())
```

***

### 示例 3：带调试标签的请求

```tsx
await fetch("https://example.com/api/ping", {
  debugLabel: "Ping Request",
})
// 调试面板中将显示标签 “Ping Request”
```

***

以下是 **`handleRedirect` 回调中 `RedirectRequest` 接口的中文说明文档**，可直接插入至 `Request` 类文档的相关部分，用于解释自定义重定向逻辑的参数结构和用法。

***

## RedirectRequest 接口说明

当请求发生 **重定向 (Redirect)** 时，若在 `Request` 或 `RequestInit` 中设置了 `handleRedirect` 回调函数，系统会在跳转前调用该回调。
`handleRedirect` 的参数类型为 `RedirectRequest`，用于描述即将执行的重定向请求的完整信息。
你可以在回调中检查该对象的属性，并决定是否允许继续重定向，或修改请求后再继续。

***

### 接口定义

```ts
interface RedirectRequest {
  method: string
  url: string
  headers: Record<string, string>
  cookies: Cookie[]
  body?: Data
  timeout?: number
}
```

***

### 字段说明

| 字段          | 类型                       | 说明                                            |
| ----------- | ------------------------ | --------------------------------------------- |
| **method**  | `string`                 | 即将执行的重定向请求方法（例如 `"GET"`、`"POST"`）。            |
| **url**     | `string`                 | 重定向目标的完整 URL。                                 |
| **headers** | `Record<string, string>` | 该重定向请求的 HTTP 头部信息。你可以根据需要修改或记录这些头部。           |
| **cookies** | `Cookie[]`               | 当前请求中携带的 Cookie 列表，类型与 `Response.cookies` 一致。 |
| **body**    | `Data`（可选）               | 若为非 `GET` 请求，则包含请求体数据（例如表单或二进制数据）。            |
| **timeout** | `number`（可选）             | 请求的超时时间（单位：秒）。                                |

***

### 使用场景

通过 `handleRedirect` 回调，你可以：

- 检查重定向目标地址是否安全或符合业务逻辑。
- 修改重定向请求（如添加自定义头部、调整方法或携带 Token）。
- 阻止不必要或可疑的重定向。

当回调返回：

- 一个 `RedirectRequest` 对象 → 表示允许重定向，并使用你返回的对象继续请求。
- `null` → 表示阻止此次重定向，`fetch()` 将在当前响应结束。

***

### 示例：拦截与控制重定向请求

```tsx
const response = await fetch("https://example.com/start", {
  handleRedirect: async (redirect) => {
    console.log("即将重定向至:", redirect.url)

    // 如果跳转到外部域名，则阻止
    if (!redirect.url.startsWith("https://example.com")) {
      console.warn("阻止外部重定向:", redirect.url)
      return null
    }

    // 向重定向请求添加授权头
    redirect.headers["Authorization"] = "Bearer my-token"
    return redirect
  },
})
```

***

### 示例：修改重定向请求方法与体

```tsx
const response = await fetch("https://api.example.com/login", {
  handleRedirect: async (redirect) => {
    // 如果重定向目标为 POST 接口，则保持原始请求体
    if (redirect.url.includes("/finalize")) {
      redirect.method = "POST"
      redirect.body = Data.fromRawString("action=confirm", "utf-8")
    }
    return redirect
  },
})
```

***

### 注意事项

- 若未设置 `handleRedirect`，所有重定向将默认自动执行。
- 若设置了 `handleRedirect` 且返回 `null`，`fetch()` 不会继续跳转。
- 该机制不会自动携带 Cookie，需要手动在 `RedirectRequest.cookies` 中读取并决定是否传递。
- 修改 `RedirectRequest` 返回后，系统会基于修改后的内容重新发起请求。

***

## 小结

`Request` 与 `RequestInit` 是 **Scripting 网络请求系统的核心基础**：

- `Request` 封装了完整的 HTTP 请求对象，可复用、克隆与传递。
- `RequestInit` 定义请求参数，提供灵活的初始化方式。
- 二者与 `fetch()`、`Response`、`Headers`、`Data`、`FormData` 等类型紧密配合。



---
url: /v2/zh/guide/Utilities/Request/Response.md
---

# 响应 （Response）

`Response` 类表示通过 `fetch()` 方法发起的网络请求返回的响应结果。
它提供了访问响应体（body）、头部（headers）、状态码、MIME 类型、以及服务器返回的 Cookies 的接口。

在 **Scripting app** 中，`Response` 的设计基于标准 Fetch API，但进行了原生扩展，支持：

- 原生级 **Cookie 访问与解析**
- **二进制数据 (`Data`)** 支持
- **流式响应 (`ReadableStream<Data>`)** 读取
- 响应的 MIME 类型、编码信息与预期长度
- 完整兼容标准 Web Fetch 行为

***

## 定义

```ts
class Response {
  readonly body: ReadableStream<Data>
  
  constructor(body: ReadableStream<Data>, init?: ResponseInit)

  get bodyUsed(): boolean
  get cookies(): Cookie[]
  json(): Promise<any>
  text(): Promise<string>
  data(): Promise<Data>
  bytes(): Promise<Uint8Array>
  arrayBuffer(): Promise<ArrayBuffer>
  formData(): Promise<FormData>
  get status(): number
  get statusText(): string
  get headers(): Headers
  get ok(): boolean
  get url(): string
  get mimeType(): string | undefined
  get expectedContentLength(): number | undefined
  get textEncodingName(): string | undefined
}
```

***

## 属性说明

| 属性                        | 类型                     | 说明                                   |
| ------------------------- | ---------------------- | ------------------------------------ |
| **body**                  | `ReadableStream<Data>` | 响应体数据的可读流。                           |
| **bodyUsed**              | `boolean`              | 指示响应体是否已被读取。                         |
| **cookies**               | `Cookie[]`             | 服务器通过 `Set-Cookie` 返回的 Cookie 列表。    |
| **status**                | `number`               | HTTP 状态码（如 `200`、`404`、`500`）。       |
| **statusText**            | `string`               | 状态描述（如 `"OK"`、`"Not Found"`）。        |
| **headers**               | `Headers`              | 响应头对象。                               |
| **ok**                    | `boolean`              | 当状态码在 200–299 范围内时为 `true`。          |
| **url**                   | `string`               | 响应的最终 URL（可能经过重定向）。                  |
| **mimeType**              | `string \| undefined`  | 响应的 MIME 类型（如 `"application/json"`）。 |
| **expectedContentLength** | `number \| undefined`  | 响应体的预期长度（字节），由服务器提供。                 |
| **textEncodingName**      | `string \| undefined`  | 文本编码方式（如 `"utf-8"`）。                 |

***

## 方法说明

### `json(): Promise<any>`

将响应体解析为 JSON 对象。

#### 示例

```tsx
const response = await fetch("https://api.example.com/user")
const data = await response.json()
console.log(data.name)
```

***

### `text(): Promise<string>`

将响应体读取为字符串。
默认使用 UTF-8 编码，若服务器返回了编码信息则自动识别。

#### 示例

```tsx
const response = await fetch("https://example.com/message.txt")
const text = await response.text()
console.log(text)
```

***

### `data(): Promise<Data>`

将响应体读取为二进制数据对象 `Data`，适合文件下载、图片处理、或转换为 Base64。

#### 示例

```tsx
const response = await fetch("https://example.com/image.png")
const imageData = await response.data()
FileManager.write(imageData, "/local/image.png")
```

***

### `bytes(): Promise<Uint8Array>`

将响应体读取为字节数组。

#### 示例

```tsx
const response = await fetch("https://example.com/file.bin")
const bytes = await response.bytes()
console.log("Received", bytes.length, "bytes")
```

***

### `arrayBuffer(): Promise<ArrayBuffer>`

将响应体读取为 `ArrayBuffer`，适合进行底层二进制操作。

#### 示例

```tsx
const response = await fetch("https://example.com/file")
const buffer = await response.arrayBuffer()
console.log(buffer.byteLength)
```

***

### `formData(): Promise<FormData>`

将响应体解析为 `FormData`（适用于 `multipart/form-data` 类型的响应）。

#### 示例

```tsx
const response = await fetch("https://example.com/form")
const form = await response.formData()
console.log(form.get("username"))
```

***

## Cookies 支持

### `cookies: Cookie[]`

Scripting 的 `Response` 支持直接访问服务器返回的 `Set-Cookie` 信息。
返回值为一个 `Cookie` 对象数组，每个元素包含完整的 Cookie 元数据。

#### Cookie 类型定义

```ts
interface Cookie {
  name: string
  value: string
  domain: string
  path: string
  isSecure: boolean
  isHTTPOnly: boolean
  isSessionOnly: boolean
  expiresDate?: Date | null
}
```

| 字段                | 类型             | 说明                     |
| ----------------- | -------------- | ---------------------- |
| **name**          | `string`       | Cookie 名称。             |
| **value**         | `string`       | Cookie 值。              |
| **domain**        | `string`       | 所属域名。                  |
| **path**          | `string`       | 作用路径。                  |
| **isSecure**      | `boolean`      | 是否仅通过 HTTPS 发送。        |
| **isHTTPOnly**    | `boolean`      | 是否为 HTTP-only，无法被脚本访问。 |
| **isSessionOnly** | `boolean`      | 是否为会话 Cookie（无过期时间）。   |
| **expiresDate**   | `Date \| null` | 过期时间（若有设置）。            |

***

### 示例：读取响应中的 Cookies

```tsx
const response = await fetch("https://example.com/login")
for (const cookie of response.cookies) {
  console.log(`${cookie.name} = ${cookie.value}`)
}
```

***

### 示例：手动管理 Cookie（跨请求复用）

默认情况下，**Scripting 的 `fetch()` 不会自动存储或携带 Cookie**。
如果希望在多次请求中复用 Cookie，可以手动拼接 `Cookie` 头：

```tsx
const response = await fetch("https://example.com/login")
const cookies = response.cookies
const cookieHeader = cookies.map(c => `${c.name}=${c.value}`).join("; ")

const next = await fetch("https://example.com/dashboard", {
  headers: { "Cookie": cookieHeader },
})
```

这种方式让开发者能够像浏览器开发者工具一样 **完全掌控 Cookie 的发送与存储**。

***

## 与其他类的关系

| 类名             | 说明                                |
| -------------- | --------------------------------- |
| **`Request`**  | 表示生成此响应的请求对象。                     |
| **`Headers`**  | 用于访问响应头部信息。                       |
| **`Data`**     | 表示响应体的二进制数据。                      |
| **`FormData`** | 表示 `multipart/form-data` 格式的表单响应。 |
| **`Cookie`**   | 表示服务器返回的单个 Cookie 对象。             |

***

## 使用示例

### 示例 1：处理 JSON API 响应

```tsx
const response = await fetch("https://api.example.com/profile")
if (response.ok) {
  const user = await response.json()
  console.log(user.email)
} else {
  console.log("请求失败:", response.status, response.statusText)
}
```

***

### 示例 2：下载文件并保存

```tsx
const response = await fetch("https://example.com/photo.jpg")
const fileData = await response.data()
FileManager.write(fileData, "/local/photo.jpg")
```

***

### 示例 3：读取服务器返回的 Cookies

```tsx
const response = await fetch("https://example.com/login")
for (const cookie of response.cookies) {
  console.log(`Cookie: ${cookie.name} = ${cookie.value}`)
}
```

***

### 示例 4：跨请求手动复用 Cookies

```tsx
const loginResponse = await fetch("https://example.com/login", {
  method: "POST",
  body: JSON.stringify({ username: "Tom", password: "1234" }),
  headers: { "Content-Type": "application/json" },
})

// 读取 Cookie 并拼接成请求头
const cookieHeader = loginResponse.cookies.map(c => `${c.name}=${c.value}`).join("; ")

// 携带 Cookie 发起新请求
const dashboard = await fetch("https://example.com/dashboard", {
  headers: { "Cookie": cookieHeader },
})
console.log(await dashboard.text())
```

***

### 示例 5：读取响应的元信息

```tsx
const response = await fetch("https://example.com/video.mp4")
console.log("MIME 类型:", response.mimeType)
console.log("预期长度:", response.expectedContentLength)
```

***

## 小结

`Response` 是 Scripting 网络请求体系中最核心的组成部分之一，具有以下特性：

- 完整兼容标准 Fetch API 行为
- 新增 **原生 Cookie 访问与控制** 能力
- 支持 `Data` 类型的 **二进制数据处理**
- 支持响应流式读取、MIME 类型、编码与长度信息
- 可与 `Request`、`Headers`、`FormData`、`AbortController` 等类型无缝配合



---
url: /v2/zh/guide/Utilities/Request/fetch.md
---

# fetch 函数

`fetch()` 是用于发起 HTTP/HTTPS 网络请求的通用方法，返回一个表示响应 (`Response`) 的 Promise。
它在 Scripting 中的行为与浏览器标准 Fetch API 基本一致，但进行了原生增强以更好地支持 iOS 本地运行环境（包括文件请求、Data 对象、FormData 上传、可控重定向、信号中止与调试标签等）。

***

## 方法定义

```ts
function fetch(url: string, init?: RequestInit): Promise<Response>
function fetch(request: Request): Promise<Response>
```

***

## 参数说明

### 1. `url: string`

要请求的资源地址。
可以是：

- 网络地址（例如 `"https://api.example.com/data"`）
- 本地文件 URL（例如 `"file:///var/mobile/Containers/Data/Application/..."`）

***

### 2. `init?: RequestInit`

可选配置对象，用于自定义请求方法、头部、正文、超时、信号等。
定义如下：

```ts
type RequestInit = {
  method?: string;
  headers?: HeadersInit;
  body?: Data | FormData | string | ArrayBuffer;
  allowInsecureRequest?: boolean;
  handleRedirect?: (newRequest: RedirectRequest) => Promise<RedirectRequest | null>;
  shouldAllowRedirect?: (newRequest: Request) => Promise<boolean>; // 已废弃
  timeout?: number; // 秒
  signal?: AbortSignal;
  cancelToken?: CancelToken; // 已废弃
  debugLabel?: string;
}
```

#### 参数详解：

| 参数                       | 类型                                                                  | 说明                                                               |   |
| ------------------------ | ------------------------------------------------------------------- | ---------------------------------------------------------------- | - |
| **method**               | `string`                                                            | 请求方法，如 `"GET"`, `"POST"`, `"PUT"`, `"DELETE"`。默认为 `"GET"`。       |   |
| **headers**              | `HeadersInit`                                                       | 请求头，可以是 `Headers` 实例、键值对象或 `[key, value]` 数组。                    |   |
| **body**                 | `Data` \| `FormData` \| `string` \| `ArrayBuffer`                   | 请求正文，仅对非 GET/HEAD 请求有效。                                          |   |
| **allowInsecureRequest** | `boolean`                                                           | 允许通过 HTTP 发送请求。默认 `false`。如果主进程运行在 HTTPS 环境下而 URL 为 HTTP，需要显式启用。 |   |
| **handleRedirect**       | `(newRequest: RedirectRequest) => Promise<RedirectRequest \| null>` | 自定义重定向处理逻辑。如果返回 `null`，则阻止重定向。                                   |   |
| **shouldAllowRedirect**  | `(newRequest: Request) => Promise<boolean>`                         | 已废弃，用于兼容旧版重定向判断。                                                 |   |
| **timeout**              | `number`                                                            | 请求超时时间（秒）。超时将抛出 `AbortError`。                                    |   |
| **signal**               | `AbortSignal`                                                       | 可通过 `AbortController` 控制的中止信号，用于主动取消请求。                          |   |
| **cancelToken**          | `CancelToken`                                                       | 已废弃，用于取消请求的旧机制。建议改用 `signal`。                                    |   |
| **debugLabel**           | `string`                                                            | 调试标签，会显示在日志面板中，方便识别请求来源。                                         |   |

***

## 返回值

返回一个 `Promise<Response>` 对象。

`Response` 表示请求的响应数据。
即使返回的 HTTP 状态码为 4xx 或 5xx，`fetch` 仍然会 **成功解析并返回 Response 对象**。
只有当请求本身出错（如网络错误、无效 URL、超时、中止）时，Promise 才会被拒绝。

***

## 异常与错误处理

以下情况会触发 `Promise` 拒绝：

| 错误类型         | 抛出条件                             |
| ------------ | -------------------------------- |
| `TypeError`  | URL 无效、协议不受支持或请求体类型不兼容。          |
| `AbortError` | 请求被 `AbortController` 主动中止或超时触发。 |

***

## 示例

### 示例 1：基础 GET 请求

```tsx
const response = await fetch("https://api.example.com/data")
if (response.ok) {
  const json = await response.json()
  console.log(json)
} else {
  console.log("请求失败:", response.status)
}
```

***

### 示例 2：POST 请求（JSON）

```tsx
const response = await fetch("https://api.example.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Hello", content: "World" }),
})
const result = await response.json()
console.log(result)
```

***

### 示例 3：上传文件（FormData）

```tsx
const form = new FormData()
form.append("file", Data.fromFile("/path/to/image.png"), "image/png", "image.png")
form.append("user", "Tom")

const response = await fetch("https://api.example.com/upload", {
  method: "POST",
  body: form,
})
console.log(await response.json())
```

***

### 示例 4：带超时的请求

```tsx
try {
  const response = await fetch("https://example.com/slow", { timeout: 10 })
  const text = await response.text()
  console.log(text)
} catch (err) {
  if (err.name === "AbortError") {
    console.log("请求超时被中止")
  }
}
```

***

### 示例 5：通过 AbortController 主动中止请求

```tsx
const controller = new AbortController()

setTimeout(() => {
  controller.abort("用户取消了请求")
}, 3000)

try {
  const response = await fetch("https://example.com/large", { signal: controller.signal })
  const data = await response.text()
  console.log(data)
} catch (err) {
  if (err.name === "AbortError") {
    console.log("请求已被用户中止")
  }
}
```

***

### 示例 6：自定义重定向处理

```tsx
const response = await fetch("https://example.com/redirect", {
  handleRedirect: async (newRequest) => {
    console.log("收到重定向:", newRequest.url)
    if (newRequest.url.includes("forbidden")) {
      return null // 阻止跳转
    }
    return newRequest // 允许继续
  },
})
```

***

### 示例 7：调试标签与日志

```tsx
await fetch("https://api.example.com/status", {
  debugLabel: "Health Check",
})
// 日志面板中将显示标签 "Health Check"
```

***

## 与其他类的关系

| 类名                                    | 说明                                                   |
| ------------------------------------- | ---------------------------------------------------- |
| **`Request`**                         | 可直接创建一个请求对象并传入 `fetch(request)`。用于重复请求或在多个函数间复用请求配置。 |
| **`Response`**                        | 表示响应结果，可通过 `.json()`, `.text()`, `.data()` 等方法获取内容。  |
| **`AbortController` / `AbortSignal`** | 用于主动中止请求。                                            |
| **`FormData`**                        | 用于构造 multipart/form-data 请求体。                        |
| **`Headers`**                         | 管理请求与响应头部。                                           |
| **`Data`**                            | 表示二进制数据，可用于请求体或响应数据处理。                               |

***

## 特性说明

- **Cookie 管理**：Scripting 中的 `fetch` 默认不自动保存或携带 Cookie。响应中的 `Set-Cookie` 可通过 `response.cookies` 获取。
- **重定向行为**：默认自动跟随，除非设置了 `handleRedirect`。
- **并发安全**：多个并行请求相互独立。
- **文件支持**：可通过 `Data.fromFile()` 直接上传文件内容。

***

## 小结

`fetch()` 是 Scripting 网络请求体系的核心方法，兼容标准 Web API，同时提供更强的原生扩展能力：

- 支持本地文件访问
- 支持二进制 `Data` 类型
- 支持自定义重定向逻辑
- 支持中止与超时机制
- 支持调试标识与原生日志追踪



---
url: /v2/zh/guide/Utilities/SSH/SFTP Client.md
---

`SFTPClient` 用于通过 SSH 连接访问远程文件系统，基于 **SFTP 协议**。
它提供目录操作、文件操作、路径解析等能力，并可通过 `openFile()` 获得更强大的 `SFTPFile` 对象执行读取、写入等低层操作。

该类实例通常由：

```ts
const sftp = await ssh.openSFTP()
```

返回。

***

## 属性

### `readonly isActive: boolean`

指示当前 SFTP 连接是否仍然有效。

- `true`：连接仍然处于活跃状态
- `false`：连接已关闭或发生错误

***

## 方法

***

## `close(): Promise<void>`

关闭当前 SFTP 连接。

#### 返回值：

- `Promise<void>`：关闭成功后 resolve

#### 示例：

```ts
await sftp.close()
```

***

## `readDirectory(atPath: string): Promise<DirectoryEntry[]>`

读取指定目录下的文件与子目录。

#### 参数：

- **`atPath`**：远程目录路径

#### 返回值：

**`DirectoryEntry[]`** 数组，结构如下：

```ts
{
  filename: string
  longname: string
  attributes: {
    size?: number
    userId?: number
    groupId?: number
    accessTime?: Date
    modificationTime?: Date
    permissions?: number
  }
}[]
```

#### 示例：

```ts
const items = await sftp.readDirectory("/var/log")
```

***

## `createDirectory(atPath: string): Promise<void>`

在指定路径创建一个目录。

#### 参数：

- `atPath`：目标目录路径

#### 返回值：

- `Promise<void>`：创建成功后 resolve

#### 示例：

```ts
await sftp.createDirectory("/home/user/new-folder")
```

***

## `removeDirectory(atPath: string): Promise<void>`

删除一个目录（需为空目录）。

#### 参数：

- `atPath`：要删除的目录路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.removeDirectory("/home/user/empty-dir")
```

***

## `rename(oldPath: string, newPath: string): Promise<void>`

重命名或移动文件 / 目录。

#### 参数：

- `oldPath`：原路径
- `newPath`：目标路径

#### 返回值：

- `Promise<void>`

#### 示例：

```ts
await sftp.rename("/home/user/a.txt", "/home/user/b.txt")
```

***

## `getAttributes(atPath: string): Promise<FileAttributes>`

读取文件或目录的信息。

#### 返回值：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

#### 示例：

```ts
const attrs = await sftp.getAttributes("/etc/hosts")
```

***

## `openFile(filePath: string, flags: SFTPOpenFileFlags | SFTPOpenFileFlags[]): Promise<SFTPFile>`

以指定模式打开远程文件，返回 `SFTPFile` 对象进行读写。

#### 参数：

- `filePath`：文件路径
- `flags`：打开文件的模式，可为单个 flag 或数组

可用的 flag：

```
"read" | "write" | "append" | "create" | "truncate" | "forceCreate"
```

#### 返回值：

- `Promise<SFTPFile>`：一个可读写、可关闭的文件对象

#### 示例：

```ts
const file = await sftp.openFile("/home/user/log.txt", ["read"])
const data = await file.readAll()
await file.close()
```

***

## `remove(atPath: string): Promise<void>`

删除指定路径的文件。

#### 参数：

- `atPath`：要删除的文件路径

#### 示例：

```ts
await sftp.remove("/home/user/old.txt")
```

***

## `getRealPath(atPath: string): Promise<string>`

解析符号链接、相对路径、`~` 等，返回绝对路径。

#### 示例：

```ts
const real = await sftp.getRealPath("~/documents")
```

***

# 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "pass")
})

const sftp = await ssh.openSFTP()

// 查看目录内容
const list = await sftp.readDirectory("/home/user")

// 打开文件读取
const file = await sftp.openFile("/home/user/info.txt", "read")
const data = await file.readAll()
await file.close()

// 创建目录
await sftp.createDirectory("/home/user/new-folder")

// 删除文件
await sftp.remove("/home/user/temp.txt")

await sftp.close()
```



---
url: /v2/zh/guide/Utilities/SSH/SFTP File.md
---

`SFTPFile` 表示一个已经通过 SFTP 打开的远程文件句柄。
通过该类，你可以对文件执行读取、写入、获取属性、关闭等底层操作。

实例通常通过：

```ts
const file = await sftp.openFile(path, flags)
```

获得。

***

## 属性

***

### `readonly isActive: boolean`

指示当前文件是否仍然处于打开状态。

- `true`：文件句柄有效，可继续读写
- `false`：文件已关闭或出现错误

***

## 方法

***

# `readAttributes(): Promise<FileAttributes>`

读取文件的元数据属性。

### 返回值：

一个包含文件属性的对象：

```ts
{
  size?: number
  userId?: number
  groupId?: number
  accessTime?: Date
  modificationTime?: Date
  permissions?: number
}
```

### 示例：

```ts
const attrs = await file.readAttributes()
console.log(attrs.size)
```

***

# `read(options?: { from?: number, length?: number }): Promise<Data>`

按指定范围读取文件内容。

### 参数：

- `from?`：读取的起始偏移（字节），默认从 `0` 开始
- `length?`：读取的字节数，默认读取到文件末尾

### 返回值：

- 一个 `Promise<Data>`，包含读取到的数据

### 示例：

```ts
const data = await file.read({ from: 100, length: 50 })
```

***

# `readAll(): Promise<Data>`

读取文件的全部内容。

### 返回值：

- 一个 `Promise<Data>`，包含完整的文件数据

### 示例：

```ts
const data = await file.readAll()
```

***

# `write(data: Data, at?: number): Promise<void>`

向文件写入数据。

### 参数：

- `data`：要写入的二进制数据
- `at?`：写入的起始偏移（字节）。

  - 若未提供，则根据 flags 的模式决定：

    - 若使用 `"append"` 打开，则追加到文件末尾
    - 若使用 `"write"` 打开，则从当前偏移或默认 0 写入

### 返回值：

- `Promise<void>`，写入成功后 resolve

### 示例：

```ts
await file.write(Data.fromRawString("Hello world"))
```

***

# `close(): Promise<void>`

关闭文件句柄。
关闭后，`isActive` 将变为 `false`，无法继续读写。

### 示例：

```ts
await file.close()
```

***

# 使用示例

```ts
// 打开文件（读取模式）
const file = await sftp.openFile("/home/user/info.txt", ["read"])

// 获取文件属性
const attrs = await file.readAttributes()

// 读取内容
const allData = await file.readAll()

// 部分读取
const partial = await file.read({ from: 50, length: 100 })

// 关闭文件
await file.close()
```



---
url: /v2/zh/guide/Utilities/SSH/SSH Authentication Method.md
---

# SSH 认证方法

表示 SSH 身份验证方法。该类提供多个静态方法用于创建不同类型的 SSH 身份验证方式，包括基于密码、RSA 私钥、ED25519 私钥，以及 ECDSA（P-256、P-384、P-521）私钥的认证方式。

你可以将本类创建的实例传递给 `SSHClient.connect()` 方法中的 `authenticationMethod` 参数，用于连接 SSH 服务器。

## 静态方法

***

### `static passwordBased(username: string, password: string): SSHAuthenticationMethod`

创建一个基于用户名和密码的 SSH 身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录使用的用户名。

- `password`（字符串）：
  用户名对应的密码。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例，使用用户名密码进行身份验证。

#### 示例：

```ts
const auth = SSHAuthenticationMethod.passwordBased("user1", "mypassword")
```

***

### `static ras(username: string, sshRsa: Data, decryptionKey?: Data): SSHAuthenticationMethod | null`

创建一个基于 RSA 私钥的身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录使用的用户名。

- `sshRsa`（`Data` 对象）：
  OpenSSH 格式的 RSA 私钥内容，通常通过 `Data.fromString()` 读取。

- `decryptionKey`（可选的 `Data` 对象）：
  如果私钥加密了，请提供解密密码（同样为 `Data` 类型）。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例。如果密钥无效，则返回 `null`。

#### 示例：

```ts
const rsaKey = Data.fromString(privateKeyContent)!
const auth = SSHAuthenticationMethod.ras("user1", rsaKey)
```

***

### `static ed25519(username: string, sshEd25519: Data, decryptionKey?: Data): SSHAuthenticationMethod | null`

创建一个基于 ED25519 私钥的身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `sshEd25519`（`Data` 对象）：
  ED25519 格式的私钥内容。

- `decryptionKey`（可选的 `Data` 对象）：
  私钥若加密，需提供对应的解密密码。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例。如果密钥无效，则返回 `null`。

#### 示例：

```ts
const edKey = Data.fromString(ed25519KeyContent)!
const auth = SSHAuthenticationMethod.ed25519("user1", edKey)
```

***

### `static p256(username: string, pemRepresentation: string): SSHAuthenticationMethod | null`

使用 PEM 格式的 P-256（ECDSA）私钥创建身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `pemRepresentation`（字符串）：
  PEM 格式的 P-256 私钥内容。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例。如果 PEM 格式无效，则返回 `null`。

#### 示例：

```ts
const auth = SSHAuthenticationMethod.p256("user1", pemKeyContent)
```

***

### `static p384(username: string, pemRepresentation: string): SSHAuthenticationMethod | null`

使用 PEM 格式的 P-384（ECDSA）私钥创建身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `pemRepresentation`（字符串）：
  PEM 格式的 P-384 私钥内容。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例，如果无效则返回 `null`。

***

### `static p521(username: string, pemRepresentation: string): SSHAuthenticationMethod | null`

使用 PEM 格式的 P-521（ECDSA）私钥创建身份验证方法。

#### 参数：

- `username`（字符串）：
  SSH 登录用户名。

- `pemRepresentation`（字符串）：
  PEM 格式的 P-521 私钥内容。

#### 返回值：

- 一个 `SSHAuthenticationMethod` 实例，如果无效则返回 `null`。

***

## 使用示例

```ts
// 使用用户名密码认证
const passwordAuth = SSHAuthenticationMethod.passwordBased("root", "secret123")

// 使用 RSA 私钥认证
const privateKey = await FileManager.readAsData("/path/to/id_rsa")
const rsaAuth = SSHAuthenticationMethod.ras("root", privateKey)

// 建立 SSH 连接
const ssh = await SSHClient.connect({
  host: "192.168.0.1",
  authenticationMethod: rsaAuth
})
```



---
url: /v2/zh/guide/Utilities/SSH/SSH Client.md
---

# SSH 客户端

`SSHClient` 类用于连接远程 SSH 服务器，支持执行命令、打开 TTY/PTY 会话、使用 SFTP 进行文件传输，以及通过跳板主机进行多级 SSH 跳转。该类是建立和管理 SSH 会话的核心接口。

***

## 静态方法

### `SSHClient.connect(options): Promise<SSHClient>`

建立与远程 SSH 服务器的连接。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    服务器的主机名或 IP 地址。

  - `port?`（数字）：
    连接端口，默认是 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    SSH 身份验证方式，例如密码或私钥。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任服务器公钥列表。如果提供，客户端将验证服务器公钥。

  - `reconnect?`（`"never" | "once" | "always"`）：
    可选的重连策略，默认是 `"never"`。

#### 返回值：

- 成功连接时返回 `Promise<SSHClient>` 实例。

#### 示例：

```ts
const ssh = await SSHClient.connect({
  host: "192.168.0.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("root", "password")
})
```

***

## 属性

### `onDisconnect: (() => void) | null`

SSH 连接断开时触发的回调函数。

#### 示例：

```ts
ssh.onDisconnect = () => {
  console.log("SSH 已断开")
}
```

***

## 实例方法

### `executeCommand(command: string, options?): Promise<string>`

在远程服务器上执行命令，并返回结果字符串。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `options?`（对象）：

  - `maxResponseSize?`（数字）：
    最大响应字节数。

  - `includeStderr?`（布尔）：
    是否包含标准错误输出，默认为 `false`。

  - `inShell?`（布尔）：
    是否在 shell 中执行命令（如 `sh -c`），默认是 `false`。

#### 返回值：

- 返回一个 `Promise<string>`，为命令的输出。

#### 示例：

```ts
const result = await ssh.executeCommand("uname -a")
```

***

### `executeCommandStream(command, onOutput, options?): Promise<void>`

以流的形式逐行执行命令并获取输出。

#### 参数：

- `command`（字符串）：
  要执行的命令。

- `onOutput`（函数）：
  每一行输出都会调用该回调函数 `(data: Data, isStderr: boolean) => boolean`。返回 `false` 可提前终止输出接收。

- `options?`（对象）：

  - `inShell?`（布尔）：
    是否在 shell 中执行。

#### 返回值：

- 返回一个 `Promise`，命令执行完毕后 resolve。

#### 示例：

```ts
const output = Data.fromIntArray([])
await ssh.executeCommandStream("ping -c 4 google.com", (data, isStderr) => {
  output.append(data)
  return true
})
console.log(output.toDecodedString()())
```

***

### `withPTY(options): Promise<TTYStdinWriter>`

打开一个 PTY（伪终端）会话，支持交互式终端程序（如 `top`、`vim`）。

#### 参数：

- `options`（对象）：

  - `wantReply?`（布尔）：
    是否等待服务器回应，默认 `true`。

  - `term?`（字符串）：
    终端类型，默认是 `"xterm"`。

  - `terminalCharacterWidth?`（数字）：
    字符宽度，默认 `80`。

  - `terminalRowHeight?`（数字）：
    字符行数，默认 `24`。

  - `terminalPixelWidth?`（数字）：
    像素宽度，默认 `0`。

  - `terminalPixelHeight?`（数字）：
    像素高度，默认 `0`。

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>`，可用于写入输入和调整终端大小。

#### 示例：

```ts
let output: Data | undefined
let timerId: number | undefined
const writer = await ssh.withPTY({
  onOutput: (data, isStderr) => {
    if (output == null) {
      output = data
    } else {
      output.append(data)
    }
    clearTimeout(timerId)
    timerId = setTimeout(() => {
      console.log(output.toDecodedString()())
      output = undefined
    }, 500)
    return true
  }
})
await writer.write("top\n")
```

***

### `withTTY(options): Promise<TTYStdinWriter>`

打开一个简化的 TTY 会话（不包含终端尺寸设置）。

#### 参数：

- `options`（对象）：

  - `onOutput`（函数）：
    每一行输出的回调 `(data: Data, isStderr: boolean) => boolean`。

  - `onError?`（函数）：
    出错时的回调 `(error: string) => void`。

#### 返回值：

- 一个 `Promise<TTYStdinWriter>` 实例。

***

### `openSFTP(): Promise<SFTPClient>`

打开一个 SFTP 会话，用于远程文件读写、目录管理等操作。

#### 返回值：

- 一个 `Promise<SFTPClient>` 实例。

#### 示例：

```ts
const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/test.txt", "Hello world")
```

***

### `jump(options): Promise<SSHClient>`

从当前连接跳转（跳板）至另一个远程 SSH 主机。

#### 参数：

- `options`（对象）：

  - `host`（字符串）：
    目标主机地址。

  - `port?`（数字）：
    端口，默认为 `22`。

  - `authenticationMethod`（`SSHAuthenticationMethod`）：
    跳转主机的身份验证方式。

  - `trustedHostKeys?`（字符串数组）：
    可选的受信任主机公钥。

#### 返回值：

- 一个新的 `SSHClient` 实例，表示跳转后的连接。

#### 示例：

```ts
const nextHop = await ssh.jump({
  host: "10.0.0.2",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user2", "pass2")
})
```

***

### `close(): Promise<void>`

关闭 SSH 连接并释放资源。

> **注意：** 当不再需要 SSH 连接时应显式调用该方法，以防资源或 socket 泄漏。

#### 返回值：

- 一个 `Promise`，成功关闭连接时 resolve。

#### 示例：

```ts
await ssh.close()
```

***

## 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "password")
})

const output = await ssh.executeCommand("uptime")
console.log("系统运行时间：", output)

const sftp = await ssh.openSFTP()
await sftp.writeFile("/tmp/hello.txt", "Hello SSH")

await ssh.close()
```



---
url: /v2/zh/guide/Utilities/SSH/TTY Stdin Writer.md
---

# TTY 标准输入写入器

表示一个可写的 TTY（终端）标准输入流，用于通过 SSH 建立的伪终端（PTY）或 TTY 会话。该类支持将数据写入远程终端的 `stdin`，以及动态调整终端窗口大小。

通常由 `SSHClient.withPTY()` 或 `SSHClient.withTTY()` 方法返回。

***

## 方法

### `write(data: string): Promise<void>`

向远程 TTY 会话的标准输入写入文本数据。

#### 参数：

- `data`（字符串）：
  要发送给远程终端标准输入的字符串，可以包含控制字符（如 `"\r"` 表示回车，`\x03` 表示 Ctrl+C）。

#### 返回值：

- 一个 `Promise`，在数据成功写入后 resolve。

#### 示例：

```ts
const writer = await ssh.withTTY({
  onOutput: (text) => {
    console.log("输出：", text)
    return true
  }
})
await writer.write("ls -la\n")
```

***

### `changeSize(options: { cols: number; rows: number; pixelWidth: number; pixelHeight: number }): Promise<void>`

更改远程终端的窗口尺寸，适用于需要特定终端尺寸的程序（如 `vim`、`htop` 等）。

#### 参数：

- `options`（对象）：
  一个包含终端尺寸信息的对象：

  - `cols`（数字）：
    终端的字符列数，例如 80。

  - `rows`（数字）：
    终端的字符行数，例如 24。

  - `pixelWidth`（数字）：
    终端的像素宽度（如果不适用可设为 0）。

  - `pixelHeight`（数字）：
    终端的像素高度（如果不适用可设为 0）。

#### 返回值：

- 一个 `Promise`，在终端尺寸更改成功后 resolve。

#### 示例：

```ts
await writer.changeSize({
  cols: 100,
  rows: 30,
  pixelWidth: 0,
  pixelHeight: 0
})
```

***

## 使用示例

```ts
const ssh = await SSHClient.connect({
  host: "192.168.1.10",
  authenticationMethod: SSHAuthenticationMethod.passwordBased("user", "password")
})

const writer = await ssh.withPTY({
  term: "xterm",
  onOutput: (text, isStderr) => {
    console.log(text)
    return true
  }
})

// 写入命令
await writer.write("top\n")

// 2 秒后调整终端尺寸
await new Promise(resolve => setTimeout(resolve, 2000))
await writer.changeSize({
  cols: 120,
  rows: 40,
  pixelWidth: 0,
  pixelHeight: 0
})
```



---
url: /v2/zh/guide/Utilities/Storage.md
---

`Storage` 模块为脚本提供轻量级的持久化存储能力。
开发者可以在脚本中保存与读取简单的数据类型（如字符串、数字、布尔值、JSON 对象）以及二进制数据（`Data`）。

所有数据默认存储在 **当前脚本的私有存储域**，不会被其他脚本访问。
若希望在多个脚本之间共享数据，可将 `shared: true` 作为选项传入，使数据写入 **共享存储域**。

数据会在后台异步持久化到磁盘，但写入方法同步返回执行结果。

***

# 支持的数据类型

Storage 支持以下类型的数据：

- `string`
- `number`
- `boolean`
- `JSON`（符合 JSON 可序列化类型的结构）
- `Data`（需使用 `setData` / `getData`）

以上类型均可安全持久化。

***

# 存储域说明

| 类型          | 默认                    | 可访问性     | 适用场景                  |
| ----------- | --------------------- | -------- | --------------------- |
| 私有（Private） | 是                     | 仅当前脚本    | 保存当前脚本的配置、状态、用户数据等    |
| 共享（Shared）  | 否（需设置 `shared: true`） | 所有脚本都可访问 | 多脚本之间共享数据，如全局设置、用户偏好等 |

***

# API 参考

## 1. `Storage.set(key, value, options?)`

```ts
function set<T>(key: string, value: T, options?: { shared: boolean }): boolean
```

将值保存到持久化存储中。支持 `string`、`number`、`boolean` 和 `JSON` 类型。

### 参数

| 名称             | 类型        | 必须 | 说明                    |
| -------------- | --------- | -- | --------------------- |
| key            | `string`  | 是  | 要保存的键名                |
| value          | `T`       | 是  | 要持久化的值                |
| options.shared | `boolean` | 否  | 如果为 `true`，将数据写入共享存储域 |

### 返回值

- `boolean`：表示操作是否成功。

***

## 2. `Storage.get(key, options?)`

```ts
function get<T>(key: string, options?: { shared: boolean }): T | null
```

读取已保存的值。如果不存在，返回 `null`。

### 参数

| 名称             | 类型        | 必须 | 说明         |
| -------------- | --------- | -- | ---------- |
| key            | `string`  | 是  | 要读取的键名     |
| options.shared | `boolean` | 否  | 是否从共享存储域读取 |

### 返回值

- `T | null`：对应的值或 `null`。

***

## 3. `Storage.setData(key, data, options?)`

```ts
function setData(key: string, data: Data, options?: { shared: boolean }): void
```

保存二进制数据 `Data` 到持久化存储。

### 参数

- 与 `set` 的参数格式一致，但 `value` 替换为 `Data`。

***

## 4. `Storage.getData(key, options?)`

```ts
function getData(key: string, options?: { shared: boolean }): Data | null
```

读取保存的二进制数据。不存在时返回 `null`。

***

## 5. `Storage.remove(key, options?)`

```ts
function remove(key: string, options?: { shared: boolean }): void
```

移除指定键的数据。

***

## 6. `Storage.contains(key, options?)`

```ts
function contains(key: string, options?: { shared: boolean }): boolean
```

检测存储中是否包含某个键。

***

## 7. `Storage.clear()`

```ts
function clear(): void
```

清空所有存储的键值对。
**注意：该操作仅清空当前脚本的私有存储，不会影响共享存储域。**

***

## 8. `Storage.keys()`

```ts
function keys(): string[]
```

返回当前存储域中所有键名数组。

***

# 使用示例

## 示例 1：保存与读取简单类型

```ts
import { Storage } from "scripting"

Storage.set("username", "Thom")
const name = Storage.get<string>("username")
console.log(name) // "Thom"
```

***

## 示例 2：保存 JSON 对象

```ts
Storage.set("profile", {
  name: "Alice",
  age: 30
})

const profile = Storage.get<{ name: string; age: number }>("profile")
console.log(profile?.age) // 30
```

***

## 示例 3：保存与读取 Data

```ts
import { Data, Storage } from "scripting"

const bytes = Data.fromUTF8("hello")
Storage.setData("payload", bytes)

const result = Storage.getData("payload")
console.log(result?.toUTF8()) // "hello"
```

***

## 示例 4：使用 shared 共享数据

```ts
Storage.set("theme", "dark", { shared: true })

const value = Storage.get<string>("theme", { shared: true })
console.log(value) // "dark"
```

***

## 示例 5：检测与删除键

```ts
if (Storage.contains("token")) {
  Storage.remove("token")
}
```

***

## 示例 6：获取所有键

```ts
console.log(Storage.keys()) // ["username", "profile", ...]
```

***

# 注意事项

1. 所有写入操作异步持久化，但 API 会立即返回成功与否。
2. `Data` 类型不能通过 `Storage.set()` 保存，必须使用 `setData()`。
3. JSON 类型必须是可序列化的结构。
4. 避免将大型二进制数据保存在 Storage；此功能用于轻量级数据存储。
5. `Storage.clear()` 不会清空 shared 存储域。



---
url: /v2/zh/guide/Utilities/Thread.md
---

# 线程（Thread）

Scripting 的 UI 渲染系统以及绝大多数 JavaScript 执行逻辑默认运行在主线程中，因此通常开发者无需主动切换线程。

为了确保 UI 更新安全、避免主线程阻塞，并在必要时执行后台任务，Scripting 提供了全局 `Thread` API。部分系统 API 或运行时逻辑可能会在后台执行，此 API 能帮助你安全地处理复杂场景。

`Thread` 为全局命名空间，无需导入即可使用。

***

## `Thread.isMainThread: boolean`

指示当前 JavaScript 执行环境是否在主线程。

在大多数情况下此值为 `true`，但某些系统回调或内部任务可能会切换到后台线程。在需要进行 UI 更新时，可以通过此属性确认当前线程是否安全。

```ts
if (Thread.isMainThread) {
  console.log('当前在主线程')
} else {
  console.log('当前不在主线程')
}
```

***

## `Thread.runInMain(execute: () => void): void`

在主线程中执行指定的函数。

由于 JavaScript 默认运行在主线程，通常无需手动调用此方法。它主要用于以下情况：

- 某些系统 API 回调在后台线程触发，开发者需要确保 UI 更新在主线程执行
- 希望严格保证某段逻辑在主线程中执行

此方法不会返回值，也不会切回执行前的线程，仅保证同步在主线程执行。

```ts
Thread.runInMain(() => {
  title.value = 'Updated on main thread'
})
```

***

## `Thread.runInBackground<T>(execute: () => T | Promise<T>): Promise<T>`

在后台线程执行指定函数，并以 Promise 形式将结果切回到调用处所在的线程（通常是主线程）。

适用于：

- 计算密集型任务
- 大型数据处理
- 不希望阻塞 UI 的耗时操作

`execute` 可以返回值或 Promise。

```ts
const sum = await Thread.runInBackground(() => {
  let v = 0
  for (let i = 0; i < 5_000_000; i++) v += i
  return v
})

console.log('结果:', sum)
```

异步示例：

```ts
const image = await Thread.runInBackground(async () => {
  const raw = await loadImage()
  return processImage(raw)
})

Thread.runInMain(() => {
  setImage(image)
})
```

***

## 异步 I/O 的自动线程切换行为

Scripting 中 **大量异步 I/O 方法**（包括文件、网络、数据库等）会自动在后台线程执行，无需开发者手动使用 `runInBackground`。

例如：

```ts
const content = await FileManager.readAsString(path)
```

`readAsString` 会自动切换到后台线程执行文件读取操作，然后将结果以 Promise 的方式切回调用时所在的线程（通常是主线程）。
这意味着你可以放心地直接调用异步 API，而无需担心阻塞 UI。

### 只有同步方法会在主线程执行

例如：

```ts
const content = FileManager.readAsStringSync(path)
```

同步方法不会切线程，会在主线程直接执行 I/O 操作。因此：

- 不建议在同步方法中处理大型文件或执行耗时操作
- 如果需要高性能且不阻塞 UI，应使用异步版本（如 readAsString）

***

## 使用建议

- JavaScript 默认在主线程运行，大部分场景不需要调用 `runInMain`
- 异步 I/O（如 FileManager.readAsString）已经自动在后台线程执行
- 仅在执行计算密集型任务或同步 I/O 时需要使用 `runInBackground`
- 如果某些系统 API 回调在后台线程中触发，可使用 `runInMain` 保证 UI 更新安全
- 不应在后台线程中直接访问 UI，应在后台任务完成后再回到主线程处理



---
url: /v2/zh/guide/Utilities/UIImage.md
---

# UIImage

`UIImage` 类表示一个图像对象，可用于加载、编码、转换与显示。它支持从文件路径、二进制数据或 Base64 字符串中创建图像，并提供多种格式转换方法（PNG/JPEG）。
`UIImage` 可直接用于 `Image` 组件显示，也可与 `Data` 类配合用于图像存储、上传、加密等操作。

***

## 概述

`UIImage` 是脚本环境中处理图像的核心类，常用于以下场景：

- 从本地文件、二进制数据、网络URL或 Base64 字符串中加载图像
- 获取图像的像素宽高与缩放比例
- 转换图像格式（如 PNG、JPEG）
- 生成 Base64 字符串
- 调整渲染模式与可拉伸区域
- 对图像进行翻转或着色
- 生成缩略图
- 支持浅色/深色模式切换的动态图像显示

***

## 属性

### `width: number`

图像的宽度（单位：像素）。

```ts
const image = UIImage.fromFile("/path/to/image.png")
console.log(image?.width)
```

***

### `height: number`

图像的高度（单位：像素）。

```ts
const image = UIImage.fromFile("/path/to/image.png")
console.log(image?.height)
```

***

### `scale: number`

图像的缩放比例（Scale Factor），通常为 `1` 或 `2`（Retina 屏幕）。

```ts
console.log(image?.scale)
```

***

### `imageOrientation: string`

图像的方向，可能的值包括：

- `"up"`
- `"down"`
- `"left"`
- `"right"`
- `"upMirrored"`
- `"downMirrored"`
- `"leftMirrored"`
- `"rightMirrored"`
- `"unknown"`

```ts
console.log(image?.imageOrientation)
```

***

### `isSymbolImage: boolean`

指示该图像是否为 SFSymbol 符号图像。

```ts
const symbol = UIImage.fromSFSymbol("heart.fill")
console.log(symbol?.isSymbolImage) // true
```

***

### `renderingMode: "automatic" | "alwaysOriginal" | "alwaysTemplate" | "unknown"`

图像的渲染模式。

- `automatic`: 系统自动决定渲染方式
- `alwaysOriginal`: 显示原始颜色
- `alwaysTemplate`: 使用模板渲染（可通过 tintColor 着色）

***

### `resizingMode: "tile" | "stretch" | "unknown"`

图像的拉伸模式：

- `"tile"`：平铺重复绘制
- `"stretch"`：直接拉伸

***

### `capInsets: { top: number, left: number, bottom: number, right: number }`

定义图像的可拉伸区域边距（Cap Insets）。

***

### `flipsForRightToLeftLayoutDirection: boolean`

是否为右到左（RTL）布局方向自动翻转图像。

***

## 实例方法

### `preparingThumbnail(size: Size): UIImage | null`

生成指定尺寸的缩略图。

- **参数：**

  - `size.width`: 缩略图宽度
  - `size.height`: 缩略图高度

- **返回值：**

  - 新的 `UIImage` 实例或 `null`

**示例：**

```ts
const image = UIImage.fromFile("/path/to/photo.jpg")
const thumb = image?.preparingThumbnail({ width: 200, height: 200 })
```

***

### `withBaselineOffset(offset: number): UIImage`

设置图像的基线偏移量（Baseline Offset），用于调整图像在垂直方向上的显示位置，在文本布局中很有用。

```ts
const image = UIImage.fromFile("/path/to/image.png")
const offset = image?.withBaselineOffset(10)
```

***

### `withHorizontallyFlippedOrientation(): UIImage`

水平翻转图像方向，返回新的 `UIImage` 实例。

```ts
const flipped = image?.withHorizontallyFlippedOrientation()
```

***

### `withTintColor(color: string, renderingMode?: "automatic" | "alwaysOriginal" | "alwaysTemplate"): UIImage | null`

为图像应用指定的渲染模式和颜色着色。

- **参数：**

  - `color`: 要应用的颜色字符串，例如 `"#ffcc00"` 或 `"rgb(255,128,0)"`
  - `renderingMode`: 渲染模式，默认为 `"automatic"`

**示例：**

```ts
const symbol = UIImage.fromSFSymbol("star.fill")
const tinted = symbol?.withTintColor("#ffcc00", "alwaysTemplate")
```

***

### `withRenderingMode(renderingMode: "automatic" | "alwaysOriginal" | "alwaysTemplate"): UIImage | null`

返回使用指定渲染模式的新图像。

```ts
const templated = image?.withRenderingMode("alwaysTemplate")
```

***

### `resizableImage(capInsets, resizingMode?): UIImage | null`

返回带有指定可拉伸区域和模式的新图像。

- **参数：**

  - `capInsets`: `{ top, left, bottom, right }`
  - `resizingMode`: `"tile"` 或 `"stretch"`，默认 `"tile"`

**示例：**

```ts
const resizable = image?.resizableImage(
  { top: 10, left: 10, bottom: 10, right: 10 },
  "stretch"
)
```

***

### `renderedInCircle(radius?: number | null, fitEntireImage?: boolean): UIImage`

返回一个新的圆形渲染版本的图像，可选指定圆的半径和是否完整显示整个图像。

- **参数：**

  - `radius`（可选）：圆的半径（单位：点）。

    - 如果未指定：

      - 当 `fitEntireImage` 为 `false` 时，圆形将使用图像的**最短边**作为直径；
      - 当 `fitEntireImage` 为 `true` 时，圆形将使用图像的**最长边**作为直径。
  - `fitEntireImage`（可选）：是否让整个图像内容都适应在圆形范围内。

    - 默认值为 `true`。
    - 若为 `false`，图像会填满圆形区域，但可能出现内容裁剪。

- **返回值：**

  - 返回一个新的 `UIImage` 实例，表示圆形渲染结果。

**示例 1：创建默认的圆形头像**

```ts
const image = UIImage.fromFile("/path/to/avatar.jpg")
const circle = image?.renderedInCircle()
<Image image={circle} />
```

**示例 2：指定半径并完整显示整个图像**

```ts
const image = UIImage.fromFile("/path/to/photo.png")
const circle = image?.renderedInCircle(60, true)
<Image image={circle} />
```

**示例 3：填充模式（可能裁剪图像部分内容）**

```ts
const image = UIImage.fromFile("/path/to/icon.png")
const circle = image?.renderedInCircle(50, false)
<Image image={circle} />
```

***

### `renderedIn(size: { width: number, height: number }, source?: {  position?: ..., size?: ... }): UIImage | null`

返回一个新的图像，将源图像缩放到指定大小，可选指定源图像的位置和尺寸。

- **参数：**

  - `size`: `{ width: number, height: number }`，目标图像的尺寸（单位：点）
  - `source`: `{ position?: { x: number, y: number }, size?: { width: number, height: number } }`，源图像的位置和尺寸。

- **返回值：**

  - 成功时返回新的 `UIImage` 实例；失败时返回 `null`。

**示例 1：将整张图片缩放绘制到矩形区域**

```ts
const image = UIImage.fromFile("/path/to/photo.jpg")
const rendered = image?.renderedIn({width: 200, height: 200 })
<Image image={rendered} />
```

**示例 2：从源图像中裁剪指定区域并绘制**

```ts
const image = UIImage.fromFile("/path/to/landscape.jpg")
const cropped = image?.renderedIn({
    width: 150,
    height: 150 
  }, {
  position: { x: 100, y: 50 },
  size: { width: 300, height: 300 }
})
<Image image={cropped} />
```

***

### `applySymbolConfiguration(config: UIImageSymbolConfiguration | UIImageSymbolConfiguration[]): UIImage | null`

返回一个应用指定符号配置（`UIImageSymbolConfiguration`）的新图像实例。
该方法主要用于自定义 **SF Symbols** 图标的外观（如颜色、粗细、大小、配色模式等）。

- **参数：**

  - `config`: 要应用的符号配置对象。

    - 可以是单个 `UIImageSymbolConfiguration` 实例；
    - 或由多个配置组成的数组，多个配置将按顺序依次应用（后者可覆盖前者）。

- **返回值：**

  - 返回一个新的 `UIImage` 实例，表示应用配置后的图像。
    如果应用失败，返回 `null`。

**示例 1：设置符号图标为多色显示**

```ts
const image = UIImage.fromFile("/path/to/sf_symbol.png")
const config = UIImageSymbolConfiguration.preferringMulticolor()
const colored = image?.applySymbolConfiguration(config)
<Image image={colored} />
```

**示例 2：同时应用缩放和权重配置**

```ts
const image = UIImage.fromFile("/path/to/sf_symbol.png")
const config = [
  UIImageSymbolConfiguration.scale("large"),
  UIImageSymbolConfiguration.weight("bold")
]
const boldLarge = image?.applySymbolConfiguration(config)
<Image image={boldLarge} />
```

**示例 3：设置分层颜色与调色板颜色**

```ts
const image = UIImage.fromFile("/path/to/symbol.png")
const config = [
  UIImageSymbolConfiguration.hierarchicalColor(Color.blue()),
  UIImageSymbolConfiguration.paletteColors([Color.red(), Color.orange()])
]
const customized = image?.applySymbolConfiguration(config)
<Image image={customized} />
```

***

## UIImageSymbolConfiguration

`UIImageSymbolConfiguration` 是用于配置 **符号图像（SF Symbols）** 外观的类。
可通过其静态方法创建不同的配置对象，并在 `applySymbolConfiguration()` 中使用。

### 可用静态方法

| 方法                          | 说明                                                                                                                       |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `preferringMonochrome()`    | 优先使用单色显示符号。                                                                                                              |
| `preferringMulticolor()`    | 优先使用多色显示符号。                                                                                                              |
| `scale(value)`              | 设置符号缩放比例，可选值：`"default"`, `"large"`, `"medium"`, `"small"`, `"unspecified"`。                                             |
| `weight(value)`             | 设置符号线条粗细，可选值：`"ultraLight"`, `"thin"`, `"light"`, `"regular"`, `"medium"`, `"semibold"`, `"bold"`, `"heavy"`, `"black"`。 |
| `pointSize(value)`          | 设置符号点大小。                                                                                                                 |
| `paletteColors(value)`      | 设置符号调色板颜色数组（用于多层符号）。                                                                                                     |
| `hierarchicalColor(value)`  | 设置符号的层级颜色（分层阴影样式）。                                                                                                       |
| `variableValueMode(value)`  | 设置符号的动态数值显示模式，可选值：`"automatic"`, `"color"`, `"draw"`。                                                                    |
| `colorRenderingMode(value)` | 设置颜色渲染模式，可选值：`"automatic"`, `"flat"`, `"gradient"`。                                                                      |
| `locale(identifier)`        | 设置用于符号本地化的语言标识符（如 `"en"`, `"zh-Hans"`）。                                                                                  |

***

**示例：组合配置符号图标外观**

```ts
const config = [
  UIImageSymbolConfiguration.scale("medium"),
  UIImageSymbolConfiguration.weight("semibold"),
  UIImageSymbolConfiguration.preferringMonochrome(),
  UIImageSymbolConfiguration.colorRenderingMode("flat")
]

const image = UIImage.fromFile("/path/to/symbol.png")
const result = image?.applySymbolConfiguration(config)
<Image image={result} />
```

***

### `toJPEGData(compressionQuality?: number): Data | null`

将图像转换为 JPEG 格式的二进制数据。

- **参数：**

  - `compressionQuality`（可选）: 压缩质量（0–1，默认 1）
- **返回值：**

  - `Data` 实例或 `null`

***

### `toPNGData(): Data | null`

将图像转换为 PNG 格式的二进制数据。
返回 `Data` 实例或 `null`。

***

### `toJPEGBase64String(compressionQuality?: number): string | null`

将图像转换为 Base64 编码的 JPEG 字符串。

***

### `toPNGBase64String(): string | null`

将图像转换为 Base64 编码的 PNG 字符串。

***

## 静态方法

### `UIImage.fromData(data: Data): UIImage | null`

通过 `Data` 创建图像。

***

### `UIImage.fromFile(filePath: string): UIImage | null`

从文件路径加载图像（支持 PNG/JPEG）。

***

### `UIImage.fromBase64String(base64String: string): UIImage | null`

通过 Base64 字符串创建图像。

***

### `UIImage.fromSFSymbol(name: string): UIImage | null`

从 **SFSymbol 名称** 创建系统图标。

**示例：**

```ts
const heart = UIImage.fromSFSymbol("heart.fill")
<Image image={heart} />
```

***

### `UIImage.fromURL(url: string): Promise<UIImage | null>`

通过 URL 加载图像（支持 PNG/JPEG）。

**示例：**

```ts
const image = await UIImage.fromURL("https://example.com/image.jpg")
<Image image={image} />
```

***

## 在 UI 中使用 UIImage

`UIImage` 可以直接用于 `<Image>` 组件中显示图像。

### 组件定义

```ts
declare const Image: FunctionComponent<UIImageProps>
```

***

### 属性定义

```ts
type UIImageProps = {
  image: UIImage | DynamicImageSource<UIImage>
}
```

***

### 类型定义

```ts
type DynamicImageSource<T> = {
  light: T
  dark: T
}
```

***

### 示例：显示单张图片

```ts
const image = UIImage.fromFile("/path/to/avatar.png")
<Image image={image} />
```

***

### 示例：适配浅色与深色模式

```ts
const lightImage = UIImage.fromFile("/path/to/light-logo.png")
const darkImage = UIImage.fromFile("/path/to/dark-logo.png")

<Image image={{ light: lightImage, dark: darkImage }} />
```

***

## 常见用法示例

### 1. 图像转 Base64

```ts
const image = UIImage.fromFile("/path/to/image.png")
const base64 = image?.toPNGBase64String()
```

***

### 2. 压缩为 JPEG 数据并保存

```ts
const image = UIImage.fromFile("/path/to/photo.jpg")
const jpegData = image?.toJPEGData(0.6)
if (jpegData) {
  // 写入到本地文件
}
```

***

### 3. 从 Base64 字符串还原图片并显示

```ts
const base64 = "iVBORw0KGgoAAAANSUhEUgAA..."
const image = UIImage.fromBase64String(base64)
<Image image={image} />
```

***

### 4. 将 PNG 图片转换为 JPEG 并上传

```ts
const image = UIImage.fromFile("/path/to/logo.png")
const jpegData = image?.toJPEGData(0.8)
if (jpegData) {
  const response = await fetch("https://example.com/upload", {
    method: "POST",
    body: jpegData.toUint8Array()
  })
}
```

***

### 5. 创建 SFSymbol 图像并着色

```ts
const symbol = UIImage.fromSFSymbol("star.fill")
const colored = symbol?.withTintColor("#ffcc00", "alwaysTemplate")
<Image image={colored} />
```

***

### 6. 生成缩略图

```ts
const image = UIImage.fromFile("/path/to/large.jpg")
const thumb = image?.preparingThumbnail({ width: 120, height: 120 })
<Image image={thumb} />
```

***

## 总结

`UIImage` 是 Scripting 脚本环境中图像操作的核心类，具备以下特性：

- 从文件、二进制或 Base64 加载图像
- 支持 SFSymbol 系统图标
- 读取图像宽高、比例、方向与渲染信息
- 可进行翻转、着色与可拉伸处理
- 支持 PNG/JPEG 格式转换与 Base64 编码
- 生成缩略图与自定义渲染模式
- 可直接用于 `<Image>` 组件显示，支持浅色/深色模式自动切换



---
url: /v2/zh/guide/Utilities/URLSession/BackgroundURLSession.md
---

# 后台网络会话

`BackgroundURLSession` 提供在 **Scripting app** 中发起、恢复与查询「后台可持续」的下载与上传任务的能力。

> **可用性：** 仅当脚本运行在主应用 (`Script.env === "index"`) 时可用。

***

## 命名空间：`BackgroundURLSession`

### 1) `startDownload(options): URLSessionDownloadTask`

**作用**：启动一个新的后台下载任务。

**签名**

```ts
function startDownload(options: {
  url: string
  destination: string
  headers?: Record<string, string>
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionDownloadTask
```

**参数说明**

- `url` (`string`)：要下载的文件 URL。
- `destination` (`string`)：下载完成后保存的目标文件路径。
- `headers` (`Record<string, string>`, 可选)：HTTP 请求头。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：下载完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionDownloadTask`：下载任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.startDownload({
  url: 'https://example.com/file.zip',
  destination: '/var/mobile/Containers/.../Downloads/file.zip',
  headers: { 'User-Agent': 'Scripting/1.0' },
  notifyOnFinished: {
    success: '下载成功',
    failure: '下载失败'
  }
})

// 开始下载
task.resume()

// 监听进度与完成事件
task.onProgress = d => console.log('进度：', d.progress)
task.onFinishDownload = (err, info) => {
  if (!err) console.log('下载完成，文件保存于：', info.destination)
}
```

***

### 2) `resumeDownload(options): URLSessionDownloadTask`

**作用**：从断点续传数据恢复一个下载任务。

**签名**

```ts
function resumeDownload(options: {
  resumeData: Data
  destination: string
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionDownloadTask
```

**参数说明**

- `resumeData` (`Data`)：通过 `cancelByProducingResumeData()` 获取的断点数据。
- `destination` (`string`)：下载完成后的目标保存路径。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：下载完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionDownloadTask`：下载任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.resumeDownload({
  resumeData,
  destination: '/.../Downloads/file.zip',
  notifyOnFinished: true
})

// 开始续传
task.resume()

task.onFinishDownload = (err, info) => {
  if (!err) console.log('续传完成：', info.destination)
}
```

***

### 3) `getDownloadTasks(): Promise<URLSessionDownloadTask[]>`

**作用**：获取当前系统中仍存在的后台下载任务。
脚本被终止或重启后，可通过该方法重新获取任务实例并重新设置回调。

**签名**

```ts
function getDownloadTasks(): Promise<URLSessionDownloadTask[]>
```

**返回值**

- `Promise<URLSessionDownloadTask[]>`：下载任务对象数组。

**示例**

```ts
const tasks = await BackgroundURLSession.getDownloadTasks()
for (const task of tasks) {
  console.log('任务ID:', task.id, '状态:', task.state)
  task.onComplete = err => {
    if (err) console.error('下载失败：', err)
  }
}
```

***

### 4) `startUpload(options): URLSessionUploadTask`

**作用**：启动一个新的后台上传任务。

**签名**

```ts
function startUpload(options: {
  filePath: string
  toURL: string
  method?: string
  headers?: Record<string, string>
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionUploadTask
```

**参数说明**

- `filePath` (`string`)：要上传的本地文件路径。
- `toURL` (`string`)：服务器目标 URL。
- `method` (`string`, 可选，默认 `"POST"`)：HTTP 请求方法。
- `headers` (`Record<string, string>`, 可选)：HTTP 请求头。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：上传完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionUploadTask`：上传任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.startUpload({
  filePath: '/.../upload.bin',
  toURL: 'https://api.example.com/upload',
  method: 'PUT',
  headers: { Authorization: 'Bearer token' },
  notifyOnFinished: {
    success: '上传成功',
    failure: '上传失败'
  }
})

// 开始上传
task.resume()

task.onComplete = err => {
  if (!err) console.log('上传完成')
  else console.error('上传失败：', err)
}
```

***

### 5) `resumeUpload(options): URLSessionUploadTask`

**作用**：恢复一个可续传的上传任务。

**签名**

```ts
function resumeUpload(options: {
  resumeData: Data
  notifyOnFinished?: {
    success: string
    failure: string
  }
}): URLSessionUploadTask
```

**参数说明**

- `resumeData` (`Data`)：先前上传任务失败时生成的续传数据。
- `notifyOnFinished` (`{ success: string, failure: string }`, 可选)：上传完成后是否发送本地通知, `success` 为成功通知标题，`failure` 为失败通知标题。

**返回值**

- `URLSessionUploadTask`：新的上传任务对象（任务会自动启动）。

**示例**

```ts
const task = BackgroundURLSession.resumeUpload({
  resumeData,
  notifyOnFinished: {
    success: '上传成功',
    failure: '上传失败'
  }
})

// 开始续传
task.resume()

task.onComplete = err => {
  if (!err) console.log('上传续传完成')
}
```

***

### 6) `getUploadTasks(): Promise<URLSessionUploadTask[]>`

**作用**：获取系统中仍存在的后台上传任务，用于脚本重启后恢复任务状态与回调。

**签名**

```ts
function getUploadTasks(): Promise<URLSessionUploadTask[]>
```

**返回值**

- `Promise<URLSessionUploadTask[]>`：上传任务数组。

**示例**

```ts
const tasks = await BackgroundURLSession.getUploadTasks()
for (const t of tasks) {
  console.log('任务ID:', t.id, '状态:', t.state)
  t.onComplete = err => {
    if (err) console.error('上传失败：', err)
  }
}
```

***

## 使用说明与建议

- **暂停与恢复：** 如果调用了 `task.suspend()` 暂停任务，则可通过 `task.resume()` 恢复。
- **断点续传：** 下载任务可通过 `cancelByProducingResumeData()` 生成续传数据；上传任务是否支持续传取决于服务器。
- **任务恢复：** 当脚本被系统终止后，后台任务仍会继续。重新启动脚本后，可使用 `getDownloadTasks()` 或 `getUploadTasks()` 取回并重新绑定事件回调。
- **通知提示：** `notifyOnFinished` 仅影响任务完成时的本地通知显示，不影响任务执行流程。



---
url: /v2/zh/guide/Utilities/URLSession/URLSessionDownloadTask.md
---

# 下载任务

`URLSessionDownloadTask` 表示一个后台下载任务实例。
它由 `BackgroundURLSession.startDownload()` 或 `BackgroundURLSession.resumeDownload()` 创建，用于在前台或后台下载文件，并可在脚本被终止后继续运行。

每个下载任务都由系统负责调度与执行，并提供进度、状态和事件回调等信息。
任务在创建后需手动调用 `resume()` 开始任何。

***

## 属性（Properties）

### `id: string`

下载任务的唯一标识符。
可用于在脚本重启后识别同一个下载任务。

**示例**

```ts
console.log(task.id) // 输出任务唯一 ID
```

***

### `state: URLSessionTaskState`

当前任务的状态。

可能的值包括：

- `"running"`：任务正在进行中
- `"suspended"`：任务已暂停
- `"canceling"`：任务正在取消中
- `"completed"`：任务已完成
- `"unknown"`：状态未知（通常表示任务已被系统移除）

**示例**

```ts
if (task.state === "running") {
  console.log("下载中…")
}
```

***

### `progress: URLSessionProgress`

任务的实时进度信息。

包含以下字段：

- `fractionCompleted: number`：完成比例（0–1）
- `totalUnitCount: number`：总字节数
- `completedUnitCount: number`：已完成字节数
- `isFinished: boolean`：是否已完成
- `estimatedTimeRemaining: number | null`：预计剩余时间（秒），可能为 `null`

**示例**

```ts
const p = task.progress
console.log(`已完成 ${(p.fractionCompleted * 100).toFixed(2)}%`)
```

***

### `priority: number`

任务的优先级（0.0–1.0），默认值为 `0.5`。
值越高，系统越可能优先调度此任务。

**示例**

```ts
task.priority = 0.8
```

***

### `earliestBeginDate?: Date | null`

任务可开始执行的最早时间。
可用于延迟任务开始（例如在网络空闲时再执行）。

**示例**

```ts
task.earliestBeginDate = new Date(Date.now() + 10_000) // 延迟 10 秒后可开始
```

***

### `countOfBytesClientExpectsToSend: number`

客户端预计将要发送的字节数（仅供系统参考，不影响任务执行）。

### `countOfBytesClientExpectsToReceive: number`

客户端预计将要接收的字节数（仅供系统参考，不影响任务执行）。

***

## 回调函数（Callbacks）

### `onProgress?: (details) => void`

当下载进度变化时调用。
`details` 参数包含：

- `progress: number`：完成比例（0–1）
- `bytesWritten: number`：本次写入的字节数
- `totalBytesWritten: number`：已下载的总字节数
- `totalBytesExpectedToWrite: number`：预期的总下载字节数

**示例**

```ts
task.onProgress = details => {
  console.log(`下载进度：${(details.progress * 100).toFixed(1)}%`)
}
```

***

### `onFinishDownload?: (error, details) => void`

当下载完成（或失败）后调用。

**参数说明**

- `error: Error | null`：若下载失败则为错误对象，否则为 `null`。
- `details.temporary: string`：临时文件路径。
- `details.destination: string | null`：目标文件路径（如果下载成功则为目标路径，否则可能为 `null`）。

**注意**：文件在下载完成后系统会自动移动到指定 `destination` 路径。

**示例**

```ts
task.onFinishDownload = (error, details) => {
  if (error) {
    console.error("下载失败：", error)
  } else {
    console.log("下载完成，文件保存于：", details.destination)
  }
}
```

***

### `onComplete?: (error, resumeData) => void`

任务完全结束时调用，无论成功或失败都会触发。

**参数说明**

- `error: Error | null`：若任务失败则为错误对象，否则为 `null`。
- `resumeData: Data | null`：如果任务支持断点续传且失败，可通过此数据恢复下载。

**示例**

```ts
task.onComplete = (error, resumeData) => {
  if (error) {
    console.error("下载失败：", error)
    if (resumeData) {
      console.log("可使用 resumeData 续传")
    }
  } else {
    console.log("任务成功完成")
  }
}
```

***

## 方法（Methods）

### `suspend(): void`

暂停任务。
暂停后不会再产生网络流量，也不会超时。
稍后可通过 `resume()` 继续。

**示例**

```ts
task.suspend()
console.log("任务已暂停")
```

***

### `resume(): void`

恢复被暂停的任务。
仅在任务处于 `"suspended"` 状态时可调用。

**示例**

```ts
task.resume()
console.log("任务已恢复")
```

***

### `cancel(): void`

取消任务。
调用后立即返回，任务状态变为 `"canceling"`，完成后触发 `onComplete` 回调并带上错误信息。

**示例**

```ts
task.cancel()
console.log("任务已取消")
```

***

### `cancelByProducingResumeData(): Promise<Data | null>`

取消任务并生成可续传的数据。
若任务支持断点续传，返回的 `Data` 可用于恢复下载；否则返回 `null`。

可在之后使用：

```ts
BackgroundURLSession.resumeDownload({ resumeData, destination })
```

**示例**

```ts
const resumeData = await task.cancelByProducingResumeData()
if (resumeData) {
  console.log("任务已取消，可通过 resumeData 续传")
}
```

***

## 示例代码（完整流程）

```ts
const task = BackgroundURLSession.startDownload({
  url: "https://example.com/largefile.zip",
  destination: "/.../Downloads/largefile.zip",
  notifyOnFinished: {
    success: "下载成功",
    failure: "下载失败"
  }
})

// 开始任务
task.resume()

task.onProgress = ({ progress }) => {
  console.log(`下载进度：${(progress * 100).toFixed(1)}%`)
}

task.onFinishDownload = (error, details) => {
  if (error) {
    console.error("下载出错：", error)
  } else {
    console.log("下载完成：", details.destination)
  }
}

task.onComplete = async (error, resumeData) => {
  if (error && resumeData) {
    console.log("可继续下载，保存 resumeData 以备后续恢复")
  }
}
```

***

## 注意事项与最佳实践

- 任务创建后需调用 `resume()` 开始下载。
- 任务暂停后（`suspend()`）可稍后用 `resume()` 继续执行。
- 使用 `cancelByProducingResumeData()` 可实现**断点续传**功能。
- 即使脚本退出或被系统终止，下载仍会在后台继续执行。
- 重新启动脚本后可通过 `BackgroundURLSession.getDownloadTasks()` 找回任务并重新绑定回调。
- 建议为长时间任务设置 `notifyOnFinished` 以便用户了解进度完成状态。



---
url: /v2/zh/guide/Utilities/URLSession/URLSessionUploadTask.md
---

# 上传任务

`URLSessionUploadTask` 表示一个后台上传任务实例。
它由 `BackgroundURLSession.startUpload()` 或 `BackgroundURLSession.resumeUpload()` 创建，用于在前台或后台上传文件。
上传任务由系统管理，可以在应用或脚本被暂停、切换到后台甚至被终止后继续执行。

每个上传任务都提供状态、进度信息，以及多个回调事件以便追踪上传过程。

***

## 属性（Properties）

### `id: string`

任务的唯一标识符。
可用于脚本重启后识别并恢复同一个上传任务。

**示例**

```ts
console.log(task.id) // 输出任务唯一ID
```

***

### `state: URLSessionTaskState`

上传任务的当前状态。

可能的值包括：

- `"running"`：任务正在上传中
- `"suspended"`：任务已暂停
- `"canceling"`：任务正在取消
- `"completed"`：任务已完成
- `"unknown"`：状态未知（可能任务已被系统清除）

**示例**

```ts
if (task.state === "running") {
  console.log("文件上传中…")
}
```

***

### `progress: URLSessionProgress`

任务的实时进度信息。

包含以下字段：

- `fractionCompleted: number`：完成比例（0–1）
- `totalUnitCount: number`：总字节数
- `completedUnitCount: number`：已上传的字节数
- `isFinished: boolean`：是否已完成
- `estimatedTimeRemaining: number | null`：预计剩余时间（秒），可能为 `null`

**示例**

```ts
const p = task.progress
console.log(`上传进度 ${(p.fractionCompleted * 100).toFixed(1)}%`)
```

***

### `priority: number`

任务优先级（范围 0.0–1.0），默认值为 `0.5`。
数值越高，系统越倾向于优先调度此任务。

**示例**

```ts
task.priority = 0.8
```

***

### `earliestBeginDate?: Date | null`

任务可以开始的最早时间。
可用于延迟任务启动，例如等到网络空闲或充电时执行。

**示例**

```ts
task.earliestBeginDate = new Date(Date.now() + 5_000) // 5秒后可开始上传
```

***

### `countOfBytesClientExpectsToSend: number`

客户端预估将要上传的字节数，仅供系统参考。

### `countOfBytesClientExpectsToReceive: number`

客户端预估将要接收的字节数，仅供系统参考。

***

## 回调函数（Callbacks）

### `onReceiveData?: (data: Data) => void`

当服务器返回响应数据时触发。
参数 `data` 为服务端返回的二进制内容（`Data` 对象）。

**示例**

```ts
task.onReceiveData = data => {
  console.log("收到响应数据：", data.length, "字节")
}
```

***

### `onComplete?: (error: Error | null, resumeData: Data | null) => void`

当上传任务完成（成功或失败）后触发。

**参数说明**

- `error`：若上传失败则为错误对象，否则为 `null`。
- `resumeData`：若上传失败且支持断点续传，包含可用于恢复的 `Data` 对象，否则为 `null`。

**示例**

```ts
task.onComplete = (error, resumeData) => {
  if (error) {
    console.error("上传失败：", error)
    if (resumeData) {
      console.log("任务支持断点续传，可稍后恢复")
    }
  } else {
    console.log("上传完成！")
  }
}
```

***

## 方法（Methods）

### `suspend(): void`

暂停上传任务。
暂停后不会再产生网络流量，也不会超时。可通过 `resume()` 继续。

**示例**

```ts
task.suspend()
console.log("任务已暂停")
```

***

### `resume(): void`

恢复被暂停的上传任务。
新创建的任何任务都处于暂停状态，需要调用 `resume()` 才能开始上传。

**示例**

```ts
task.resume()
console.log("任务已恢复上传")
```

***

### `cancel(): void`

取消上传任务。
调用后任务会立即进入 `"canceling"` 状态，完成取消后触发 `onComplete` 回调并返回错误信息。

**示例**

```ts
task.cancel()
console.log("任务已取消")
```

***

## 示例代码（完整上传流程）

```ts
const task = BackgroundURLSession.startUpload({
  filePath: "/path/to/file.txt",
  toURL: "https://api.example.com/upload",
  method: "POST",
  headers: { Authorization: "Bearer my_token" },
  notifyOnFinished: true
})

task.resume()

task.onReceiveData = data => {
  console.log("收到服务器响应：", data.length, "字节")
}

task.onComplete = (error, resumeData) => {
  if (error) {
    console.error("上传出错：", error)
    if (resumeData) console.log("可以使用 resumeData 恢复上传")
  } else {
    console.log("上传成功！")
  }
}
```

***

## 注意事项与最佳实践

- 任务暂停（`suspend()`）后可通过 `resume()` 恢复。
- 某些服务器支持断点续传，可利用 `resumeData` 实现上传恢复。
- 即使脚本被终止或应用切换到后台，上传任务仍可继续执行。
- 可通过 `BackgroundURLSession.getUploadTasks()` 在脚本重启后找回仍在执行的任务，并重新绑定回调。
- 使用 `notifyOnFinished` 可在上传完成时显示本地通知，方便用户获知任务状态。
- 若需要携带鉴权信息（如 `Authorization`），请务必安全地管理凭证并在请求头中配置。



---
url: /v2/zh/guide/Utilities/UUID.md
---

# UUID

`UUID` 模块提供了简便的方法来生成唯一的 UUID 字符串。

***

## 函数

### `string(): string`

生成一个新的 UUID（通用唯一标识符）字符串。

- **返回值**：\
  一个 UUID 格式的字符串，例如 `"550e8400-e29b-41d4-a716-446655440000"`。

***

## 使用示例

```tsx
const id = UUID.string()
console.log('生成的 UUID：', id)
```



---
url: /v2/zh/guide/Utilities/WebScoket.md
---

# WebScoket

`WebSocket` 类提供了创建和管理 WebSocket 连接的接口，允许与服务器进行实时通信。你可以通过 WebSocket 连接发送和接收文本和二进制数据，包括字节缓冲区。

***

## 概述

WebSocket 是一种通信协议，允许客户端与服务器之间进行全双工通信。这使其非常适用于实时应用程序，如即时消息、通知或数据流。

***

## 类：`WebSocket`

### 构造函数

#### `new WebSocket(url: string)`

创建一个新的 WebSocket 连接到指定的 URL，并立即尝试建立连接。

- **参数**：
  - `url: string`：要连接的 WebSocket 服务器 URL。示例：`"ws://example.com/socket"` 或 `"wss://example.com/socket"`（对于安全的 WebSocket 连接）。

- **返回**：一个表示连接的 `WebSocket` 对象。

***

### 属性

- **`url: string`**\
  WebSocket 连接的 URL。此属性为只读。

- **`onopen?: () => void`**\
  可选的回调函数，当 WebSocket 连接成功建立时触发。

- **`onerror?: (error: Error) => void`**\
  可选的回调函数，当 WebSocket 连接或通信发生错误时触发。

- **`onmessage?: (message: string | Data) => void`**\
  可选的回调函数，当从 WebSocket 服务器接收到消息时触发。`message` 参数可以是字符串或二进制数据（由 `Data` 类表示）。

- **`onclose?: (reason?: string) => void`**\
  可选的回调函数，当 WebSocket 连接关闭时触发。`reason` 参数提供了关闭连接的可选解释。

***

### 方法

#### `send(message: string | Data): void`

通过 WebSocket 连接向服务器发送数据。

- **参数**：
  - `message: string | Data`：要发送到服务器的数据。可以是字符串或 `Data` 类的实例。

- **返回**：`void`

#### `close(code?: 1000 | 1001 | 1002 | 1003, reason?: string): void`

关闭 WebSocket 连接。如果连接已经关闭，则此方法不执行任何操作。

- **参数**：
  - `code?: 1000 | 1001 | 1002 | 1003`：可选的 WebSocket 连接关闭代码。常见的代码包括：
    - `1000`：正常关闭
    - `1001`：离开
    - `1002`：协议错误
    - `1003`：不支持的数据类型
  - `reason?: string`：可选的关闭连接原因。此字符串的长度不得超过 123 字节（UTF-8 编码）。

- **返回**：`void`

***

### 事件处理

你可以使用 `addEventListener` 来监听 WebSocket 事件，并使用 `removeEventListener` 来移除事件监听器。

#### `addEventListener(event: "open", listener: () => void): void`

为 `"open"` 事件添加事件监听器，该事件在 WebSocket 连接建立时触发。

#### `addEventListener(event: "error", listener: (error: Error) => void): void`

为 `"error"` 事件添加事件监听器，该事件在 WebSocket 连接发生错误时触发。

#### `addEventListener(event: "message", listener: (message: string | Data) => void): void`

为 `"message"` 事件添加事件监听器，该事件在从 WebSocket 服务器接收到消息时触发。

#### `addEventListener(event: "close", listener: (reason?: string) => void): void`

为 `"close"` 事件添加事件监听器，该事件在 WebSocket 连接关闭时触发。

#### `removeEventListener(event: "open", listener: () => void): void`

移除 `"open"` 事件的事件监听器。

#### `removeEventListener(event: "error", listener: (error: Error) => void): void`

移除 `"error"` 事件的事件监听器。

#### `removeEventListener(event: "message", listener: (message: string | Data) => void): void`

移除 `"message"` 事件的事件监听器。

#### `removeEventListener(event: "close", listener: (reason?: string) => void): void`

移除 `"close"` 事件的事件监听器。

***

## 示例使用

### 建立 WebSocket 连接

```ts
const ws = new WebSocket("wss://example.com/socket")

// 设置事件监听器
ws.addEventListener("open", () => {
  console.log("连接已建立！")
  ws.send("你好，服务器！")
})

ws.addEventListener("message", (message) => {
  console.log("接收到消息：", message)
})

ws.addEventListener("error", (error) => {
  console.log("WebSocket 错误：", error)
})

ws.addEventListener("close", (reason) => {
  console.log("连接已关闭：", reason)
})
```

### 发送字符串消息

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("open", () => {
  ws.send("你好，这是测试消息！")
})
```

### 使用 `Data` 发送二进制数据

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("open", () => {
  const data = Data.fromString("一些消息")
  ws.send(data) // 发送二进制数据
})
```

### 处理二进制数据

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("message", (message) => {
  if (message instanceof Data) {
    const byteArray = message.getBytes()
    if (byteArray) {
      console.log("接收到的二进制数据：", byteArray)
    }
  }
})
```

### 关闭 WebSocket 连接

```ts
const ws = new WebSocket("wss://example.com/socket")

ws.addEventListener("open", () => {
  console.log("连接已建立！")
  // 使用自定义原因关闭连接
  ws.close(1000, "测试后关闭连接")
})
```

***

## 注意事项

- `send()` 方法可以处理文本和二进制数据。对于二进制数据，你可以使用 `Data` 类来处理字节缓冲区。
- 对于二进制数据，请确保你的 WebSocket 服务器能够处理二进制数据，例如 `ArrayBuffer` 或 `Uint8Array`。
- `close()` 方法可以接受 `code` 和可选的 `reason` 参数来指定 WebSocket 连接如何关闭。



---
url: /v2/zh/guide/Utilities/socket.io.md
---

# socket.io

`Socket.IO` API 提供强大的工具，用于管理客户端与服务器之间的实时双向通信。它包括 `SocketManager`（用于管理多个命名空间）和 `SocketIOClient`（用于单个 socket 连接）。以下是该 API 的详细使用指南，包括设置、配置和常见用例。

***

## 入门

通过 `SocketManager` 创建和管理 WebSocket 连接。每个 `SocketManager` 可以管理多个命名空间和配置。

### 示例：

```typescript
// 创建一个 SocketManager 实例
const manager = new SocketManager("http://localhost:8080", {
    reconnects: true,
    reconnectAttempts: 5,
    compress: true
})

// 获取默认命名空间的 socket
const defaultSocket = manager.defaultSocket

// 创建特定命名空间的 socket
const roomASocket = manager.socket("/roomA")
```

***

## API 参考

### `SocketManager`

#### 构造函数

**`constructor(url: string, config?: SocketManagerConfig)`**

- **`url`**：Socket.IO 服务器的 URL。
- **`config`**：可选的配置对象。

#### 属性

- **`socketURL: string`**：服务器 URL。
- **`status: SocketIOStatus`**：连接状态（如 `connected`、`connecting`、`disconnected` 等）。
- **`defaultSocket: SocketIOClient`**：默认命名空间（`"/"`）的 socket。

#### 方法

- **`socket(namespace: string): SocketIOClient`**\
  返回指定命名空间的 `SocketIOClient`。

- **`setConfigs(config: SocketManagerConfig): void`**\
  更新管理器配置。

- **`disconnect(): void`**\
  断开所有由此实例管理的 socket 连接。

- **`reconnect(): void`**\
  尝试重新连接服务器。

***

### `SocketIOClient`

#### 属性

- **`id: string | null`**：socket 连接的唯一标识符。
- **`status: SocketIOStatus`**：客户端连接状态（如 `connected`、`connecting` 等）。

#### 方法

- **`connect(): void`**\
  发起连接。

- **`disconnect(): void`**\
  断开连接。

- **`emit(event: string, data: any): void`**\
  向服务器发送带有数据的事件。

- **`on(event: string, callback: (data: any[], ack: (value?: any) => void) => void): void`**\
  注册事件监听器。

***

## 配置

通过 `SocketManagerConfig` 对象自定义连接行为。

### 关键选项：

- **`compress`**：启用 WebSocket 传输的压缩。
- **`connectParams`**：连接 URL 中包含的 GET 参数。
- **`cookies`**：在初始连接中发送的 cookies。
- **`forceNew`**：确保每次连接都创建一个新的引擎实例。
- **`reconnects`**：启用自动重连。
- **`reconnectAttempts`**：最大重连次数。
- **`reconnectWait`**：重连尝试之间的最小时间（秒）。

### 示例：

```typescript
const config: SocketManagerConfig = {
    compress: true,
    reconnects: true,
    reconnectAttempts: 5,
    reconnectWait: 2,
    extraHeaders: {
        Authorization: "Bearer token"
    }
}
const manager = new SocketManager("http://example.com", config)
```

***

## 常见用例

### 发送和监听事件

```typescript
const socket = manager.defaultSocket

socket.on("connect", () => {
    console.log("成功连接服务器")
    socket.emit("joinRoom", { room: "roomA" })
})

socket.on("message", (data) => {
    console.log("收到消息：", data)
})
```

### 处理重连

```typescript
manager.setConfigs({ reconnects: true, reconnectAttempts: 10 })

manager.defaultSocket.on("reconnect", () => {
    console.log("已重新连接服务器")
})
```

### 使用命名空间

```typescript
const chatSocket = manager.socket("/chat")

chatSocket.on("newMessage", (data) => {
    console.log("聊天中收到新消息：", data)
})
```

***

## 最佳实践

1. **生命周期管理**：不再需要时调用 `disconnect()`。
2. **命名空间隔离**：为逻辑上不同的通信通道使用独立命名空间。
3. **重连策略**：根据应用需求配置重连参数。
4. **错误处理**：注册 `on("error")` 监听器以优雅地处理连接问题。
5. **安全连接**：对于敏感数据，使用安全 WebSocket（WSS），并配置 `secure: true`。

***

## 完整示例

```typescript
// 创建一个带配置的 SocketManager
const manager = new SocketManager("https://example.com", {
    reconnects: true,
    reconnectAttempts: -1,
    reconnectWait: 1
})

// 获取默认命名空间
const socket = manager.defaultSocket

// 注册事件处理器
socket.on("connect", () => {
    console.log("已连接到服务器")
    socket.emit("join", { room: "lobby" })
})

socket.on("message", (data) => {
    console.log("收到消息：", data)
})

socket.on("disconnect", () => {
    console.log("已断开连接")
})

// 发送自定义事件
socket.emit("sendMessage", { text: "你好，世界！" })

// 完成后断开连接
setTimeout(() => {
    manager.disconnect()
}, 60000)
```



---
url: /v2/zh/guide/View Modifiers/Animation and Transition.md
---

# 动画和过渡

Scripting 通过 `Observable` / `useObservable`、`Animation`、`Transition`、`withAnimation` 以及视图的 `animation` / `transition` 属性，基本对齐了 SwiftUI 的动画能力，包括：

- **属性动画**：数值、颜色、布局等属性随状态变化平滑过渡
- **过渡动画**：视图插入 / 移除时的进出效果（如淡入淡出、滑入滑出、翻转）
- **显式动画**：通过 `withAnimation` 包裹一段「状态更新代码」统一加动画

## Animation 类

`Animation` 用来描述「属性变化的时间曲线与节奏」，类似 SwiftUI 的 `Animation`。

### 工厂方法（创建动画）

#### `Animation.default()`

```ts
static default(): Animation
```

- 创建一个默认动画（通常是系统预设的 ease-in-out 曲线）
- 无需配置，适合「只想要一个普通的过渡效果」的场景

示例：

```tsx
<Text animation={{
  animation: Animation.default(),
  value: value
}}>默认动画</Text>
```

***

#### `Animation.linear(duration?)`

```ts
static linear(duration?: DurationInSeconds | null): Animation
```

- 匀速动画，整段时间内速度保持恒定
- `duration`：动画持续时间（秒），可选，不传时使用默认时长

适合：进度条数值增长、颜色线性变化等。

***

#### `Animation.easeIn(duration?)`

```ts
static easeIn(duration?: DurationInSeconds | null): Animation
```

- 开始慢、后面加速
- 适合：元素「加速进入」的感觉

***

#### `Animation.easeOut(duration?)`

```ts
static easeOut(duration?: DurationInSeconds | null): Animation
```

- 开始快、结尾慢
- 适合：元素「减速停止」的感觉，如卡片滑入后停在目标位置

***

#### `Animation.bouncy(options?)`

```ts
static bouncy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 带回弹效果的动画
- 参数：

  - `duration`：总时长（秒）
  - `extraBounce`：额外弹性，越大越明显

适合：按钮点击放大回弹、卡片弹出等「有趣」的动效。

***

#### `Animation.smooth(options?)`

```ts
static smooth(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 相对柔和、过渡自然的动画
- 与 `bouncy` 相比，弹性感更弱，更偏「丝滑」

***

#### `Animation.snappy(options?)`

```ts
static snappy(options?: {
  duration?: DurationInSeconds
  extraBounce?: number
}): Animation
```

- 动作「干脆利落」，响应速度快
- 常见于触控反馈、选中高亮等瞬间反馈场景

***

#### `Animation.spring(options?)`

```ts
static spring(options?: {
  blendDuration?: number
} & ({
  duration?: DurationInSeconds
  bounce?: number
  response?: never
  dampingFraction?: never
} | {
  response?: number
  dampingFraction?: number
  duration?: never
  bounce?: never
})): Animation
```

支持两种配置方式（注意互斥）：

1. **基于时长的弹簧动画**

   - `duration`: 动画持续时间
   - `bounce`: 弹性大小

2. **物理参数模式**

   - `response`: 响应速度（值越小反馈越快）
   - `dampingFraction`: 阻尼系数（0\~1，越大越「稳」，越小越「弹」）

额外参数：

- `blendDuration`：动画混合时长，用于多动画衔接场景（可选）

示例：

```tsx
// 简单弹簧
const anim1 = Animation.spring({
  duration: 0.4,
  bounce: 0.3
})

// 高级弹簧
const anim2 = Animation.spring({
  response: 0.25,
  dampingFraction: 0.7
})
```

***

#### `Animation.interactiveSpring(options?)`

```ts
static interactiveSpring(options?: {
  response?: number
  dampingFraction?: number
  blendDuration?: number
}): Animation
```

- 面向「交互驱动」的弹簧动画，例如拖拽结束后的回弹
- 参数与 `spring` 的物理参数模式类似，语义更偏向手势交互

***

#### 0 `Animation.interpolatingSpring(options?)`

```ts
static interpolatingSpring(options?: {
  mass?: number
  stiffness: number
  damping: number
  initialVelocity?: number
} | {
  duration?: DurationInSeconds
  bounce?: number
  initialVelocity?: number
  mass?: never
  stiffness?: never
  damping?: never
}): Animation
```

两种配置方式（互斥）：

1. **物理参数模式**

   - `mass`: 质量
   - `stiffness`: 刚度
   - `damping`: 阻尼
   - `initialVelocity`: 初速度（可选）

2. **时长 + 弹性模式**

   - `duration`: 动画时长
   - `bounce`: 弹性
   - `initialVelocity`: 初速度（可选）

适合对动态效果「非常在意手感」的高级场景。

***

### 修改已有动画（链式 API）

#### `delay(time)`

```ts
delay(time: DurationInSeconds): Animation
```

- 使动画延迟 `time` 秒后再开始
- 返回一个新的 `Animation` 实例（原动画不变）

示例：

```tsx
const [animValue, setAnimValue] = useState(0)
const anim = Animation
  .spring({ duration: 0.4, bounce: 0.3 })
  .delay(0.2)

<Text animation={{
  animation: anim,
  value: animValue
}>延迟弹簧</Text>
```

***

#### `repeatCount(count, autoreverses?)`

```ts
repeatCount(count: number, autoreverses?: boolean): Animation
```

- 重复执行动画 `count` 次
- `autoreverses`（默认 `true`）：是否来回反向播放

示例：

```tsx
const pulse = Animation
  .easeIn(0.6)
  .repeatCount(3, true)

<Text animation={{
  animation: pulse,
  value: value
}}>闪烁三次</Text>
```

***

#### `repeatForever(autoreverses?)`

```ts
repeatForever(autoreverses?: boolean): Animation
```

- 无限次重复动画
- 适合加载动画、呼吸灯效果等

***

### Animation 实战示例

#### 示例 1：基本大小动画

```tsx
import { VStack, Button, Rectangle, useObservable, Animation, withAnimation } from "scripting"

export function Demo() {
  const size = useObservable(80)

  return <VStack spacing={16}>
    <Rectangle
      frame={{ width: size.value, height: size.value }}
      backgroundColor="blue"
      animation={{
        animation: Animation.spring({ duration: 0.3, bounce: 0.2 }),
        value: size.value
      }}
    />

    <Button
      title="Toggle Size"
      action={() => {
        withAnimation(() => {
          size.setValue(size.value === 80 ? 140 : 80)
        })
      }}
    />
  </VStack>
}
```

***

## Transition 类（视图过渡）

`Transition` 描述的是**视图插入与移除**时的「进场 / 退场效果」，对应 SwiftUI 的 `AnyTransition`。

> 注意：只有当视图在 JSX 中「存在与否」发生变化（如 `{visible.value && <Text ... />}`）时，`transition` 才会生效。

### 实例方法

#### `animation(animation?)`

```ts
animation(animation?: Animation): Transition
```

- 为当前过渡指定（或覆盖）使用的 `Animation`
- 不传时使用默认动画

示例：

```tsx
const t = Transition
  .move("bottom")
  .animation(Animation.spring({ duration: 0.4 }))
```

***

#### `combined(other)`

```ts
combined(other: Transition): Transition
```

- 组合两个过渡效果，类似 SwiftUI 的 `.combined`
- 如：向下滑入 + 淡入

示例：

```tsx
const t = Transition
  .move("bottom")
  .combined(Transition.opacity())
```

在视图中使用：

```tsx
<Text transition={t}>组合过渡</Text>
```

***

### 静态方法（构造不同类型的过渡）

#### `Transition.identity()`

```ts
static identity(): Transition
```

- 「没有任何过渡」，视图插入 / 移除时不会做动画
- 通常用于禁用某些分支的过渡效果

***

#### `Transition.move(edge)`

```ts
static move(edge: Edge): Transition
```

- 从某个边缘移入 / 移出
- `edge` 通常是 `"leading" | "trailing" | "top" | "bottom"` 等（和 SwiftUI 对齐）

示例：

```tsx
<Text transition={Transition.move("leading")}>
  从左侧滑入 / 滑出
</Text>
```

***

#### `Transition.offset(position?)`

```ts
static offset(position?: Point): Transition
```

- 通过偏移实现过渡
- `position`: `{ x: number, y: number }`，默认 `{ x: 0, y: 0 }`

例如：

```tsx
<Text
  transition={Transition.offset({ x: 0, y: 40 })}
>
  从下方位移进出
</Text>
```

***

#### `Transition.pushFrom(edge)`

```ts
static pushFrom(edge: Edge): Transition
```

- 类似导航 push 的效果，从某个边缘推入并把旧内容推走
- 适合做「页面切换」类效果

***

#### `Transition.opacity()`

```ts
static opacity(): Transition
```

- 单纯的淡入 / 淡出
- 与 `Animation` 搭配可以控制淡入淡出的节奏

***

#### `Transition.scale(scale?, anchor?)`

```ts
static scale(
  scale?: number,
  anchor?: Point | KeywordPoint
): Transition
```

- 缩放过渡
- `scale`：缩放比（默认 1）
- `anchor`：缩放基准点，支持：

  - `Point`：如 `{ x: 0.5, y: 0.5 }`
  - `KeywordPoint`：如 `"center"`、`"top"`, `"bottom"` 等（具体值与 Scripting 内部对齐）

示例：

```tsx
<Text
  transition={Transition.scale(0.8, "center")}
>
  缩放进出
</Text>
```

***

#### `Transition.slide()`

```ts
static slide(): Transition
```

- 类似 SwiftUI 的 `.slide`，通常是从一侧滑入 / 滑出（具体方向由系统决定）
- 常用于列表项、简单出现 / 消失效果

***

#### `Transition.fade(duration?)`

```ts
static fade(duration?: DurationInSeconds): Transition
```

- 带时长配置的淡入 / 淡出
- 与 `Transition.opacity()` 类似，但可以直接指定过渡时间

***

#### Flip 系列（翻转过渡）

```ts
static flipFromLeft(duration?: DurationInSeconds): Transition
static flipFromBottom(duration?: DurationInSeconds): Transition
static flipFromRight(duration?: DurationInSeconds): Transition
static flipFromTop(duration?: DurationInSeconds): Transition
```

- 类似卡片翻转的 3D 过渡

示例：

```tsx
<Text
  transition={Transition.flipFromLeft(0.4)}
>
  左侧翻入 / 翻出
</Text>
```

***

#### 0 `Transition.asymmetric(insertion, removal)`

```ts
static asymmetric(
  insertion: Transition,
  removal: Transition
): Transition
```

- 插入和移除使用不同的过渡效果
- 典型用法：进入时从下方滑入，离开时淡出

示例：

```tsx
const appear = Transition
  .move("bottom")
  .combined(Transition.opacity())

const disappear = Transition.opacity()

const t = Transition.asymmetric(appear, disappear)

<Text transition={t}>不对称过渡</Text>
```

***

### Transition 实战示例

#### 示例：多种过渡效果对比

```tsx
const visible = useObservable(true)

return <VStack spacing={12}>
  {visible.value &&
    <Text
      transition={Transition.slide().combined(Transition.opacity())}
    >
      Slide + Fade
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.move("leading")}
    >
      Move leading
    </Text>
  }

  {visible.value &&
    <Text
      transition={Transition.scale()}
    >
      Scale
    </Text>
  }

  <Button
    title="Toggle"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## withAnimation：显式动画入口

`withAnimation` 用来「显式」地将一段状态更新包裹在动画上下文中，类似 SwiftUI 的 `withAnimation`。
它返回 `Promise<void>`，方便在异步逻辑中等待动画完成。

### 重载签名

```ts
function withAnimation(body: () => void): Promise<void>
function withAnimation(animation: Animation, body: () => void): Promise<void>
function withAnimation(
  animation: Animation,
  completionCriteria: "logicallyComplete" | "removed",
  body: () => void
): Promise<void>
```

- 第一个重载：使用默认动画
- 第二个重载：指定动画曲线 / 弹性等
- 第三个重载：额外指定**完成条件**：

  - `"logicallyComplete"`：动画在时间轴上播放完成时视为完成（典型属性动画）
  - `"removed"`：通常用于涉及过渡的场景，等待相关视图被移出 / 动画结束后再继续逻辑（具体行为依赖底层 SwiftUI）

> 实际等待的精确时机由内部动画系统决定，一般可理解为「该动画相关的视图不再处于动画中」。

***

### 基本用法

#### 默认动画

```tsx
const size = useObservable(100)

<Button
  title="Toggle"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value === 100 ? 200 : 100)
    })
  }}
/>
```

***

#### 指定动画

```tsx
const visible = useObservable(true)

<Button
  title="Toggle Panel"
  action={() => {
    withAnimation(
      Animation.spring({ duration: 0.3, bounce: 0.2 }),
      () => {
        visible.setValue(!visible.value)
      }
    )
  }}
/>
```

***

#### 在异步函数中等待动画结束

```ts
async function hideThenRunTask() {
  await withAnimation(Animation.easeOut(0.25), () => {
    visible.setValue(false)
  })

  // 此处可以认为相关动画已经结束，再继续耗时任务或导航
  await doSomethingHeavy()
}
```

***

## 视图上的 animation / transition 属性

在 Scripting 的视图组件上，可以通过 props 的形式配置动画相关行为：

- `animation?: Animation`（属性动画）
- `transition?: Transition`（插入 / 移除过渡）

### 属性动画（animation）

属性动画的核心逻辑：

- 当某个视图依赖的 `Observable` 的 `value` 发生变化时
- 如果该视图设置了 `animation={...}` 或更新发生在 `withAnimation` 中
- 则 SwiftUI 会对这些属性差异进行插值，从原值平滑过渡到新值

示例：

```tsx
const size = useObservable(80)

<Rectangle
  frame={{
    width: size.value,
    height:size.value
  }}
  backgroundColor="green"
  animation={{
    animation: Animation.spring({ duration: 0.3, bounce: 0.25 }),
    value: size.value
  }}
/>
```

配合 `withAnimation`：

```tsx
<Button
  title="Grow"
  action={() => {
    withAnimation(() => {
      size.setValue(size.value + 20)
    })
  }}
/>
```

***

### 过渡动画（transition）

过渡动画只在「视图从无到有 / 从有到无」时生效。

关键点：

- 通常通过条件渲染控制：

  ```tsx
  {visible.value && <Text transition={...}>Hello</Text>}
  ```

- 状态变化本身需要动画上下文（`withAnimation` 或默认动画）

- `Transition.animation(...)` 可为过渡指定特定 `Animation`

示例：条件面板的进出过渡

```tsx
const visible = useObservable(false)

<VStack>
  {visible.value &&
    <Text
      transition={Transition
        .move("bottom")
        .combined(Transition.opacity())
        .animation(Animation.spring({ duration: 0.35, bounce: 0.3 }))
      }
    >
      Panel
    </Text>
  }

  <Button
    title="Toggle Panel"
    action={() => {
      withAnimation(() => {
        visible.setValue(!visible.value)
      })
    }}
  />
</VStack>
```

***

## 综合示例：列表增删带过渡与属性动画

```tsx
import {
  VStack,
  HStack,
  Text,
  Button,
  useObservable,
  Animation,
  Transition
} from "scripting"

type Item = { id: string; title: string }

export function AnimatedList() {
  const items = useObservable<Item[]>([
    { id: "1", title: "First" },
    { id: "2", title: "Second" }
  ])

  function addItem() {
    withAnimation(Animation.spring({ duration: 0.3 }), () => {
      const next = items.value.length + 1
      items.setValue([
        ...items.value,
        { id: String(next), title: `Item ${next}` }
      ])
    })
  }

  function removeLast() {
    if (items.value.length === 0) return
    withAnimation(Animation.easeOut(0.25), () => {
      items.setValue(items.value.slice(0, -1))
    })
  }

  return <VStack spacing={12}>
    {items.value.map(item =>
      <HStack
        key={item.id}
        transition={Transition
          .move("trailing")
          .combined(Transition.opacity())
        }
      >
        <Text>{item.title}</Text>
      </HStack>
    )}

    <HStack spacing={12}>
      <Button title="Add" action={addItem} />
      <Button title="Remove Last" action={removeLast} />
    </HStack>
  </VStack>
}
```

这个示例中：

- 使用 `Observable<Item[]>` 作为列表数据源
- `transition` 负责列表项插入 / 删除时的滑动 + 淡入淡出
- `withAnimation` 包裹增删操作，确保这些更新被动画化



---
url: /v2/zh/guide/View Modifiers/Chaining View Modifiers.md
---

# 可链式调用的修饰符

`modifiers` 是一个支持链式调用的视图修饰器集合，允许你为同一个视图应用多个修饰器，并以严格的顺序依次执行。

与传统 TSX 中每个视图只能通过一个 `modifier` 属性传入单个修饰器不同，`modifiers` 支持：

- 同一种修饰器的重复使用（例如多个 `padding()`、`background()`）
- 明确控制修饰器的应用顺序
- 更贴近 SwiftUI 的声明方式和效果

***

## 类型定义

```ts
declare function modifiers(): ViewModifiers;

declare class ViewModifiers {
  padding(value): this;
  background(value): this;
  opacity(value): this;
  frame(value): this;
  font(value): this;
  // ... 还有更多方法（同 `CommonViewProps` 的属性）
}
```

`ViewModifiers` 是一个可链式调用的类，内部方法对应 SwiftUI 中的各类 View Modifier。每个方法返回自身（`this`），以支持流式调用。

***

## 使用优势

- **支持多次使用相同修饰器**
  如：连续嵌套多个 `.padding()` 或 `.background()`，可表达更加丰富的 UI 层级。

- **明确的顺序控制**
  修饰器按调用顺序依次生效，结果与 SwiftUI 一致。

- **更好的结构化与复用**
  可将复杂的修饰器链提取为变量或函数，增强可维护性与复用性。

- **更贴近 SwiftUI**
  如果你熟悉 SwiftUI，会发现 `modifiers()` 的调用方式几乎一模一样。

***

## 使用示例

### 示例 1：多层背景与内边距嵌套

```tsx
<VStack
  modifiers={
    modifiers()
      .padding()
      .background("red")
      .padding()
      .background("blue")
  }
>
  <Text>Hello</Text>
</VStack>
```

等价于 SwiftUI：

```swift
Text("Hello")
  .padding()
  .background(Color.red)
  .padding()
  .background(Color.blue)
```

### 示例 2：提取并复用修饰器链

```ts
const cardStyle = modifiers()
  .padding(12)
  .background("gray")
  .cornerRadius(8)
  .opacity(0.9)

<List modifiers={cardStyle}>
  <Text>Item 1</Text>
</List>
```

### 示例 3：根据条件动态生成修饰器

```ts
const base = modifiers().padding()

if (isDarkMode) {
  base.background("black")
} else {
  base.background("white")
}

return <HStack modifiers={base}>...</HStack>
```

***

## 使用建议

在以下情况中建议使用 `modifiers`：

- 需要对视图多次使用同一个修饰器（如 `padding()`）
- 希望拆分 UI 样式并复用一套完整的样式链
- 需要控制修饰器的执行顺序
- 需要在运行时根据条件动态组装修饰器

***

## 支持的修饰器方法

`ViewModifiers` 提供了超过 200 个修饰器方法，覆盖：

- **布局类**：`padding`、`frame`、`offset`、`position`、`zIndex` 等
- **样式类**：`background`、`foregroundStyle`、`opacity`、`shadow`、`clipShape` 等
- **文本字体类**：`font`、`bold`、`italic`、`kerning`、`underline` 等
- **交互事件类**：`onTapGesture`、`onAppear`、`contextMenu` 等
- **图表类**：`chartXAxis`、`chartYAxisLabel`、`chartSymbolScale` 等
- **组件专属类**：如 `widgetURL`、`widgetBackground` 等

> 可查阅完整的 `ViewModifiers` 类型定义以获取所有支持的方法。

***

## 注意事项

- 每次调用 `modifiers()` 会创建一个新的实例，不会与其他实例合并。
- 修饰器的执行顺序完全依赖于调用顺序。
- 当需要同一个修饰器在同一个视图上多次使用时，可以使用 `modifiers` 进行链式调用。

***

通过 `modifiers`，你可以实现更灵活、结构化、可复用的 UI 风格配置，构建贴近 SwiftUI 的声明式体验。适合构建复杂布局、响应式风格以及脚本组件样式抽象。



---
url: /v2/zh/guide/View Modifiers/ChartMarkProps/index.md
---

# 通用图表标记属性 (ChartMarkProps)

`ChartMarkProps` 用于配置图表中的每一个 mark（例如柱状图的 BarMark、折线图的 LineMark 等），提供一系列通用的修饰属性，支持设置样式、符号、位置、注解、变换等内容。该类型可用于 `BarChart`、`LineChart`、`AreaChart` 等组件的 `marks` 属性中。

***

## 一、样式修饰

### `foregroundStyle`

设置图表内容的填充颜色或样式。

- 类型：`ShapeStyle | DynamicShapeStyle`
- 示例：

  ```tsx
  foregroundStyle: "systemGreen"
  ```

***

### `opacity`

设置透明度，取值范围为 `0.0 ~ 1.0`。

- 类型：`number`
- 示例：

  ```tsx
  opacity: 0.5
  ```

***

### `cornerRadius`

设置图形的圆角半径，常用于柱状图或胶囊图。

- 类型：`number`
- 示例：

  ```tsx
  cornerRadius: 8
  ```

***

### `lineStyle`

设置线条样式，适用于折线图或路径图。

- 类型：`StrokeStyle`
- 结构：

  ```ts
  {
    lineWidth?: number
    lineCap?: 'butt' | 'round' | 'square'
    lineJoin?: 'bevel' | 'miter' | 'round'
    mitterLimit?: number
    dash?: number[]
    dashPhase?: number
  }
  ```
- 示例：

  ```tsx
  lineStyle: {
    lineWidth: 2,
    lineCap: "round",
    dash: [4, 2]
  }
  ```

***

### `interpolationMethod`

设置线图或面积图的插值方式（曲线连接方式）。

- 类型：`ChartInterpolationMethod`
- 可选值：
  `"cardinal"`、`"catmullRom"`、`"linear"`、`"monotone"`、`"stepCenter"`、`"stepEnd"`、`"stepStart"`
- 示例：

  ```tsx
  interpolationMethod: "catmullRom"
  ```

***

### `alignsMarkStylesWithPlotArea`

样式是否与绘图区对齐。

- 类型：`boolean`
- 示例：

  ```tsx
  alignsMarkStylesWithPlotArea: true
  ```

***

## 二、符号设置（用于折线图或散点图）

### `symbol`

设置标记符号的形状，或使用自定义视图作为标记。

- 类型：`ChartSymbolShape | VirtualNode`
- 可选值：
  `"circle"`、`"square"`、`"triangle"`、`"diamond"`、`"cross"`、`"plus"`、`"asterisk"`、`"pentagon"`
- 示例：

  ```tsx
  symbol: "triangle"
  ```

***

### `symbolSize`

设置符号大小，可以是单一数值或包含宽高的对象。

- 类型：`number | { width: number; height: number }`
- 示例：

  ```tsx
  symbolSize: 18
  // 或
  symbolSize: { width: 16, height: 16 }
  ```

***

## 三、注解设置

### `annotation`

为某个 mark 添加注释视图，并可设置位置、对齐、间距及溢出处理策略。

- 类型：`VirtualNode | { position?, alignment?, spacing?, overflowResolution?, content }`
- 示例：

  ```tsx
  annotation: {
    position: "top",
    alignment: "center",
    spacing: 4,
    overflowResolution: {
      x: "fit",
      y: "padScale"
    },
    content: <Text>注解</Text>
  }
  ```

#### `AnnotationPosition` 注解位置

用于控制注解视图相对于 mark 的定位位置。

- 类型：字符串
- 可选值：
  `"automatic"`、`"top"`、`"topLeading"`、`"topTrailing"`、
  `"bottom"`、`"bottomLeading"`、`"bottomTrailing"`、
  `"leading"`、`"trailing"`、`"overlay"`

***

#### `AnnotationOverflowResolutionStrategy` 溢出处理策略

用于处理注解超出图表边界时的排版策略。

- 可选值：

  - `"automatic"`：自动选择合适的策略
  - `"fit"`：自动调整位置以适配边界
  - `"fitToPlot"`：限制在绘图区范围内
  - `"fitToChart"`：限制在整个图表范围内
  - `"fitToAutomatic"`：自动选择图表或绘图区
  - `"padScale"`：扩展坐标范围为注解留出空间
  - `"disabled"`：不处理溢出，允许剪裁

***

## 四、图形变换效果

### `clipShape`

设置图形裁剪区域的形状。

- 类型：`"rect"`、`"circle"`、`"capsule"`、`"ellipse"`、`"buttonBorder"`、`"containerRelative"`
- 示例：

  ```tsx
  clipShape: "capsule"
  ```

***

### `shadow`

为 mark 添加阴影。

- 类型：

  ```ts
  {
    color?: string
    radius: number
    x?: number
    y?: number
  }
  ```
- 示例：

  ```tsx
  shadow: {
    color: "systemGray",
    radius: 4,
    x: 2,
    y: 2
  }
  ```

***

### `blur`

添加模糊效果，数值越大模糊越强。

- 类型：`number`
- 示例：

  ```tsx
  blur: 5
  ```

***

### `zIndex`

控制 mark 在图层中的显示顺序。

- 类型：`number`
- 示例：

  ```tsx
  zIndex: 10
  ```

***

### `offset`

为 mark 设置偏移量，可控制其在 X/Y 轴上的位置偏移。

- 类型支持以下形式：

  - `{ x, y }`
  - `{ x, yStart, yEnd }`
  - `{ xStart, xEnd, y }`
  - `{ xStart, xEnd, yStart, yEnd }`
- 示例：

  ```tsx
  offset: { x: 10, y: -5 }
  ```

***

## 五、数据绑定修饰（`xxxBy`）

通过绑定数据字段实现动态设置样式或位置，不能与相同功能的静态属性同时使用。

***

### `foregroundStyleBy`

根据数据字段动态设置填充样式。

- 类型：`string | number | Date | { value, label }`
- 示例：

  ```tsx
  foregroundStyleBy: {
    value: item.color,
    label: "颜色"
  }
  ```

***

### `lineStyleBy`

根据数据字段动态设置线条样式。

- 示例：

  ```tsx
  lineStyleBy: {
    value: item.type,
    label: "线型"
  }
  ```

***

### `positionBy`

设置 mark 的位置和在图表坐标轴上的作用方向。

- 类型：

  ```ts
  {
    value: string | number | Date
    label?: string
    axis: 'horizontal' | 'vertical'
    span?: MarkDimension
  }
  ```
- 示例：

  ```tsx
  positionBy: {
    value: item.category,
    axis: "horizontal",
    span: {
      type: "ratio",
      value: 0.8
    }
  }
  ```

#### `MarkDimension` 标记尺寸控制

用于控制 mark 在轴向上的占用空间或尺寸。

- 类型：`"automatic"` 或：

  ```ts
  {
    type: "inset" | "fixed" | "ratio"
    value: number
  }
  ```
- 含义说明：

  - `"automatic"`：系统自动决定尺寸
  - `"inset"`：根据设定的边距减少宽度或高度
  - `"fixed"`：固定的像素尺寸
  - `"ratio"`：根据比例占据坐标轴步长（范围 0\~1）

***

### `symbolBy`

根据数据字段动态设置符号形状。

- 示例：

  ```tsx
  symbolBy: {
    value: item.category,
    label: "类型"
  }
  ```

***

### `symbolSizeBy`

根据数据字段动态设置符号大小。

- 示例：

  ```tsx
  symbolSizeBy: {
    value: item.count,
    label: "数量"
  }
  ```

***

## 示例：分组柱状图

```tsx
<BarChart
  marks={data.map(item => ({
    label: item.type,
    value: item.count,
    positionBy: {
      value: item.color,
      axis: "horizontal"
    },
    foregroundStyleBy: item.color,
    cornerRadius: 8
  }))}
/>
```



---
url: /v2/zh/guide/View Modifiers/Charts Style.md
---

# 图表样式

该组件提供了一个高度可定制的界面，用于创建和展示多种类型的图表。本文档详细说明了如何使用 `Chart` 视图的属性来配置轴、比例、标签、图例等。

***

### **1. 轴的可见性**

- **`chartXAxis`**
  - **类型**: `"automatic" | "hidden" | "visible"`
  - **描述**: 设置 X 轴的可见性。
  - **示例**:
    ```tsx
    <Chart chartXAxis="visible">
      <BarChart ... />
    </Chart>
    ```

- **`chartYAxis`**
  - **类型**: `"automatic" | "hidden" | "visible"`
  - **描述**: 设置 Y 轴的可见性。
  - **示例**:
    ```tsx
    <Chart chartYAxis="hidden">
      <LineChart ... />
    </Chart>
    ```

***

### **2. 轴标签**

- **`chartXAxisLabel`**
  - **类型**:
    ```ts
    {
      position?: "automatic" | "bottom" | "bottomLeading" | "bottomTrailing" | "leading" | "overlay" | "top" | "topLeading" | "topTrailing" | "trailing";
      alignment?: "leading" | "center" | "trailing";
      spacing?: number;
      content: VirtualNode;
    }
    ```
  - **描述**: 为 X 轴添加标签。
  - **示例**:
    ```tsx
    <Chart
      chartXAxisLabel={{
        position: "bottom",
        alignment: "center",
        spacing: 10,
        content: <Text>X 轴标签</Text>,
      }}
    >
      <BarChart ... />
    </Chart>
    ```

- **`chartYAxisLabel`**
  - **类型**: 与 `chartXAxisLabel` 相同。
  - **描述**: 为 Y 轴添加标签。
  - **示例**:
    ```tsx
    <Chart
      chartYAxisLabel={{
        position: "leading",
        content: <Text>Y 轴标签</Text>,
      }}
    >
      <LineChart ... />
    </Chart>
    ```

***

### **3. 图例**

- **`chartLegend`**
  - **类型**:
    ```ts
    "automatic" | "hidden" | "visible" | {
      position?: "automatic" | "bottom" | "bottomLeading" | "bottomTrailing" | "leading" | "overlay" | "top" | "topLeading" | "topTrailing" | "trailing";
      alignment?: "leading" | "center" | "trailing";
      spacing?: number;
      content?: VirtualNode;
    }
    ```
  - **描述**: 配置图例。
  - **示例**:
    ```tsx
    <Chart
      chartLegend={{
        position: "top",
        alignment: "center",
        content: <Text>图例</Text>,
      }}
    >
      <AreaChart ... />
    </Chart>
    ```

***

### **4. 比例**

- **`chartXScale` / `chartYScale`**
  - **类型**:
    ```ts
    ClosedRange<number> | ClosedRange<Date> | string[] | "category" | "date" | "linear" | "log" | "squareRoot" | "symmetricLog" | {
      domain: ClosedRange<number> | ClosedRange<Date> | string[];
      type: "category" | "date" | "linear" | "log" | "squareRoot" | "symmetricLog";
    }
    ```
  - **描述**: 配置 X 或 Y 轴的比例。
  - **示例**:
    ```tsx
    <Chart
      chartXScale={{ domain: { from: 0, to: 100 }, type: "linear" }}
      chartYScale={["A", "B", "C"]}
    >
      <LineChart ... />
    </Chart>
    ```

***

### **5. 背景**

- **`chartBackground`**
  - **类型**:
    ```ts
    VirtualNode | {
      alignment?: "leading" | "center" | "trailing";
      content: VirtualNode;
    }
    ```
  - **描述**: 为图表容器添加背景。
  - **示例**:
    ```tsx
    <Chart
      chartBackground={{
        alignment: "center",
        content: <Rectangle fill="gray" />,
      }}
    >
      <PieChart ... />
    </Chart>
    ```

***

### **6. 前景样式**

- **`chartForegroundStyleScale`**
  - **类型**:
    ```ts
    Record<string, ShapeStyle>;
    ```
  - **描述**: 自定义图表标记的颜色。
  - **示例**:
    ```tsx
    <Chart
      chartForegroundStyleScale={{
        "类别 1": { color: "blue" },
        "类别 2": { color: "red" },
      }}
    >
      <BarChart ... />
    </Chart>
    ```

***

### **7. 可滚动轴**

- **`chartScrollableAxes`**
  - **类型**:
    ```ts
    "vertical" | "horizontal" | "all"
    ```
  - **描述**: 启用指定轴的滚动。
  - **示例**:
    ```tsx
    <Chart chartScrollableAxes="horizontal">
      <LineChart ... />
    </Chart>
    ```

***

### **8. 选中**

- **`chartXSelection` / `chartYSelection` / `chartAngleSelection`**
  - **类型**:
    ```ts
    {
      value: string | number | null;
      onChanged: (newValue: string | number | null) => void;
      valueType: "string" | "number";
    }
    ```
  - **描述**: 启用指定轴的选择功能。
  - **示例**:
    ```tsx
    <Chart
      chartXSelection={{
        value: "类别 1",
        onChanged: (newValue) => console.log("已选择:", newValue),
        valueType: "string",
      }}
    >
      <BarChart ... />
    </Chart>
    ```

***

### **9. 滚动位置**

- **`chartScrollPositionX` / `chartScrollPositionY`**
  - **类型**:
    ```ts
    number | string | {
      value: number | string;
      onChanged: (newValue: number | string) => void;
    }
    ```
  - **描述**: 设置 X 或 Y 轴的初始滚动位置。
  - **示例**:
    ```tsx
    <Chart
      chartScrollPositionX={{
        value: 0,
        onChanged: (newValue) => console.log("滚动 X:", newValue),
      }}
    >
      <BarChart ... />
    </Chart>
    ```

***

## **综合示例**

以下示例展示了如何使用多个属性来创建一个完全自定义的图表：

```tsx
<Chart
  chartXAxis="visible"
  chartYAxis="visible"
  chartXAxisLabel={{
    position: "bottom",
    alignment: "center",
    spacing: 8,
    content: <Text>X 轴标签</Text>,
  }}
  chartYAxisLabel={{
    position: "leading",
    content: <Text>Y 轴标签</Text>,
  }}
  chartLegend={{
    position: "top",
    alignment: "center",
    content: <Text>图例</Text>,
  }}
  chartXScale={{ domain: { from: 0, to: 100 }, type: "linear" }}
  chartScrollableAxes="all"
  chartForegroundStyleScale={{
    "类别 A": { color: "green" },
    "类别 B": { color: "blue" },
  }}
  chartBackground={{
    content: <Rectangle fill="lightgray" />,
  }}
>
  <BarChart
    marks={[
      { label: "A", value: 30, foregroundStyle: { color: "red" } },
      { label: "B", value: 70 },
    ]}
  />
  <LineChart
    marks={[
      { label: "A", value: 40 },
      { label: "B", value: 80 },
    ]}
  />
</Chart>
```

此示例在单个 `Chart` 容器中结合了轴标签、滚动、图例、比例、前景样式以及多种图表类型。可将其用作构建自定义图表的模板。



---
url: /v2/zh/guide/View Modifiers/Grid Layout Control.md
---

# 网格布局控制

这些修饰符用于控制视图在 `Grid` 网格布局中的行为，包括单元格的跨列、对齐方式、尺寸限制等，适用于构建灵活且精细的二维界面布局。

***

### `gridCellColumns`

设置某个视图在网格中跨越的列数。

#### 类型

```ts
gridCellColumns?: number
```

#### 说明

用于让单个视图占据多个列，常见用法包括用作区块标题或需要额外水平空间的内容。

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text gridCellColumns={2}>跨越两列的文本</Text>
  </GridRow>
  <GridRow>
    <Text>单元格 A</Text>
    <Text>单元格 B</Text>
  </GridRow>
</Grid>
```

***

### `gridCellAnchor`

设置当前视图在网格单元格内的对齐锚点。

#### 类型

```ts
gridCellAnchor?: KeywordPoint | Point
```

#### 说明

使用关键词（如 `"center"`、`"topLeading"`）或自定义点（如 `{ x: 0.5, y: 0.0 }`）来控制该视图在其单元格中的对齐位置。

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text gridCellAnchor="topLeading">顶部左对齐</Text>
  </GridRow>
</Grid>
```

***

### `gridCellUnsizedAxes`

阻止网格在指定方向上为视图分配额外空间。

#### 类型

```ts
gridCellUnsizedAxes?: AxisSet
```

#### 说明

此修饰符用于告诉网格布局：不要在特定方向（水平或垂直）扩展该视图的尺寸，使其内容尺寸更紧凑。

#### 可选值

- `"horizontal"` – 禁止水平扩展
- `"vertical"` – 禁止垂直扩展
- `"all"` – 禁止两个方向的扩展

#### 示例

```tsx
<Grid>
  <GridRow>
    <Image
      gridCellUnsizedAxes="horizontal"
      imageUrl="https://example.com/icon.png"
    />
    <Text>图标说明</Text>
  </GridRow>
</Grid>
```

***

### `gridColumnAlignment`

设置该视图所在列的水平对齐方式。

#### 类型

```ts
gridColumnAlignment?: "leading" | "center" | "trailing"
```

#### 说明

此修饰符将影响该列中所有视图的水平对齐方式。通常只需要对列中的第一个视图设置即可。

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text gridColumnAlignment="trailing">右对齐列</Text>
    <Text>下一单元格</Text>
  </GridRow>
</Grid>
```

***

## Grid 与 GridRow 结构说明

上述修饰符需在 `Grid` 和 `GridRow` 结构内使用，结构类似 SwiftUI 的 `Grid` 布局系统。

### `Grid`

二维容器，按照行和列排列子视图。

#### 可用属性

- `alignment?: Alignment` — 网格中单元格的默认对齐方式
- `horizontalSpacing?: number` — 列之间的水平间距
- `verticalSpacing?: number` — 行之间的垂直间距

#### 示例

```tsx
<Grid>
  <GridRow>
    <Text>Hello</Text>
    <Image systemName="globe" />
  </GridRow>
  <Divider />
  <GridRow>
    <Image systemName="hand.wave" />
    <Text>World</Text>
  </GridRow>
</Grid>
```

### `GridRow`

表示网格中的一行，包含若干水平排列的单元格。

#### 可用属性

- `alignment?: VerticalAlignment` — 控制整行中内容的垂直对齐方式

***

## 总结

| 修饰符                   | 功能描述              |
| --------------------- | ----------------- |
| `gridCellColumns`     | 设置视图跨越的列数         |
| `gridCellAnchor`      | 设置视图在单元格中的对齐锚点    |
| `gridCellUnsizedAxes` | 指定视图不在特定方向上自动扩展   |
| `gridColumnAlignment` | 控制当前列中所有视图的水平对齐方式 |



---
url: /v2/zh/guide/View Modifiers/Image Style.md
---

# 图片样式

这些修饰符专门用于控制图像视图的缩放、布局与渲染方式。

***

## `scaleToFit`

### 定义

```ts
scaleToFit?: boolean
```

### 描述

将图像按比例缩放，使其完整地**适配容器尺寸**，保持原始宽高比例，不进行裁剪。

等效于 SwiftUI 的：

```swift
.aspectRatio(contentMode: .fit)
```

### 行为说明

- 保留图像的原始宽高比
- 图像完全显示在容器内
- 如果图像比例与容器不一致，可能会留白

### 示例

```tsx
<Image
  filePath="path/to/photo.jpg"
  scaleToFit={true}
/>
```

***

## `scaleToFill`

### 定义

```ts
scaleToFill?: boolean
```

### 描述

将图像按比例缩放，使其**填满整个容器**，保持宽高比，但图像可能会被**裁剪**以适配。

等效于 SwiftUI 的：

```swift
.aspectRatio(contentMode: .fill)
```

### 行为说明

- 图像完全填充容器
- 保持原始宽高比
- 如果比例不同，图像边缘可能会被截断

### 示例

```tsx
<Image
  imageUrl="https://example.com/banner.jpg"
  scaleToFill={true}
/>
```

***

## `aspectRatio`

### 定义

```ts
aspectRatio?: {
  value?: number | null
  contentMode: "fit" | "fill"
}
```

### 描述

强制视图按照指定的**宽高比例**进行布局，可以选择使用 `fit` 或 `fill` 模式控制适配方式。

- `value`: 设置具体的宽高比，例如 `16 / 9`；设为 `null` 表示保持图像原始比例。
- `contentMode`：`"fit"` 表示缩放适配容器但完整显示，`"fill"` 表示缩放填满容器可能被裁剪。

### 示例：设置 3:2 比例并适配显示

```tsx
<Image
  filePath="path/to/photo.jpg"
  aspectRatio={{
    value: 3 / 2,
    contentMode: "fit"
  }}
/>
```

### 示例：保持原始比例并填满容器

```tsx
<Image
  systemName="photo"
  aspectRatio={{
    value: null,
    contentMode: "fill"
  }}
/>
```

***

## `imageScale`

### 定义

```ts
imageScale?: "small" | "medium" | "large"
```

### 描述

设置 SF Symbols 图像的**渲染缩放级别**，不会影响视图的实际布局大小，仅影响图像本身的显示尺寸。

- `"small"`：较小尺寸
- `"medium"`：默认尺寸
- `"large"`：较大尺寸

> 仅适用于通过 `systemName` 创建的系统图标图像。

### 示例

```tsx
<Image
  systemName="bolt.fill"
  imageScale="large"
/>
```

***

## 总结对比

| 修饰符名称         | 功能说明             | 是否影响布局 | 是否裁剪图像 | 是否仅用于符号图像        |
| ------------- | ---------------- | ------ | ------ | ---------------- |
| `scaleToFit`  | 保持比例缩放，完整显示图像    | 是      | 否      | 否                |
| `scaleToFill` | 保持比例缩放，填满容器，可能裁剪 | 是      | 是      | 否                |
| `aspectRatio` | 设置具体宽高比，适配或填充容器  | 是      | 可选     | 否                |
| `imageScale`  | 设置符号图像的渲染尺寸      | 否      | 否      | ✅ 仅用于 SF Symbols |



---
url: /v2/zh/guide/View Modifiers/Lifecycle Events.md
---

# 生命周期事件

Scripting 支持 SwiftUI 风格的生命周期钩子 `onAppear` 与 `onDisappear`，用于在视图显示或从界面中消失时执行自定义逻辑。你可以使用这些钩子执行动画、加载数据、初始化状态或在视图不再可见时清理资源。

***

## 属性定义

```ts
onAppear?: () => void
onDisappear?: () => void
```

### 属性说明

| 属性名           | 类型           | 说明           |
| ------------- | ------------ | ------------ |
| `onAppear`    | `() => void` | 视图可见时触发。     |
| `onDisappear` | `() => void` | 视图从界面上消失时触发。 |

***

## 示例

```tsx
import { VStack, Text, useState } from "scripting"

function Example() {
  const [message, setMessage] = useState("")

  return <VStack
    onAppear={() => setMessage("视图已显示")}
    onDisappear={() => setMessage("视图已隐藏")}
    padding
  >
    <Text>{message}</Text>
  </VStack>
}
```



---
url: /v2/zh/guide/View Modifiers/Liquid Glass/Glass Effect Transition/index.md
---

Liquid Glass 在 iOS 26 引入了更先进的几何匹配与材质过渡能力。
Scripting 完整支持这些特性，并通过 `glassEffectTransition`、`glassEffectID`、`glassEffectUnion`、`GlassEffectContainer` 以及 `NamespaceReader` 组合实现自然、顺滑且结构化的玻璃动画体验。

本文将详细说明：

- 什么是 Glass Effect Transition
- 三种过渡类型
- 为什么需要 glassEffectID 与 namespace
- glassEffectUnion 的作用
- NamespaceReader 的设计目的与机制
- 实际示例解析
- 最佳实践

***

# 1. 概述：什么是 Glass Effect Transition

`glassEffectTransition` 用于指定 Liquid Glass 在视图出现、消失或布局变化期间应如何过渡。

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

Glass Effect Transition 控制三个核心内容：

1. **玻璃材质如何出现 / 消失**
2. **玻璃的几何形状是否会参与动画**
3. **玻璃是否与容器中其他视图的几何形状匹配**

过渡效果只影响“玻璃材质本身”，而不是普通视图的 opacity 或 scale。

***

# 2. 三种过渡类型

## 2.1 identity（无过渡）

```tsx
glassEffectTransition="identity"
```

含义：

- 不应用任何几何或材质动画。
- 内容会直接呈现，不做淡入或几何匹配。

适用于：

- 禁用动画
- 确保界面非常静态
- 开发调试

***

## 2.2 materialize（材质出现动画）

```tsx
glassEffectTransition="materialize"
```

特点：

- 内容会逐渐淡入。
- Liquid Glass 材质会以柔和方式出现和消失。
- 不进行几何匹配，不尝试从其他玻璃形状“过渡”。

适用于：

- 材质出现／消失强调明显
- 不需要几何跟随效果
- 简单切换菜单或按钮

***

## 2.3 matchedGeometry（匹配几何）

```tsx
glassEffectTransition="matchedGeometry"
```

特点：

- 玻璃材质会尝试“继承”同一 namespace 内、相同 ID 的玻璃形状。
- 在视图切换时，从旧形状平滑过渡到新形状。
- 需要使用 `glassEffectID` 指定对应关系。

适用于：

- 复杂菜单切换
- 视图替换（Edit → Home）
- 需要视觉连续性的动画

是 Liquid Glass 最强大也是最常用的模式。

***

# 3. glassEffectID 与 namespace：匹配几何的核心

## 3.1 为什么需要 ID？

几何匹配动画需要知道：

- “旧玻璃”是谁
- “新玻璃”是谁

因此必须给玻璃效果一个身份标识：

```tsx
glassEffectID={{
  id: 1,
  namespace
}}
```

如果两个玻璃视图：

- 位于相同 namespace
- glassEffectID 的 id 相同

系统会认为它们是同一“玻璃实体”的不同状态，允许过渡。

***

## 3.2 为什么必须有 namespace？

SwiftUI 的 matchedGeometry 效果依赖 `@Namespace`，在 Scripting 中我们通过 `NamespaceReader` 暴露给 TSX。

`NamespaceReader` 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ... 在此作用域中所有 glassEffectID 都应使用这个 namespace ...
  )}
</NamespaceReader>
```

原因：

- namespace 用于组织 matchedGeometry 的作用域
- 同一 namespace 内的 ID 才能互相匹配
- 不同 namespace 之间永远不会彼此动画匹配

***

# 4. glassEffectUnion：玻璃材质的联合区域

除了匹配几何形状外，Liquid Glass 还能把多个玻璃区域合并为一个连续材质区域：

```tsx
glassEffectUnion={{
  id: 1,
  namespace
}}
```

效果：

- 相同 union ID 的按钮共享同一个玻璃材质分区
- 多个按钮可看起来像“同一块玻璃切出来的”
- 提升视觉统一性

通常和 matchedGeometry 同时使用。

***

# 5. 示例解析

以下示例展示菜单在两种布局之间切换，并使用动画呈现玻璃过渡：

```tsx
isAlternativeMenu.value
  ? <>
      <Button
        title="Home"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Settings"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
  : <>
      <Button
        title="Edit"
        glassEffectID={{id:1, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
      <Button
        title="Erase"
        glassEffectID={{id:3, namespace}}
        glassEffectUnion={{id:1,namespace}}
        glassEffectTransition="materialize"
      />
      <Button
        title="Delete"
        glassEffectID={{id:2, namespace}}
        glassEffectUnion={{id:1,namespace}}
      />
    </>
```

重点说明：

### 1. 按钮之间共享 Union ID = 1

所有按钮（无论菜单 A 或 B）实际上共享一个玻璃材质“池”。
这样切换时材质背景连续且自然。

### 2. Home / Edit 共享 ID = 1

- 当菜单切换时，Edit → Home 的玻璃材质会自动匹配几何形状，触发 matchedGeometry 动画。

### 3. Delete / Settings 共享 ID = 2

- Delete → Settings 也会使用 matching transition。

### 4. Erase 设置了 materialize

```tsx
glassEffectTransition="materialize"
```

它不会尝试匹配几何，而是用材质淡入淡出的动画。
这可以让某个按钮以不同方式呈现，令人体验变化更明显。

### 5. 整个 HStack 包裹在 GlassEffectContainer

```tsx
<GlassEffectContainer>
  <HStack> ... </HStack>
</GlassEffectContainer>
```

容器提供：

- 匹配几何所需的上下文
- 优化渲染性能
- 让 union 生效

***

# 6. NamespaceReader：Scripting 如何暴露 @Namespace

在 SwiftUI 中：

```swift
@Namespace private var ns
```

只能在 SwiftUI View 中使用，无法直接从 TypeScript 中访问。

因此 Scripting 提供：

```tsx
<NamespaceReader>
  {namespace => (
    ...
  )}
</NamespaceReader>
```

### 作用：

1. 实际内部创建 SwiftUI 的 `@Namespace`
2. 自动管理生命周期
3. 将 namespace 提供给 TS
4. 保证同一 TSX 作用域使用同一个 namespace

等价于：

```tsx
@Namespace var namespace

glassEffectID={{ id: x, namespace }}
```

没有 NamespaceReader，无论 matchedGeometry 还是 union 都无法工作。

***

# 7. 动画触发方式（withAnimation）

玻璃过渡不会自行动画，必须使用动画触发状态切换：

```tsx
withAnimation(() => {
  isAlternativeMenu.setValue(
    !isAlternativeMenu.value
  )
})
```

匹配几何、材质出现动画等会自动附着到这次动画事务中。

***

# 8. 最佳实践

### 1. 所有参与动画的视图必须在同一个 GlassEffectContainer

否则 matchedGeometry 不会生效。

### 2. namespace 必须由同一个 NamespaceReader 提供

**不要跨层级或重复构造 namespace**。

### 3. glassEffectID 必须在两个状态中都出现

否则 SwiftUI 无法关联动画。

### 4. 若要连续的材质外观，应使用 glassEffectUnion

让按键像同一块玻璃切换。

### 5. 除特殊情况外，尽量使用 matchedGeometry

可获得更自然的“流动感”。

***

# 9. 总结

Glass Effect Transition 是 iOS 26 Liquid Glass 系统的核心特性之一，它让玻璃材质在视图切换中具备几何匹配、材质渐变与联合区域动画。

在 Scripting 中：

- `glassEffectTransition` 控制动画类型
- `glassEffectID` + `namespace` 让几何匹配成为可能
- `glassEffectUnion` 提供材质连续感
- `GlassEffectContainer` 管理动画环境
- `NamespaceReader` 使 TSX 能访问 SwiftUI 的 @Namespace



---
url: /v2/zh/guide/View Modifiers/Liquid Glass/Glass Effect Transition/index_example.md
---

# 示例

```tsx
import { Button, GlassEffectContainer, HStack, NamespaceReader, Navigation, Script, VStack, useObservable } from "scripting"

function View() {

  const isAlternativeMenu = useObservable(false)

  return <NamespaceReader>{namespace => <VStack
    spacing={50}
    frame={{
      maxWidth: 'infinity',
      maxHeight: 'infinity'
    }}
    background="systemYellow"
  >
    <GlassEffectContainer
    >
      <HStack
        spacing={0}
        font="largeTitle"
        imageScale="large"
        buttonStyle="glass"
        labelStyle="iconOnly"
      >
        {
          isAlternativeMenu.value
            ? <>
              <Button
                title="Home"
                systemImage="house"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Settings"
                systemImage="gear"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>

            : <>
              <Button
                title="Edit"
                systemImage="pencil"
                action={() => { }}
                glassEffectID={{
                  id: 1,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
              <Button
                title="Erase"
                systemImage="eraser"
                action={() => { }}
                glassEffectID={{
                  id: 3,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
                glassEffectTransition="materialize"
              />
              <Button
                title="Delete"
                systemImage="trash"
                action={() => { }}
                glassEffectID={{
                  id: 2,
                  namespace
                }}
                glassEffectUnion={{
                  id: 1,
                  namespace
                }}
              />
            </>
        }
      </HStack>
    </GlassEffectContainer>

    <Button
      title="Toggle"
      buttonStyle="bordered"
      action={() => {
        withAnimation(() => {
          isAlternativeMenu.setValue(
            !isAlternativeMenu.value
          )
        })
      }}
    />
  </VStack>
  }</NamespaceReader>
}

async function run() {
  await Navigation.present(<View />)

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/View Modifiers/Liquid Glass/Liquid Glass Effect/index.md
---

**GlassEffect、GlassEffectContainer、UIGlass** 等相关 API 基于 SwiftUI 新引入的 Liquid Glass 技术，让开发者能够在脚本中以 TSX 方式使用流体化、动态的玻璃材质效果，并支持过渡动画、匹配几何、联合玻璃区域等高级特性。

***

## 1. Liquid Glass 概述

Liquid Glass 是 iOS 26 新增的视觉效果系统，用于创建带有流动质感、半透明材质与动态边界的玻璃效果。与早期的 `blur` 或 `material` 不同，Liquid Glass 提供了：

- 动态玻璃形状（使用 Shape）
- 基于几何匹配的过渡动画
- 可交互的玻璃（interactive）
- 可指定 tint 色彩的玻璃材质
- 可组合多个视图的玻璃“联合”

***

# 2. GlassEffect 基础用法

所有支持玻璃效果的视图，都可以通过 `glassEffect` 修饰符添加 Liquid Glass 材质。

### 属性定义

```ts
type GlassProps = {
  glassEffect?: boolean | UIGlass | Shape | {
      glass: UIGlass
      shape: Shape
  }

  glassEffectTransition?: GlassEffectTransition

  glassEffectID?: {
      id: string | number
      namespace: NamespaceID
  }

  glassEffectUnion?: {
      id: string | number
      namespace: NamespaceID
  }
}
```

***

## 2.1 `glassEffect`

glassEffect 有四种主要使用方式：

### 方式一：启用默认玻璃材质

```tsx
<Text glassEffect>Foo</Text>
```

使用系统默认的 Liquid Glass 材质（相当于 `UIGlass.regular()`）。

***

### 方式二：使用指定的 UIGlass

```tsx
<Text glassEffect={UIGlass.regular().interactive(false)}>Foo</Text>
```

可以链式配置 tint、interactive 等属性。

***

### 方式三：设置玻璃的形状（Shape）

```tsx
<Text glassEffect={{ glass: UIGlass.regular(), shape: { type: 'rect', cornerRadius: 10 } }}>
  Foo
</Text>
```

或直接传入 Shape：

```tsx
<Text
  glassEffect={{
    type: 'rect',
    cornerRadius: 10
  }}
>
  Foo
</Text>
```

表示该视图的玻璃材质会严格限定在指定几何图形内。

***

### 方式四：Boolean 短写

```tsx
<View glassEffect />
```

等同于默认 UIGlass.regular()。

***

# 3. UIGlass 类

`UIGlass` 用于描述玻璃材质本身，可以选用内置材质或链式组合属性。

### 可用静态方法

| 方法                   | 描述                        |
| -------------------- | ------------------------- |
| `UIGlass.clear()`    | 完全透明的玻璃材质，用于融合或叠加效果。      |
| `UIGlass.regular()`  | 默认的 Liquid Glass 材质。      |
| `UIGlass.identity()` | 身份材质，不会改变内容外观，相当于不应用玻璃效果。 |

### 链式配置方法

```ts
interactive(value?: boolean): UIGlass
tint(color: Color): UIGlass
```

示例：

```tsx
glassEffect={UIGlass.regular().interactive().tint("red")}
```

***

# 4. GlassEffectTransition（玻璃过渡动画）

```ts
type GlassEffectTransition = 'identity' | 'materialize' | 'matchedGeometry'
```

### 三种模式说明

| transition          | 描述                                 |
| ------------------- | ---------------------------------- |
| `'identity'`        | 不应用任何几何或材质的动画变化。                   |
| `'materialize'`     | 内容渐入，同时玻璃材质出现或消失，但不尝试匹配几何形状。       |
| `'matchedGeometry'` | 根据容器内其他玻璃形状的几何信息匹配过渡动画，具备更自然的动画效果。 |

### 使用方式

```tsx
<Text 
  glassEffect
  glassEffectTransition="materialize"
>
  Foo
</Text>
```

matchedGeometry 通常需要配合 `glassEffectID` 或 `glassEffectUnion` 使用。

***

# 5. glassEffectID 与 glassEffectUnion

Liquid Glass 支持“识别”不同视图间的玻璃效果，用于 matched geometry 动画或合并多块玻璃区域。

***

## 5.1 glassEffectID

为玻璃效果赋予唯一的 ID，用于 matchedGeometry 动画。

```tsx
<Text
  glassEffect
  glassEffectID={{ id: "avatar", namespace }}
>
  Foo
</Text>
```

多个视图使用相同 ID + namespace 时，系统会尝试匹配形状，从而产生流体几何动画效果。

***

## 5.2 glassEffectUnion

用于将多个玻璃效果统一为一个更大区域。

```tsx
<Text
  glassEffect
  glassEffectUnion={{ id: 1, namespace }}
/>
```

多个视图的玻璃材质将被合并，形成更一致的视觉区域。

***

# 6. GlassEffectContainer

`GlassEffectContainer` 是用于组织和管理玻璃效果的容器。容器内部的所有 glassEffect 视图，都能参与几何匹配、联合效果和过渡动画。

### 示例

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image glassEffect systemName="1.circle" />
    <Image glassEffect systemName="2.circle" />
  </HStack>
</GlassEffectContainer>
```

在容器中：

- matchedGeometry 正常工作
- glassEffectUnion 可以跨子视图生效
- glassEffectID 的动画效果可互相关联

GlassEffectContainer 不需要额外参数，但提供了玻璃效果组织空间。

***

# 7. 按钮的玻璃样式 buttonStyle

Scripting 在 iOS 26 提供新增按钮样式：

- `"glass"`
- `"glassProminent"`

示例：

```tsx
<Button title="Glass" action={...} buttonStyle="glass" />
<Button title="Glass Prominent" action={...} buttonStyle="glassProminent" />

<Button
  title="Glass & Tint"
  buttonStyle="glass"
  tint="red"
/>
```

这些按钮会自动使用 Liquid Glass 材质，并适配 tint、press 动效。

***

# 8. 实战示例说明

以下示例展示完整的用法，包括：

- 背景图片
- Glass 按钮
- GlassEffectContainer
- 使用 UIGlass 自定义玻璃
- 使用指定形状的玻璃

```tsx
<GlassEffectContainer>
  <HStack spacing={40}>
    <Image
      systemName="1.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: 30, y: 0 }}
    />
    <Image
      systemName="2.circle"
      frame={{ width: 80, height: 80 }}
      font={36}
      glassEffect
      offset={{ x: -30, y: 0 }}
    />
  </HStack>
</GlassEffectContainer>
```

***

# 9. 使用建议与最佳实践

### 1. 大量玻璃视图应包裹在同一个 GlassEffectContainer

可提高动画一致性与性能。

### 2. 使用 matchedGeometry 时务必提供 glassEffectID

否则无法产生几何跟随动画。

### 3. 复杂的玻璃区域可使用 glassEffectUnion 合并

让多个子视图形成连续材质。

### 4. 为了避免过度渲染，玻璃不应嵌套太深

可以多用 ZStack 管理效果。

### 5. UIGlass.identity 非常适合“禁用玻璃但保持结构”

它允许你保留现有布局但不实际渲染材质。



---
url: /v2/zh/guide/View Modifiers/Liquid Glass/Liquid Glass Effect/index_example.md
---

# 示例

```tsx
import { Button, Navigation, NavigationStack, Script, Text, VStack, ZStack, Image, Path, GlassEffectContainer, HStack } from "scripting"

function View({
  image
}: {
  image: UIImage
}) {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle="GlassEffect DEMO"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <ZStack>
        <Image
          image={image}
          resizable
          scaleToFill
        />
        <VStack>
          <HStack>
            <Button
              title="Glass"
              action={() => { }}
              buttonStyle="glass"
            />
            <Button
              title="Glass & Tint"
              action={() => { }}
              buttonStyle="glass"
              tint="red"
            />
          </HStack>
          <HStack>
            <Button
              title="Glass Prominent"
              action={() => { }}
              buttonStyle="glassProminent"
            />
            <Button
              title="Glass Prominent & Tint"
              action={() => { }}
              buttonStyle="glassProminent"
              tint="red"
            />
          </HStack>
          <GlassEffectContainer>
            <HStack spacing={40}>
              <Image
                systemName="1.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: 30, y: 0 }}
              />
              <Image
                systemName="2.circle"
                frame={{ width: 80, height: 80 }}
                font={36}
                glassEffect
                offset={{ x: -30, y: 0 }}
              />
            </HStack>
          </GlassEffectContainer>
          <HStack spacing={12}>
            <Text
              padding
              glassEffect
            >Foo</Text>
            <Text
              padding
              glassEffect={{
                type: 'rect',
                cornerRadius: 10
              }}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().interactive()}
            >Foo</Text>
            <Text
              padding
              glassEffect={UIGlass.regular().tint("red")}
              foregroundStyle="white"
            >Foo</Text>
          </HStack>
        </VStack>
      </ZStack>
    </VStack>
  </NavigationStack>
}

async function run() {
  try {
    const image = (await Photos.pickPhotos(1))?.at(0)
    if (!image) {
      throw new Error("You must pick an image as the background.")
    }
    // Present view.
    await Navigation.present({
      element: <View
        image={image}
      />
    })
  } catch (e) {
    console.present()
    console.error(e)
  }

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/View Modifiers/List and Section View Modifiers/Common.md
---

# 通用修饰符

这些修饰符可用于精细控制 `<List>` 中每一行（Row）或每一个区块（Section）的布局与样式。

## 适用对象：

- 列表中的单个行（如 `<Text>`、`<HStack>`）
- 区块 `<Section>`
- 整个 `<List>`

***

## `listItemTint`

设置该行及其内容使用的 **前景色（tint）**。

### 类型

```ts
listItemTint?: Color
```

### 说明

- 设置为 `null` 表示不覆盖继承颜色。
- 可使用关键词颜色、Hex、或 rgba。

### 示例

```tsx
<Text listItemTint="green">
  带颜色的行
</Text>
```

***

## `listRowInsets`

设置该行的 **内边距（insets）**。

### 类型

```ts
listRowInsets?: number | EdgeInsets
```

### 说明

- 使用单个数字表示上下左右相同的内边距；
- 使用 `EdgeInsets` 对象设置四个方向的独立间距。

### 示例

```tsx
<Text
  listRowInsets={{
    top: 10,
    bottom: 10,
    leading: 20,
    trailing: 20
  }}
>
  自定义边距的行
</Text>
```

***

## `listRowSpacing`

设置 **相邻两行之间的垂直间距**。

### 类型

```ts
listRowSpacing?: number
```

### 示例

```tsx
<List listRowSpacing={12}>
  <Text>第一行</Text>
  <Text>第二行</Text>
</List>
```

***

## `listRowSeparator`

设置当前行的 **分隔线可见性**。

### 类型

```ts
listRowSeparator?: Visibility | {
  visibility: Visibility
  edges: VerticalEdgeSet
}
```

### 可选值（Visibility）：

- `"visible"`：始终显示分隔线
- `"hidden"`：隐藏分隔线
- `"automatic"`：系统默认行为

### 示例

```tsx
<Text
  listRowSeparator={{
    visibility: "hidden",
    edges: "bottom"
  }}
>
  隐藏底部分隔线的行
</Text>
```

***

## `listRowSeparatorTint`

设置该行的 **分隔线颜色**。

### 类型

```ts
listRowSeparatorTint?: Color | {
  color: Color
  edges: VerticalEdgeSet
}
```

### 示例

```tsx
<Text
  listRowSeparatorTint={{
    color: "rgba(255,0,0,0.5)",
    edges: "bottom"
  }}
>
  带红色分隔线的行
</Text>
```

***

## `listRowBackground`

为该行设置一个自定义的 **背景视图**。

### 类型

```ts
listRowBackground?: VirtualNode
```

### 示例

```tsx
<Text
  listRowBackground={
    <Rectangle fill="#f0f0f0" cornerRadius={10} />
  }
>
  带灰色背景的行
</Text>
```

***

## `listSectionSpacing`

设置 **区块（Section）之间的垂直间距**。

### 类型

```ts
listSectionSpacing?: number | "compact" | "default"
```

### 示例

```tsx
<List listSectionSpacing="compact">
  <Section>...</Section>
  <Section>...</Section>
</List>
```

***

## `listSectionSeparator`

控制某个区块的 **顶部或底部分隔线显示情况**。

### 类型

```ts
listSectionSeparator?: Visibility | {
  visibility: Visibility
  edges: VerticalEdgeSet
}
```

### 示例

```tsx
<Section
  listSectionSeparator={{
    visibility: "hidden",
    edges: "top"
  }}
>
  <Text>内容</Text>
</Section>
```

***

## `listSectionSeparatorTint`

设置区块分隔线的 **颜色**。

### 类型

```ts
listSectionSeparatorTint?: Color | {
  color: Color
  edges: VerticalEdgeSet
}
```

### 示例

```tsx
<Section
  listSectionSeparatorTint={{
    color: "#cccccc",
    edges: "bottom"
  }}
>
  <Text>灰色底部分隔线</Text>
</Section>
```

***

## 辅助类型定义

## `EdgeInsets` 示例

```ts
{
  top: number
  bottom: number
  leading: number
  trailing: number
}
```

## `Visibility`

```ts
"automatic" | "visible" | "hidden"
```

## `VerticalEdgeSet`

```ts
"top" | "bottom" | "all"
```

## `Color` 可接受格式：

- 关键词颜色（如 `"green"`、`"label"`）
- Hex 色值（如 `"#ff0000"`）
- RGBA 字符串（如 `"rgba(255,0,0,1)"`）

***

## 修饰符汇总表

| 修饰符                        | 作用说明                 |
| -------------------------- | -------------------- |
| `listItemTint`             | 设置该行内容的前景色           |
| `listRowInsets`            | 设置该行的内边距             |
| `listRowSpacing`           | 设置相邻两行之间的间距          |
| `listRowSeparator`         | 控制该行分隔线的显示           |
| `listRowSeparatorTint`     | 设置该行分隔线的颜色           |
| `listRowBackground`        | 设置该行的背景视图            |
| `listSectionSpacing`       | 设置两个 Section 之间的垂直间距 |
| `listSectionSeparator`     | 控制区块的顶部或底部分隔线是否显示    |
| `listSectionSeparatorTint` | 设置区块分隔线的颜色           |



---
url: /v2/zh/guide/View Modifiers/List and Section View Modifiers/New List View Modifiers.md
---

# 属性概览

| 属性名                          | 类型                                                          | 系统要求      | 说明                         |
| ---------------------------- | ----------------------------------------------------------- | --------- | -------------------------- |
| `listSectionIndexVisibility` | `Visibility`                                                | iOS 26.0+ | 控制 List 右侧 Section 索引条的可见性 |
| `listSectionMargins`         | `number \| EdgeSets \| { edges: EdgeSets; length: number }` | iOS 26.0+ | 自定义 Section 边距，替换系统默认边距规则  |
| `sectionIndexLabel`          | `string`                                                    | iOS 26.0+ | 设置 Section 在索引条中的字符标签      |
| `sectionActions`             | `VirtualNode`                                               | iOS 18.0+ | 为 Section 添加自定义操作区域        |

***

# 1. listSectionIndexVisibility

```ts
/**
 * Sets the visibility of the list section index.
 * @available iOS 26.0+.
 */
listSectionIndexVisibility?: Visibility
```

### 功能说明

控制 List 的右侧索引条是否显示。常用于需要类似通讯录 A-Z 快速跳转的场景。

可选值：

- `"visible"`
- `"hidden"`
- `"automatic"`（系统自行判断）

### 示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```

***

# 2. listSectionMargins

```ts
/**
 * Set the section margins for the specific edges.
 * @available iOS 26.0+.
 */
listSectionMargins?: number | EdgeSets | {
  edges: EdgeSets
  length: number
}
```

### 功能说明

设置 Section 的外边距，完全替换系统默认边距。可使用数值、 EdgeSets，或指定边的写法。

### 三种写法说明

### 2.1 使用单一数字作为四边边距

```tsx
listSectionMargins={12}
```

### 2.2 使用 EdgeInsets

```tsx
listSectionMargins={"all"}
```

### 2.3 针对特定边设置长度

```tsx
listSectionMargins={{
  edges: "horizontal",
  length: 20
}}
```

此写法等同于 SwiftUI 中：

```swift
.listSectionMargins(.horizontal, 20)
```

### 示例

```tsx
<Section
  header={<Text>Favorites</Text>}
  listSectionMargins={{
    edges: "vertical",
    12
  }}
>
  <Text>Item A</Text>
  <Text>Item B</Text>
</Section>
```

***

# 3. sectionIndexLabel

```ts
/**
 * Sets the label that is used in a section index.
 * @available iOS 26.0+.
 */
sectionIndexLabel?: string
```

### 功能说明

为 Section 设置索引条的显示字符，一般为单字母，如 “A”、“B”、“C”。

### 示例

```tsx
<Section
  header={<Text>A</Text>}
  sectionIndexLabel="A"
>
  <Text>Adam</Text>
  <Text>Ana</Text>
</Section>
```

***

# 4. sectionActions

```ts
/**
 * Adds custom actions to a section.
 * @available iOS 18.0+
 */
sectionActions?: VirtualNode
```

### 功能说明

为 Section 添加自定义操作按钮、菜单等 UI，位置通常显示在 Section Header 区域的右侧。

### 示例：添加刷新按钮

```tsx
<Section
  header={<Text>Downloads</Text>}
  sectionActions={
    <Button title="Refresh" action={() => doRefresh()} />
  }
>
  <Text>File 1</Text>
  <Text>File 2</Text>
</Section>
```

### 示例：添加菜单动作

```tsx
<Section
  header={<Text>Photos</Text>}
  sectionActions={
    <Menu title="Actions">
      <Button title="Upload All" action={() => uploadAll()} />
      <Button title="Delete All" action={() => deleteAll()} />
    </Menu>
  }
>
  {photos.map(photo => <Text key={photo.id}>{photo.name}</Text>)}
</Section>
```

***

# 完整示例

```tsx
<List listSectionIndexVisibility="visible">
  <ForEach
    data={groups}
    builder={group => (
      <Section
        header={<Text>{group.title}</Text>}
        sectionIndexLabel={group.title}
        listSectionMargins={12}
        sectionActions={
          <Button title="Refresh" action={() => refreshGroup(group)} />
        }
      >
        {group.items.map(item => <Text key={item}>{item}</Text>)}
      </Section>
    )}
  />
</List>
```



---
url: /v2/zh/guide/View Modifiers/LiveActivity View Modifiers.md
---

Scripting 支持与 SwiftUI 等效的 Live Activity 外观控制修饰符。这些修饰符专门用于 **锁屏（Lock Screen）中的 Live Activity 界面**，用于自定义背景色和系统动作按钮颜色。

通过为 Activity UI 中的 `content` 视图设置这些修饰符，可使 Live Activity 更符合品牌风格或特定活动主题。

***

# 修饰符定义

```ts
/**
 * 用于设置 Live Activity 在锁屏界面显示时的背景着色。
 */
activityBackgroundTint?: Color | {
  light: Color
  dark: Color
}

/**
 * 用于设置 Live Activity 在锁屏界面显示时，系统提供的辅助操作按钮的文本（前景）颜色。
 */
activitySystemActionForegroundColor?: Color | {
  light: Color
  dark: Color
}
```

***

# 属性说明

## 1. activityBackgroundTint

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置 Live Activity 在锁屏界面显示时的背景 Tint。
这个颜色会影响系统渲染 Live Activity 主卡片的底色。

### 使用示例

- 使用品牌主色作为 Activity 背景
- 为不同活动提供独立主题色
- 让内容在亮色或深色背景下更易阅读

***

## 2. activitySystemActionForegroundColor

**类型：** `Color | { light: Color; dark: Color }`
**说明：**
设置系统在锁屏的 Live Activity 卡片旁显示的“辅助操作按钮”的文本前景色。
这些操作按钮可能包括暂停、继续、停止等。

### 使用示例

- 在深色背景上显示浅色按钮文本
- 将关键操作按钮突出显示
- 使用和 UI 一致的主题色

***

# 示例：在 Live Activity UI Builder 中使用

Live Activity 的 UI builder 必须返回包含多个区域（content / compactLeading / compactTrailing / minimal等）的对象结构。

以下示例展示了如何在 **content** 区域中使用这两个修饰符：

```tsx
function ActivityView() {
  <LiveActivityUI
    content={
      <ContentView
        activityBackgroundTint={"blue"}
        activitySystemActionForegroundColor={"white"}
      />
    }
    compactLeading={...}
    compactTrailing={...}
    minimal={<Image systemName="clock" />}
  >
    <LiveActivityUIExpandedCenter>
      <ContentView />
    </LiveActivityUIExpandedCenter>
  </LiveActivityUI>
}
```

***

# 使用说明

- **修饰符仅在 Live Activity UI 中有效**，并且只影响 **锁屏界面** 的外观。
- 必须在 Live Activity UI builder 的 `content` 中使用。
- 如果不设置颜色，系统会使用默认样式。



---
url: /v2/zh/guide/View Modifiers/Navigation View Modifiers.md
---

# 导航视图修饰符

Scripting App 提供了一组用于配置导航行为的视图修饰符，允许开发者控制页面标题的展示内容与样式，并自定义返回按钮的显示与否。这些修饰符与 SwiftUI 中的导航系统高度一致，适用于导航栈中的任意视图。

***

## `navigationTitle`

````ts
navigationTitle?: string

设置当前视图在导航栏中显示的标题。

### 说明

* 在 **iOS** 中，当视图被嵌套在导航栈中时，所设置的标题将显示在导航栏中。
* 在 **iPadOS** 中，主导航目的地的标题也会在多任务切换界面中显示为窗口的标题。

---

## `navigationBarTitleDisplayMode`

```ts
navigationBarTitleDisplayMode?: NavigationBarTitleDisplayMode
````

设置导航栏标题的展示样式。

### 枚举类型：`NavigationBarTitleDisplayMode`

```ts
type NavigationBarTitleDisplayMode = "automatic" | "large" | "inline"
```

- **`automatic`**：系统根据上下文自动选择合适的标题样式。
- **`large`**：以大标题样式显示，通常用于导航栈的根视图。
- **`inline`**：将标题与导航栏控件同行显示，采用紧凑布局。

***

## `navigationBarBackButtonHidden`

```ts
navigationBarBackButtonHidden?: boolean
```

控制是否隐藏默认的导航栏返回按钮。

### 说明

- 设为 `true` 时，系统将不显示默认的返回按钮。
- 适用于需要自定义返回行为，或禁止用户返回的界面场景。

***

## 示例

```tsx
<VStack
  navigationTitle={"个人资料"}
  navigationBarTitleDisplayMode={"inline"}
  navigationBarBackButtonHidden={true}
>
  <Text>欢迎来到个人资料页面</Text>
</VStack>
```

在该示例中：

- 设置视图标题为 `"个人资料"`，并展示在导航栏中。
- 标题采用 `inline` 紧凑样式。
- 默认的返回按钮被隐藏。



---
url: /v2/zh/guide/View Modifiers/Picture in Pictuer View Modifiers.md
---

# Picture in Picture （画中画）

Scripting 提供了一组 PiP（Picture in Picture，画中画）相关的 View Modifiers，用于将任意 SwiftUI View 以系统级 PiP 窗口的形式呈现。
开发者无需直接接触底层 AVPictureInPicture API，即可完整控制 PiP 的展示、隐藏、交互行为及生命周期。

PiP 适用于以下典型场景：

- 实时状态展示（计时、运动、任务进度）
- 音频 / 视频播放的辅助 UI
- 应用进入后台后仍需持续展示的轻量信息视图

***

## 一、PiPProps API 定义

```ts
type PiPProps = {
  pip?: {
    isPresented: Observable<boolean>
    maximumUpdatesPerSecond?: number
    content: VirtualNode
  }
  
  onPipStart?: () => void
  onPipStop?: () => void
  onPipPlayPauseToggle?: (isPlaying: boolean) => void
  onPipSkip?: (isForward: boolean) => void
  onPipRenderSizeChanged?: (size: Size) => void

  pipHideOnForeground?: boolean
  pipShowOnBackground?: boolean
}
```

***

## 二、核心属性详解

### 1. `pip.isPresented`

```ts
isPresented: Observable<boolean>
```

- PiP 的**唯一控制开关**
- `true`：系统 PiP 窗口展示
- `false`：PiP 窗口关闭

通常由用户操作（按钮、手势）或应用生命周期驱动。

***

### 2. `pip.content`

```ts
content: VirtualNode
```

- 指定 PiP 窗口中实际渲染的视图
- 强烈建议使用**专门为 PiP 设计的 View**
- 视图结构应尽量简单、稳定、可预测

***

### 3. `pip.maximumUpdatesPerSecond`

```ts
maximumUpdatesPerSecond?: number
```

- **默认值：30**
- 用于限制 PiP 视图每秒最大刷新次数
- 是影响 PiP 稳定性和性能的关键参数

#### 使用建议

- **无动画 / 低频更新场景**
  建议设置为 `1 ~ 5`

- **包含动画的 PiP 视图**
  可设置为 `60`

**重要提示**
将该值设置为 `60` 会显著增加 CPU 与 GPU 压力，对系统性能影响非常明显，应谨慎使用，仅适用于确有必要的动画场景。

***

## 三、PiP 生命周期回调（仅限 PipView 使用）

### `onPipStart`

```ts
onPipStart?: () => void
```

- 当 PiP 窗口**成功开始展示**时触发
- 适合执行以下操作：

  - 启动定时器
  - 开始状态更新
  - 订阅数据流

***

### `onPipStop`

```ts
onPipStop?: () => void
```

- 当 PiP 被关闭或系统回收时调用
- 必须在此清理所有副作用：

  - 定时器
  - 订阅
  - 长时间运行任务

***

## 四、PiP 交互回调（仅限 PipView 使用）

### 1. 播放 / 暂停切换

```ts
onPipPlayPauseToggle?: (isPlaying: boolean) => void
```

- 当用户点击 PiP 控制区的播放 / 暂停按钮
- `isPlaying` 表示切换后的状态
- 常用于音频、视频、运动记录等场景

***

### 2. 快进 / 快退按钮

```ts
onPipSkip?: (isForward: boolean) => void
```

- `true`：向前
- `false`：向后

***

## 五、PiP 渲染尺寸变化

### `onPipRenderSizeChanged`

```ts
onPipRenderSizeChanged?: (size: Size) => void
```

- 当 PiP 窗口尺寸发生变化时触发
- 可根据尺寸动态调整布局
- 适用于横竖屏切换或系统自动调整 PiP 大小时

***

## 六、前后台行为控制（仅限 PipView 使用）

### `pipHideOnForeground`

```ts
pipHideOnForeground?: boolean
```

- 当应用进入前台时：

  - 若 PiP 正在运行，是否自动关闭
- 默认：`false`

***

### `pipShowOnBackground`

```ts
pipShowOnBackground?: boolean
```

- 当应用进入后台时是否自动启动 PiP
- 常用于音频播放、实时状态展示类场景

***

## 七、完整代码示例

### 1. PiP 内容视图（PipView）

```tsx
function PipView() {
  const started = useObservable(false)
  const count = useObservable(0)

  useEffect(() => {
    if (!started.value) {
      return
    }

    let timerId: number

    function startTimer() {
      timerId = setTimeout(() => {
        count.setValue(count.value + 1)
        startTimer()
      }, 1000)
    }

    startTimer()

    return () => {
      clearTimeout(timerId)
    }
  }, [started.value])

  return <HStack
    onPipStart={() => {
      started.setValue(true)
    }}
    frame={{
      width: Device.screen.width,
      height: 50
    }}
    background="systemBlue"
  >
    <Image
      systemName="figure.walk"
      font="title"
    />
    <Text foregroundStyle="white">
      Count: {count.value}
    </Text>
  </HStack>
}
```

***

### 2. 页面中启用 PiP

```tsx
function PageView() {
  const dismiss = Navigation.useDismiss()
  const pipPresented = useObservable(false)

  return <NavigationStack>
    <List
      navigationTitle="PiP Demo"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
      pip={{
        isPresented: pipPresented,
        content: <PipView />
      }}
    >
      <Button
        title="Toggle PiP"
        action={() => {
          pipPresented.setValue(!pipPresented.value)
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 八、重要注意事项（必须阅读）

### 1. PiPView 在 `isPresented = false` 时仍会被构建

- PiPView **不可见**
- 但仍然参与状态绑定与生命周期
- 不应在构建阶段执行任何重计算或副作用

**推荐做法**

- 所有逻辑延迟到 `onPipStart`
- 在 `onPipStop` 中彻底释放资源

***

### 2. PiP 专用修饰符只能在 PipView 中使用

以下属性和回调：

- `onPipStart`
- `onPipStop`
- `onPipPlayPauseToggle`
- `onPipSkip`
- `onPipRenderSizeChanged`
- `pipHideOnForeground`
- `pipShowOnBackground`

**只能定义在 PiP 内容视图（PipView）中**

如果定义在普通页面 View 中：

- 不会触发
- 无法获取正确状态
- 行为不可预测

***

### 3. PiP 不适合复杂 UI

不建议在 PiP 中使用：

- `List`、`ScrollView`
- 复杂动画
- 高频状态更新
- 网络请求驱动的 UI

PiP 的设计目标是：

> 轻量、稳定、可持续展示的系统级辅助视图

***

## 九、推荐实践总结

- 为 PiP 单独设计一个最小化 View
- 控制更新频率，合理设置 `maximumUpdatesPerSecond`
- 所有副作用延迟到 `onPipStart`
- 始终在 `onPipStop` 中清理资源
- 不在 PiP 中复用页面级复杂视图



---
url: /v2/zh/guide/View Modifiers/Presentation View Modifiers.md
---

# 弹出视图修饰符（Presentation

这些修饰符用于配置通过 `sheet` 呈现的视图的行为和外观，包括在不同尺寸环境下的适配方式、拖拽指示器、支持的尺寸（detents）、背景交互、滚动与调整优先级等。

> 这些修饰符应作用于 **被 sheet 弹出显示的根视图**（例如 `<VStack>`、`<NavigationStack>` 或 `<List>`）。

***

## `presentationCompactAdaptation`

定义当设备处于 **横向或纵向紧凑尺寸类（Compact Size Class）** 时，sheet 的适配方式。

### 类型

```ts
presentationCompactAdaptation?: PresentationAdaptation | {
  horizontal: PresentationAdaptation
  vertical: PresentationAdaptation
}
```

### `PresentationAdaptation` 可选值：

- `"automatic"`：系统默认行为
- `"fullScreenCover"`：使用全屏显示
- `"sheet"`：使用普通 sheet 弹出样式
- `"popover"`：使用气泡样式（部分平台支持）
- `"none"`：不进行适配（尽可能维持原样）

### 示例

```tsx
<NavigationStack
  presentationCompactAdaptation={{
    horizontal: "fullScreenCover",
    vertical: "sheet"
  }}
>
  {/* 弹出内容 */}
</NavigationStack>
```

***

## `presentationDragIndicator`

控制 sheet 顶部是否显示 **拖拽指示器**（即小横条）。

### 类型

```ts
presentationDragIndicator?: "visible" | "hidden" | "automatic"
```

### 示例

```tsx
<VStack presentationDragIndicator="visible">
  <Text>可以拖动顶部指示器来改变高度</Text>
</VStack>
```

***

## `presentationDetents`

定义 sheet 支持的 **高度位置（detents）**，用户可以通过拖拽在这些高度间切换。

### 类型

```ts
presentationDetents?: PresentationDetent[]
```

### `PresentationDetent` 可选值：

- `"medium"`：大约为屏幕高度的一半（在紧凑纵向尺寸下无效）
- `"large"`：占满整个屏幕高度
- `number > 1`：表示固定的高度（单位为 pt）
- `0 < number <= 1`：表示按屏幕高度的百分比（例如 `0.5` 表示 50% 高度）

### 示例

```tsx
<VStack presentationDetents={[200, "medium", "large"]}>
  <Text>拖动可在不同高度之间切换</Text>
</VStack>
```

***

## `presentationBackgroundInteraction`

定义在弹出页面显示时，用户是否可以与 **底层视图交互**。

### 类型

```ts
presentationBackgroundInteraction?:
  | "automatic"
  | "enabled"
  | "disabled"
  | { enabledUpThrough: PresentationDetent }
```

### 示例：仅在 sheet 高度较小时允许背景交互

```tsx
<VStack presentationBackgroundInteraction={{
  enabledUpThrough: "medium"
}}>
  <Text>当 sheet 为中等高度时，背景可交互</Text>
</VStack>
```

***

## `presentationContentInteraction`

控制在向上滑动手势中，sheet 是优先 **调整高度** 还是 **滚动内容**。

### 类型

```ts
presentationContentInteraction?: "automatic" | "resizes" | "scrolls"
```

### 说明

- `"resizes"`：优先调整 detent 高度，滚动内容居后
- `"scrolls"`：立即滚动内部内容（如 ScrollView）
- `"automatic"`：系统默认行为（通常优先调整 detent）

### 示例

```tsx
<ScrollView presentationContentInteraction="scrolls">
  {/* 向上滑时会立即滚动，而不会先调整 sheet 高度 */}
</ScrollView>
```

***

## `presentationCornerRadius`

设置 sheet 背景的 **圆角半径**。

### 类型

```ts
presentationCornerRadius?: number
```

### 示例

```tsx
<VStack presentationCornerRadius={16}>
  <Text>该 sheet 具有圆角背景</Text>
</VStack>
```

***

## 完整使用示例

```tsx
function SheetPage({ onDismiss }: {
  onDismiss: () => void
}) {
  return <NavigationStack>
    <List navigationTitle="弹出页">
      <Text font="title" padding={50}>
        拖动指示器可改变 sheet 高度。
      </Text>
      <Button
        title="关闭"
        action={onDismiss}
      />
    </List>
  </NavigationStack>
}

<Button
  title="显示"
  action={() => setIsPresented(true)}
  sheet={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    content: <SheetPage
      presentationDragIndicator="visible"
      presentationDetents={[200, "medium", "large"]}
      onDismiss={() => setIsPresented(false)}
    />
  }}
/>
```

***

## 修饰符汇总

| 修饰符                                 | 功能说明                  |
| ----------------------------------- | --------------------- |
| `presentationCompactAdaptation`     | 设置在紧凑尺寸类下的适配方式        |
| `presentationDragIndicator`         | 控制是否显示拖拽指示器           |
| `presentationDetents`               | 定义 sheet 可拖拽的高度（支持多个） |
| `presentationBackgroundInteraction` | 设置是否允许与背景内容交互         |
| `presentationContentInteraction`    | 控制是优先滚动还是优先调整高度       |
| `presentationCornerRadius`          | 设置 sheet 的圆角大小        |



---
url: /v2/zh/guide/View Modifiers/Redaction View Modifiers.md
---

# 数据遮罩视图修饰符

Scripting App 支持用于视图层级的数据遮罩（Redaction）修饰符。通过这些修饰符，开发者可以将视图内容以占位符、隐私保护或失效状态的形式展示，常用于加载中、隐私信息隐藏或内容待更新的场景。

这些修饰符的行为与 SwiftUI 中的 `redacted(reason:)` 和 `unredacted()` 完全一致。

***

## `redacted`

```ts
redacted?: RedactedReason | null
```

为当前视图及其子视图应用数据遮罩效果，根据传入的遮罩原因改变内容的显示方式。

### 描述

`redacted` 会在不改变原始数据的情况下，以视觉形式替代原始内容。常用于提升用户体验，例如在内容加载时使用占位图形，或在展示敏感信息时进行遮罩。

### 枚举类型：`RedactedReason`

```ts
type RedactedReason = "placeholder" | "invalidated" | "privacy"
```

- **`placeholder`**：以占位符形式展示数据，适用于加载中状态。
- **`invalidated`**：表示数据已失效或正在等待更新。
- **`privacy`**：对内容进行遮罩，以保护用户隐私或敏感信息。

### 示例

```tsx
<Text
  redacted={"placeholder"}
>
  加载中...
</Text>
```

上述示例中，文本内容将以占位符样式展示，适用于数据尚未加载完成的情况。

***

## `unredacted`

```ts
unredacted?: boolean
```

用于移除继承自父视图的遮罩效果，使当前视图恢复原始样式。

### 描述

当上层视图应用了 `redacted` 后，可以在子视图中通过设置 `unredacted: true` 取消遮罩，使该子视图内容正常显示。

### 示例

```tsx
<VStack redacted={"placeholder"}>
  <Text>加载中...</Text>
  <Text unredacted={true}>此内容不遮罩</Text>
</VStack>
```

在此示例中，整个 `VStack` 应用了遮罩，但第二个 `Text` 通过 `unredacted: true` 显示真实内容，不受遮罩影响。

***

## 使用说明

- 遮罩效果仅影响视图的外观，不会影响布局或无障碍功能（如 VoiceOver）。
- `unredacted` 仅在其所在视图受到父视图遮罩影响时才会生效。
- 设置 `redacted: null` 可移除当前视图的遮罩状态（不推荐同时使用 `unredacted`）。



---
url: /v2/zh/guide/View Modifiers/Safe Area.md
---

# 安全区域

Scripting 提供与 SwiftUI 类似的安全区域控制功能，允许你灵活地**向安全区域内插入视图内容**，或让视图**忽略安全区域限制**进行全屏布局。安全区域通常指设备屏幕上的“刘海”、工具栏、键盘等系统 UI 所保留的边距。

***

## `safeAreaPadding`

为视图的安全区域添加自定义内边距。该修饰符可调整视图在系统安全区域内的显示范围（例如避开刘海、Home 指示器或圆角），用于保持内容在合理的可视范围内。

### 类型

```ts
safeAreaPadding?: 
  true | 
  number | 
  {
    horizontal?: number | true
    vertical?: number | true
    leading?: number | true
    trailing?: number | true
    top?: number | true
    bottom?: number | true
  }
```

***

### 描述

该修饰符允许你为视图的安全区域内边距进行灵活设置：

- 传入 `true`：在所有安全区域边缘应用系统默认的内边距；
- 传入一个数字：为所有边缘应用统一的内边距值；
- 传入对象：分别设置各个方向或边缘的内边距，支持数值或 `true` 表示使用系统默认值。

适合在你希望视图保持适配安全区域的同时进行自定义布局的场景使用。

***

### 用法说明

- `true`：在所有安全区域边缘应用系统默认内边距
- `number`：为所有边缘应用指定数值的内边距
- `object`：为不同方向或边缘单独设置内边距

***

### 对象属性说明

- `horizontal`：左右（`leading` 和 `trailing`）方向的内边距
- `vertical`：上下（`top` 和 `bottom`）方向的内边距
- `leading`、`trailing`、`top`、`bottom`：各个边缘的单独内边距
- 值可以是具体的数值，也可以是 `true`（表示使用系统默认值）

***

### 示例：默认内边距

```tsx
<VStack safeAreaPadding={true}>
  <Text>Hello</Text>
</VStack>
```

在所有安全区域边缘应用系统默认的内边距。

***

### 示例：自定义内边距

```tsx
<VStack
  safeAreaPadding={{
    top: 20,
    bottom: true,
    horizontal: 12
  }}
>
  <Text>内容</Text>
</VStack>
```

上边距为 20 点，下边距为系统默认值，左右边距为 12 点。

***

## `safeAreaInset`

在指定的安全区域边缘插入一个视图内容（如底部工具栏、顶部标题等）。

### 类型

```ts
safeAreaInset?: {
  top?: {
    alignment?: HorizontalAlignment
    spacing?: number
    content: VirtualNode
  },
  bottom?: {
    alignment?: HorizontalAlignment
    spacing?: number
    content: VirtualNode
  },
  leading?: {
    alignment?: VerticalAlignment
    spacing?: number  // 实际为 spacing
    content: VirtualNode
  },
  trailing?: {
    alignment?: VerticalAlignment
    spacing?: number  // 实际为 spacing
    content: VirtualNode
  }
}
```

### 参数说明

- `top` / `bottom`：向顶部或底部安全区域插入内容，使用 **水平对齐（HorizontalAlignment）**。
- `leading` / `trailing`：向左右安全区域插入内容，使用 **垂直对齐（VerticalAlignment）**。
- `alignment`：内容在插入区域内的对齐方式。
- `spacing`：原始视图与插入内容之间的额外间距。
- `content`：要插入的视图节点，如 `<Text>`、`<HStack>` 等。

### 示例

```tsx
<ScrollView
  safeAreaInset={{
    bottom: {
      alignment: "center",
      spacing: 8,
      content: <Text>底部工具栏</Text>
    }
  }}
>
  <VStack>
    <Text>滚动内容</Text>
  </VStack>
</ScrollView>
```

### 对齐方式

- **水平对齐（top / bottom）**：`"leading"`、`"center"`、`"trailing"`
- **垂直对齐（leading / trailing）**：`"top"`、`"center"`、`"bottom"`

> 注意：`spacing` 是拼写错误，实际应为 `spacing`。

***

## `ignoresSafeArea`

让视图内容**扩展至安全区域之外**，用于构建沉浸式或全屏背景内容。

### 类型

```ts
ignoresSafeArea?: boolean | {
  regions?: SafeAreaRegions
  edges?: EdgeSet
}
```

### 简单用法（布尔值）

```tsx
<Image
  imageUrl="https://example.com/background.jpg"
  ignoresSafeArea
/>
```

> 整个视图将忽略所有边缘的安全区域，填满全屏。

### 配置用法（对象形式）

```tsx
<VStack
  ignoresSafeArea={{
    regions: "all",
    edges: "bottom"
  }}
>
  <Text>底部内容扩展到系统栏下方</Text>
</VStack>
```

***

### `regions`（可选）

| 值             | 描述                         |
| ------------- | -------------------------- |
| `"all"`       | 忽略所有安全区域（默认）               |
| `"container"` | 忽略容器级别的 UI（如导航栏、标签栏）       |
| `"keyboard"`  | 忽略键盘弹出区域（适用于需要背景填满键盘下方的场景） |

### `edges`（可选）

| 值              | 描述         |
| -------------- | ---------- |
| `"top"`        | 忽略顶部安全区域   |
| `"bottom"`     | 忽略底部安全区域   |
| `"leading"`    | 忽略左侧安全区域   |
| `"trailing"`   | 忽略右侧安全区域   |
| `"vertical"`   | 忽略上下       |
| `"horizontal"` | 忽略左右       |
| `"all"`        | 忽略所有边缘（默认） |



---
url: /v2/zh/guide/View Modifiers/Search Interactions.md
---

# 搜索交互

Scripting 支持与 SwiftUI 类似的搜索功能。你可以为列表等滚动视图添加搜索栏，控制搜索栏的显示位置、状态，监听输入变化，并动态显示搜索建议。

***

## `searchable`

为视图添加搜索栏，并将搜索文本与状态绑定。

### 类型

```ts
searchable?: {
  value: string
  onChanged: (value: string) => void
  placement?: SearchFieldPlacement
  prompt?: string
  presented?: {
    value: boolean
    onChanged: (value: boolean) => void
  }
}
```

### 参数说明

- `value`: 当前搜索输入的文本（受控状态）。
- `onChanged`: 每当用户输入发生变化时调用，传入新的搜索内容。
- `placement`: 控制搜索栏的显示位置（可选）。
- `prompt`: 搜索栏中的提示占位文本（可选）。
- `presented`: 控制搜索栏是否处于激活状态，可以主动打开或关闭搜索界面（可选）。

### 示例

```tsx
function SearchExample() {
  const [query, setQuery] = useState("")
  const [showSearch, setShowSearch] = useState(false)

  return (
    <List
      searchable={{
        value: query,
        onChanged: setQuery,
        placement: "navigationBarDrawer",
        prompt: "搜索项目",
        presented: {
          value: showSearch,
          onChanged: setShowSearch,
        }
      }}
    >
      <Text>当前搜索内容：{query}</Text>
    </List>
  )
}
```

### `SearchFieldPlacement` 可选值

| 值                                       | 描述                           |
| --------------------------------------- | ---------------------------- |
| `'automatic'`                           | 系统自动决定搜索栏位置（默认）。             |
| `'navigationBarDrawer'`                 | 在导航栏下方作为抽屉式显示。               |
| `'navigationBarDrawerAlwaysDisplay'`    | 始终显示抽屉搜索栏。                   |
| `'navigationBarDrawerAutomaticDisplay'` | 根据需要自动显示抽屉搜索栏。               |
| `'toolbar'`                             | 显示在工具栏中。                     |
| `'sidebar'`                             | 显示在侧边栏（适用于 iPad 或 macOS 风格）。 |

***

## `searchSuggestions`

设置搜索建议的内容区域，在用户输入时显示一组建议项。

### 类型

```ts
searchSuggestions?: VirtualNode
```

### 示例

```tsx
const suggestions = useMemo(() => [
  {
    label: "🍎 Apple",
    value: "Apple"
  },
  {
    label: "🍌 Bananer",
    value: "Bananer"
  }
], [])
const filteredSuggestions = useMemo(() => {
  if (!/\S+/.test(query)) {
    return suggestions
  }
  const q = query.toLowerCase()
  return suggestions.filter(s =>
    s.label.toLowerCase().includes(q) ||
    s.value.toLowerCase().includes(q))
}, [query, suggestions])

<List
  searchable={{
    value: query,
    onChanged: setQuery
  }}
  searchSuggestions={
    <>
      {filteredSuggestions.map(s =>
        <Text
          searchCompletion={s.value}
        >{s.label}</Text>
      )}
    </>
  }
/>
```

***

## `searchSuggestionsVisibility`

控制搜索建议的显示位置和是否可见。

### 类型

```ts
searchSuggestionsVisibility?: {
  visibility: 'visible' | 'hidden'
  placements: SearchSuggestionsPlacementSet
}
```

### `SearchSuggestionsPlacementSet` 可选值

| 值           | 描述                |
| ----------- | ----------------- |
| `'content'` | 在主内容区域中显示建议项。     |
| `'menu'`    | 在弹出菜单或下拉列表中显示建议项。 |
| `'all'`     | 同时适用于所有可用位置。      |

### 示例

```tsx
<List
  searchSuggestionsVisibility={{
    visibility: 'visible',
    placements: 'menu'
  }}
/>
```

***

## `searchCompletion`

将某个视图（如 `<Text>`）标记为可点击的搜索建议项，并指定点击后填入搜索框的值。

### 类型

```ts
searchCompletion?: string
```

### 示例

```tsx
<Text searchCompletion="Mango">🥭 芒果</Text>
```

当用户点击该建议项后，搜索栏将自动填入 `"Mango"`。

***

## 小结

| 修饰符                           | 功能说明               |
| ----------------------------- | ------------------ |
| `searchable`                  | 添加搜索栏，绑定搜索状态与行为。   |
| `searchSuggestions`           | 提供搜索建议项列表。         |
| `searchSuggestionsVisibility` | 控制建议项的显示位置和是否可见。   |
| `searchCompletion`            | 设置建议项点击后自动填入搜索栏的值。 |



---
url: /v2/zh/guide/View Modifiers/Set environment values (environments).md
---

`environments` 是 Scripting 新增的视图修饰符，用于向当前视图树（View Hierarchy）注入特定的 environment values。
它的作用与 SwiftUI 的 `.environment()` 类似，但基于 Scripting 的设计进行了显式声明和类型收敛，避免隐式行为。

目前 `environments` 支持以下 environment 值：

- `editMode`: 控制视图的编辑模式（如 List 的编辑状态）
- `openURL`: 自定义打开链接（URL）的处理方式

这些 environment 值会影响其子视图中的行为与交互能力。

***

# 修饰符定义

```ts
environments?: {
  editMode?: Observable<EditMode>;
  openURL?: (url: string) => OpenURLActionResult;
};
```

***

# 一、editMode（编辑模式）

`editMode` 用于设置当前视图树中所有支持编辑模式的组件的编辑状态。

典型用途：

- 控制 `List` 的编辑状态
- 启用批量删除、移动操作
- 与用户交互同步（如切换编辑按钮）

## 类型定义

```ts
class EditMode {
  readonly value: "active" | "inactive" | "transient" | "unknown"
  readonly isEditing: boolean

  static active(): EditMode
  static inactive(): EditMode
  static transient(): EditMode
}
```

### `value` 含义

| 值           | 描述           |
| ----------- | ------------ |
| `active`    | 编辑模式已开启      |
| `inactive`  | 编辑模式已关闭      |
| `transient` | 临时状态（如交互中切换） |
| `unknown`   | 非预期状态，通常不需使用 |

### 与 `Observable` 配合使用

由于 editMode 是动态值，必须使用 `Observable<EditMode>` 传递，以便视图随编辑状态变化而刷新。

***

## editMode 使用示例

```tsx
const editMode = useObservable(() => EditMode.active())

<List
  environments={{
    editMode: editMode
  }}
>
  <ForEach
    editActions="all"
    data={items}
    builder={item => <Text key={item.id}>{item}</Text>}
  />
</List>
```

说明：

- 将 `editMode` 设置到 List 的 environment 中
- List 中的 `ForEach` 会根据该状态启用、禁用删除/移动等编辑能力
- 修改 `editMode.value` 将自动刷新界面

***

# 二、openURL（自定义 URL 打开行为）

`openURL` environment 允许为当前视图树定义一套自定义的 URL 打开逻辑。
这会覆盖如 `<Link>`、`Text(url:)` 等组件的默认行为。

用途示例：

- 控制 URL 在 App 内打开还是系统浏览器打开
- 根据 URL 类型执行不同逻辑
- 拦截 URL 点击并进行验证或跳转处理

## 类型定义

```ts
openURL?: (url: string) => OpenURLActionResult;
```

***

# OpenURLActionResult

自定义 URL 打开逻辑的返回类型。

```ts
class OpenURLActionResult {
  type: string

  static handled(): OpenURLActionResult
  static discarded(): OpenURLActionResult

  static systemAction(options?: {
    url?: string
    prefersInApp: boolean // Requires iOS26.0+
  }): OpenURLActionResult
}
```

## 作用说明

| 返回值                     | 含义                         |
| ----------------------- | -------------------------- |
| `handled()`             | URL 已处理，不执行默认行为            |
| `discarded()`           | 忽略该 URL                    |
| `systemAction(options)` | 要求系统打开给定 URL（支持 App 内或外打开） |

***

## openURL 使用示例

```tsx
<Group
  environments={{
    openURL: (url) => {
      return OpenURLActionResult.systemAction({
        url,
        prefersInApp: false
      })
    }
  }}
>
  {urls.map(url =>
    <Link url={url}>{url}</Link>
  )}
</Group>
```

说明：

- 所有 `<Link>` 均会交给自定义的 `openURL` 方法处理
- 示例将所有 URL 交由系统处理，并要求“非 App 内打开（prefersInApp: false）”

***

# 使用总结

| environment key | 类型                             | 作用范围      | 使用场景         |
| --------------- | ------------------------------ | --------- | ------------ |
| `editMode`      | `Observable<EditMode>`         | 影响所有可编辑组件 | List 编辑、批量操作 |
| `openURL`       | `(url) => OpenURLActionResult` | 所有链接组件    | 自定义 URL 处理逻辑 |

***

# 完整示例：同时使用 editMode 与 openURL

```tsx
const editMode = useObservable(() => EditMode.inactive())

<VStack
  environments={{
    editMode,
    openURL: (url) => {
      if (url.startsWith("https://safe.com")) {
        return OpenURLActionResult.systemAction({ url, prefersInApp: true })
      }
      return OpenURLActionResult.discarded()
    }
  }}
>
  <Button
    title="Toggle Edit"
    action={() => {
      editMode.value = editMode.value.isEditing
        ? EditMode.inactive()
        : EditMode.active()
    }}
  />

  <List>
    ...
  </List>

  <Link url="https://safe.com">Safe Link</Link>
  <Link url="https://blocked.com">Blocked Link</Link>
</VStack>
```

***

# 注意事项

1. `environments` 为局部作用域，仅影响其子视图。
2. `editMode` 必须是 `Observable<EditMode>` 才能触发界面更新。
3. `openURL` 若返回 `handled()`，将阻止默认行为。
4. `systemAction` 中的 `prefersInApp` 会影响是否在 App 内打开链接。
5. 与 SwiftUI 不同，Scripting 的 `environment` 是显式声明，不会隐式传播所有 key。



---
url: /v2/zh/guide/View Modifiers/Swipe Actions/index.md
---

# 滑动操作

在 **Scripting** 中，你可以为用作 `<List>` 列表行的视图（如 `<HStack>`）添加滑动操作按钮，支持如“删除”、“编辑”、“收藏”等常见交互。

为了更清晰地支持 TypeScript，Scripting 将 SwiftUI 的 `swipeActions` 拆分为两个方向明确的修饰符：

- `leadingSwipeActions`: 向右滑动（从左到右）
- `trailingSwipeActions`: 向左滑动（从右到左）

***

## `leadingSwipeActions`

为列表行的 **左侧（leading）** 添加滑动操作。

### 类型

```ts
leadingSwipeActions?: {
  allowsFullSwipe?: boolean
  actions: VirtualNode[]
}
```

### 参数说明

- `actions`: 滑动后显示的按钮组件数组（通常为 `<Button>`）。
- `allowsFullSwipe`: 是否允许“完全滑动”直接执行第一个按钮的操作。默认值为 `true`。

***

## `trailingSwipeActions`

为列表行的 **右侧（trailing）** 添加滑动操作。

### 类型

```ts
trailingSwipeActions?: {
  allowsFullSwipe?: boolean
  actions: VirtualNode[]
}
```

### 参数说明

- `actions`: 滑动后显示的按钮组件数组（通常为 `<Button>`）。
- `allowsFullSwipe`: 是否允许“完全滑动”直接执行第一个按钮的操作。默认值为 `true`。

***

## 示例用法

```tsx
<List>
  {list.map(item => 
    <HStack
      trailingSwipeActions={{
        allowsFullSwipe: true,
        actions: [
          <Button
            title="删除"
            role="destructive"
            action={() => deleteItem(item)}
          />,
          <Button
            title="编辑"
            tint="accentColor"
            action={() => editItem(item)}
          />
        ]
      }}
    >
      <Image systemName={item.icon} />
      <Text>{item.title}</Text>
    </HStack>
  )}
</List>
```

添加左滑操作（向右滑）示例：

```tsx
<HStack
  leadingSwipeActions={{
    actions: [
      <Button
        title="收藏"
        tint="orange"
        action={() => markAsFavorite(item)}
      />
    ]
  }}
>
  <Text>{item.title}</Text>
</HStack>
```

***

## `<Button>` 属性说明

每个滑动操作项都是一个 `<Button>`，你可以使用以下属性来自定义外观与行为：

- `title`: 按钮显示文本
- `action`: 点击按钮时执行的函数
- `role`（可选）: 设置为 `"destructive"` 会显示红色，适用于“删除”操作
- `tint`（可选）: 自定义按钮颜色，例如 `"accentColor"` 或系统颜色名

***

## 注意事项

- `leadingSwipeActions` 和 `trailingSwipeActions` 可以在同一个行视图上同时使用。
- 仅用于列表行中的视图（例如 `<List>` 中的 `<HStack>`）才支持滑动操作。
- 当 `allowsFullSwipe` 为 `false` 时，用户必须点击按钮，而不能通过滑动全程触发操作。



---
url: /v2/zh/guide/View Modifiers/Swipe Actions/index_example.md
---

# 示例

```tsx
import { Button, Circle, HStack, Label, List, Navigation, NavigationStack, Script, Text, useState, VStack } from "scripting"

type Message = {
  from: string
  content: string
  isUnread: boolean
}

function MessageCell({
  message
}: {
  message: Message
}) {
  return <HStack>
    <Circle
      fill={message.isUnread ? "systemBlue" : "clear"}
      frame={{
        width: 16,
        height: 16,
      }}
    />
    <VStack
      alignment={"leading"}
    >
      <Text font={"headline"}>{message.from}</Text>
      <Text>{message.content}</Text>
    </VStack>
  </HStack>
}

function Example() {
  const [messages, setMessages] = useState<Message[]>(() => [
    {
      from: "Maria Ruiz",
      content: "If you have a list of messages, you can add an action to toggle a message as unread on a swipe from the leading edge, and actions to delete or flag messages on a trailing edge swipe.",
      isUnread: true,
    },
    {
      from: "Mei Chen",
      content: "Actions appear in the order you list them, starting from the swipe’s originating edge. In the example, the Delete action appears closest to the screen’s trailing edge",
      isUnread: true,
    },
    {
      from: "Maria Ruiz",
      content: "By default, the user can perform the first action for a given swipe direction with a full swipe. The user can perform both the toggle unread and delete actions with full swipes. You can opt out of this behavior for an edge by setting the allowsFullSwipe parameter to false.",
      isUnread: false,
    },
    {
      from: "Mei Chen",
      content: "When you set a role for a button using one of the values from the ButtonRole, system styles the button according to its role. In the example above, the delete action appears in red because it has the destructive role. If you want to set a different color, add the tint property to the button",
      isUnread: true,
    }
  ])

  function toggleUnread(message: Message) {
    setMessages(messages.map(item => item !== message ? item : {
      ...message,
      isUnread: !item.isUnread
    }))
  }

  function deleteMessage(message: Message) {
    setMessages(messages.filter(item => item !== message))
  }

  return <NavigationStack>
    <List
      navigationTitle={"Messages"}
      navigationBarTitleDisplayMode={"inline"}
      listStyle={"inset"}
    >
      {messages.map(message =>
        <MessageCell
          message={message}
          leadingSwipeActions={{
            allowsFullSwipe: false,
            actions: [
              <Button
                action={() => toggleUnread(message)}
                tint={"systemBlue"}
              >
                {message.isUnread
                  ? <Label title={"Read"} systemImage={"envelope.open"} />
                  : <Label title={"Unread"} systemImage={"envelope.badge"} />
                }
              </Button>
            ]
          }}
          trailingSwipeActions={{
            actions: [
              <Button
                role={"destructive"}
                action={() => deleteMessage(message)}
              >
                <Label title={"Delete"} systemImage={"trash"} />
              </Button>,
              <Button
                action={() => { }}
                tint={"systemOrange"}
              >
                <Label title={"Flag"} systemImage={"flag"} />
              </Button>
            ]
          }}
        />
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/View Modifiers/Symbol Style.md
---

# 符号样式

这些修饰符用于配置 SF Symbols（系统符号图标）的显示样式和动画效果，常用于 `<Image systemName="...">` 组件。

***

### `symbolRenderingMode`

设置符号图像的 **渲染模式**。

#### 类型

```ts
symbolRenderingMode?: SymbolRenderingMode
```

#### 可选值（SymbolRenderingMode）：

- `"monochrome"`：单色模式，使用当前前景色绘制
- `"hierarchical"`：层次渲染，根据不同图层设置不透明度（适合语义着色）
- `"multicolor"`：使用符号内置颜色
- `"palette"`：分层渲染，可自定义每一层的颜色样式（需搭配 `foregroundStyle`）

#### 示例

```tsx
<Image
  systemName="star.fill"
  symbolRenderingMode="palette"
  foregroundStyle={{
    primary: "red",
    secondary: "orange",
    tertiary: "yellow"
  }}
/>
```

***

### `foregroundStyle`

设置符号或前景元素的颜色样式。

#### 类型

```ts
foregroundStyle?: 
  | ShapeStyle
  | DynamicShapeStyle
  | {
      primary: ShapeStyle | DynamicShapeStyle
      secondary: ShapeStyle | DynamicShapeStyle
      tertiary?: ShapeStyle | DynamicShapeStyle
    }
```

#### 说明：

- 在 `"monochrome"` 模式下使用单个颜色或渐变；
- 在 `"palette"` 模式下使用 `{ primary, secondary, tertiary }` 对象指定多层样式；
- `tertiary` 可选，仅在符号有三层图层时有效。

***

### `symbolVariant`

为符号添加特定的 **视觉变体**。

#### 类型

```ts
symbolVariant?: SymbolVariants
```

#### 可选值（SymbolVariants）：

- `"none"`：无变体，原始符号样式
- `"fill"`：填充样式
- `"circle"`：包裹在圆形轮廓中
- `"square"`：包裹在方形轮廓中
- `"rectangle"`：包裹在矩形轮廓中
- `"slash"`：斜杠样式，表示禁止/关闭等状态

#### 示例

```tsx
<Image
  systemName="wifi"
  symbolVariant="slash"
/>
```

***

### `symbolEffect`

为符号添加 **动画效果**，支持静态应用或绑定数值以触发动画。

#### 类型

```ts
symbolEffect?: SymbolEffect
```

#### 使用方式：

##### 1. 静态符号效果（SymbolEffect 简写字符串）

```tsx
<Image
  systemName="checkmark"
  symbolEffect="scaleUp"
/>
```

##### 2. 动态绑定符号效果（每次值变化时触发动画）

```tsx
<Image
  systemName="heart"
  symbolEffect={{
    effect: "bounce",
    value: isLiked
  }}
/>
```

每次 `isLiked` 状态变化时，图标会执行 bounce 动画。

***

### 可用 Symbol 动效分类（DiscreteSymbolEffect）

| 类别                 | 动效关键字                                                                                                                                                                                 |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 弹跳 Bounce          | `bounce`, `bounceByLayer`, `bounceDown`, `bounceUp`, `bounceWholeSymbol`                                                                                                              |
| 呼吸 Breathe         | `breathe`, `breatheByLayer`, `breathePlain`, `breathePulse`, `breatheWholeSymbol`                                                                                                     |
| 脉冲 Pulse           | `pulse`, `pulseByLayer`, `pulseWholeSymbol`                                                                                                                                           |
| 旋转 Rotate          | `rotate`, `rotateByLayer`, `rotateClockwise`, `rotateCounterClockwise`, `rotateWholeSymbol`                                                                                           |
| 颜色变化 VariableColor | `variableColor`, `variableColorIterative`, `variableColorDimInactiveLayers`, `variableColorHideInactiveLayers`, `variableColorCumulative`                                             |
| 摇晃 Wiggle          | `wiggle`, `wiggleLeft`, `wiggleRight`, `wiggleUp`, `wiggleDown`, `wiggleForward`, `wiggleBackward`, `wiggleByLayer`, `wiggleWholeSymbol`, `wiggleClockwise`, `wiggleCounterClockwise` |

***

### 综合示例

```tsx
<Image
  systemName="bell.fill"
  symbolRenderingMode="hierarchical"
  symbolVariant="circle"
  foregroundStyle="indigo"
  symbolEffect={{
    effect: "breathePulse",
    value: isNotified
  }}
/>
```

上述示例中：

- 使用了分层渲染（hierarchical）；
- 添加了圆形变体（circle）；
- 设置了 `indigo` 颜色；
- 每当 `isNotified` 变化时，符号执行 `breathePulse` 动画。

***

## 修饰符汇总表

| 修饰符                   | 说明                        |
| --------------------- | ------------------------- |
| `symbolRenderingMode` | 设置符号图标的渲染模式（单色、多色、层次、调色板） |
| `foregroundStyle`     | 设置符号的颜色风格，可支持多图层配色        |
| `symbolVariant`       | 添加符号样式变体，如填充、圆形、斜杠等       |
| `symbolEffect`        | 添加符号动画，可静态或绑定值驱动          |



---
url: /v2/zh/guide/View Modifiers/Text Field.md
---

# 文本输入框

这些修饰符可用于自定义 `TextField` 组件的行为和外观，包括键盘类型、自动更正、自动大写、提交操作等。

***

## `onSubmit`

为文本字段添加提交时触发的操作。

### 类型

```ts
onSubmit?: (() => void) | {
  triggers: SubmitTriggers
  action: () => void
}
```

### 行为说明

- 若直接提供函数形式：

  ```tsx
  <TextField onSubmit={() => console.log('提交了')} />
  ```

  等价于：

  ```tsx
  <TextField
    onSubmit={{
      triggers: 'text',
      action: () => console.log('提交了')
    }}
  />
  ```

- 也可以明确指定触发提交操作的方式：

  ```tsx
  <TextField
    onSubmit={{
      triggers: 'search',
      action: () => console.log('搜索提交')
    }}
  />
  ```

### `SubmitTriggers` 可选值：

- `"text"`：由文本输入控件（如 `TextField`、`SecureField`）触发。
- `"search"`：由搜索输入框（使用 `searchable` 修饰符）触发。

***

## `keyboardType`

设置聚焦输入时显示的键盘类型。

### 类型

```ts
keyboardType?: KeyboardType
```

### 可选值：

- `'default'`
- `'numberPad'`
- `'phonePad'`
- `'namePhonePad'`
- `'URL'`
- `'decimalPad'`
- `'asciiCapable'`
- `'asciiCapableNumberPad'`
- `'emailAddress'`
- `'numbersAndPunctuation'`
- `'twitter'`
- `'webSearch'`

### 示例

```tsx
<TextField keyboardType="emailAddress" />
```

***

## `autocorrectionDisabled`

控制是否启用系统的自动更正功能。

### 类型

```ts
autocorrectionDisabled?: boolean
```

### 默认值

- `true` — 默认禁用自动更正。

### 示例

```tsx
<TextField autocorrectionDisabled={false} />
```

***

## `textInputAutocapitalization`

设置文本输入时的自动大写行为。

### 类型

```ts
textInputAutocapitalization?: TextInputAutocapitalization
```

### 可选值

- `"never"` – 不自动大写。
- `"characters"` – 每个字母都大写。
- `"sentences"` – 每个句子的首字母大写。
- `"words"` – 每个单词的首字母大写。

### 示例

```tsx
<TextField textInputAutocapitalization="words" />
```

***

## `submitScope`

阻止当前视图触发的提交操作向上传递到父级视图的 `onSubmit` 处理器。

### 类型

```ts
submitScope?: boolean
```

### 默认值

- `false` — 默认允许事件向上传递。

### 示例

```tsx
<TextField submitScope />
```

启用此项后，该字段的提交事件将不会触发父视图中的提交处理逻辑。

## `submitLabel`

设置提交按钮的文本。

### 类型

```ts
submitLabel?: "continue" | "return" | "send" | "go" | "search" | "join" | "done" | "next" | "route"
```

### 示例

```tsx
<TextField submitLabel="send" />
```



---
url: /v2/zh/guide/View Modifiers/Text View Modifiers.md
---

# 文本修饰符

以下属性可用于为基于文本的视图（如 `Text` 或 `Label`）设置样式和格式，其功能与 SwiftUI 的内建修饰符类似。通过自定义这些属性，您可以控制文本的字体、字重、设计、间距及其他排版特性。

## 概览

这些属性通常作为属性传递给与文本相关的组件，如 `Text` 或 `Label`。例如，您可以设置字体大小、启用加粗格式，或添加自定义颜色的下划线——无需手动调用多个修饰符。

```tsx
<Text
  font={{ name: 'SystemFontName', size: 18 }}
  fontWeight="semibold"
  italic
  underline="red"
  lineLimit={2}
  multilineTextAlignment="center"
>
  Stylish Text Here
</Text>
```

在上面的示例中，文本使用了自定义字体、半粗体、斜体风格、红色下划线，限制为两行，并居中对齐。

***

## 字体配置

### `font`

定义文本的字体和大小。

- **数字**：提供一个数字（例如 `14`）时，将应用该大小的系统字体。
- **预设字体名称**（`Font` 类型）：使用内建的文本样式之一（如 `"largeTitle"`、`"title"`、`"headline"`、`"subheadline"`、`"body"`、`"callout"`、`"footnote"`、`"caption"`）。系统会根据样式决定大小和字重。
- **包含名称和大小的对象**：指定 `name` 和 `size` 来应用自定义字体。

```tsx
<Text font={20}>系统字体，大小为 20</Text>
<Text font="headline">系统标题字体</Text>
<Text font={{ name: "CustomFontName", size: 16 }}>自定义字体</Text>
```

***

### `fontWeight`

设置字体的粗细程度。可选值包括从 `"ultraLight"` 到 `"black"`。

```tsx
<Text fontWeight="bold">加粗文本</Text>
```

***

### `fontWidth`

指定字体的宽度变体（如果可用）。可选值有 `"compressed"`、`"condensed"`、`"expanded"` 和 `"standard"`，也可以使用数字（如果支持）。

```tsx
<Text fontWidth="condensed">压缩宽度字体</Text>
```

***

### `fontDesign`

修改字体设计风格。可选值包括 `"default"`、`"monospaced"`、`"rounded"`、`"serif"`。

```tsx
<Text fontDesign="rounded">圆角字体设计</Text>
```

***

## 文本格式

### `minScaleFactor`

一个介于 0 到 1 之间的数字，表示当文本超出空间限制时最多可以缩小到原始大小的多少。例如，`0.5` 表示文本可以缩小到 50%。

```tsx
<Text minScaleFactor={0.8}>当文本超出时会稍微缩小。</Text>
```

***

### `bold`

如果为 `true`，应用加粗字体。

```tsx
<Text bold>这是加粗文本</Text>
```

***

### `baselineOffset`

调整文本相对于基线的垂直位置。正值向上移动，负值向下移动。

```tsx
<Text baselineOffset={5}>文本向上偏移</Text>
```

***

### `kerning`

控制字符间距。正值增加间距，负值减小间距。

```tsx
<Text kerning={2}>字符间距增加</Text>
```

***

### `italic`

如果为 `true`，应用斜体样式。

```tsx
<Text italic>斜体文本</Text>
```

***

### `monospaced`

强制所有子文本使用等宽字体（如果可用）。

```tsx
<Text monospaced>等宽字体文本</Text>
```

***

### `monospacedDigit`

使用固定宽度数字，而其他字符保持原样。适用于表格或计时器中的数字对齐。

```tsx
<Text monospacedDigit>数字等宽对齐 1234</Text>
```

***

## 文本装饰

### `strikethrough`

应用删除线（贯穿文本）。可以提供颜色，或一个包含样式和颜色的对象。

- **仅颜色**：`strikethrough="red"`
- **对象**：`strikethrough={{ pattern: 'dash', color: 'blue' }}`

```tsx
<Text strikethrough="gray">灰色删除线文本</Text>
<Text strikethrough={{ pattern: 'dot', color: 'red' }}>红色点状删除线</Text>
```

***

### `underline`

以下划线方式装饰文本，使用方式与 `strikethrough` 类似。

- **仅颜色**：`underline="blue"`
- **对象**：`underline={{ pattern: 'dashDot', color: 'green' }}`

```tsx
<Text underline="blue">蓝色下划线文本</Text>
<Text underline={{ pattern: 'dot', color: 'pink' }}>粉色点状下划线</Text>
```

***

## 行数、行间距与布局控制

### `lineLimit`

指定文本最多显示的行数。可以：

- 提供一个数字来设置最大行数；
- 或提供一个对象 `{ min?: number; max: number; reservesSpace?: boolean }`，来指定最小和最大行数，并选择是否预留最大行数空间以避免布局跳动。

```tsx
<Text lineLimit={1}>如果超出一行将被截断。</Text>
<Text lineLimit={{ min: 2, max: 4, reservesSpace: true }}>
  可显示 2 到 4 行文本，并始终预留 4 行空间，避免布局变化。
</Text>
```

***

### `lineSpacing`

设置行间距，单位为像素。

```tsx
<Text lineSpacing={5}>设置行间距为 5 像素</Text>
```

***

### `multilineTextAlignment`

设置多行文本的对齐方式：`"leading"`（左对齐）、`"center"`（居中）或 `"trailing"`（右对齐）。

```tsx
<Text multilineTextAlignment="center">
  多行文本居中显示。
</Text>
```

***

### `truncationMode`

指定文本太长时的截断方式。

#### 类型

```ts
type TruncationMode = "head" | "middle" | "tail"
```

#### 描述

定义截断的位置：

- `"head"`：截断行首，保留末尾。
- `"middle"`：截断中间，保留首尾。
- `"tail"`：截断尾部，保留开头。

```tsx
<Text truncationMode="middle">
  这是一段可能会被截断的很长文本。
</Text>
```

***

### `allowsTightening?: boolean`

是否允许系统在必要时压缩字符间距以适应一行内显示。

#### 类型

`boolean`

#### 默认值

`false`

#### 描述

设置为 `true` 时，系统可以压缩字距以避免截断，并改善在受限空间下的布局适应性。

```tsx
<Text allowsTightening={true}>
  在需要时压缩的文本
</Text>
```

***

## 总结

通过组合这些属性，您可以完全掌控文本视图的排版，而无需多个包装组件或修饰符。无论您需要加粗、斜体、带自定义字符间距和下划线的标题，还是仅限两行显示的正文文本，这些选项都能满足广泛的文本样式需求。



---
url: /v2/zh/guide/View Modifiers/Toast.md
---

# Toast提示

`toast` 修饰器用于在视图上显示一个临时提示框（Toast）。
它通常用于短暂地展示消息或反馈信息，例如“保存成功”、“操作完成”、“网络错误”等。

Toast 可以包含简单的文本消息，也可以自定义内容视图。
你可以控制其显示位置、持续时间、背景颜色、圆角、阴影等外观属性。

***

## 类型定义

```ts
toast?: {
  duration?: number | null
  position?: "top" | "bottom" | "center"
  backgroundColor?: Color | null
  textColor?: Color | null
  cornerRadius?: number | null
  shadowRadius?: number | null
} & (
  | { message: string; content?: never }
  | { message?: never; content: VirtualNode }
) & ({
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
} | {
  isPresented: Observable<boolean>
})
```

***

## 属性说明

### `isPresented: boolean` 和 `onChanged(isPresented: boolean): void`

**说明**：
使用`isPresented`和`onChanged`来控制Toast的显示和隐藏。

**示例**：

```tsx
const [showToast, setShowToast] = useState(false)

toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  message: "Saved successfully"
}}
```

***

### `isPresented: Observable<boolean>`

**说明**：使用 `isPresented` 作为 `Observable` 来控制 Toast 的显示和隐藏。

**示例**：

````tsx
const showToast = useObservable(false)

toast={{
  isPresented: showToast,
  message: "Saved successfully"
}}

---

### `duration?: number | null`

**说明**：
Toast 显示的持续时间（单位：秒）。
默认值为 `2` 秒。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  duration: 3,
  message: "Action completed"
}}
````

***

### `position?: "top" | "bottom" | "center"`

**说明**：
控制 Toast 在屏幕上的显示位置。
可选值：

- `"top"`：顶部显示
- `"bottom"`：底部显示（默认）
- `"center"`：居中显示

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  position: "top",
  message: "New message received"
}}
```

***

### `backgroundColor?: Color | null`

**说明**：
设置 Toast 的背景颜色。可以使用任意支持的 `Color` 类型。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  backgroundColor: "blue",
  message: "Upload successful"
}}
```

***

### `textColor?: Color | null`

**说明**：
设置 Toast 文本的颜色。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  textColor: "white",
  message: "Download failed"
}}
```

***

### `cornerRadius?: number | null`

**说明**：
设置 Toast 的圆角大小。
默认值为 `16`。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  cornerRadius: 8,
  message: "Item added"
}}
```

***

### `shadowRadius?: number | null`

**说明**：
设置阴影的模糊半径。
默认值为 `4`。

**示例**：

```tsx
toast={{
  isPresented: showToast,
  onChanged: setShowToast,
  shadowRadius: 6,
  message: "Success"
}}
```

***

## 显示文本消息

**示例**：

```tsx
function View() {
  const [showToast, setShowToast] = useState(false)

  return (
    <List
      toast={{
        isPresented: showToast,
        onChanged: setShowToast,
        message: "Data saved successfully",
        duration: 2,
        position: "bottom",
        backgroundColor: "green",
        textColor: "white"
      }}
    >
      <Button
        title="Save"
        action={() => setShowToast(true)}
      />
    </List>
  )
}
```

该示例中，当点击按钮后，会在底部显示一个绿色背景的提示“Data saved successfully”，持续 2 秒后自动消失。

***

## 显示自定义内容

**说明**：
除了简单文本，你还可以传入一个 `VirtualNode` 来自定义 Toast 的内容，例如包含图标、布局或按钮的自定义组件。

**示例**：

```tsx
function View() {
  const [showToast, setShowToast] = useState(false)

  return (
    <List
      toast={{
        isPresented: showToast,
        onChanged: setShowToast,
        content: (
          <HStack spacing={8}>
            <Image systemName="checkmark.circle.fill" />
            <Text foregroundStyle="white">Upload Complete</Text>
          </HStack>
        ),
        backgroundColor: "black",
        cornerRadius: 12
      }}
    >
      <Button
        title="Show Toast"
        action={() => setShowToast(true)}
      />
    </List>
  )
}
```

该示例展示了一个包含图标与文本的自定义 Toast。

***

## 使用建议

1. **保持状态同步**：
   `isPresented` 必须与 `onChanged` 回调保持同步，否则 Toast 无法正确关闭。

2. **简洁提示**：
   Toast 应用于短暂、轻量级的信息提示，而非需要交互的复杂内容。

3. **避免同时显示多个 Toast**：
   屏幕上同时出现多个 Toast 可能造成用户困惑。

4. **可组合使用**：
   你可以与 `Button`、`List` 等组件配合使用，用于即时反馈用户操作。



---
url: /v2/zh/guide/View Modifiers/ToolBar View Modifiers.md
---

# 工具栏修饰符

Scripting App 支持一系列视图修饰符，用于控制系统工具栏（包括导航栏、底部工具栏、标签栏等）的可见性、外观样式以及行为。这些修饰符参考了 SwiftUI 的设计，允许你在每个视图中以声明式方式对工具栏进行个性化配置。

***

## 可见性控制修饰符

以下修饰符用于控制系统界面中各类栏（bar）的显示与隐藏：

```ts
bottomBarVisibility?: Visibility
navigationBarVisibility?: Visibility
tabBarVisibility?: Visibility
```

### Visibility 类型定义

```ts
type Visibility = "automatic" | "hidden" | "visible"
```

- **`automatic`**：由系统自动决定是否显示。
- **`hidden`**：强制隐藏该栏。
- **`visible`**：强制显示该栏。

***

## 工具栏标题菜单

```ts
toolbarTitleMenu?: VirtualNode
```

为导航栏的标题添加一个可点击菜单。点击导航标题后，系统会展示该菜单内容。常用于展示与当前页面相关的上下文操作选项。

***

## 工具栏背景样式

```ts
toolbarBackground?: ShapeStyle | DynamicShapeStyle | {
  style: ShapeStyle | DynamicShapeStyle
  bars?: ToolbarPlacement[]
}
```

配置工具栏的背景样式。支持颜色、材质、渐变等形式，可通过 `bars` 参数限定应用到特定栏位。

### bars（可选）

```ts
type ToolbarPlacement = "automatic" | "tabBar" | "bottomBar" | "navigationBar"
```

- 若未设置 `bars`，系统会自动决定应用范围。
- 可指定应用到 `tabBar`、`bottomBar` 或 `navigationBar` 等栏位。

***

## 工具栏背景可见性（仅限 iOS 18+）

```ts
toolbarBackgroundVisibility?: Visibility | {
  visibility: Visibility
  bars?: ToolbarPlacement[]
}
```

控制工具栏背景的可见性。例如，可使导航栏背景透明、半透明或完全不显示。

- **`visibility`**：可选值包括 `"automatic"`、`"visible"`、`"hidden"`。
- **`bars`**（可选）：指定希望应用该设置的栏位。若不指定，默认作用于所有工具栏。

***

## 工具栏配色方案

```ts
toolbarColorScheme?: ColorScheme | {
  colorScheme: ColorScheme | null
  bars?: ToolbarPlacement[]
}
```

指定工具栏的配色风格（亮色或暗色），影响工具栏内容的颜色（如按钮、标题等）。

### ColorScheme 类型定义

```ts
type ColorScheme = "light" | "dark"
```

- **`light`**：使用浅色配色风格。
- **`dark`**：使用深色配色风格。
- **`null`**：恢复系统默认配色。

`bars` 参数可限制仅对特定工具栏应用该配色设置。

***

## 工具栏标题展示模式

```ts
toolbarTitleDisplayMode?: ToolbarTitleDisplayMode
```

控制导航栏中标题的展示样式。

### ToolbarTitleDisplayMode 类型定义

```ts
type ToolbarTitleDisplayMode = "automatic" | "large" | "inline" | "inlineLarge"
```

- **`automatic`**：由系统自动决定使用大标题或小标题。
- **`large`**：使用大标题样式（通常在导航栈顶显示）。
- **`inline`**：标题与导航栏控件同行显示。
- **`inlineLarge`**：使用 inline 布局，但保留大标题的视觉风格（适用于自定义标题样式）。

***

## 使用说明

- 所有修饰符可组合使用，为每个视图实现精细化的工具栏配置。
- `toolbarBackground`、`toolbarColorScheme` 和 `toolbarBackgroundVisibility` 可通过 `bars` 参数作用于特定栏位，提供精准的外观控制。
- `toolbarBackgroundVisibility` 仅在 iOS 18 及以上版本有效。
- `toolbarTitleMenu` 适用于具备导航栏的视图，用于增强导航标题的交互性。



---
url: /v2/zh/guide/View Modifiers/blur.md
---

# 模糊

对视图应用高斯模糊效果。

## 类型

```ts
blur?: number | {
  radius: number
  opaque: boolean
}
```

## 示例

简单模糊：

```tsx
<Image blur={10} />
```

自定义模糊：

```tsx
<Image
  blur={{
    radius: 12,
    opaque: false
  }}
/>
```



---
url: /v2/zh/guide/View Modifiers/border.md
---

# 边框

`border` 属性用于为视图添加边框，可指定边框样式与可选的宽度。支持使用纯色、渐变、系统材质等视觉样式，并能根据系统浅色/深色模式自动切换。

## 定义

```ts
border?: {
  style: ShapeStyle | DynamicShapeStyle
  width?: number
}
```

- **`style`**：必填，定义边框的视觉样式，支持 `ShapeStyle` 或 `DynamicShapeStyle`。
- **`width`**：选填，设置边框的粗细（像素单位），默认值为 `1`。

## 使用示例

### 纯色边框

```tsx
<Text
  border={{
    style: "systemRed",
    width: 2
  }}
>
  带边框的文字
</Text>
```

### 默认宽度（1px）边框

```tsx
<HStack
  border={{
    style: "#000000"
  }}
>
  ...
</HStack>
```

### 渐变边框

```tsx
<Text
  border={{
    style: {
      gradient: [
        { color: "red", location: 0 },
        { color: "blue", location: 1 }
      ],
      startPoint: { x: 0, y: 0 },
      endPoint: { x: 1, y: 1 }
    },
    width: 3
  }}
>
  渐变边框
</Text>
```

### 动态边框样式（浅色/深色模式自动切换）

```tsx
<Text
  border={{
    style: {
      light: "gray",
      dark: "white"
    },
    width: 1.5
  }}
>
  自适应边框
</Text>
```

## 注意事项

- 边框将包裹整个视图边缘，并与视图尺寸和 `frame` 设置一起作用。
- `style` 支持所有 `ShapeStyle` 类型，也可使用系统材质（如 `"regularMaterial"`、`"ultraThinMaterial"`）来创建原生 iOS 风格的边框。



---
url: /v2/zh/guide/View Modifiers/buttonStyle.md
---

# 按钮样式

该属性用于自定义 UI 中视图层次结构内按钮的交互行为和外观。

***

## 属性声明

```tsx
buttonStyle?: ButtonStyle;
```

### 描述

`buttonStyle` 属性为视图层次结构中的所有按钮应用特定样式，从而自定义它们的外观和交互行为。

***

### 可接受的值

`buttonStyle` 属性接受以下字符串值：

- **`automatic`**: 默认按钮样式，根据按钮的上下文进行自适应。
- **`bordered`**: 应用基于按钮上下文的标准边框样式。
- **`borderedProminent`**: 应用突出显示的边框样式，适合需要重点强调的按钮。
- **`borderless`**: 无边框样式。
- **`plain`**: 在空闲状态下不添加装饰，但会在按钮被按下、聚焦或启用时以视觉方式指示其状态。

***

### 默认行为

如果未指定 `buttonStyle`，则会根据按钮的上下文自动应用默认样式（`automatic`）。

***

## 使用示例

以下展示如何在 TypeScript 代码中使用 `buttonStyle` 属性：

### 示例：带边框的按钮样式

```tsx
<Button
  title="按下我"
  buttonStyle="bordered"
  action={() => console.log('按钮被按下！')}
/>
```

此示例创建了一个带有标准边框的按钮。

***

### 示例：无边框的按钮样式

```tsx
<Button
  title="按下我"
  buttonStyle="borderless"
  action={() => console.log('按钮被按下！')}
/>
```

此示例创建了一个无边框的按钮。

***

### 示例：纯样式按钮

```tsx
<Button
  title="按下我"
  buttonStyle="plain"
  action={() => console.log('按钮被按下！')}
/>
```

此示例创建了一个在空闲状态下不装饰内容，但在交互时会通过视觉效果指示状态的按钮。

***

## 注意事项

- `buttonStyle` 属性直接映射到 SwiftUI 的 `buttonStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。



---
url: /v2/zh/guide/View Modifiers/clipShape.md
---

# 裁剪形状

将视图裁剪为指定形状，并保持内容比例。

### 类型

```ts
clipShape?: Shape
```

### 示例

```tsx
<Image 
  filePath="path/to/photo.jpg"
  clipShape="Circle"
/>

<Image 
  filePath="path/to/photo.jpg"
  clipShape={
    type: "rect",
    cornerRadius: 12
  }
/>
```



---
url: /v2/zh/guide/View Modifiers/clipped.md
---

# 裁剪形状

将视图裁剪为其矩形边界。若为 `true`，启用裁剪；否则忽略该修饰符。可用于避免内容超出布局。

## 类型

```ts
clipped?: boolean
```

## 示例

```tsx
<Text
  fixedSize
  frame={{
    width: 175,
    height: 100
  }}
  clipped={true}
  border={{
    style: "gray"
  }}
>This long text string is clipped</Text>
```



---
url: /v2/zh/guide/View Modifiers/colorConvert.md
---

# 反转颜色

反转该视图的颜色，用于视觉强调或辅助功能场景。

### 类型

```ts
colorConvert?: boolean
```

### 示例

```tsx
<Image
  colorConvert={true}
  imageUrl="https://example.com/imgs/example.jpg"
/>
```



---
url: /v2/zh/guide/View Modifiers/containerRelativeFrame.md
---

# containerRelativeFrame

将当前视图放置在一个相对于其最近容器尺寸的“隐形框架”中。该修饰符适用于 `ScrollView`、`Grid`、布局栈等容器中，用于实现按比例布局或视图对齐。

## 类型定义

```ts
containerRelativeFrame?: {
  axes: AxisSet
  alignment?: Alignment
  count: never
  span: never
  spacing: never
} | {
  axes: AxisSet
  alignment?: Alignment
  count: number
  span?: number
  spacing: number
}
```

***

## 描述

该修饰符允许视图根据其父容器的尺寸进行相对的布局和定位。常用于构建按比例划分空间的布局，或配合滚动视图对视图进行精准定位。

***

## 属性说明

- **`axes`** (`AxisSet`，必填)
  指定在哪些轴向上应用相对布局（可选值：`horizontal`、`vertical` 或 `all`）。

- **`alignment`** (`Alignment`，可选，默认值：`"center"`）
  控制视图在容器内的对齐方式。

- **`count`** (`number`，可选，仅在第二种用法中有效)
  容器会被划分为多少等分。

- **`span`** (`number`，可选，默认值为 `1`)
  当前视图应占据多少等分。

- **`spacing`** (`number`，仅在第二种用法中为必填)
  分段之间的间距。

***

## 使用方式

该修饰符支持两种配置模式：

### 1. **自动适应模式**

仅指定对齐方向和轴向，不设置具体划分方式。

```tsx
containerRelativeFrame={{
  axes: 'horizontal',
  alignment: 'leading'
}}
```

### 2. **按比例划分模式**

将容器划分为若干等分，并为每个视图分配所占比例及间距。

```tsx
containerRelativeFrame={{
  axes: 'horizontal',
  count: 4,
  span: 2,
  spacing: 10
}}
```

***

## 示例

```tsx
<HStack>
  <Text
    containerRelativeFrame={{
      axes: 'horizontal',
      count: 3,
      span: 1,
      spacing: 8,
      alignment: 'center'
    }}
  >
    占据三分之一宽度
  </Text>
</HStack>
```

该示例将文字放入一个宽度为容器三分之一的区域内，视图之间的间距为 8。

***

## 参考资料

- [Apple 官方文档](https://developer.apple.com/documentation/swiftui/view/containerrelativeframe%28_:alignment:%29)
- [Hacking with Swift 教程](https://www.hackingwithswift.com/quick-start/swiftui/how-to-adjust-the-size-of-a-view-relative-to-its-container)



---
url: /v2/zh/guide/View Modifiers/contentMargins.md
---

# 内容外边距

`contentMargins` 修饰符用于为视图内容添加自定义的外边距（Margins）。它支持统一设置所有边，也支持根据指定方向（如顶部、底部、水平、垂直）以及不同位置（内容区域或滚动指示器区域）灵活设置边距。

***

## 类型定义

```ts
contentMargins?: 
  | number
  | EdgeInsets
  | {
      edges?: EdgeSet
      insets: number | EdgeInsets
      placement?: ContentMarginPlacement
    }
```

***

## 参数说明

## `insets`（必填）

指定要添加的边距数值：

- 可传入一个数字，表示所有边统一使用该数值；
- 或传入 `EdgeInsets` 对象，分别设置 `top`、`bottom`、`leading`、`trailing`。

### 示例：统一边距

```tsx
<ScrollView contentMargins={20}>
  <Text>上下左右各添加 20 点边距</Text>
</ScrollView>
```

### 示例：分别设置边距

```tsx
<ScrollView
  contentMargins={{
    top: 10,
    bottom: 30,
    leading: 16,
    trailing: 16
  }}
>
  <Text>自定义边距</Text>
</ScrollView>
```

***

## `edges`（可选）

设置要在哪些方向上应用边距，默认是全部方向。

### 类型

```ts
type EdgeSet = "top" | "bottom" | "leading" | "trailing" | "vertical" | "horizontal" | "all"
```

### 示例：仅设置上下边距

```tsx
<ScrollView
  contentMargins={{
    edges: "vertical",
    insets: 12
  }}
>
  <Text>仅上下有边距</Text>
</ScrollView>
```

***

## `placement`（可选）

指定边距的作用区域，适用于滚动容器（如 ScrollView）中需要区分内容区域和滚动条指示区域的场景。

### 类型

```ts
type ContentMarginPlacement = "automatic" | "scrollContent" | "scrollIndicators"
```

### 可选值说明：

| 值                    | 描述                  |
| -------------------- | ------------------- |
| `"automatic"`        | 默认行为，系统决定边距应用位置     |
| `"scrollContent"`    | 边距应用于可滚动的内容区域       |
| `"scrollIndicators"` | 边距仅应用于滚动指示器（如滚动条）区域 |

### 示例：边距仅作用于内容区域

```tsx
<ScrollView
  contentMargins={{
    insets: 24,
    placement: "scrollContent"
  }}
>
  <Text>内容区域设置边距，滚动条不受影响</Text>
</ScrollView>
```

***

## 完整示例

```tsx
<ScrollView
  contentMargins={{
    edges: "horizontal",
    insets: { leading: 20, trailing: 20, top: 0, bottom: 0 },
    placement: "scrollContent"
  }}
>
  <VStack spacing={10}>
    <Text>仅在横向内容区域添加边距</Text>
  </VStack>
</ScrollView>
```

***

## 参数汇总

| 参数          | 说明                                         |
| ----------- | ------------------------------------------ |
| `insets`    | 必填。边距数值，可为统一数字或 `EdgeInsets` 对象            |
| `edges`     | 可选。应用边距的方向，如 `"vertical"`、`"horizontal"` 等 |
| `placement` | 可选。边距作用区域（内容区域或滚动条区域）                      |



---
url: /v2/zh/guide/View Modifiers/contentShape.md
---

# 内容形状

`contentShape` 属性用于定义视图内容的**交互区域或视觉边界形状**。该形状可影响视图在点击、拖放、辅助功能、悬停等场景中的行为。常用于精确控制**命中测试（hit-testing）区域**或指定用于辅助功能和交互反馈的自定义轮廓。

这在如下场景中特别有用：

- 控制按钮或自定义视图的可点击区域；
- 定义拖放预览或上下文菜单的形状；
- 指定辅助功能的可聚焦区域；
- 优化鼠标悬停的交互体验。

## 定义

```ts
contentShape?: Shape | {
  kind: ContentShapeKinds
  shape: Shape
}
```

***

## 支持的写法

### 1. 简单形状（适用于所有用途）

直接传入一个 `Shape` 值，作为默认交互区域，用于所有情境（点击、辅助功能、拖放等）。

```tsx
contentShape="circle"
```

***

### 2. 按用途定义的指定形状

使用结构体形式设置指定类型的内容形状：

```ts
{
  kind: ContentShapeKinds
  shape: Shape
}
```

用于为特定交互类型（如 `accessibility`、`dragPreview`）设置不同的区域。

***

## 支持的 `ContentShapeKinds`

| 类型名称                   | 用途说明                      |
| ---------------------- | ------------------------- |
| `"interaction"`        | 命中测试区域（如点击、手势）            |
| `"dragPreview"`        | 拖放操作中的预览形状                |
| `"contextMenuPreview"` | 上下文菜单预览的形状                |
| `"hoverEffect"`        | 鼠标悬停交互区域（适用于连接鼠标的设备）      |
| `"accessibility"`      | 辅助功能可聚焦区域，用于朗读、排序、高亮等辅助操作 |

***

## 示例

### 为所有交互设置默认形状

```tsx
<Button
  title="点击我"
  action={() => {}}
  contentShape="capsule"
/>
```

***

### 仅为辅助功能定义内容形状

```tsx
<Button
  title="可访问按钮"
  action={() => {}}
  contentShape={{
    kind: "accessibility",
    shape: {
      type: "rect",
      cornerRadius: 12
    }
  }}
/>
```

***

### 自定义点击区域为椭圆形

```tsx
<Text
  contentShape={{
    kind: "interaction",
    shape: "ellipse"
  }}
>
  自定义点击区域
</Text>
```

***

## 注意事项

- `contentShape` **不会影响视图的外观**，只影响其**交互行为**；
- 如果使用自定义形状，建议确保其与视图的 `frame` 对齐合理；
- 对于只有图标的按钮或较小区域，设置合适的 `contentShape` 有助于提升点击命中率与可访问性。



---
url: /v2/zh/guide/View Modifiers/contentTransition.md
---

# 内容过渡动画

`contentTransition` 修饰符用于指定当视图 **内容发生变化** 时所应用的动画过渡效果。不同于 `.transition(...)` 这种控制视图出现或消失的动画，`contentTransition` 仅作用于视图内部内容的更新，例如 `Text` 文本变化、`Image` 图标替换等。

适用于需要在数据变化时提供平滑视觉过渡的场景，增强界面响应性和用户体验。

***

## 类型定义

```ts
contentTransition?: ContentTransition
```

***

## 可选值说明（`ContentTransition`）

\| 值 | 说明 |

***

### `"identity"`

- 默认行为，不进行任何动画处理。
- 内容会直接更新，无任何过渡效果。

```tsx
<Text contentTransition="identity">{value}</Text>
```

***

### `"interpolate"`

- 尝试在旧内容与新内容之间进行插值动画。
- 适用于颜色、形状、可插值视图等类型。

```tsx
<Rectangle fill={color} contentTransition="interpolate" />
```

***

### `"opacity"`

- 使用透明度进行过渡：旧内容淡出，新内容淡入。
- 通用型过渡动画，适用于各种视图。

```tsx
<Text contentTransition="opacity">{message}</Text>
```

***

### `"numericText"`

- 专为数字文本（`Text`）设计的过渡动画。
- 适用于数字更新场景，如统计数字或分数显示。

```tsx
<Text contentTransition="numericText">{score}</Text>
```

***

### `"numericTextCountsUp"`

- 适用于 **数字递增** 的动画优化。
- 类似计数器的上升效果。

```tsx
<Text contentTransition="numericTextCountsUp">{level}</Text>
```

***

### `"numericTextCountsDown"`

- 适用于 **数字递减** 的动画优化。
- 常用于倒计时、剩余时间等场景。

```tsx
<Text contentTransition="numericTextCountsDown">{remainingTime}</Text>
```

***

### `"symbolEffect"`

- 针对 SF Symbols 图标（如 `Image(systemName)`）的默认动画。
- 仅对符号图标生效，其他视图不受影响。

```tsx
<Image
  systemName={isOn ? "lightbulb.fill" : "lightbulb"}
  contentTransition="symbolEffect"
/>
```

***

### `"symbolEffectAutomatic"`

- 系统自动选择合适的符号动画方式。
- 常用于上下文自适应的图标切换。

```tsx
<Image
  systemName={icon}
  contentTransition="symbolEffectAutomatic"
/>
```

***

### `"symbolEffectReplace"`

- 以过渡方式替换符号图层。
- 提供比直接替换更平滑的过渡效果。

```tsx
<Image
  systemName={currentSymbol}
  contentTransition="symbolEffectReplace"
/>
```

***

### `"symbolEffectAppear"` / `"symbolEffectDisappear"`

- 控制符号图标的显现或消失动画。
- 通常结合条件渲染（`if`）使用。

```tsx
{isShown
  ? <Image
    systemName="checkmark"
    contentTransition="symbolEffectAppear"
  />
  : null
}
```

***

### `"symbolEffectScale"`

- 内容变化时应用缩放动画。
- 常用于状态切换或强调某个图标时使用。

```tsx
<Image
  systemName={statusIcon}
  contentTransition="symbolEffectScale"
/>
```

***

## 用法总结

| 过渡类型                               | 使用场景              |
| ---------------------------------- | ----------------- |
| `identity`                         | 无动画，直接更新内容        |
| `interpolate`                      | 可插值类型（颜色、形状）之间的过渡 |
| `opacity`                          | 通用型淡入淡出           |
| `numericText`                      | 数字变动过渡            |
| `numericTextCountsUp`              | 数字递增动画（计数器）       |
| `numericTextCountsDown`            | 数字递减动画（倒计时）       |
| `symbolEffect`                     | SF Symbols 图标切换动画 |
| `symbolEffectAutomatic`            | 系统自动选择图标过渡方式      |
| `symbolEffectReplace`              | 符号图层替换过渡          |
| `symbolEffectAppear` / `Disappear` | 控制符号显现或消失动画       |
| `symbolEffectScale`                | 缩放动画，用于状态变更反馈     |

***

## 说明

- 该修饰符不会影响视图的布局或层级，仅作用于“内部内容”的视觉表现。
- 对于 SF Symbols 图标变化，推荐使用符号专属的过渡类型以获得最佳动画效果。



---
url: /v2/zh/guide/View Modifiers/contextMenu.md
---

# 上下文菜单

`contextMenu` 属性用于为任意视图添加系统风格的上下文菜单。在触控设备上通过长按触发，在使用鼠标的设备上则可通过右键点击触发。开发者可以自定义菜单项内容，并可选地添加一个预览视图，与菜单同时显示。

***

## 定义

```ts
contextMenu?: {
  menuItems: VirtualNode
  preview?: VirtualNode
}
```

***

## 字段说明

- **`menuItems`**：定义菜单项内容的 `VirtualNode`。通常包含多个 `Button` 组件，并建议使用 `Group` 元素进行组织，以确保良好的布局与交互。

- **`preview`**（可选）：一个预览视图，类型为 `VirtualNode`。该视图会在上下文菜单旁边展示，用于提供可视化的上下文提示，例如当前操作的对象缩略图或详细信息。

***

## 行为说明

当用户对视图进行长按（触控设备）或右键点击（指针设备）时，系统将展示由 `menuItems` 定义的上下文菜单；如果提供了 `preview` 属性，则在菜单旁边显示对应的预览内容。

***

## 示例

```tsx
function View() {
  return <Text
    contextMenu={{
      menuItems: <Group>
        <Button
          title="添加"
          action={() => {
            // 执行添加操作
          }}
        />
        <Button
          title="删除"
          role="destructive"
          action={() => {
            // 执行删除操作
          }}
        />
      </Group>
    }}
  >
    长按以打开上下文菜单
  </Text>
}
```

上述示例中，`Text` 视图被添加了上下文菜单。在长按该文本时，系统会展示两个操作项：“添加” 和 “删除”，其中“删除”按钮带有破坏性角色样式（`destructive`）。

***

## 注意事项

- 上下文菜单的样式由系统自动管理，符合各平台的界面规范。
- `preview` 字段为可选项，未提供时仅展示菜单项。
- 推荐使用 `Group` 对 `menuItems` 进行结构化组织，以确保良好的交互体验和渲染效果。



---
url: /v2/zh/guide/View Modifiers/controlGroupStyle.md
---

# 控件组样式

通过该属性，你可以为视图中的控件组设置视觉和交互样式，模仿 SwiftUI 的外观和体验。通过定义 `ControlGroupStyle`，可以影响相关控件（如按钮、切换开关或其他可交互元素）如何被分组和呈现给用户。

***

## 概述

在 SwiftUI 中，你可以像这样设置 `controlGroupStyle`：

```swift
ControlGroup {
    Button("操作 1") { ... }
    Button("操作 2") { ... }
}
.controlGroupStyle(.navigation)
```

**在 Scripting（TypeScript/TSX）中**，可以通过 `controlGroupStyle` 属性在包含控件组的视图上实现类似的样式设置：

```tsx
<ControlGroup
  title="文本格式化"
  controlGroupStyle="navigation"
>
  <Button title="加粗" action={() => console.log('加粗按钮被按下')} />
  <Button title="斜体" action={() => console.log('斜体按钮被按下')} />
  <Button title="下划线" action={() => console.log('下划线按钮被按下')} />
</ControlGroup>
```

***

## 可用样式

你可以将以下字符串值分配给 `controlGroupStyle`，以定义控件组的显示方式：

- **`automatic`**：让系统根据上下文决定合适的样式。
- **`compactMenu`**：将控件以紧凑菜单的形式展示，点击后展开，或者作为嵌套菜单的一部分。
- **`menu`**：将控件以菜单形式显示，按下时呈现为一个菜单或嵌套子菜单。
- **`navigation`**：将控件样式化以适应导航上下文，通常与平台特定的导航样式一致。
- **`palette`**：以调色板式分组显示控件，通常同时显示多个操作选项。

***

## 使用示例

### 设置 `controlGroupStyle` 为菜单样式

```tsx
<ControlGroup
  controlGroupStyle="menu"
>
  {/* 在此添加你的控件内容 */}
</ControlGroup>
```

在此示例中，控件组将以菜单形式显示。点击或与该组交互时，会以菜单界面呈现项目。

***

### 使用调色板样式

```tsx
<ControlGroup
  title="文本格式化"
  controlGroupStyle="palette"
>
  <Button title="加粗" action={() => console.log('加粗按钮被按下')} />
  <Button title="斜体" action={() => console.log('斜体按钮被按下')} />
  <Button title="下划线" action={() => console.log('下划线按钮被按下')} />
</ControlGroup>
```

在此示例中，控件会以调色板样式显示，多个样式选项可以同时展示，方便用户快速选择。

***

### 自动样式

如果不确定哪种样式最佳，或者希望让系统选择合适的样式，可以使用 `automatic`：

```tsx
<ControlGroup
  title="媒体控制"
  controlGroupStyle="automatic"
>
  <Button title="操作 A" action={() => console.log('操作 A')} />
  <Button title="操作 B" action={() => console.log('操作 B')} />
</ControlGroup>
```

在此示例中，系统会根据上下文自动选择适合的控件组样式。

***

## 小结

通过设置 `controlGroupStyle`，你可以决定控件组的显示和交互方式。无论是选择 `menu`、`compactMenu`、`navigation`、`palette`，还是依赖系统默认的 `automatic` 样式，该属性都能帮助你的脚本控件自然地融入平台的 UI 规范和用户期望。



---
url: /v2/zh/guide/View Modifiers/datePickerStyle.md
---

# 日期选择器样式

该属性用于自定义 `DatePicker` 视图在 UI 中的外观和交互方式。

***

## 属性声明

```tsx
DatePickerStyle = "automatic" | "compact" | "graphical" | "wheel" | "field" | "stepperField"
DatePickerComponents = "hourAndMinute" | "date" | "hourMinuteAndSecond"
```

***

## `DatePickerStyle` 值

`DatePickerStyle` 属性接受以下字符串值，用于定义日期选择器的外观和交互方式：

- **`automatic`**: 日期选择器的默认样式。
- **`compact`**: 将日期选择器组件以紧凑的文本格式显示。
- **`graphical`**: 将日期选择器显示为交互式日历或时钟。
- **`wheel`**: 将日期选择器组件显示为可滚动的轮状列。
- **`field`** _(仅 macOS)_: 将组件显示为可编辑的字段。
- **`stepperField`** _(仅 macOS)_: 将组件显示为带有递增/递减控件的可编辑字段。

***

## `DatePickerComponents` 值

`displayedComponents` 属性指定日期选择器显示和可编辑的日期组件。可接受的值包括：

- **`date`**: 显示基于本地化的日、月、年。
- **`hourAndMinute`**: 显示基于本地化的小时和分钟。
- **`hourMinuteAndSecond`** _(仅 watchOS)_: 显示基于本地化的小时、分钟和秒。

***

## 使用示例

### 示例 1: 图形化日期选择器

```tsx
function View() {
  const [date, setDate] = useState(Date.now())

  return <DatePicker
    title="选择日期"
    value={date}
    onChanged={setDate}
    startDate={Date.now() - 31556926000} // 1 年前
    endDate={Date.now() + 31556926000}  // 1 年后
    displayedComponents={["date"]}
    datePickerStyle="graphical"
  />
}
```

此示例创建了一个用于选择日期的图形化日期选择器。

***

### 示例 2: 紧凑型时间选择器

```tsx
function View() {
  const [time, setTime] = useState(Date.now())
  return <DatePicker
    title="选择时间"
    value={time}
    onChanged={setTime}
    displayedComponents={["hourAndMinute"]}
    datePickerStyle="compact"
  />
}
```

此示例创建了一个紧凑型日期选择器，用于选择小时和分钟。

***

### 示例 3: 滚轮日期选择器

```tsx
function View() {
  const [date, setDate] = useState(Date.now())
  return <DatePicker
    title="选择日期和时间"
    value={date}
    onChanged={setDate}
    displayedComponents={["hourAndMinute", "date"]}
    datePickerStyle="wheel"
  />
}
```

此示例创建了一个带滚轮的日期选择器，用于选择日期和时间。

***

## 注意事项

- `DatePickerStyle` 属性直接映射到 SwiftUI 的 `datePickerStyle` 修饰符。
- 确保 `displayedComponents` 和 `datePickerStyle` 的值与目标平台兼容，以避免运行时错误。
- 对于 macOS 特定的样式（`field` 和 `stepperField`），请确保应用在 macOS 上运行。

通过使用 `DatePickerStyle`，可以创建多功能的日期选择器，满足应用设计和功能需求。



---
url: /v2/zh/guide/View Modifiers/disabled.md
---

# 禁用

禁用当前视图及其子视图的用户交互行为，视觉上通常为半透明状态。

## 类型

```ts
disabled?: boolean
```

## 示例

```tsx
<Button
 title="提交" 
 disabled={submitDisabled}
 action={submit}
/>
```



---
url: /v2/zh/guide/View Modifiers/fixedSize.md
---

# 固定大小

将视图固定在其理想大小，防止其被压缩或扩展超出其内容本身所需的尺寸。

## 类型

```ts
fixedSize?: boolean | {
  horizontal: boolean
  vertical: boolean
}
```

## 概述

`fixedSize` 修饰符会告诉布局系统使用视图的“理想尺寸”进行布局，而不是根据父视图的限制拉伸或压缩视图。这在你希望文本不被截断、内容完整显示时非常有用，或者在你希望视图不随父容器大小变化而自动调整尺寸时使用。

该行为与 SwiftUI 中的 [`fixedSize()`](https://developer.apple.com/documentation/swiftui/view/fixedsize%28%29) 一致。

## 使用方式

你可以通过两种方式设置 `fixedSize`：

### 1. 布尔值形式

```tsx
<Text fixedSize>
  这段文字不会被压缩或截断。
</Text>
```

等价于：

```tsx
<Text fixedSize={{ horizontal: true, vertical: true }}>
  这段文字不会被压缩或截断。
</Text>
```

### 2. 对象形式

通过对象形式可以分别控制水平和垂直方向是否固定：

```tsx
<Text fixedSize={{ horizontal: true, vertical: false }}>
  水平方向不压缩，垂直方向仍可适应内容。
</Text>
```

## 行为说明

- `horizontal: true`：视图水平方向保持其理想宽度，不会被压缩或拉伸，常用于防止文字被截断。
- `vertical: true`：视图垂直方向保持理想高度，不会被压缩或拉伸。
- 两个方向都为 `false` 时，该修饰符不生效。
- 父容器在布局时如果给定了较小的空间，设置了 `fixedSize` 的视图将优先保持其理想尺寸，可能导致内容溢出。

## 示例

```tsx
<VStack>
  <Text fixedSize>
    一段较长的文字，不应被截断，应完整显示。
  </Text>
  <Text fixedSize={{ horizontal: true, vertical: false }}>
    这段文字保持水平方向的尺寸，但可以在垂直方向自动换行或扩展。
  </Text>
</VStack>
```

## 注意事项

- 常用于防止 `Text` 视图在父容器中被截断。
- 与 `HStack`、`VStack` 等布局组件结合时，可以更精确地控制某个子视图不随整体布局缩放。
- 使用该修饰符时，应考虑可能出现的内容溢出或布局冲突问题。



---
url: /v2/zh/guide/View Modifiers/flipsForRightToLeftLayoutDirection.md
---

# flipsForRightToLeftLayoutDirection

设置当系统使用从右到左（Right-to-Left, RTL）布局方向时，当前视图是否应水平镜像其内容。

## 类型

`flipsForRightToLeftLayoutDirection?: boolean`

## 描述

当设为 `true` 时，视图会在 RTL 布局环境下水平翻转其内容，以符合阿拉伯语、希伯来语等从右到左语言的阅读方向。这在需要手动控制视图镜像行为的自定义组件中尤为有用。

若设为 `false`，则视图无论当前系统布局方向如何，都会保持从左到右的默认布局。

## 默认值

`false`（默认不会自动翻转视图）

## 示例

```tsx
<Image
  filePath="path/to/icon.png"
  flipsForRightToLeftLayoutDirection={true}
/>
```

在上述示例中，当界面处于 RTL 布局时，图像会自动进行水平翻转。



---
url: /v2/zh/guide/View Modifiers/foregroundStyle & background.md
---

# 前景色和背景样式

`foregroundStyle` 和 `background` 是用于设置视图前景与背景视觉效果的两个常用属性，支持颜色、渐变、系统材质，以及深浅模式自动切换等丰富的样式能力。

***

## `foregroundStyle`

### 定义

```ts
foregroundStyle?: ShapeStyle | DynamicShapeStyle | {
  primary: ShapeStyle | DynamicShapeStyle
  secondary: ShapeStyle | DynamicShapeStyle
  tertiary?: ShapeStyle | DynamicShapeStyle
}
```

用于设置视图前景的样式，如文字、图形或符号的颜色。支持单一样式或三层样式（primary、secondary、tertiary），可用于 SF Symbols 或富文本等需要多层渲染的内容。

### 示例

#### 基础颜色前景

```tsx
<Text foregroundStyle="white">
  Hello World!
</Text>
```

#### 动态前景色（根据深浅模式切换）

```tsx
<Text
  foregroundStyle={{
    light: "black",
    dark: "white"
  }}
>
  自适应文本
</Text>
```

#### 多层前景样式

```tsx
<Text
  foregroundStyle={{
    primary: "red",
    secondary: "orange",
    tertiary: "yellow"
  }}
>
  多层样式
</Text>
```

> 多层样式常用于 SF Symbols 或支持图层渲染的系统图标。

***

## `background`

### 定义

```ts
background?: 
  | ShapeStyle 
  | DynamicShapeStyle 
  | { style: ShapeStyle | DynamicShapeStyle, shape: Shape }
  | VirtualNode 
  | { content: VirtualNode, alignment: Alignment }
```

设置视图的背景。支持使用颜色、渐变、材质等样式，也可以自定义形状或组件作为背景，甚至指定对齐方式。

### 支持格式说明

1. **`ShapeStyle`**：颜色、渐变或材质等。
2. **`DynamicShapeStyle`**：根据系统深浅模式切换样式。
3. **`shape + style`**：将样式应用于指定形状，如圆角矩形。
4. **`VirtualNode`**：使用另一个组件作为背景。
5. **`content + alignment`**：设置背景内容并指定对齐方式。

### 示例

#### 纯色背景

```tsx
<Text background="systemBlue">
  Hello
</Text>
```

#### 渐变背景

```tsx
<Text
  background={{
    gradient: [
      { color: "purple", location: 0 },
      { color: "blue", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  }}
>
  渐变背景
</Text>
```

#### 动态背景（根据系统模式自动切换）

```tsx
<Text
  background={{
    light: "white",
    dark: "black"
  }}
>
  模式自适应背景
</Text>
```

#### 使用形状作为背景

```tsx
<Text
  background={
    <RoundedRectangle fill="systemBlue" />
  }
>
  Hello World!
</Text>
```

#### 自定义背景内容与对齐方式

```tsx
<Text
  background={{
    content: <Image filePath="path/to/background.jpg" />,
    alignment: "center"
  }}
>
  覆盖文字
</Text>
```

***

## 相关类型说明

- **`ShapeStyle`**
  定义颜色、渐变或材质的样式，可使用字符串颜色（如 `"red"`、`"#FF0000"`）、渐变对象、系统材质等。

- **`DynamicShapeStyle`**
  根据浅色或深色模式分别定义不同的样式，系统自动切换。

- **`VirtualNode`**
  表示一个视图组件，例如 `<Image />`、`<RoundedRectangle />` 等 JSX 元素。

- **`Shape`**
  用于设置背景形状，如 `RoundedRectangle`、`Circle`、`Capsule` 等。

***

## 小结

| 属性名称              | 功能描述          | 支持的类型说明                                       |
| ----------------- | ------------- | --------------------------------------------- |
| `foregroundStyle` | 设置前景样式（如文字颜色） | `ShapeStyle`、`DynamicShapeStyle` 或三层样式对象      |
| `background`      | 设置背景内容        | `ShapeStyle`、`DynamicShapeStyle`、形状样式、组件或对齐配置 |

通过灵活使用 `foregroundStyle` 与 `background`，你可以快速构建出具有丰富视觉表现力且适应系统样式的 UI 界面。



---
url: /v2/zh/guide/View Modifiers/formStyle.md
---

# 表单样式

通过设置 `FormStyle`，你可以定义表单内容的视觉排列方式和呈现方式，从而提供更清晰、更直观的用户体验。

***

## 概述

一个 `Form` 视图可以包含多种控件（如文本框、切换开关、选择器等），以行的形式排列。`FormStyle` 决定了这些行的显示方式——是标签和值分列对齐，还是控件以视觉上分组的形式显示。

***

## 可用样式

- **`automatic`**：\
  让系统根据上下文选择最适合的样式。这通常是一个不错的默认选择，适合没有特定布局需求的场景。

- **`columns`**：\
  显示一个不可滚动的表单，标签在左侧的列中右对齐，对应的值或控件在右侧的列中左对齐。这种样式非常适合需要清晰查看标签-值对的场景。

- **`grouped`**：\
  将表单组织成视觉上分组的部分。每行通常是左对齐的标签和右对齐的控件。这种样式有助于将相关的输入字段划分为不同的类别，适合较长或复杂的表单，方便用户导航。

***

## 使用示例

### **列样式 (Columns Style)**

```tsx
<Form formStyle="columns">
  <TextField
    title="名字"
    value={firstName} 
    onChanged={setFirstName}
  />
  <TextField 
    title="姓氏" 
    value={lastName} 
    onChanged={setLastName} 
  />
  <Toggle 
    title="订阅" 
    value={subscribe} 
    onChanged={setSubscribe} 
  />
</Form>
```

在此布局中，标签（如“名字”、“姓氏”、“订阅”）整齐地排列在一列中，输入字段或切换开关与其对应对齐。

***

### **分组样式 (Grouped Style)**

```tsx
<Form formStyle="grouped">
  <Section 
    header={
      <Text>个人信息</Text>
    }>
    <TextField 
      title="电子邮件" 
      value={email} 
      onChanged={setEmail} 
    />
    <TextField 
      title="电话" 
      value={phone} 
      onChanged={setPhone} 
    />
  </Section>
  <Section 
    header={
      <Text>设置</Text>
    }>
    <Toggle 
      title="启用通知" 
      value={notificationsEnabled} 
      onChanged={setNotificationsEnabled} 
    />
    <Toggle 
      title="自动更新" 
      value={autoUpdate} 
      onChanged={setAutoUpdate} 
    />
  </Section>
</Form>
```

在此示例中，输入字段被分组为“个人信息”和“设置”两部分。每个部分的行都呈现为清晰的标签和控件对，帮助用户理解输入字段的逻辑分组。

***

### **自动样式 (Automatic Style)**

```tsx
<Form formStyle="automatic">
  <TextField 
    title="用户名" 
    value={username} 
    onChanged={setUsername} 
  />
  <SecureField 
    title="密码" 
    value={password} 
    onChanged={setPassword} 
  />
</Form>
```

使用 `automatic` 样式时，系统会选择默认样式。此选项适合简单表单或希望让系统根据不同上下文或平台自动调整样式的场景。

***

## 总结

- 选择 **`columns`** 用于结构化的两列布局，便于快速扫描标签和值。
- 选择 **`grouped`** 用于将控件分组成视觉上独立的部分，适合更复杂的表单。
- 选择 **`automatic`** 让系统自动处理布局决策，适合简单或需要适应多平台的界面。

通过在 `Form` 上设置 `formStyle`，你可以根据表单的复杂性和用户需求微调其显示方式，提供最佳的用户体验。



---
url: /v2/zh/guide/View Modifiers/frame.md
---

# frame

`frame` 属性用于设置视图的尺寸（固定或弹性）以及在容器中的对齐方式。支持两种不同的配置格式：

***

### 1. 固定尺寸格式

```ts
frame?: {
  width?: number
  height?: number
  alignment?: Alignment
}
```

用于指定固定的宽度和高度，并设置在该区域内的对齐方式。

#### 示例

```tsx
<VStack
  frame={{
    width: 100,
    height: 100,
    alignment: 'center'
  }}
>
  <Text>固定尺寸</Text>
</VStack>
```

***

### 2. 弹性尺寸格式

```ts
frame?: {
  alignment?: Alignment
  minWidth?: number
  minHeight?: number
  maxWidth?: number | 'infinity'
  maxHeight?: number | 'infinity'
  idealWidth?: number | 'infinity'
  idealHeight?: number | 'infinity'
}
```

用于设置最小、最大和理想尺寸。数值可以为具体数值或字符串 `'infinity'`，表示尽可能占满可用空间。

#### 示例

```tsx
<HStack
  frame={{
    minWidth: 100,
    maxWidth: 'infinity',
    minHeight: 50,
    idealHeight: 100,
    alignment: 'leading'
  }}
>
  <Text>可扩展宽度</Text>
</HStack>
```

***

## 对齐方式（Alignment）

`alignment` 决定视图在其 frame 内的布局位置。支持的值包括：

- `'center'`（居中）
- `'top'`（顶部对齐）
- `'bottom'`（底部对齐）
- `'leading'`（前导边对齐，LTR 中为左）
- `'trailing'`（尾部边对齐，LTR 中为右）
- `'topLeading'`（左上角）
- `'topTrailing'`（右上角）
- `'bottomLeading'`（左下角）
- `'bottomTrailing'`（右下角）

> **注意**：仅当 frame 的尺寸大于内容视图的自然尺寸时，对齐方式才会起作用。

#### 示例

```tsx
<Text
  frame={{
    width: 200,
    height: 100,
    alignment: 'bottomTrailing'
  }}
>
  对齐文本
</Text>
```

***

## 使用建议

- 如果需要精确控制尺寸，建议使用固定格式的 `width` 和 `height`。
- 如果希望布局适应不同屏幕或内容，推荐使用弹性尺寸的 `min` / `max` / `ideal` 格式。
- 请勿在同一个 `frame` 对象中混合使用 `width` / `height` 与 `minWidth` / `maxWidth` 等，以避免冲突。

***

## 总结

`frame` 属性是布局控制的基础工具，可用于设定视图尺寸和定位方式。借助 `CommonViewProps`，你可以灵活地构建适配性强、结构清晰的界面布局。



---
url: /v2/zh/guide/View Modifiers/gaugeStyle.md
---

# 仪表盘样式

通过设置 `GaugeStyle`，你可以定义仪表（Gauge）的视觉表示方式，从而控制其外观是否显示为环形、条形或通过标记指示当前值。一些样式仅适用于特定平台（如 watchOS），其他样式则具有更广泛的适用性。

***

## 概述

`Gauge` 组件用来以视觉方式表示指定范围内的值。例如，你可以用它显示电池电量、下载进度或温度读数。通过结合 `Gauge` 和指定的 `GaugeStyle`，你可以调整仪表的外观，以匹配应用的设计语言或功能需求。

**关键点：**

- 根据数据的性质选择合适的样式——环形适用于圆形上下文，条形适用于线性上下文。
- 有些样式使用标记指示当前值；其他样式使用填充段表示部分容量。
- 某些样式仅适用于 watchOS，具体见下文说明。

***

## 可用样式

- **`automatic`**：\
  使用系统为当前平台和上下文选择的默认样式。如果你没有特定偏好，这是一个很好的起点。

- **`accessoryCircular`**：\
  显示一个开口的环形，标记指针沿环的圆周指向当前值。适用于以紧凑圆形表示水平或百分比的场景。

- **`accessoryCircularCapacity`**：\
  类似于 `accessoryCircular`，但显示一个闭合的部分环形，填充到当前值。这种样式非常适合显示容量级别，例如存储使用情况。

- **`circular`** _(仅适用于 watchOS)_：\
  类似于 `accessoryCircular`，显示一个带标记指针的开口环形。适合用于 watchOS 的复杂功能或类似小型设备显示。

- **`linearCapacity`**：\
  显示一个水平条，从左侧填充到右侧，表示值的增长。非常适合用作进度条、电池电量或内存使用指示器。

- **`accessoryLinear`**：\
  一个线性仪表，通过条形上的标记指示当前值，而不是填充段。

- **`accessoryLinearCapacity`**：\
  结合了 `linearCapacity` 和 `accessoryLinear` 样式，显示一个随值增长的填充条段，非常适合显示容量或整体进度。

- **`linear`** _(仅适用于 watchOS)_：\
  类似于 `accessoryLinear`，但专为 watchOS 提供。通过条形上的标记指示当前值。

***

## 使用示例

### 环形容量仪表

```tsx
<Gauge
  value={0.7}
  min={0}
  max={1}
  label={<Text>电池</Text>}
  currentValueLabel={<Text>70%</Text>}
  minValueLabel={<Text>0%</Text>}
  maxValueLabel={<Text>100%</Text>}
  gaugeStyle="accessoryCircularCapacity"
/>
```

此示例展示了一个部分填充的环形仪表，表示电池电量为 70%。

***

### 线性容量样式

```tsx
<Gauge
  value={0.7}
  min={0}
  max={1}
  label={<Text>下载进度</Text>}
  currentValueLabel={<Text>70%</Text>}
  gaugeStyle="linearCapacity"
/>
```

此示例展示了一个从左到右填充 70% 的水平条形进度仪表。

***

### 标记样式仪表

```tsx
<Gauge
  value={0.7}
  min={0}
  max={1}
  label={<Text>温度</Text>}
  currentValueLabel={<Text>温暖</Text>}
  gaugeStyle="accessoryCircular"
/>
```

此示例使用标记样式显示一个开口环形，标记指针指向当前值（70%），而不是显示填充段。

***

## 适用场景

- **`circular` 和 `accessoryCircular` 样式：**\
  适用于直观表示圆形数据的场景，例如计时器、速度表或以环形显示容量的情况。

- **`linear` 和 `accessoryLinear` 样式：**\
  最适合用于线性数据的场景，如进度条、完成百分比或从左到右读取的水平值。

- **`Capacity` 样式：**\
  适用于需要通过填充段表示“已满”或“已完成”状态的场景，例如电池电量、存储空间使用情况或加载进度。

- **`automatic`：**\
  让系统根据上下文选择样式，适合用作默认选择。

***

## 总结

通过为 `Gauge` 设置 `gaugeStyle`，你可以完全控制数据的视觉表示方式。无论是环形仪表、线性条形、简单标记还是填充容量指示器，`GaugeStyle` 提供了灵活的选项，让信息的呈现既直观又美观，满足不同的设计需求和功能要求。



---
url: /v2/zh/guide/View Modifiers/hidden.md
---

# 隐藏

若为 `true`，视图不可见且无法交互，但仍保留在视图层级中并参与布局。

### 类型

```ts
hidden?: boolean
```

### 示例

```tsx
<Text hidden={true}>这段文字被隐藏</Text>
```



---
url: /v2/zh/guide/View Modifiers/labelsHidden.md
---

# 隐藏标签

隐藏视图内控件（如 `Picker`, `DatePicker`）的标签部分，但控件本身仍然显示。

## 类型

```ts
labelsHidden?: boolean
```

## 示例

```tsx
<Picker
  title="Picker"
  labelsHidden={true}
  value={value}
  onChanged={onChanged}
>
  <Text tag={0}>Option 1</Text>
  <Text tag={1}>Option 2</Text>
</Picker>
```



---
url: /v2/zh/guide/View Modifiers/layoutPriority.md
---

# 布局优先级

`layoutPriority` 用于控制父级布局在空间不足或需要分配空间时，优先给予哪些子视图更多空间。

在同一个父视图下，如果多个子视图竞争空间，设置了较高 `layoutPriority` 的视图将被优先分配更多空间，而较低或未设置的则可能被压缩或裁剪。

## 参数说明

- `layoutPriority`（可选）
  一个数字，表示该视图的布局优先级。
  数值越大，优先级越高。默认值为 `0`。支持小数值。

## 使用场景示例

假设你有一组水平排列的文本视图，在空间受限时希望某些内容尽量显示完整，而其他内容可以被压缩：

```tsx
<HStack>
  <Text layoutPriority={1}>标题</Text>
  <Text>副标题（可压缩）</Text>
</HStack>
```

在这个示例中，`"标题"` 的视图被设置了较高的布局优先级，因此在空间不足时 `"副标题"` 会优先被压缩，而 `"标题"` 会尽可能完整显示。

## 注意事项

- `layoutPriority` 仅在其父视图需要对多个子视图进行空间分配时生效。
- 若所有子视图都具有相同的优先级，系统将均衡分配空间。
- 适用于 `HStack`, `VStack`, `ZStack` 等可组合视图布局中存在内容冲突或布局紧缩的场景。

***

如需控制内容在受限空间下的显示优先顺序，`layoutPriority` 是非常有效的布局控制工具。通过合理设置优先级，可以提升界面的适应性与可读性。



---
url: /v2/zh/guide/View Modifiers/listStyle.md
---

# 列表样式

通过该属性，你可以自定义 `List` 视图在 UI 中的行为和外观。

***

## 属性声明

```tsx
listStyle?: ListStyle;
```

### 描述

`listStyle` 属性定义了列表的视觉样式，允许你从多种预定义样式中选择合适的样式。

***

### 可接受的值

`listStyle` 属性接受以下字符串值：

- **`automatic`**：使用平台的默认列表行为和外观。
- **`bordered`**：以标准边框显示列表。
- **`carousel`**：将列表设置为类似于旋转木马的外观。
- **`elliptical`**：为列表提供椭圆形的样式。
- **`grouped`**：以分组格式显示列表。
- **`inset`**：为列表应用内嵌外观。
- **`insetGroup`**：结合内嵌和分组样式。
- **`plain`**：以简单样式显示列表，不添加额外的装饰。
- **`sidebar`**：将列表呈现为类似侧边栏的外观。

***

### 默认行为

如果未指定 `listStyle`，系统会根据平台选择默认样式。

***

## 使用示例

以下展示了如何在 TypeScript 代码中应用 `listStyle` 属性：

### 示例 1：简单列表样式 (Plain Style)

```tsx
<List
  listStyle="plain"
>
  <Text>项目 1</Text>
  <Text>项目 2</Text>
  <Text>项目 3</Text>
</List>
```

此示例创建了一个简单样式的列表。

***

### 示例 2：分组列表样式 (Grouped Style)

```tsx
<List
  listStyle="grouped"
>
  <Section header={
    <Text>水果</Text>
  }>
    <Text>苹果</Text>
    <Text>香蕉</Text>
  </Section>
  <Section header={
    <Text>蔬菜</Text>
  }>
    <Text>胡萝卜</Text>
    <Text>西兰花</Text>
  </Section>
</List>
```

此示例创建了一个分组样式的列表，每个分组有一个标题。

***

### 示例 3：侧边栏列表样式 (Sidebar Style)

```tsx
<List
  listStyle="sidebar"
>
  <Text>主页</Text>
  <Text>设置</Text>
  <Text>个人资料</Text>
</List>
```

此示例创建了一个类似于侧边栏的列表。

***

## 注意事项

- `listStyle` 属性直接映射到 SwiftUI 的 `listStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过选择合适的 `listStyle`，你可以根据设计需求调整列表的外观，从而为用户提供更符合场景的视觉体验。



---
url: /v2/zh/guide/View Modifiers/mask.md
---

# 遮罩

`mask` 修饰符使用另一个视图的 **透明度（alpha 通道）** 作为遮罩，将目标视图按形状进行裁剪。遮罩中不透明的区域会显示目标视图，透明区域则被隐藏。

该修饰符常用于图像裁剪、聚光灯效果、遮挡与图形渐显等视觉表现中。

***

## 类型定义

```ts
mask?: VirtualNode | {
  alignment: Alignment
  content: VirtualNode
}
```

***

## 使用方式

## 1. 简洁形式（默认居中遮罩）

直接传入一个视图作为遮罩，系统默认使用居中对齐。

```tsx
<Image
  filePath="path/to/photo.png"
  frame={{ width: 100, height: 100 }}
  mask={<Circle />}
/>
```

上例中，图像将被裁剪成一个圆形，仅圆形区域可见，其他部分被遮罩隐藏。

***

## 2. 对象形式（带对齐方式）

如果需要控制遮罩的位置，可使用对象形式指定对齐方式。

### 对象结构：

```ts
{
  alignment: Alignment
  content: VirtualNode
}
```

### 可选对齐方式（`Alignment`）：

- `"top"` | `"bottom"` | `"leading"` | `"trailing"`
- `"topLeading"` | `"topTrailing"` | `"bottomLeading"` | `"bottomTrailing"`
- `"center"`

### 示例：顶部对齐的矩形遮罩

```tsx
<Rectangle
  fill="blue"
  frame={{ width: 100, height: 100 }}
  mask={{
    alignment: "top",
    content: <Rectangle frame={{ width: 100, height: 50 }} />
  }}
/>
```

上述示例中，蓝色矩形的顶部一半区域可见，底部部分被遮罩隐藏。

***

## 行为说明

- 遮罩视图的 **透明度** 决定了显示区域：

  - 完全不透明（alpha = 1）区域将显示原始内容；
  - 完全透明（alpha = 0）区域将被遮挡。
- 遮罩不会影响布局，仅影响视图渲染效果；
- 为了确保遮罩尺寸与对齐正确，建议对遮罩和目标视图都设置 `frame={{ width, height }}`。

***

## 常见用途

- 图像裁剪（如圆形头像）
- 创建局部显示或聚焦效果
- 与动画结合实现遮罩揭示
- 仅显示特定形状区域内容

***

## 总结

| 字段                  | 说明                |
| ------------------- | ----------------- |
| `mask`（VirtualNode） | 遮罩视图，默认居中叠加在当前视图上 |
| `alignment`         | 可选，控制遮罩相对于当前视图的位置 |
| `content`           | 遮罩内容视图，用于控制可见区域   |



---
url: /v2/zh/guide/View Modifiers/matchedGeometryEffect.md
---

# 匹配几何效果（matchedGeometryEffect）

`matchedGeometryEffect` 用于在 **不同视图之间建立几何关联关系**，使视图在：

- 位置变化
- 尺寸变化
- 布局层级变化
- 条件渲染切换

这些场景中，仍然保持 **连续、平滑、空间一致的动画过渡效果**。

该能力对应 SwiftUI 中的 `matchedGeometryEffect`，属于 **组件级几何联动动画系统**，不依赖导航系统。

***

## 一、API 定义

```ts
matchedGeometryEffect?: {
  id: string | number
  namespace: NamespaceID
  properties?: MatchedGeometryProperties
  anchor?: Point | KeywordPoint
  isSource?: boolean
}
```

```ts
type MatchedGeometryProperties = "frame" | "position" | "size"
```

***

## 二、核心作用

`matchedGeometryEffect` 的核心作用是：

> 让两个“逻辑上是同一个元素”的视图，在 **不同布局结构中共享几何信息**，从而产生连续的过渡动画。

它解决的问题包括：

- 视图从一个容器移动到另一个容器时的“跳变”
- 视图尺寸变化时的“突变”
- 列表项展开为详情页时的“断层感”
- Tab 切换指示器的“瞬移感”

***

## 三、参数详解

### 1. id（几何匹配唯一标识）

```ts
id: string | number
```

- 用于标识这是 **哪一个几何元素**
- 在同一个 `namespace` 下：

  - **id 相同的视图才会参与几何匹配**
- 通常来自：

  - 数据模型 ID
  - 索引值
  - 业务唯一标识

规则：

- id 必须稳定
- 动画期间不能频繁变化
- 同一时刻：

  - 一个 id 只能有一个 `isSource = true`

***

### 2. namespace（几何命名空间）

```ts
namespace: NamespaceID
```

- 用于将多个匹配动画分组隔离
- 不同 namespace 之间：

  - 即使 id 相同，也不会产生动画
- 必须由 `NamespaceReader` 创建并注入

规则：

- source 与 target 必须使用 **同一个 namespace**
- 不允许跨 namespace 匹配

***

### 3. properties（参与匹配的几何属性）

```ts
properties?: "frame" | "position" | "size"
```

默认值：

```ts
properties = "frame"
```

含义说明：

| 值            | 含义          |
| ------------ | ----------- |
| `"frame"`    | 同时匹配位置 + 尺寸 |
| `"position"` | 仅匹配中心点位置    |
| `"size"`     | 仅匹配尺寸，不匹配位置 |

选择原则：

- `"frame"`：最完整、最自然的动画
- `"position"`：指示器、滑块、选中背景
- `"size"`：放大缩小、展开收起

***

### 4. anchor（锚点）

```ts
anchor?: Point | KeywordPoint
```

默认值：

```ts
anchor = "center"
```

作用：

- 决定动画进行时：

  - 元素是从哪个相对位置进行对齐和计算的

常见取值：

- `"center"`
- `"topLeading"`
- `"topTrailing"`
- `"bottomLeading"`
- `"bottomTrailing"`

使用场景：

- 卡片从左上角展开
- 头像从右上角放大
- 底部元素向上弹出

***

### 5. isSource（是否作为几何数据的“源”）

```ts
isSource?: boolean
```

默认值：

```ts
isSource = true
```

含义说明：

| 值       | 行为             |
| ------- | -------------- |
| `true`  | 当前视图向外“提供”几何数据 |
| `false` | 当前视图“接收”几何动画结果 |

标准使用模式：

- 原始视图：`isSource = true`
- 目标视图：`isSource = false`

如果省略：

- 第一个出现的视图默认作为 source
- 其余作为接收方

***

## 四、最小可用示例（位置 + 尺寸联动）

该示例演示：
一个圆形在两个区域之间切换位置与尺寸，并保持连续动画。

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <VStack spacing={40}>
      <Button
        title="Toggle"
        action={() => {
          expanded.setValue( !expanded.value)
        }}
      />

      <ZStack
        frame={{ width: 300, height: 200 }}
        background="systemGray6"
      >
        {!expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 60, height: 60 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace
            }}
          />
        )}
      </ZStack>

      <ZStack
        frame={{ width: 300, height: 300 }}
        background="systemGray4"
      >
        {expanded.value && (
          <Circle
            fill="systemOrange"
            frame={{ width: 150, height: 150 }}
            matchedGeometryEffect={{
              id: "circle",
              namespace,
              isSource: false
            }}
          />
        )}
      </ZStack>
    </VStack>
  )}
</NamespaceReader>
```

该示例实现的动画效果：

- 同一个圆：

  - 从上方小尺寸区域
  - 平滑移动并放大到下方大区域
- 无跳变、无突变、无瞬移

***

## 五、仅同步“位置”的示例（指示器动画）

```tsx
const selected = useObservable(0)

return <NamespaceReader>
  {namespace => (
    <HStack spacing={24}>
      <Text
        onTapGesture={() => selected.setValue(0)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 0
        }}
      >
        Tab 1
      </Text>

      <Text
        onTapGesture={() => selected.setValue(1)}
        matchedGeometryEffect={{
          id: "indicator",
          namespace,
          properties: "position",
          isSource: selected.value === 1
        }}
      >
        Tab 2
      </Text>
    </HStack>
  )}
</NamespaceReader>
```

适用于：

- Tab 选中动画
- 滑块指示器
- 选中背景平移

***

## 六、仅同步“尺寸”的示例（放大缩小）

```tsx
const expanded = useObservable(false)

return <NamespaceReader>
  {namespace => (
    <ZStack>
      <Circle
        fill="systemBlue"
        frame={{
          width: expanded.value ? 200 : 80,
          height: expanded.value ? 200 : 80
        }}
        matchedGeometryEffect={{
          id: "avatar",
          namespace,
          properties: "size"
        }}
        onTapGesture={() => {
          expanded.setValue(!expanded.value)
        }}
      />
    </ZStack>
  )}
</NamespaceReader>
```

适用于：

- 头像放大
- 卡片展开
- 按钮按压动画

***

## 七、多元素联动示例（卡片 → 详情）

```tsx
<NamespaceReader>
  {namespace => (
    <ZStack>
      {!showDetail.value && (
        <VStack spacing={16}>
          <Image
            source="cover"
            matchedGeometryEffect={{
              id: "card.image",
              namespace
            }}
          />
          <Text
            matchedGeometryEffect={{
              id: "card.title",
              namespace
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}

      {showDetail.value && (
        <VStack spacing={24}>
          <Image
            source="cover"
            frame={{ width: 300, height: 200 }}
            matchedGeometryEffect={{
              id: "card.image",
              namespace,
              isSource: false
            }}
          />
          <Text
            font="largeTitle"
            matchedGeometryEffect={{
              id: "card.title",
              namespace,
              isSource: false
            }}
          >
            Card Title
          </Text>
        </VStack>
      )}
    </ZStack>
  )}
</NamespaceReader>
```

效果说明：

- 图片与标题同时参与几何匹配
- 从卡片形态平滑过渡为详情页布局
- 无需使用导航动画

***

## 八、关键使用规则总结

1. **namespace 必须完全相同**
2. **id 必须完全一致**
3. 同一时刻：

   - 一个 id 只能有一个 `isSource = true`
4. 默认行为：

   ```ts
   properties = "frame"
   anchor = "center"
   isSource = true
   ```
5. source 与 target 必须：

   - 同一渲染周期内完成切换
6. 如果 source 和 target：

   - 同时存在，且都为 `isSource = true`
     → 动画不确定，可能失效
7. Widget 与 Live Activity 环境不支持完整 matchedGeometry 动画能力

***

## 九、适用场景总结

适合使用 `matchedGeometryEffect` 的场景：

- Tab 指示器动画
- 卡片 → 详情展开
- 图片放大预览
- 列表项选中动画
- 分栏布局中的选中项切换

不适合使用的场景：

- 高频数据刷新列表
- 大量同时进行几何动画的复杂视图树
- 帧率敏感的实时图表



---
url: /v2/zh/guide/View Modifiers/matchedTransitionSource.md
---

# 匹配过渡源（matchedTransitionSource）

`matchedTransitionSource` 用于 **标记某个视图作为“导航转场动画的几何源视图”**，使该视图在页面跳转时可以作为：

- 缩放动画的起点
- 位置过渡的起点
- 共享几何动画的起始帧

该能力对应 SwiftUI 中的 `matchedTransitionSource`，主要用于：

- 页面级导航动画
- Zoom（缩放）转场
- Hero 动画（共享元素转场）

它 **只用于导航转场**，不用于组件级几何联动（组件级联动应使用 `matchedGeometryEffect`）。

***

## 一、API 定义

```ts
/**
 * Identifies this view as the source of a navigation transition, such as a zoom transition.
 * @available iOS 18.0+
 */
matchedTransitionSource?: {
  id: string | number
  namespace: NamespaceID
}
```

***

## 二、核心作用

`matchedTransitionSource` 的核心作用是：

> 在一次导航跳转中，指定“从哪个视图开始做几何过渡动画”。

它解决的问题是：

- 页面跳转时视图“瞬间消失 + 新页面突然出现”的割裂感
- 图片、卡片、头像等元素在跳转时缺乏空间连续性
- 无法实现从“点击的那个元素”缩放进入目标页面的效果

通过 `matchedTransitionSource`，可以实现典型的：

- 图片 → 图片详情页的缩放动画
- 卡片 → 详情页的 Hero 动画
- 头像 → 个人主页的放大过渡

***

## 三、参数详解

### 1. id（转场源唯一标识）

```ts
id: string | number
```

含义：

- 标识“这是哪一个转场源视图”
- 必须与目标页面中 `navigationTransition.sourceID` 完全一致

规则：

- 同一个 `namespace` 内：

  - `id` 必须唯一
- 一次导航转场中：

  - 只能有一个 `matchedTransitionSource` 与 `sourceID` 对应

***

### 2. namespace（转场命名空间）

```ts
namespace: NamespaceID
```

含义：

- 用于把“源视图”和“目标页面”放入同一个转场作用域
- 由 `NamespaceReader` 创建并注入

规则：

1. 源视图与目标页面 **必须使用同一个 namespace**
2. 不同 namespace 之间 **绝对不会发生转场匹配**
3. 即使 `id` 相同，只要 namespace 不同，也不会触发动画

***

## 四、matchedTransitionSource 的工作机制

一次完整的导航缩放转场，必须同时满足以下四个条件：

1. **源视图定义了 `matchedTransitionSource`**
2. **目标页面定义了 `navigationTransition`**
3. **`sourceID === matchedTransitionSource.id`**
4. **两者使用的是同一个 `namespace`**

只有在这四个条件全部满足时，系统才会：

- 读取源视图的：

  - 真实 Frame
  - 屏幕位置
  - 缩放比例
- 读取目标页面的最终布局 Frame
- 自动计算：

  - 初始缩放比例
  - 平移路径
  - 最终尺寸
- 并生成完整的缩放过渡动画

***

## 五、最小可用示例：图片缩放进入详情页

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        frame={{
          width: 120,
          height: 160
        }}
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

### 该示例实现的效果

1. 用户点击封面图片
2. 页面开始跳转到 `DetailPage`
3. 新页面并不是“直接出现”
4. 而是：

   - 从点击的那张图片位置开始
   - 按比例放大
   - 平滑过渡到详情页的最终布局

***

## 六、卡片 → 详情页 Hero 动画示例

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "card-1"
          }}
        />
      }
    >
      <VStack
        frame={{
          width: 280,
          height: 180
        }}
        background="systemGray6"
        matchedTransitionSource={{
          id: "card-1",
          namespace
        }}
      >
        <Text>Card Title</Text>
      </VStack>
    </NavigationLink>
  )}
</NamespaceReader>
```

该示例实现：

- 整个卡片作为转场起点
- 跳转后卡片“变形为”详情页容器
- 具备典型的 Hero 动画特征

***

## 七、matchedTransitionSource 与 matchedGeometryEffect 的本质区别

| 对比项             | matchedTransitionSource | matchedGeometryEffect |
| --------------- | ----------------------- | --------------------- |
| 使用场景            | 页面级导航转场                 | 组件级几何联动               |
| 是否依赖 Navigation | 是                       | 否                     |
| 是否支持多个元素同步      | 否                       | 是                     |
| 是否需要 sourceID   | 是                       | 否                     |
| 是否控制 properties | 否                       | 是                     |
| 是否支持布局内动画       | 否                       | 是                     |

一句话总结：

- `matchedTransitionSource`：**只负责“从哪儿开始跳页面”**
- `matchedGeometryEffect`：**负责“布局内部怎么动”**

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- `sourceID` 是否与 `matchedTransitionSource.id` 完全一致
- 是否使用了同一个 `namespace`
- 是否真的发生了 `NavigationLink` 跳转

***

### 2. 动画方向异常或缩放错位

常见原因：

- 源视图有 `scaleEffect`、`offset` 等变换
- 源视图所在的容器使用了：

  - `clipShape`
  - `mask`
  - `containerShape`

这些变换会影响系统获取“真实几何 Frame”。

***

### 3. 同时存在多个 source

错误示例：

- 同一个页面中：

  - 多个视图都使用了相同 `id`
  - 且都设置了 `matchedTransitionSource`

后果：

- 系统无法判定哪个才是转场源
- 动画结果不可预测

***

## 九、使用限制说明

1. `matchedTransitionSource` 仅适用于：

   - `NavigationLink`
   - 基于 Navigation 的页面跳转
2. 在以下环境中不支持或行为受限：

   - Widget
   - Live Activity
3. 不适用于：

   - 组件内部状态切换
   - tab 切换
   - 展开折叠菜单

这些场景应使用 `matchedGeometryEffect`。

***

## 十、适用场景总结

非常适合使用 `matchedTransitionSource` 的场景：

- 图片点击 → 图片详情页
- 文章封面 → 阅读页
- 商品卡片 → 商品详情页
- 用户头像 → 个人主页
- 卡片列表 → 大卡详情页

不适合使用的场景：

- 高频切换的 UI 状态
- 大量小组件同时动画
- 实时刷新型界面



---
url: /v2/zh/guide/View Modifiers/offset.md
---

# 设置偏移

将视图从其默认位置沿 x 和 y 方向偏移指定的距离。

## 类型

```ts
offset?: {
  x: number
  y: number
}
```

## 示例

```tsx
<Text 
  offset={{
    x: 10,
    y: -20
  }}
>偏移内容</Text>
```



---
url: /v2/zh/guide/View Modifiers/onDrag and onDrop View Modifiers.md
---

# onDrag 和 onDrop 修饰符

Scripting 提供了一套与 SwiftUI Drag & Drop 行为模型高度一致的 API，用于在脚本中实现视图间、应用内或跨应用的拖拽与放置操作。

该能力主要由以下三部分构成：

- **onDrag**：将当前视图声明为拖拽源
- **onDrop**：将当前视图声明为放置目标
- **DropInfo / ItemProvider / UTType**：描述拖拽内容与状态的上下文对象

拖拽与放置是一个严格受系统控制的交互流程，部分 API 只能在特定回调中调用，文档中会明确指出这些限制。

***

## 核心数据类型

### DropInfo

`DropInfo` 描述一次拖拽在当前放置视图上的实时状态。该对象仅在 `onDrop` 相关回调中有效。

#### 属性

##### location: Point

- 表示拖拽当前位置
- 坐标空间为 **放置视图自身的本地坐标系**
- 可用于实现基于位置的高亮、插入指示线、排序逻辑等

#### 方法

##### hasItemsConforming(types: UTType\[]): boolean

- 用于判断拖拽内容中，是否至少有一个项目符合指定的 UTType
- 常用于：

  - `validateDrop`
  - `dropEntered`
  - `dropUpdated`
- 不会实际加载数据，仅用于能力判断

##### itemProviders(types: UTType\[]): ItemProvider\[]

- 返回符合指定 UTType 的 `ItemProvider` 列表
- **仅允许在 `performDrop` 回调中调用**
- 在该方法返回后，系统将撤销对拖拽数据的访问权限

> 重要约束
> 必须在 `performDrop` 方法作用域内 **立即开始** 对 ItemProvider 的数据加载（如 `loadData`、`loadText`）。
> 不允许延迟到其他回调或异步逻辑中再发起加载。

***

## DropOperation

`DropOperation` 用于描述当前拖拽更新阶段，目标视图期望执行的操作类型。

可选值如下：

- `"copy"`
  表示复制数据（最常见，用于文件、文本、图片等）

- `"move"`
  表示移动数据（通常仅用于应用内部拖拽）

- `"cancel"`
  取消本次拖拽，不执行任何数据传输

- `"forbidden"`
  明确禁止当前拖拽行为，系统通常会显示禁止指示

`DropOperation` 通常由 `dropUpdated` 回调返回，用于动态控制拖拽行为。

***

## DragDropProps

`DragDropProps` 是所有支持拖拽与放置能力的视图可选属性集合。

***

## onDrag

### 用途

将当前视图声明为 **拖拽源**，允许用户从该视图开始一次拖拽操作。

### 定义

```ts
onDrag?: {
  data: () => ItemProvider
  preview: VirtualNode
}
```

### 参数说明

#### data

```ts
data: () => ItemProvider
```

- 返回一个 `ItemProvider`
- 用于描述拖拽时传递的数据内容
- 支持文本、图片、文件、URL、自定义类型等
- 每次拖拽开始时调用

> 建议
> 仅在该回调中构造 ItemProvider，不要复用旧实例，以确保数据状态正确。

#### preview

```ts
preview: VirtualNode
```

- 指定拖拽开始后显示的预览视图
- 系统会自动将其渲染为拖拽浮层
- 预览视图默认居中于源视图

***

## onDrop

### 用途

将当前视图声明为 **放置目标**，并通过一组回调精细控制拖拽验证、状态变化与最终数据接收。

### 定义

```ts
onDrop?: {
  types: UTType[]
  validateDrop?: (info: DropInfo) => boolean
  dropEntered?: (info: DropInfo) => void
  dropUpdated?: (info: DropInfo) => DropOperation | null
  dropExited?: (info: DropInfo) => void
  performDrop: (info: DropInfo) => boolean
}
```

***

### onDrop.types

```ts
types: UTType[]
```

- 声明该视图 **允许接收的内容类型**
- 如果拖拽内容不包含任意一个匹配类型：

  - 放置区域不会激活
  - `validateDrop` 不会被调用
  - 视觉高亮不会出现

***

### validateDrop

```ts
validateDrop?: (info: DropInfo) => boolean
```

- 用于判断是否允许开始一次放置操作
- 返回 `false` 将直接拒绝拖拽
- 常见用途：

  - 检查类型数量
  - 校验业务状态（如只允许空列表接收）

默认行为：始终返回 `true`

***

### dropEntered

```ts
dropEntered?: (info: DropInfo) => void
```

- 当拖拽进入放置区域时触发
- 通常用于：

  - 显示高亮
  - 显示插入占位符
  - 触发动画状态

***

### dropUpdated

```ts
dropUpdated?: (info: DropInfo) => DropOperation | null
```

- 当拖拽在放置区域内部移动时反复调用
- 用于动态返回期望的 `DropOperation`

返回值说明：

- 返回具体的 `DropOperation`：更新当前拖拽行为
- 返回 `null`：

  - 使用上一次返回的有效值
  - 若没有历史值，默认使用 `"copy"`

***

### dropExited

```ts
dropExited?: (info: DropInfo) => void
```

- 当拖拽离开放置区域时触发
- 常用于清理高亮、移除占位 UI

***

### performDrop

```ts
performDrop: (info: DropInfo) => boolean
```

- **最关键的回调**
- 表示用户已松手，系统允许你读取拖拽数据
- 返回值：

  - `true`：表示成功接收并处理了拖拽
  - `false`：表示放置失败

#### 重要约束（必须遵守）

- 必须在该方法作用域内：

  - 调用 `info.itemProviders(...)`
  - 并立即开始数据加载
- 不允许：

  - 将 ItemProvider 保存到外部
  - 在异步回调中延迟访问拖拽数据

这是系统级安全限制，不遵守将导致数据无法访问。

***

## 典型使用流程总结

1. 用户从 `onDrag` 视图开始拖拽
2. 系统根据 `onDrop.types` 判断是否激活目标
3. 调用 `validateDrop`
4. 进入放置区域 → `dropEntered`
5. 移动过程中 → 多次 `dropUpdated`
6. 离开区域 → `dropExited`
7. 松手 → `performDrop`
8. 在 `performDrop` 中读取并处理数据

***

## 设计建议与最佳实践

- 始终精确声明 `UTType`，避免过于宽泛
- 在 `dropUpdated` 中返回 `"forbidden"` 可显式阻止非法拖拽
- 复杂数据解析逻辑应在 `ItemProvider` 加载完成后的异步回调中完成，而不是在 `performDrop` 中同步阻塞
- 跨应用拖拽时，优先使用系统标准类型（text、image、file、url）



---
url: /v2/zh/guide/View Modifiers/onDropContent.md
---

# 接收外部拖拽内容

`onDropContent` 是 Scripting 提供的一个视图修饰符，用于将当前视图设置为**拖放目标（Drop Target）**，以接收从其他 App 拖拽进入的文件、图片或文本内容。

***

## 功能说明

通过 `onDropContent`，你可以实现以下能力：

- 接收来自其他 App 的拖拽内容
- 使用 UTType 精确限制可接收的数据类型
- 实时感知拖拽指针是否悬停在视图上方
- 在内容被放下时，通过 `ItemProvider` 启动数据加载流程
- 对安全作用域文件建立持久访问权限

***

## 修饰符定义

```ts
onDropContent?: {
  types: UTType[]
  isTarget: {
    value: boolean
    onChanged: (value: boolean) => void
  } | Observable<boolean>
  perform: (attachments: ItemProvider[]) => boolean
}
```

***

## 参数说明

### types

用于指定当前视图**可以接收的内容类型列表**，类型值为 UTType 字符串。

当拖拽内容不包含任意匹配的类型时：

- 当前视图不会激活为放置目标
- `isTarget` 不会发生变化
- `perform` 不会被调用

示例：

```ts
types: ["public.image", "public.movie"]
```

***

### isTarget

用于表示拖拽操作是否悬停在当前视图上方。

- 当拖拽进入视图区域时，值为 `true`
- 当拖拽移出视图区域时，值为 `false`

支持以下两种形式：

- 绑定对象形式

  ```ts
  {
    value: boolean
    onChanged: (value: boolean) => void
  }
  ```

- Observable 形式

  ```ts
  Observable<boolean>
  ```

Observable 形式适合与 `useObservable` 搭配使用，语义更简洁。

***

### perform

当符合 `types` 要求的内容被成功放下时触发。

```ts
perform: (attachments: ItemProvider[]) => boolean
```

- 参数 `attachments` 为 `ItemProvider` 数组
- 每一个 `ItemProvider` 表示一个被拖入的内容项
- 函数返回值表示是否成功处理了此次拖放操作

返回值说明：

- 返回 `true` 表示拖放被成功接收
- 返回 `false` 表示未处理该拖放内容

***

## perform 的执行规则（重要）

在 `perform` 中需要遵循以下规则：

- 必须在 `perform` 函数的同步执行过程中**启动对 ItemProvider 的加载**
- 允许使用 `Promise` / `then` 等方式延迟完成加载
- 不允许在 `perform` 返回之后，再通过其他回调或事件启动加载
- 返回 `false` 时，系统会认为该拖放未被接受

原因说明：

- 拖放内容受系统安全机制保护
- 只有在 `perform` 执行期间，脚本才拥有对拖放数据的访问权限
- 若未在此期间启动加载，后续将无法访问对应资源

***

## ItemProvider 的使用方式

在 `perform` 中，开发者应当通过 `ItemProvider` 判断类型并启动加载。

常见流程包括：

- 使用 `hasItemConforming` 判断内容类型
- 根据内容类型选择合适的加载方式
- 对文件类资源获取路径并进行后续处理

***

## 示例用法

```tsx
const isTarget = useObservable(false)

return <VStack
  onDropContent={{
    types: ["public.image", "public.movie"],
    isTarget: isTarget,
    perform: (attachments) => {
      const images: UIImage[] = []
      const videos: string[] = []

      let found = false

      for (const attachment of attachments) {
        if (attachment.hasItemConforming("public.png")) {
          found = true
          attachment.loadUIImage().then(image => {
            if (image != null) {
              images.push(image)
            }
          })
        } else if (attachment.hasItemConforming("public.movie")) {
          found = true
          attachment.loadFilePath("public.movie").then(filePath => {
            if (filePath != null) {
              // 为安全作用域文件创建书签
              FileManager.addFileBookmark(filePath)
              videos.push(filePath)
            }
          })
        }
      }

      return found
    }
  }}
>
  ...
</VStack>
```

***

## 安全作用域文件访问

通过 `onDropContent` 获取的文件路径，通常属于**安全作用域资源**。

这类路径在以下情况下可能失效：

- `perform` 返回之后
- App 重启
- 脚本生命周期结束

为保证后续仍可访问文件，建议在获取路径后创建文件书签。

***

## FileManager.addFileBookmark

```ts
FileManager.addFileBookmark(path: string, name?: string): string | null
```

说明：

- 为指定文件或文件夹创建安全作用域书签
- 适用于通过 `Photos`、`onDropContent` 等 API 获取的路径
- 返回书签名称，用于后续访问或移除

示例：

```ts
const bookmarkName = FileManager.addFileBookmark(filePath)
```

***

## FileManager.removeFileBookmark

```ts
FileManager.removeFileBookmark(name: string): boolean
```

说明：

- 移除指定名称的文件书签
- 当不再需要访问对应文件时应及时调用
- 返回是否成功移除

示例：

```ts
FileManager.removeFileBookmark(bookmarkName)
```

***

## 使用建议

- 在 `types` 中尽量明确声明可接收的内容类型
- 在 `perform` 中只负责启动加载，不要等待加载完成
- 对图片等轻量内容可直接加载为对象
- 对视频、音频、文档等资源优先使用文件路径
- 对需要长期访问的文件务必创建书签
- 在资源不再使用时移除对应书签



---
url: /v2/zh/guide/View Modifiers/opacity.md
---

# 不透明度

设置视图的不透明度。`0` 表示完全透明不可见，`1` 表示完全不透明。

## 类型

```ts
opacity?: number
```

## 示例

```tsx
<Text opacity={0.5}>半透明文本</Text>
```



---
url: /v2/zh/guide/View Modifiers/overlay.md
---

# overlay

`overlay` 修饰符用于在当前视图的上方叠加一个额外视图，形成层叠的视觉效果。这在添加装饰元素（如徽章）、加载指示器、半透明遮罩或交互按钮等场景中非常有用。

***

## 类型定义

```ts
overlay?: VirtualNode | {
  alignment: Alignment
  content: VirtualNode
}
```

***

## 参数说明

### 1. 简洁形式：直接传入 `VirtualNode`

直接将一个视图叠加在当前视图之上，默认对齐方式为 **居中（center）**。

```tsx
<Image
  imageUrl="https://example.com/avatar.png"
  overlay={<Circle fill="black" opacity={0.2} />}
/>
```

该例会在头像图上方添加一个半透明黑色圆形遮罩。

***

### 2. 对象形式：带对齐方式的 Overlay

提供 `content` 和 `alignment`，用于指定叠加视图的内容与对齐方式。

#### 对象结构：

```ts
{
  alignment: Alignment
  content: VirtualNode
}
```

#### `Alignment` 可选值包括：

- `"top"` | `"bottom"` | `"leading"` | `"trailing"`
- `"topLeading"` | `"topTrailing"` | `"bottomLeading"` | `"bottomTrailing"`
- `"center"`

#### 示例：右上角徽章叠加

```tsx
<Image
  imageUrl="https://example.com/avatar.png"
  overlay={{
    alignment: "topTrailing",
    content: <Circle
      fill="red"
      frame={{
        width: 10,
        height: 10
      }}
    />
  }}
/>
```

该例会在图像右上角叠加一个红色圆形小徽章。

***

## 行为说明

- `overlay` 的内容会绘制在目标视图之上。
- 叠加内容不会改变原始视图的尺寸与布局。
- 若未设置 `clip`，叠加内容可能超出边界。

***

## 常见用途

- 添加通知角标或状态徽章
- 显示加载指示器或遮罩层
- 高亮视图特定区域
- 显示动画图标或文字提示

***

## 示例：居中文字叠加

```tsx
<Rectangle
  fill="blue"
  frame={{
    width: 100,
    height: 100
  }}
  overlay={{
    alignment: "center",
    content: <Text foregroundColor="white">你好</Text>
  }}
/>
```

该示例会在一个蓝色矩形中央叠加白色文字“你好”。

***

## 总结

| 参数            | 说明               |
| ------------- | ---------------- |
| `VirtualNode` | 要叠加的视图内容（默认居中）   |
| `alignment`   | 可选。叠加视图在目标视图中的位置 |
| `content`     | 要显示的叠加内容视图       |

`overlay` 是构建多层 UI、实现状态标记、视觉效果叠加等的核心修饰符之一，可灵活组合使用，适配各种视觉需求。



---
url: /v2/zh/guide/View Modifiers/padding.md
---

# 间距

`padding` 属性用于设置视图内容与其边缘之间的间距，相当于 SwiftUI 中的 `padding` 修饰符。它有助于视图之间的分隔与整体布局美观。

## 定义

```ts
padding?: true | number | {
  horizontal?: number | true
  vertical?: number | true
  leading?: number | true
  trailing?: number | true
  top?: number | true
  bottom?: number | true
}
```

## 支持的写法

***

### 1. 默认边距

```ts
padding: true
```

为所有边应用系统默认的内边距。

#### 示例：

```tsx
<Text padding={true}>
  默认边距
</Text>
```

***

### 2. 统一边距

```ts
padding: 8
```

为所有边设置相同的数值边距。

#### 示例：

```tsx
<VStack padding={12}>
  <Text>统一边距</Text>
</VStack>
```

***

### 3. 指定边距对象

可以分别设置特定方向的边距。

```ts
padding: {
  horizontal: 16,
  vertical: 8
}
```

#### 可用属性说明：

| 属性名          | 含义说明                           |
| ------------ | ------------------------------ |
| `horizontal` | 同时设置 `leading` 和 `trailing` 边距 |
| `vertical`   | 同时设置 `top` 和 `bottom` 边距       |
| `leading`    | 设置前导边距（在 LTR 语言中为左侧）           |
| `trailing`   | 设置尾部边距（在 LTR 语言中为右侧）           |
| `top`        | 设置顶部边距                         |
| `bottom`     | 设置底部边距                         |

每个值可以是具体数值，也可以是 `true`，`true` 表示使用系统默认边距。

#### 示例：

```tsx
<Text
  padding={{
    top: 10,
    bottom: 10,
    horizontal: 16
  }}
>
  自定义边距
</Text>
```

#### 使用 `true` 设置特定边：

```tsx
<Text
  padding={{
    top: true,
    horizontal: 12
  }}
>
  混合边距
</Text>
```

***

## 注意事项

- `padding` 不会直接改变视图内容的大小，但会影响它与外部内容之间的间距。
- 可以灵活组合 `horizontal` / `vertical` 与 `leading` / `top` 等单项配置，单项配置会覆盖对应方向的组合配置。
- 合理使用 `padding` 能提升界面排版的整洁性与可读性。



---
url: /v2/zh/guide/View Modifiers/pickerStyle.md
---

# 选择器样式

通过该属性，你可以自定义视图层次结构中选择器（Picker）的外观和行为。

***

## 属性声明

```tsx
pickerStyle?: PickerStyle;
```

### 描述

`pickerStyle` 属性用于设置选择器的视觉样式，使其能够适应不同的上下文和用户体验需求。

***

### 可接受的值

`pickerStyle` 属性接受以下字符串值：

- **`automatic`**：默认选择器样式，根据选择器的上下文进行适配。
- **`inline`**：将每个选项内嵌显示在当前容器中的其他视图之间。
- **`menu`**：当用户按下按钮时，将选项作为菜单显示，或者作为嵌套菜单的一部分。
- **`navigationLink`**：通过导航链接将选项呈现为推送列表样式的选择器视图。
- **`palette`**：将选项以紧凑元素行的形式呈现。
- **`segmented`**：以分段控件的形式显示选项。
- **`wheel`**：将选项显示为可滚动的轮状视图，同时展示所选选项及其附近的一些选项。

***

### 默认行为

如果未指定 `pickerStyle`，则根据选择器的上下文自动应用默认样式（`automatic`）。

***

## 使用示例

以下示例展示了如何在 TypeScript 代码中应用 `pickerStyle` 属性：

### 示例 1：内嵌样式 (Inline Style)

```tsx
function View() {
  const [value, setValue] = useState(0)

  return <Picker
    title="选择器"
    pickerStyle="inline"
    value={value}
    onChanged={(value) => {
      setValue(value)
      console.log('选择了:', value)
    }}
  >
    <Text tag={0}>选项 1</Text>
    <Text tag={1}>选项 2</Text>
    <Text tag={2}>选项 3</Text>
  </Picker>
}
```

此示例创建了一个内嵌样式的选择器。

***

### 示例 2：分段样式 (Segmented Style)

```tsx
function View() {
  const [value, setValue] = useState(0)

  return <Picker
    title="选择器"
    pickerStyle="segmented"
    value={value}
    onChanged={(value) => {
      setValue(value)
      console.log('选择了:', value)
    }}
  >
    <Text tag={0}>选项 1</Text>
    <Text tag={1}>选项 2</Text>
    <Text tag={2}>选项 3</Text>
  </Picker>
}
```

此示例创建了一个以分段控件形式显示的选择器。

***

### 示例 3：滚轮样式 (Wheel Style)

```tsx
function View() {
  const [value, setValue] = useState(0)

  return <Picker
    title="选择器"
    pickerStyle="wheel"
    value={value}
    onChanged={(value) => {
      setValue(value)
      console.log('选择了:', value)
    }}
  >
    <Text tag={0}>选项 1</Text>
    <Text tag={1}>选项 2</Text>
    <Text tag={2}>选项 3</Text>
  </Picker>
}
```

此示例创建了一个滚轮样式的选择器。

***

## 注意事项

- `pickerStyle` 属性直接映射到 SwiftUI 的 `pickerStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过使用 `pickerStyle`，你可以根据不同的上下文自定义选择器的外观，从而提供流畅的用户体验。



---
url: /v2/zh/guide/View Modifiers/position.md
---

# 设置位置

将视图的**中心点**定位到父视图坐标空间中的指定位置。

## 类型

```ts
position?: {
  x: number
  y: number
}
```

## 示例

```tsx
<Text
  position={{ 
    x: 100,
    y: 200 
  }}
>Positioned Text</Text>
```



---
url: /v2/zh/guide/View Modifiers/preferredColorScheme.md
---

# 首选配色模式

指定该视图层级使用的系统配色模式（浅色或深色）。通常用于控制系统覆盖元素的显示样式。

### 类型

```ts
preferredColorScheme?: "light" | "dark"
```

### 示例

```tsx
<NavigationStack>
  <List preferredColorScheme="dark">
    <Text>暗色模式视图</Text>
  </List>
</NavigationStack>
```



---
url: /v2/zh/guide/View Modifiers/progressViewStyle.md
---

# 进度视图样式

通过该属性，你可以自定义进度视图在 UI 中的外观。

***

## 属性声明

```tsx
progressViewStyle?: ProgressViewStyle;
```

### 描述

`progressViewStyle` 属性定义了进度视图的样式，允许你选择最适合应用上下文的视觉表示形式。

***

### 可接受的值

`progressViewStyle` 属性接受以下字符串值：

- **`automatic`**：使用默认的进度视图样式，适配视图当前的上下文。
- **`circular`**：以环形仪表显示，用于指示活动的部分完成情况。在非 macOS 平台上，该样式可能显示为不确定的加载指示器。
- **`linear`**：以水平条的形式显示进度，直观地指示任务完成情况。

***

### 默认行为

如果未指定 `progressViewStyle`，则根据视图上下文自动应用默认样式（`automatic`）。

***

## 进度视图属性

### 定时器进度视图属性

这些属性用于为基于时间的任务显示进度视图：

- **`timerFrom`**：进度开始的时间戳。
- **`timerTo`**：进度结束的时间戳。
- **`countsDown`** _(可选)_：如果为 true（默认值），随着时间推移进度将逐渐减少。
- **`label`** _(可选)_：描述正在进行的任务的视图。
- **`currentValueLabel`** _(可选)_：描述任务已完成进度的视图。

***

### 普通进度视图属性

这些属性用于为具有明确范围的任务显示进度视图：

- **`value`** _(可选)_：当前任务已完成的部分，范围为 0.0 到 `total`；如果进度不确定，则为 `nil`。
- **`total`** _(可选)_：任务的完整范围（默认值为 1.0）。
- **`title`** _(可选)_：描述正在进行任务的标题。
- **`label`** _(可选)_：描述正在进行任务的视图。
- **`currentValueLabel`** _(可选)_：描述任务已完成进度的视图。

***

## 使用示例

### 示例 1：定时器进度视图

```tsx
<ProgressView
  progressViewStyle="circular"
  timerFrom={Date.now()}
  timerTo={Date.now() + 3600000}
  countsDown={true}
  label={<Text>定时器进度</Text>}
  currentValueLabel={<Text>剩余时间</Text>}
/>
```

此示例为定时器任务创建了一个环形进度视图。

***

### 示例 2：普通进度视图

```tsx
<ProgressView
  progressViewStyle="linear"
  value={0.5}
  total={1.0}
  title="文件上传"
  label={<Text>正在上传...</Text>}
  currentValueLabel={<Text>50%</Text>}
/>
```

此示例为一个完成 50% 的任务创建了一个线性进度视图。

***

## 注意事项

- `progressViewStyle` 属性直接映射到 SwiftUI 的 `progressViewStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过设置 `progressViewStyle`，你可以根据任务的不同需求自定义进度视图的外观，提供直观且符合设计语言的用户体验。



---
url: /v2/zh/guide/View Modifiers/refresable/index.md
---

# 可刷新修饰符

将可滚动视图标记为 **可刷新**，允许用户下拉以触发异步的数据刷新操作。

## 类型

```ts
refreshable?: () => Promise<void>
```

***

## 概述

在如 `<List>` 这样的可滚动视图上使用 `refreshable` 修饰符，可以启用下拉刷新的交互行为。当用户在页面顶部下拉时，框架会调用你提供的异步处理函数。

在处理函数中，你可以执行异步操作（例如请求网络数据或更新本地状态），当该函数返回后，刷新指示器将自动隐藏。

此行为与 SwiftUI 的 [`refreshable`](https://developer.apple.com/documentation/swiftui/view/refreshable%28action:%29) 非常相似。

***

## 使用示例

```tsx
<List
  navigationTitle="可刷新列表"
  navigationBarTitleDisplayMode="inline"
  refreshable={refresh}
/>
```

### 完整示例

```tsx
function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 2000) // 模拟2秒刷新
    })
  }

  return <NavigationStack>
    <List
      navigationTitle="可刷新列表"
      navigationBarTitleDisplayMode="inline"
      refreshable={refresh}
    >
      <Section header={<Text textCase={null}>下拉即可刷新</Text>}>
        {data.map(item =>
          <Text>数字：{item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}
```

***

## 行为说明

- `refreshable` 必须返回一个 `Promise<void>`。只有在该 promise 被解析（`resolve`）后，刷新指示器才会消失。
- 在处理函数内部可以使用 `await` 进行异步操作：

  ```ts
  refreshable={async () => {
    const result = await fetchData()
    setData(result)
  }}
  ```
- 此修饰符 **仅适用于可滚动容器**（如 `<List>`）。
- 在刷新逻辑中应更新相关状态，以反映新的数据。
- 避免长时间运行或无反馈的任务，必须确保 promise 能被及时解析以防止界面卡住。

***

## 使用建议

- 保持刷新逻辑简洁高效。
- 始终在逻辑结束后调用 `resolve`。
- 开发时可使用延迟模拟加载动画：

  ```ts
  await new Promise(resolve => setTimeout(resolve, 1000))
  ```



---
url: /v2/zh/guide/View Modifiers/refresable/refreshable_list.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Script, Section, Text, useState } from "scripting"

function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 1000 * 2)
    })
  }

  return <NavigationStack>
    <List
      navigationTitle={"Refreshable List"}
      navigationBarTitleDisplayMode={"inline"}
      refreshable={refresh}
    >
      <Section header={
        <Text textCase={null}>Pull down to refresh</Text>
      }>
        {data.map(item =>
          <Text>Number: {item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/View Modifiers/rotationEffect.md
---

# 旋转效果

将视图绕指定锚点旋转指定角度。默认锚点为 `center`。

## 类型

```ts
rotationEffect?: number | {
  degrees: number
  anchor: KeywordPoint | Point
}
```

## 示例

默认锚点：

```tsx
<Text rotationEffect={45}>旋转内容</Text>
```

自定义锚点：

```tsx
<Text
  rotationEffect={{
    degrees: 30,
    anchor: "bottomTrailing"
  }}
>
  自定义锚点旋转
</Text>
```



---
url: /v2/zh/guide/View Modifiers/scaleEffect.md
---

# 缩放效果

按指定倍数缩放视图的渲染结果。支持统一缩放值，或分别设置横向与纵向缩放，并可指定锚点。

## 类型

```ts
scaleEffect?: number | {
  x: number
  y: number
  anchor?: KeywordPoint | Point
}
```

## 示例

统一缩放：

```tsx
<Text scaleEffect={1.5}>放大内容</Text>
```

非等比缩放：

```tsx
<Text
  scaleEffect={{
    x: 1.2,
    y: 0.8,
    anchor: "center"
  }}
>
  非等比缩放
</Text>
```



---
url: /v2/zh/guide/View Modifiers/shadow.md
---

# 阴影

为视图添加阴影效果。可设置颜色、模糊半径以及偏移量。

## 类型

```ts
shadow?: {
  color: Color
  radius: number
  x?: number
  y?: number
}
```

## 示例

```tsx
<Text
  shadow={{
    color: "black",
    radius: 5,
    x: 2,
    y: 4
  }}
>
  有阴影的文字
</Text>
```



---
url: /v2/zh/guide/View Modifiers/textFieldStyle.md
---

# 文本输入框样式

通过该属性，你可以定义文本框的视觉样式，从而影响其边框、背景和布局的外观。不同的样式可以帮助文本框在各种 UI 设计中无缝融合，或提供功能上的提示。

***

## 概述

`TextField` 为用户提供了一个输入文本的方式。通过选择 `textFieldStyle`，你可以决定文本框是以简洁、无边框的样式呈现，还是以更加明显的圆角边框显示，从而突出输入区域。

***

## 可用样式

- **`automatic`**：\
  让系统根据平台和上下文选择合适的样式。如果没有明确的样式偏好，这是一个方便的默认选择。

- **`plain`**：\
  以最少的装饰显示文本框。这种样式通常看起来像纯文本，适合不希望输入框过于显眼的布局。

- **`roundedBorder`**：\
  为文本框添加一个圆角矩形边框。这种样式能让输入区域更加突出，清楚地表明用户可以在其中输入内容。适合用于表单或需要用户进行主要操作的场景。

***

## 基本用法

以下示例展示了如何使用具有特定样式的 `TextField`：

```tsx
<TextField
  title="用户名"
  value={username}
  onChanged={newVal => setUsername(newVal)}
  textFieldStyle="roundedBorder"
  prompt="输入您的用户名"
/>
```

在此示例中，`textFieldStyle="roundedBorder"` 会用视觉效果突出输入框，让用户明确知道可以点击并输入。

***

## 其他常用属性

- **`value: string`**：\
  文本框当前的内容。用户输入时更新该值以保持显示内容同步。

- **`onChanged: (value: string) => void`**：\
  每当文本框内容更改时调用的回调函数，可用于响应用户输入。

- **`prompt?: string`**：\
  提示或占位符文本，用于指导用户输入内容。

- **`axis?: Axis`**：\
  决定当文本超出显示范围时的滚动方向。如果预期用户输入的内容较长，可以使用此属性。

- **`autofocus?: boolean`** _(默认值: false)_：\
  如果设置为 `true`，文本框会在显示时自动获得焦点，方便用户立即输入。

- **`onFocus?: () => void` 和 `onBlur?: () => void`**：\
  分别在文本框获得或失去焦点时调用的回调函数，可用于提供视觉反馈、执行验证或更新其他 UI 部分。

***

## 示例

```tsx
<TextField
  label={<Text style={{fontWeight: 'bold'}}>邮箱：</Text>}
  value={email}
  onChanged={setEmail}
  prompt="you@example.com"
  textFieldStyle="plain"
  autofocus={true}
  onFocus={() => console.log('获得焦点')}
  onBlur={() => console.log('失去焦点')}
/>
```

在此示例中，文本框被设置为 `plain` 样式，与周围内容更融为一体。`autofocus` 属性确保用户在进入此视图后可以立即开始输入。

***

## 总结

通过 `textFieldStyle`，你可以根据不同的上下文调整输入框的外观。无论是选择低调的 `plain` 样式，还是选择更加结构化的 `roundedBorder` 样式，合适的样式能够帮助创建清晰、直观的用户体验。如果不确定样式选择，可以使用 `automatic` 让系统决定最合适的外观。



---
url: /v2/zh/guide/View Modifiers/tint.md
---

# 强调色

`tint` 属性用于为视图设置局部的强调色，覆盖默认的系统 accent color。与应用的全局 accent color 不同，`tint` 不会被用户偏好覆盖，始终有效，适合用来强调控件的语义意义或视觉重点。

## 定义

```ts
tint?: ShapeStyle | DynamicShapeStyle
```

## 支持的值

- **`ShapeStyle`**：可为纯色、渐变或系统材质。
- **`DynamicShapeStyle`**：可根据浅色/深色模式自动切换的样式。

## 常见用途

- 设置如 `Toggle`、`Slider`、`Button`、`ProgressView` 等控件的本地着色。
- 在表单、列表或弹窗中标记具有特定意义的组件。
- 保证 UI 色彩在不同用户主题下始终一致。

## 示例：基础颜色着色

```tsx
<Toggle
  tint="systemGreen"
  // ...
/>
```

## 示例：渐变着色

```tsx
<ProgressView
  value={0.6}
  tint={{
    gradient: [
      { color: "red", location: 0 },
      { color: "orange", location: 1 }
    ],
    startPoint: { x: 0, y: 0 },
    endPoint: { x: 1, y: 1 }
  }}
/>
```

## 示例：深浅模式适配

```tsx
<Slider
  tint={{
    light: "blue",
    dark: "purple"
  }}
  // ...
/>
```



---
url: /v2/zh/guide/View Modifiers/toggleStyle.md
---

# 切换开关样式

通过该属性，你可以定义 `Toggle`（通常称为开关或复选框）的视觉外观和行为。

***

## 概述

`Toggle` 用于表示布尔值的开/关状态。它可以显示为开关、可点击的按钮，或者根据上下文使用平台的默认样式。`toggleStyle` 属性允许你指定要使用的外观，确保你的 UI 与应用的整体设计语言保持一致。

***

## 可用样式

- **`automatic`**：\
  让系统根据平台和上下文选择最适合的样式。如果不确定使用哪种样式，`automatic` 是一个不错的默认选择。

- **`switch`**：\
  将 `Toggle` 渲染为经典的开关，类似于 iOS 设置中的开关。开关通过滑动切换状态，为大多数用户提供熟悉的交互体验。

- **`button`**：\
  将 `Toggle` 呈现为按钮样式。与滑动不同，点击按钮即可切换状态。这种样式适合需要将 `Toggle` 作为可选择选项的 UI 布局。

***

## 使用示例

### 开关样式

```tsx
<Toggle
  title="启用通知"
  value={notificationsEnabled}
  onChanged={(newVal) => setNotificationsEnabled(newVal)}
  toggleStyle="switch"
/>
```

在此示例中，`Toggle` 显示为开关。用户点击时，开关滑动，切换状态为开或关。

***

### 按钮样式

```tsx
<Toggle
  title="深色模式"
  value={darkMode}
  onChanged={(newVal) => setDarkMode(newVal)}
  toggleStyle="button"
/>
```

在这种情况下，`Toggle` 看起来像一个按钮，点击时状态切换。适合需要更突出、可点击样式的场景。

***

### 自动样式

```tsx
<Toggle
  title="使用蜂窝数据"
  value={useCellular}
  onChanged={(newVal) => setUseCellular(newVal)}
  toggleStyle="automatic"
/>
```

使用 `automatic` 样式时，系统自动选择样式。这适用于信任系统默认样式以匹配平台约定的情况，或者希望在无需手动指定样式的情况下实现最大一致性。

***

## 其他 Toggle 属性

- **`value: boolean`**：\
  指示 `Toggle` 的当前状态（开或关）。

- **`onChanged(value: boolean): void`**：\
  当 `Toggle` 状态发生变化时触发的回调。可以用来相应地更新应用的数据模型。

- **`intent: AppIntent<any>`（可选）**：\
  你可以将 `Toggle` 与 `AppIntent` 关联，而不是本地处理状态变化。这样可以直接从 `Toggle` 的状态变化中触发预定义的应用动作（例如小组件或 Live Activity 场景）。

- **`title` 和 `systemImage`**：\
  提供一个描述性文本标签，并可选地添加一个图像，以清晰传达 `Toggle` 的用途。

- **`children`**：\
  你可以提供自定义内容（如文本节点、图标或两者的组合）作为 `Toggle` 的标签，而不是使用 `title` 或 `systemImage`。

***

## 总结

通过调整 `toggleStyle` 属性，你可以控制 `Toggle` 的外观和体验。无论你选择熟悉的开关样式、按钮样式，还是依赖 `automatic` 自动选择，该属性都能确保 `Toggle` 无缝融入你的脚本设计，同时为用户提供直观清晰的方式来更改布尔值设置。



---
url: /v2/zh/guide/View Modifiers/toolbar/Use with Toolbar Component.md
---

Scripting 的工具栏系统不仅支持直接在 `toolbar` 属性中传入 `ToolBarProps` 对象，也支持使用与 SwiftUI 结构一致的 `<Toolbar>`、`<ToolbarItem>`、`<ToolbarItemGroup>`、`<ToolbarSpacer>`、`<DefaultToolbarItem>` 等组件，构建更灵活、更强大的导航栏和工具栏布局。

这些组件能够提供更精细的控制，允许开发者像 SwiftUI 一样以声明式方式编排工具栏内容，并为复杂布局提供更高可读性和可维护性。

***

# 基本概念

工具栏组件始终通过视图的 `toolbar` 属性使用：

```tsx
<List
  toolbar={
    <Toolbar>
      {/* 工具栏项 */}
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

`toolbar` 可以接受：

- `ToolBarProps` 对象（与原机制一致）
- `VirtualNode`（必须为 `<Toolbar>` 组件）

使用 `<Toolbar>` 时，所有内容都通过 `<ToolbarItem>` 系列组件明确定义位置和呈现方式。

***

# Toolbar

`Toolbar` 组件是工具栏的容器，用于包含多个工具栏项。它本身不定义位置，内部的 `ToolbarItem` 或 `ToolbarItemGroup` 决定实际布局。

## 用法示例

```tsx
<List
  toolbar={
    <Toolbar>
      <ToolbarItem placement="topBarLeading">
        <Button title="关闭" action={() => dismiss()} />
      </ToolbarItem>
      <ToolbarItem placement="topBarTrailing">
        <Button title="完成" action={() => handleDone()} />
      </ToolbarItem>
    </Toolbar>
  }
>
  {/* 主内容 */}
</List>
```

***

# ToolbarItem

`ToolbarItem` 表示放置在工具栏指定位置的单个项目。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明                                                       |
| ----------- | ---------------------- | ----------- | -------------------------------------------------------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 指定工具栏位置，如 `topBarLeading`、`navigation`、`primaryAction` 等 |
| `children`  | `VirtualNode`          | 无           | 工具栏项的实际内容，例如按钮或文本                                        |

## 示例

```tsx
<Toolbar>
  <ToolbarItem placement="navigation">
    <Button title="返回" action={Navigation.useDismiss()} />
  </ToolbarItem>
</Toolbar>
```

***

# ToolbarItemGroup

`ToolbarItemGroup` 用于在同一位置放置多个工具栏项目，所有子项目将作为一组呈现。

## 参数说明

| 参数          | 类型                     | 默认值         | 说明      |
| ----------- | ---------------------- | ----------- | ------- |
| `placement` | `ToolbarItemPlacement` | `automatic` | 工具栏位置   |
| `children`  | 多个 VirtualNode         | 无           | 多个工具栏元素 |

## 示例

```tsx
<Toolbar>
  <ToolbarItemGroup placement="topBarTrailing">
    <Button title="刷新" action={reload} />
    <Button title="更多" action={openMenu} />
  </ToolbarItemGroup>
</Toolbar>
```

***

# ToolbarSpacer

`ToolbarSpacer` 用于在工具栏项之间添加空白区域，适合需要自定义布局的场景。

## 参数说明

| 参数          | 类型                      | 默认值         | 说明                   |
| ----------- | ----------------------- | ----------- | -------------------- |
| `sizing`    | `'fixed' \| 'flexible'` | `flexible`  | 控制 Spacer 是否固定大小或可伸缩 |
| `placement` | `ToolbarItemPlacement`  | `automatic` | Spacer 所在位置          |

### 行为说明

- `flexible`: 工具栏中的弹性空间，它会占据剩余区域。
- `fixed`: 提供固定间隔，适合多个按钮之间进行细微布局。

## 示例：在同一组中强制按钮分隔

```tsx
<Toolbar>
  <ToolbarItem placement="topBarTrailing">
    <Button title="Edit" action={edit} />
  </ToolbarItem>
  <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
  <ToolbarItem placement="topBarTrailing">
    <Button title="Save" action={save} />
  </ToolbarItem>
</Toolbar>
```

***

# DefaultToolbarItem

```ts
type ToolbarDefaultItemKind = "sidebarToggle" | "search" | "title";

type DefaultToolbarItemProps = {
  kind: ToolbarDefaultItemKind;
  placement?: ToolbarItemPlacement;
};

declare const DefaultToolbarItem: FunctionComponent<DefaultToolbarItemProps>;
```

用于渲染系统提供的默认工具栏项目，例如侧边栏切换按钮、搜索按钮、标题显示等。

## 参数说明

| 参数          | 类型                                       | 默认值         | 说明         |
| ----------- | ---------------------------------------- | ----------- | ---------- |
| `kind`      | `"sidebarToggle" \| "search" \| "title"` | 无           | 选择系统默认项目类型 |
| `placement` | `ToolbarItemPlacement`                   | `automatic` | 放置位置       |

## 示例：添加默认的搜索栏按钮

```tsx
<Toolbar>
  <DefaultToolbarItem kind="search" placement="topBarTrailing" />
</Toolbar>
```

***

# 综合示例：使用 Toolbar 构建复杂工具栏

```tsx
<NavigationStack>
  <List
    toolbar={
      <Toolbar>

        {/* 左侧导航按钮 */}
        <ToolbarItem placement="navigation">
          <Button title="返回" action={Navigation.useDismiss()} />
        </ToolbarItem>

        {/* 标题 */}
        <DefaultToolbarItem kind="title" />

        {/* 右侧一组按钮 */}
        <ToolbarItem placement="topBarTrailing">
          <Button title="编辑" action={edit} />
        </ToolbarItem>
        <ToolbarSpacer sizing="fixed" placement="topBarTrailing" />
        <ToolbarItem placement="topBarTrailing">
          <Button title="完成" action={finish} />
        </ToolbarItem>

        {/* 底部区域按钮 */}
        <ToolbarItem placement="bottomBar">
          <Button title="帮助" action={showHelp} />
        </ToolbarItem>

      </Toolbar>
    }
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

此结构灵活而清晰，可复现 SwiftUI 中复杂的工具栏布局。

***

# 与 ToolBarProps 的关系

在 API 层面：

| 方式                                          | 说明                  |
| ------------------------------------------- | ------------------- |
| `toolbar={ { topBarTrailing: <Button/> } }` | 简洁、直观，适合简单场景        |
| `toolbar={<Toolbar>...</Toolbar>}`          | 可组合，可精确布局，适合复杂、多组内容 |

两种方式完全兼容，可根据需要选择。

***

# 总结

Toolbar 组件提供了高度灵活的工具栏布局能力，包括：

- 单项工具栏项 (`ToolbarItem`)
- 工具栏项目组 (`ToolbarItemGroup`)
- 自适应空白区域 (`ToolbarSpacer`)
- 系统默认工具栏元素 (`DefaultToolbarItem`)
- 容器式声明 (`<Toolbar>`)



---
url: /v2/zh/guide/View Modifiers/toolbar/Use with ToolbarProps.md
---

# 使用 ToolbarProps

通过该属性，你可以为视图的导航栏或工具栏区域添加各种项目，类似于 SwiftUI 的 `toolbar` 修饰符功能。

***

## 概述

`toolbar` 属性接受一个 `ToolBarProps` 对象。`ToolBarProps` 中的每个键都对应特定的工具栏位置或操作类型。你提供的值可以是单个 `VirtualNode` 或一个包含多个 `VirtualNode` 元素的数组，这些节点代表自定义的 UI 项目。

**SwiftUI 示例（参考）**

```swift
// SwiftUI 示例代码
YourView()
    .toolbar {
        ToolbarItem(placement: .confirmationAction) {
            Button("保存") {
                // 处理保存操作
            }
        }
    }
```

**Scripting 示例（TypeScript/TSX）**

```tsx
<NavigationStack>
  <List
    toolbar={{
      confirmationAction: <Button title="保存" action={() => handleSave()} />,
      cancellationAction: <Button title="取消" action={() => handleCancel()} />,
      topBarLeading: [
        <Button title="编辑" action={() => handleEdit()} />,
        <Button title="刷新" action={() => handleRefresh()} />
      ]
    }}
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

***

## 工具栏位置

以下是 `ToolBarProps` 中可用的键，用于指定项目的位置和行为：

- **automatic**：根据上下文和平台自动确定位置。
- **bottomBar**：将项目放置在底部工具栏。
- **cancellationAction**：在模态界面中表示取消操作。
- **confirmationAction**：在模态界面中表示确认操作（例如，“保存”）。
- **destructiveAction**：表示执行破坏性任务的操作（例如，“删除”）。
- **keyboard**：将项目放置在与键盘关联的工具栏中。
- **navigation**：表示导航相关的操作（例如，“返回”或“关闭”）。
- **primaryAction**：表示界面的主要操作。
- **principal**：将项目放置在工具栏的主区域（通常在导航栏中居中）。
- **topBarLeading**：将项目放置在顶部栏的靠前位置（例如左侧）。
- **topBarTrailing**：将项目放置在顶部栏的靠后位置（例如右侧）。

***

## 使用示例

### 单个项目

如果想在工具栏中添加一个 `confirmationAction` 按钮：

```tsx
<NavigationStack>
  <VStack
    toolbar={{
      confirmationAction: <Button
        title="保存"
        action={() => console.log('正在保存...')}
      />
    }}
  >
    {/* 主内容 */}
  </VStack>
</NavigationStack>
```

***

### 多个项目

可以将节点数组传递给单个位置，从而在同一区域添加多个项目：

```tsx
<NavigationStack>
  <VStack
    toolbar={{
      topBarLeading: [
        <Button title="编辑" action={() => console.log('编辑被点击')} />,
        <Button title="设置" action={() => console.log('设置被点击')} />
      ],
      topBarTrailing: <Button title="完成" action={() => console.log('完成被点击')} />
    }}
  >
    {/* 主内容 */}
  </VStack>
</NavigationStack>
```

***

### 组合多个工具栏位置

可以根据需要混合和匹配不同的工具栏位置：

```tsx
<NavigationStack>
  <List
    toolbar={{
      navigation: <Button title="返回" action={() => console.log('返回被点击')} />,
      principal: <Text fontWeight={"bold"}>标题</Text>,
      primaryAction: <Button title="分享" action={() => console.log('分享被点击')} />,
      bottomBar: <Button title="帮助" action={() => console.log('帮助被点击')} />
    }}
  >
    {/* 主内容 */}
  </List>
</NavigationStack>
```

***

## 总结

通过使用 `toolbar` 属性，你可以轻松在 Scripting 应用中复制 SwiftUI 的 `toolbar` 修饰符行为。将 `VirtualNode` 元素分配给 `ToolBarProps` 中的合适键，能够为你的页面构建丰富的上下文工具栏和导航栏，从而增强用户体验。



---
url: /v2/zh/guide/View Modifiers/translationHost.md
---

# 翻译宿主

`translationHost` 是一个视图修饰符，用于为当前页面提供翻译服务上下文。它支持系统级的交互提示，例如下载语言包或在语言不明确时提示用户选择。

***

## 作用

当你使用 `Translation` 类进行文本翻译时，**应将 `translationHost` 应用于页面的根视图**，以确保：

- 如果**源语言或目标语言未安装**，系统会**提示用户下载所需语言**。
- 如果未指定源语言（即 `source: null`），且系统**无法从文本中判断语言**，系统会**提示用户手动选择源语言**。

如果不设置此修饰符，系统提示可能无法正常弹出，翻译过程可能失败或抛出错误。

***

## 类型定义

```ts
translationHost?: Translation
```

该修饰符的值必须是一个 `Translation` 实例。

***

## 使用示例

```tsx
function View() {
  const translation = useMemo(() => new Translation(), [])
  const [translated, setTranslated] = useState<{[key: string]: string}>({})
  const texts = ["Hello", "Goodbye"]
  
  useEffect(() => {
    translation.translateBatch({
      texts,
      source: "en",
      target: "fr"
    }).then(result => {
      const map: {[key: string]: string} = {}
      result.forEach((item, index) => {
        map[texts[index]] = item
      })
      setTranslated(map)
    })
  }, [])

  return <VStack translationHost={translation}>
    {texts.map(text => (
      <Text key={text}>
        {translated[text] || text}
      </Text>
    ))}
  </VStack>
}
```

在上面的示例中：

- 使用 `useMemo` 创建了一个 `Translation` 实例。
- 批量将英语文本翻译为法语。
- 最外层的 `VStack` 使用了 `translationHost={translation}`，确保系统在需要时可以弹出下载或语言选择提示。

***

## 最佳实践

- 始终将 `translationHost` 应用于**页面的顶层容器视图**。
- 确保传入的 `Translation` 实例与用于调用 `.translate()` 或 `.translateBatch()` 的实例一致。
- 避免在同一个页面中重复创建多个 `Translation` 实例。



---
url: /v2/zh/guide/View Modifiers/widgetBackground.md
---

# 小组件背景

`widgetBackground` 是一个专用于**小组件**的视图修饰符，用于在不同的渲染模式下设置背景样式，特别是为适配 **iOS 18 的 tinted（强调色）模式**而设计。

## 功能说明

在 **tinted 模式**下，iOS 会将所有视图颜色（包括背景）渲染为白色，除非该视图使用了 `widgetAccentable` 标记。这可能会导致背景显示异常或视觉效果失真。

使用 `widgetBackground` 可以避免这种问题：

- **在 accented 模式下自动隐藏背景**，避免被系统渲染为纯白色；
- **在默认模式或全彩模式下正常显示背景**。

这样可以确保你的小组件在不同系统渲染环境下都具有良好的视觉一致性。

***

## 支持的背景设置方式

`widgetBackground` 支持以下几种格式：

### 1. **纯色背景（ShapeStyle）**

使用简单颜色作为背景：

```tsx
<Text widgetBackground="systemBlue">
  Hello
</Text>
```

***

### 2. **动态背景（DynamicShapeStyle）**

根据系统的浅色/深色模式动态切换背景样式：

```tsx
<Text
  widgetBackground={{
    light: "white",
    dark: "black"
  }}
>
  模式感知背景
</Text>
```

***

### 3. **带形状的背景样式**

使用指定的\*\*形状（Shape）\*\*配合填充样式，实现结构化的背景设计：

```tsx
<Text
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12,
      style: "continuous"
    }
  }}
>
  圆角背景
</Text>
```

支持的形状包括：

- 预设形状：`'rect'`、`'circle'`、`'capsule'`、`'ellipse'`、`'buttonBorder'`、`'containerRelative'`
- 自定义圆角矩形：支持统一圆角、椭圆角尺寸、每个角独立设定

***

## 在 accented 模式下的行为

- **在 iOS 的 accented（tinted）模式下**：背景会被自动隐藏，以避免出现纯白色遮盖问题；
- **在默认或全彩渲染模式下**：背景将按设定正常显示。

此行为可有效避免系统渲染方式对 UI 布局和层级的干扰。

***

## 使用建议

- 仅在小组件中使用 `widgetBackground`，以避免在普通视图中出现不必要的隐藏行为；
- 不要使用背景传达重要信息，因为在 accented 模式下它可能会被隐藏；
- 搭配 `widgetAccentable` 使用，以精确控制哪些内容应参与系统色彩渲染，哪些内容应独立呈现。



---
url: /v2/zh/guide/Views/AVPlayerView.md
---

# 视频播放组件(AVPlayerView)

`AVPlayerView` 是 Scripting 提供的视频播放组件，基于系统原生 `AVPlayerViewController` 封装。
与 `VideoPlayer` 不同，`AVPlayerView` **完整支持系统级 Picture in Picture（画中画，PiP）**，并允许脚本层监听 PiP 的生命周期变化。

该组件适用于对**原生播放行为、后台播放、PiP、锁屏与控制中心联动**有明确需求的媒体类场景。

***

## 一、何时使用 AVPlayerView

当你的场景满足以下任意条件时，应使用 `AVPlayerView`：

- 需要视频进入系统 PiP 模式
- 需要原生播放控制 UI
- 需要在后台持续播放视频
- 需要与系统 Now Playing / 锁屏 / 控制中心联动
- 需要精确感知 PiP 的开始与结束

如果仅做简单的视频展示且不需要 PiP，`VideoPlayer` 仍然是更轻量的选择。

***

## 二、核心属性详解

### 1. `player`

```ts
player: AVPlayer
```

- 实际执行播放的核心对象
- 由开发者自行创建和管理
- 支持网络视频、本地文件、HLS 等格式

`AVPlayerView` **不会管理播放器的生命周期**，播放器在 PiP 期间必须保持存活。

***

### 2. `pipStatus`

```ts
pipStatus: Observable<PIPStatus>
```

用于监听系统 PiP 的生命周期状态变化。

可能的取值如下：

| 状态                 | 含义            |
| ------------------ | ------------- |
| `willStart`        | PiP 即将开始      |
| `didStart`         | PiP 已开始       |
| `willStop`         | PiP 即将结束      |
| `didStop`          | PiP 已结束       |
| `undefined / null` | 尚未进入 PiP 生命周期 |

该状态完全由系统控制，**只能监听，不应手动修改**。

***

## 三、PiP 相关配置项

### 1. `allowsPictureInPicturePlayback`

```ts
allowsPictureInPicturePlayback?: boolean
```

- 是否允许视频进入 PiP
- 默认值：`true`

若设为 `false`：

- 系统 PiP 按钮不会显示
- 视频无法进入画中画模式

***

### 2. `canStartPictureInPictureAutomaticallyFromInline`

```ts
canStartPictureInPictureAutomaticallyFromInline?: boolean
```

- 当应用从前台切换到后台时，是否自动进入 PiP
- 默认值：`false`

适合以下场景：

- 用户按下 Home 键离开应用
- 希望播放不中断并自动进入 PiP

***

### 3. `updatesNowPlayingInfoCenter`

```ts
updatesNowPlayingInfoCenter?: boolean
```

- 是否自动更新系统 Now Playing 信息
- 默认值：`true`

开启后，视频信息会显示在：

- 锁屏界面
- 控制中心
- 外接播放设备

***

## 四、全屏播放行为

### 1. `entersFullScreenWhenPlaybackBegins`

```ts
entersFullScreenWhenPlaybackBegins?: boolean
```

- 播放开始时是否自动进入全屏
- 默认值：`false`

***

### 2. `exitsFullScreenWhenPlaybackEnds`

```ts
exitsFullScreenWhenPlaybackEnds?: boolean
```

- 播放结束时是否自动退出全屏
- 默认值：`false`

***

## 五、视频显示方式（videoGravity）

```ts
videoGravity?: AVLayerVideoGravity
```

| 值                  | 行为说明           |
| ------------------ | -------------- |
| `resize`           | 拉伸填满，不保持比例     |
| `resizeAspect`     | 保持比例，完整显示（默认）  |
| `resizeAspectFill` | 保持比例，填满区域，可能裁剪 |

***

## 六、完整 DEMO 示例

以下示例演示了：

- 创建并配置 `AVPlayer`
- 正确配置音频会话
- 监听 PiP 生命周期
- 控制播放 / 暂停
- 正确释放资源

```tsx
function Example() {
  const dismiss = Navigation.useDismiss()
  const [status, setStatus] = useState<TimeControlStatus>(
    TimeControlStatus.paused
  )
  const pipstatus = useObservable<PIPStatus>()

  console.log(pipstatus.value)

  const player = useMemo(() => {
    const player = new AVPlayer()

    player.setSource(
      "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
    )

    player.onTimeControlStatusChanged = status => {
      setStatus(status)
    }

    SharedAudioSession.setActive(true)
    SharedAudioSession.setCategory(
      "playback",
      ["defaultToSpeaker"]
    )

    return player
  }, [])

  useEffect(() => {
    return () => {
      player.dispose()
    }
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="VideoPlayer"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        cancellationAction: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <AVPlayerView
        player={player}
        pipStatus={pipstatus}
        canStartPictureInPictureAutomaticallyFromInline
        updatesNowPlayingInfoCenter
        entersFullScreenWhenPlaybackBegins
      />

      <Button
        title={
          status === TimeControlStatus.paused
            ? "Play"
            : "Pause"
        }
        action={() => {
          if (status === TimeControlStatus.paused) {
            player.play()
          } else {
            player.pause()
          }
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 七、PiP 生命周期说明

PiP 状态通常按以下顺序变化：

1. `willStart`
2. `didStart`
3. PiP 运行中
4. `willStop`
5. `didStop`

在异常或系统打断情况下，部分状态可能被跳过，因此应以 `didStart` 和 `didStop` 作为最终判断依据。

***

## 八、重要注意事项

### 1. AVPlayerView 使用的是系统级视频 PiP

- 基于系统原生视频 PiP
- 与 Scripting 的自定义 PiP View Modifiers **完全不同**
- 两种 PiP 机制不可混用

***

### 2. PiP 依赖正确的音频会话配置

要保证 PiP 正常工作，必须：

- 激活音频会话
- 使用 `playback` 类别
- 正确配置后台音频能力

否则可能出现 PiP 无法启动或静默失败的情况。

***

### 3. PiP 期间不要销毁 AVPlayer

- PiP 运行中销毁或替换 `AVPlayer`
- 会导致 PiP 异常退出
- 甚至触发系统错误

应在 `pipStatus` 变为 `didStop` 后再释放播放器资源。

***

## 九、推荐实践总结

- 视频 PiP 场景始终使用 `AVPlayerView`
- 将 `pipStatus` 视为只读状态
- PiP 期间保持 `AVPlayer` 生命周期稳定
- 显式配置音频会话
- 避免频繁创建或替换播放器
- 在 PiP 完全结束后再释放资源



---
url: /v2/zh/guide/Views/AccessoryWidgetBackground.md
---

# AccessoryWidgetBackground

一个自适应的背景视图，根据小组件当前的环境提供系统标准外观。

## 概述

`AccessoryWidgetBackground` 组件适用于配件类小组件（Accessory Widgets），如锁屏小组件或待机模式（StandBy）小组件。它会自动根据系统环境（如浅色/深色模式、透明度、系统主题）应用合适的背景样式，确保小组件与系统视觉风格一致。

通常你可以将此视图作为背景层，配合 `ZStack` 等布局使用，将自定义内容覆盖其上方，从而获得既美观又系统一致的外观。

## 示例

```tsx
import { AccessoryWidgetBackground, Text, ZStack } from "scripting"

function AccessoryView() {
  return (
    <ZStack>
      <AccessoryWidgetBackground />
      <Text font="caption">Weather</Text>
    </ZStack>
  )
}
```

在此示例中，`AccessoryWidgetBackground` 提供了系统适配的背景，`Text` 文本则显示在其上方。此布局非常适合锁屏小组件，确保内容在各种系统外观下保持清晰可读。

## 使用建议

- 通常应将 `AccessoryWidgetBackground` 放在 `ZStack` 的底层，以作为背景视图。
- 不建议对该组件直接设置颜色或样式，它会根据系统环境自动调整。
- 可与其他 SwiftUI 风格的组件结合使用，构建与原生系统一致的小组件外观。

## 兼容性

此组件主要用于配件类小组件，在普通视图中使用可能不会有任何视觉效果。建议仅在小组件开发中使用，以获得最佳系统一致性体验。



---
url: /v2/zh/guide/Views/Button.md
---

# 按钮

在 **Scripting** 应用中，`Button` 组件允许您创建具有可自定义动作、标签、样式和角色的交互式元素。按钮可以触发动作、执行意图，并根据配置显示不同的视觉样式。本指南提供了关于如何使用 `Button` API 的详细说明，包括其属性、角色、样式及示例。

***

## `Button`

### 描述

您可以通过提供一个 **动作**（action）或 **意图**（intent）以及一个 **标签**（label）来创建按钮。标签可以是简单的文本、图标或复杂的视图。按钮是创建交互界面的关键，例如提交表单或在页面之间导航。

### 属性

| **属性**        | **类型**                                                     | **描述**                                                                                |
| ------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| `title`       | `string`                                                   | 按钮上显示的文本标签。                                                                           |
| `systemImage` | `string` _(可选)_                                            | 按钮标题旁边显示的系统图标名称。                                                                      |
| `children`    | `VirtualNode` 或 `VirtualNode[]`                            | 用作按钮标签的自定义视图，替代 `title`。                                                              |
| `role`        | `'destructive' \| 'cancel' \| 'close' \| 'confirm'` _(可选)_ | 描述按钮的用途。`destructive` 用于标记执行潜在危险操作的按钮，`cancel` 表示取消操作。                                |
| `intent`      | `AppIntent<any>`                                           | 当按钮被触发时执行的意图。适用于 `Widget` 或 `LiveActivity`。详情见 `Interactive Widget and LiveActivity`。 |
| `action`      | `() => void`                                               | 用户触发按钮时执行的函数。                                                                         |

***

### `ButtonStyle`

定义按钮的视觉外观。

| **值**               | **描述**                               |
| ------------------- | ------------------------------------ |
| `automatic`         | 根据按钮的上下文设置默认样式。                      |
| `bordered`          | 标准的带边框样式。                            |
| `borderedProminent` | 突出的带边框样式，更加醒目。                       |
| `borderless`        | 无边框样式。                               |
| `plain`             | 简洁的样式，具有最少的装饰，但仍可在按下、聚焦或启用状态下提供视觉反馈。 |

***

### `ButtonBorderShape`

指定 `bordered` 或 `borderedProminent` 样式按钮的边框形状。

| **值**                                | **描述**        |
| ------------------------------------ | ------------- |
| `automatic`                          | 由系统决定适当的形状。   |
| `capsule`                            | 胶囊形状的边框。      |
| `circle`                             | 圆形边框。         |
| `roundedRectangle`                   | 带圆角的矩形边框。     |
| `buttonBorder`                       | 由环境决定最终的边框形状。 |
| `{ roundedRectangleRadius: number }` | 带特定角半径的圆角矩形。  |

***

### `ControlSize`

定义按钮和其他控件的尺寸。

| **值**        | **描述**                 |
| ------------ | ---------------------- |
| `mini`       | 最小的控件尺寸。               |
| `small`      | 紧凑的控件尺寸。               |
| `regular`    | 标准的控件尺寸。               |
| `large`      | 较大的控件尺寸。               |
| `extraLarge` | 最大的控件尺寸，通常用于高强调或无障碍场景。 |

***

### `CommonViewProps`

这些属性可用于自定义视图中按钮的外观和行为。

| **属性**              | **类型**              | **描述**                                         |
| ------------------- | ------------------- | ---------------------------------------------- |
| `controlSize`       | `ControlSize`       | 设置视图中控件的尺寸。                                    |
| `buttonStyle`       | `ButtonStyle`       | 应用自定义交互行为和按钮外观。                                |
| `buttonBorderShape` | `ButtonBorderShape` | 指定 `bordered` 和 `borderedProminent` 按钮样式的边框形状。 |

***

## 示例用法

### 带动作的基础按钮

```tsx
<Button title="Sign in" action={handleSignIn} />
```

### 带系统图标的按钮

```tsx
<Button title="Delete" systemImage="trash" role="destructive" action={handleDelete} />
```

### 自定义标签按钮

```tsx
<Button>
  <Text>Custom Label</Text>
</Button>
```

### 执行 AppIntent 的按钮

```tsx
<Button
  title="Start Workout"
  intent={MyStartWorkoutIntent({ duration: 30 })}
  buttonStyle="borderedProminent"
/>
```

### 设置按钮样式

```tsx
<Group
  buttonStyle="bordered"
  buttonBorderShape={{ roundedRectangleRadius: 8 }}
  controlSize="large"
>
  <Button title="Save" action={handleSave} />
</Group>
```

***

### 注意事项

- 使用 `role` 指定具有特定用途的按钮，例如取消或危险操作按钮。
- 将 `buttonStyle` 和 `buttonBorderShape` 结合使用，为整个视图提供一致的主题。
- `intent` 属性将按钮与 `Widget` 和 `LiveActivity` 集成，实现无缝交互。

关于 `AppIntent` 的更多细节，请参阅 `Interactive Widget and LiveActivity` 文档。



---
url: /v2/zh/guide/Views/Charts/AreaStackChart/index.md
---

# 堆叠面积图（AreaStackChart）

`AreaStackChart` 是用于展示堆叠区域图的组件，可将一系列数值以堆叠区域的方式呈现在共享坐标轴上，适用于展示各分类数据在一段时间内的变化趋势及其组合占比。

## 使用示例

```tsx
<Chart frame={{ height: 300 }}>
  <AreaStackChart
    marks={[
      {
        category: "Cheese",
        label: "2020",
        value: 0.26,
        stacking: "standard"
      },
      ...
    ]}
  />
</Chart>
```

## 属性说明

### `marks: Array<object>` **(必填)**

用于定义图表数据的数组。每一项表示一个图表标记，支持以下字段：

- `category: string`
  数据所属的分类名称，用于堆叠图中分组。

- `label: string | Date`
  图表横轴的标签，可为字符串或日期，常用于表示时间（如年份）。

- `value: number`
  对应的数值，用于绘制堆叠区域的高度。

- `unit?: CalendarComponent`
  指定时间单位，如 `"year"`、`"month"`、`"day"` 等。用于基于时间的标记。

- `stacking?: ChartMarkStackingMethod`
  设置堆叠方式，可选值包括：

  - `"standard"`：从基线开始正常堆叠（默认）。
  - `"normalized"`：将每组值归一化为总值的百分比。
  - `"center"`：以中心轴为基线对称堆叠。
  - `"unstacked"`：不进行堆叠，单独绘制。

- 其他可选的 `ChartMarkProps` 属性：
  支持丰富的样式和行为配置，如：

  - `foregroundStyle`（前景样式）
  - `opacity`（透明度）
  - `cornerRadius`（圆角）
  - `interpolationMethod`（插值方式）
  - `symbol`、`symbolSize`、`annotation`（注释）、`clipShape`、`shadow`、`blur`、`zIndex`、`offset` 等

详细配置请参考 `ChartMarkProps` 定义。

### `labelOnYAxis?: boolean`

是否将 `label` 值显示在 Y 轴上（默认在 X 轴）。默认为 `false`。

## 示例

```tsx
<AreaStackChart
  labelOnYAxis={false}
  marks={[
    {
      category: "Burger",
      label: 2020,
      value: 0.6,
      stacking: "standard"
    },
    {
      category: "Cheese",
      label: 2020,
      value: 0.26,
      stacking: "standard"
    },
    {
      category: "Bun",
      label: 2020,
      value: 0.24,
      stacking: "standard"
    }
  ]}
/>
```



---
url: /v2/zh/guide/Views/Charts/AreaStackChart/index_example.md
---

# 示例

```tsx
import { AreaStackChart, Chart, ChartMarkStackingMethod, Navigation, NavigationStack, Picker, Script, Text, useState, VStack } from "scripting"

const data = [
  { name: "Burger", price: 0.07, year: 1960 },
  { name: "Cheese", price: 0.03, year: 1960 },
  { name: "Bun", price: 0.05, year: 1960 },

  { name: "Burger", price: 0.10, year: 1970 },
  { name: "Cheese", price: 0.04, year: 1970 },
  { name: "Bun", price: 0.06, year: 1970 },

  { name: "Burger", price: 0.15, year: 1980 },
  { name: "Cheese", price: 0.10, year: 1980 },
  { name: "Bun", price: 0.1, year: 1980 },

  { name: "Burger", price: 0.23, year: 1990 },
  { name: "Cheese", price: 0.12, year: 1990 },
  { name: "Bun", price: 0.13, year: 1990 },

  { name: "Burger", price: 0.32, year: 2000 },
  { name: "Cheese", price: 0.15, year: 2000 },
  { name: "Bun", price: 0.15, year: 2000 },

  { name: "Burger", price: 0.49, year: 2010 },
  { name: "Cheese", price: 0.20, year: 2010 },
  { name: "Bun", price: 0.19, year: 2010 },

  { name: "Burger", price: 0.60, year: 2020 },
  { name: "Cheese", price: 0.26, year: 2020 },
  { name: "Bun", price: 0.24, year: 2020 },
]

const stackings: ChartMarkStackingMethod[] = [
  'center',
  'normalized',
  'standard',
  'unstacked'
]

function Example() {
  const [stacking, setStacking] = useState<ChartMarkStackingMethod>('standard')

  return <NavigationStack>
    <VStack
      navigationTitle={"AreaStackChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Picker
        title={"StackingMethod"}
        value={stacking}
        onChanged={setStacking as any}
        pickerStyle={"menu"}
      >
        {stackings.map(item =>
          <Text tag={item}>{item}</Text>
        )}
      </Picker>
      <Chart
        frame={{
          height: 300
        }}
      >
        <AreaStackChart
          marks={data.map(item => ({
            category: item.name,
            label: item.year.toString(),
            value: item.price,
            stacking: stacking,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/Bar1DChart/index.md
---

# 一维柱状图（Bar1DChart）

`Bar1DChart` 是一种一维条形图组件，用于在多个离散分类之间直观比较数值大小。每一个条形代表一个分类及其对应的数值，适合用于构建简洁的横向或纵向柱状对比图。

## 使用示例

```tsx
<Chart
  padding={0}
  frame={{ height: 400 }}
>
  <Bar1DChart
    marks={[
      { category: "Gadgets", value: 3800 },
      { category: "Gizmos", value: 4400 },
      { category: "Widgets", value: 6500 },
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

是否在 Y 轴上显示分类标签。当设置为 `true` 时，条形将以横向方式排列。
默认为 `false`，即在 X 轴上显示标签，条形图为纵向排列。

### `marks: Array<object>` **（必填）**

定义要渲染的每一个条形的数据项。每个标记包含以下字段：

- `category: string`
  条形所对应的分类名称。

- `value: number`
  条形的数值，用于决定长度。

- 其他可选的 `ChartMarkProps` 样式属性：
  可通过 `ChartMarkProps` 自定义样式和行为，包括：

  - `foregroundStyle`（颜色样式）
  - `opacity`（透明度）
  - `symbol`（图形符号）
  - `annotation`（注释）
  - `offset`（偏移位置）
  - `zIndex`（显示层级）等

## 示例代码

```tsx
const data = [
  { type: "Gadgets", profit: 3800 },
  { type: "Gizmos", profit: 4400 },
  { type: "Widgets", profit: 6500 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"Bar1DChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        padding={0}
        frame={{ height: 400 }}
      >
        <Bar1DChart
          marks={data.map(item => ({
            category: item.type,
            value: item.profit,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}
```

## 运行图表示例

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

## 使用场景

`Bar1DChart` 适用于：

- 比较多个分类项的数值差异
- 展示排行榜、排序结果等
- 以极简方式可视化清晰、有限的数据集



---
url: /v2/zh/guide/Views/Charts/Bar1DChart/index_example.md
---

# 示例

```tsx
import { Bar1DChart, Chart, Navigation, NavigationStack, Script, VStack } from "scripting"

const data = [
  { type: "Gadgets", profit: 3800 },
  { type: "Gizmos", profit: 4400 },
  { type: "Widgets", profit: 6500 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"Bar1DChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        padding={0}
        frame={{
          height: 400
        }}
      >
        <Bar1DChart
          marks={data.map(item => ({
            category: item.type,
            value: item.profit,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack >
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/BarChart/index.md
---

# 柱状图（BarChart）

`BarChart`（柱状图）组件用于以条形的形式直观比较不同分类的数值大小。每个柱形条对应一个标签，并通过其高度（纵向布局）或长度（横向布局）表示具体数值。

## 场景示例

本示例展示了三种玩具形状（`Cube`、`Sphere`、`Pyramid`）的数量，并提供一个开关用于切换柱状图的展示方向（横向或纵向），通过 `labelOnYAxis` 属性控制。

## 使用示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarChart
    labelOnYAxis={false}
    marks={[
      { label: "Cube", value: 5 },
      { label: "Sphere", value: 4 },
      { label: "Pyramid", value: 4 },
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

- 设置为 `true` 时，标签显示在 **Y 轴**，图表将以 **横向柱状图** 的形式展示。
- 设置为 `false`（默认），标签显示在 **X 轴**，图表将以 **纵向柱状图** 的形式展示。

### `marks: Array<object>` **（必填）**

每个数据点定义一个柱状条，包含以下字段：

- `label: string | Date`
  分类的标签或标识。

- `value: number`
  柱状条对应的数值。

- `unit?: CalendarComponent`（可选）
  用于表示时间单位的字段，在处理时间数据时可设置。

- 可选的 `ChartMarkProps` 属性
  用于进一步自定义柱状条的样式，例如：

  - `foregroundStyle`（前景颜色）
  - `opacity`（透明度）
  - `cornerRadius`（圆角）
  - `symbol`（图形标记）
  - `annotation`（注释）等

## 示例代码

```tsx
const toysData = [
  { type: "Cube", count: 5 },
  { type: "Sphere", count: 4 },
  { type: "Pyramid", count: 4 },
]

<BarChart
  labelOnYAxis={labelOnYAxis}
  marks={toysData.map(toy => ({
    label: toy.type,
    value: toy.count,
  }))}
/>
```

## 支持动态布局切换

示例中使用 `Toggle` 实现横向 / 纵向图表的切换：

```tsx
<Toggle
  title="labelOnYAxis"
  value={labelOnYAxis}
  onChanged={setLabelOnYAxis}
/>
```

## 使用场景

`BarChart` 非常适用于：

- 对比多个分类的数值差异
- 展示调查结果、数量统计或排行榜数据
- 需要根据布局场景自由切换方向的图表展示



---
url: /v2/zh/guide/Views/Charts/BarChart/index_example.md
---

# 示例

```tsx
import { BarChart, Chart, List, Navigation, NavigationStack, Script, Section, Toggle, useState, } from "scripting"

type ToyShape = {
  type: string
  count: number
}

const toysData: ToyShape[] = [
  {
    type: "Cube",
    count: 5,
  },
  {
    type: "Sphere",
    count: 4,
  },
  {
    type: "Pyramid",
    count: 4
  }
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"BarChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart
        chartXVisibleDomain={10}
        frame={{
          height: 400
        }}
      >
        <BarChart
          labelOnYAxis={labelOnYAxis}
          marks={toysData.map(toy => ({
            label: toy.type,
            value: toy.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/BarGanttChart/index.md
---

# 甘特柱状图（BarGanttChart）

`BarGanttChart`（甘特条形图）组件用于可视化多个分类下的时间区间，非常适合展示日程安排、任务持续时间或项目时间线。每条条形从 `start` 延伸至 `end`，表示某项任务或事件在时间轴上的跨度。

## 使用示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarGanttChart
    labelOnYAxis
    marks={[
      { label: "Job 1", start: 0, end: 15 },
      { label: "Job 2", start: 5, end: 25 },
      ...
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

是否在 Y 轴显示分类标签。当为 `true` 时，图表将以横向方式绘制（即典型甘特图布局），条形沿 X 轴表示时间跨度。
默认为 `false`，即条形纵向排列，标签显示在 X 轴。

### `marks: Array<object>` **（必填）**

定义要渲染的时间区间。每个对象必须包含以下字段：

- `label: string`
  条形所代表的分类名称（例如任务名或工种）。

- `start: number`
  条形的起始位置，通常代表开始时间或起点值。

- `end: number`
  条形的结束位置，代表结束时间或终点值。图表将绘制一条从 `start` 到 `end` 的条形。

你也可以提供其他 `ChartMarkProps` 来自定义样式和行为。

## 示例代码

```tsx
const data = [
  { job: "Job 1", start: 0, end: 15 },
  { job: "Job 2", start: 5, end: 25 },
  { job: "Job 1", start: 20, end: 35 },
  { job: "Job 1", start: 40, end: 55 },
  { job: "Job 2", start: 30, end: 60 },
  { job: "Job 2", start: 30, end: 60 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"BarGanttChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart frame={{ height: 400 }}>
        <BarGanttChart
          labelOnYAxis
          marks={data.map(item => ({
            label: item.job,
            start: item.start,
            end: item.end,
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}
```

## 运行图表示例

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

## 使用场景

`BarGanttChart` 非常适用于：

- 项目计划与任务排程
- 展示任务重叠与时间持续分布
- 表达资源在时间轴上的分配情况



---
url: /v2/zh/guide/Views/Charts/BarGanttChart/index_example.md
---

# 示例

```tsx
import { BarGanttChart, Chart, Navigation, NavigationStack, Script, VStack } from "scripting"

const data = [
  { job: "Job 1", start: 0, end: 15 },
  { job: "Job 2", start: 5, end: 25 },
  { job: "Job 1", start: 20, end: 35 },
  { job: "Job 1", start: 40, end: 55 },
  { job: "Job 2", start: 30, end: 60 },
  { job: "Job 2", start: 30, end: 60 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"BarGanttChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 400
        }}
      >
        <BarGanttChart
          labelOnYAxis
          marks={data.map(item => ({
            label: item.job,
            start: item.start,
            end: item.end
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/BarGroupChart/index.md
---

# 分组柱状图（BarGroupChart）

本示例演示如何在 `BarChart` 中使用 `positionBy` 属性将柱状图按子分类（如颜色）进行分组，并使用 `foregroundStyleBy` 对每组数据应用不同的颜色样式。此方式适用于在主分类下对多个子类进行对比展示。

## 场景说明

数据包含了不同颜色（如 `Green`, `Purple`, `Pink`, `Yellow`）下的三种物体类型（`Cube`, `Sphere`, `Pyramid`）及其数量（`count`）。图表展示了每种颜色下各类型物体的数量，按颜色分组并以不同颜色区分。

## 核心概念说明

### `positionBy`

```ts
positionBy: {
  value: item.color,
  axis: 'horizontal',
}
```

- 将柱状图按照 `value`（此处为颜色）进行分组。
- `axis` 指定分组的方向：

  - `'horizontal'`：按 Y 轴进行分组（即按颜色垂直堆叠或排列）。
  - `'vertical'`：按 X 轴分组（通常用于横向柱状图）。

### `foregroundStyleBy`

```ts
foregroundStyleBy: item.color
```

- 根据指定的字段值（颜色）为每个柱状条应用前景样式（颜色）。
- 有助于在图表中清晰地区分不同的分组。

## 代码摘要

```tsx
const data = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Purple", type: "Sphere", count: 1 },
  ...
]

const list = data.map(item => ({
  label: item.type,              // 主标签（如 Cube、Sphere）
  value: item.count,             // 数值高度
  positionBy: {
    value: item.color,           // 分组依据（颜色）
    axis: 'horizontal',
  },
  foregroundStyleBy: item.color, // 应用不同颜色
  cornerRadius: 8,
}))
```

## 完整示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarChart marks={list} />
</Chart>
```

该图表将以颜色为分组单位，每组包含三种类型（Cube、Sphere、Pyramid）的柱状条，每种颜色对应一组条，并应用统一的颜色样式。

## 适用场景

此类分组柱状图适用于：

- 展示主分类下的子分类对比（例如不同行业中不同岗位数量对比）。
- 展示结构化数据的分布情况。
- 强调多个子类在各分组中的占比和数量。



---
url: /v2/zh/guide/Views/Charts/BarGroupChart/index_example.md
---

# 示例

```tsx
import { BarChart, BarChartProps, Button, Chart, Navigation, NavigationStack, Script, VStack, useMemo } from "scripting"

const data = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Green", type: "Sphere", count: 0 },
  { color: "Green", type: "Pyramid", count: 1 },
  { color: "Purple", type: "Cube", count: 1 },
  { color: "Purple", type: "Sphere", count: 1 },
  { color: "Purple", type: "Pyramid", count: 1 },
  { color: "Pink", type: "Cube", count: 1 },
  { color: "Pink", type: "Sphere", count: 2 },
  { color: "Pink", type: "Pyramid", count: 0 },
  { color: "Yellow", type: "Cube", count: 1 },
  { color: "Yellow", type: "Sphere", count: 1 },
  { color: "Yellow", type: "Pyramid", count: 2 },
]

function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()

  const list = useMemo(() => {
    return data.map(item => ({
      label: item.type,
      value: item.count,
      positionBy: {
        value: item.color,
        axis: 'horizontal',
      },
      foregroundStyleBy: item.color,
      cornerRadius: 8,
    }) as BarChartProps["marks"][0])
  }, [])

  return <NavigationStack>
    <VStack
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <Chart
        frame={{
          height: 400
        }}
      >
        <BarChart
          marks={list}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  // Present view.
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/BarStackChart/index.md
---

# 堆叠柱状图（BarStackChart）

`BarStackChart`（堆叠柱状图）组件用于将多个子分类的数据值以堆叠条形的方式展现在同一个主分类下，便于对比每组数据的总量及其组成部分。每条柱状条会被拆分为多个颜色段，每段代表一个子分类。

## 场景示例

本示例展示了按玩具形状（`Cube`、`Sphere`、`Pyramid`）分组的数据，每组下根据颜色（`Green`、`Purple`、`Pink`、`Yellow`）堆叠显示各颜色的数量占比。

## 使用示例

```tsx
<Chart frame={{ height: 400 }}>
  <BarStackChart
    labelOnYAxis={false}
    marks={[
      { label: "Cube", value: 2, category: "Green" },
      { label: "Cube", value: 1, category: "Purple" },
      ...
    ]}
  />
</Chart>
```

## 属性说明

### `labelOnYAxis?: boolean`

- 设置为 `true` 时，分类标签显示在 **Y 轴**，图表呈 **横向柱状图**。
- 设置为 `false`（默认值）时，标签显示在 **X 轴**，图表呈 **纵向柱状图**。

### `marks: Array<object>` **（必填）**

每个数据项代表堆叠柱中的一个区块，包含以下字段：

- `label: string | Date`
  主分类标签，用于将多个子分类堆叠在同一条柱状图上（例如 `"Cube"`、`"Sphere"`）。

- `category: string`
  子分类标识，用于区分堆叠条形的不同组成部分（例如颜色：`"Green"`、`"Pink"`）。

- `value: number`
  数值，决定堆叠部分的高度或长度。

- `unit?: CalendarComponent`
  （可选）用于时间序列的单位。

- 其他可选的 `ChartMarkProps` 样式属性，支持个性化设置，如：

  - `foregroundStyle`（前景样式）
  - `cornerRadius`（圆角）
  - `symbol`（标记）
  - `annotation`（注释）
  - 等其他可视化属性

## 完整示例

```tsx
const data = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Purple", type: "Cube", count: 1 },
  ...
]

<BarStackChart
  labelOnYAxis={labelOnYAxis}
  marks={data.map(item => ({
    label: item.type,
    value: item.count,
    category: item.color,
  }))}
/>
```

## 布局切换

示例中提供了 `Toggle` 开关，可动态切换柱状图的显示方向（横向或纵向），通过控制 `labelOnYAxis` 实现。

## 执行视图

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}
```

## 适用场景

`BarStackChart` 适合用于以下场景：

- 展示各分类下的组成部分及总量对比
- 可视化每组数据中子项的占比关系
- 比较多个项目中相同结构的变化趋势



---
url: /v2/zh/guide/Views/Charts/BarStackChart/index_example.md
---

# 示例

```tsx
import { BarStackChart, Chart, List, Navigation, NavigationStack, Script, Section, Toggle, useState, } from "scripting"

type ToyShape = {
  color: string
  type: string
  count: number
}

const toyWithColorData: ToyShape[] = [
  { color: "Green", type: "Cube", count: 2 },
  { color: "Green", type: "Sphere", count: 0 },
  { color: "Green", type: "Pyramid", count: 1 },
  { color: "Purple", type: "Cube", count: 1 },
  { color: "Purple", type: "Sphere", count: 1 },
  { color: "Purple", type: "Pyramid", count: 1 },
  { color: "Pink", type: "Cube", count: 1 },
  { color: "Pink", type: "Sphere", count: 2 },
  { color: "Pink", type: "Pyramid", count: 0 },
  { color: "Yellow", type: "Cube", count: 1 },
  { color: "Yellow", type: "Sphere", count: 1 },
  { color: "Yellow", type: "Pyramid", count: 2 },
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"BarStackChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart
        frame={{
          height: 400
        }}
      >
        <BarStackChart
          labelOnYAxis={labelOnYAxis}
          marks={toyWithColorData.map(toy => ({
            label: toy.type,
            value: toy.count,
            category: toy.color,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/DonutChart/index.md
---

# 环形图（DonutChart）

`DonutChart`（环形图）组件用于以圆环的形式展示各分类在整体中的占比。每一个扇形区域代表一个数据项，角度大小与其数值成比例。相比传统的饼图，`DonutChart` 中央有一个空心区域，视觉上更清晰且易于叠加标签或图标。

## 属性

### `marks: Array<object>` **（必填）**

用于定义每个环形扇区的数据项。每个标记包含以下字段：

***

### `category: string`

分类名称，表示该扇区所属的标签（例如产品名、地区等）。

### `value: number`

用于计算该扇区的角度，数值越大，所占比例越大。角度将与该值在所有值中的占比成正比。

***

### `innerRadius?: MarkDimension`

**内半径**，即环形中间空心区域的大小。

- 格式如下：

  ```ts
  {
    type: 'ratio' | 'inset';
    value: number;
  }
  ```

- `type: 'ratio'`
  使用外半径的比例（如 `0.618`）表示内半径大小。

- `type: 'inset'`
  表示从外边缘向内缩进的固定距离（单位为 pt）。

***

### `outerRadius?: MarkDimension`

**外半径**，控制每个扇区向外延伸的范围。

- 格式如下：

  ```ts
  {
    type: 'inset';
    value: number;
  }
  ```

- `type: 'inset'`
  指定从绘图区域边缘向内缩进的距离。

***

### `angularInset?: number`

设置每个扇区之间的间隙角度（单位为度），可用于增加视觉分隔效果或实现圆角扇形。

***

### 继承自 `ChartMarkProps`

还支持所有 `ChartMarkProps` 提供的样式和行为属性，包括：

- `foregroundStyle` – 设置扇区颜色
- `annotation` – 为扇区添加标签或图标
- `opacity`、`cornerRadius`、`offset`、`shadow` 等

## 示例代码

```tsx
<DonutChart
  marks={data.map(item => ({
    category: item.name,
    value: item.sales,
    innerRadius: {
      type: 'ratio',
      value: 0.618
    },
    outerRadius: {
      type: 'inset',
      value: 10
    },
    angularInset: 1
  }))}
/>
```

## 适用场景

- 展示不同产品的销售占比
- 可视化市场份额、人口结构等整体分布
- 对多个分类在总体中的比例进行对比



---
url: /v2/zh/guide/Views/Charts/DonutChart/index_example.md
---

# 示例

```tsx
import { Chart, DonutChart, Navigation, NavigationStack, Script, VStack } from "scripting"

let data = [
  { name: "Cachapa", sales: 9631 },
  { name: "Crêpe", sales: 6959 },
  { name: "Injera", sales: 4891 },
  { name: "Jian Bing", sales: 2506 },
  { name: "American", sales: 1777 },
  { name: "Dosa", sales: 625 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"DonutChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <DonutChart
          marks={
            data.map(item => ({
              category: item.name,
              value: item.sales,
              innerRadius: {
                type: 'ratio',
                value: 0.618
              },
              outerRadius: {
                type: 'inset',
                value: 10,
              },
              angularInset: 1,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/HeatMapChart/index.md
---

# 热力图（HeatMapChart）

`HeatMapChart`（热力图）组件用于以网格形式展示二维数据的分布情况，其中每个单元格的颜色深浅表示该位置对应的数值大小。非常适合用于可视化两个分类维度之间的关系、频率或强度。

## 使用示例

```tsx
<Chart
  aspectRatio={{
    value: 1,
    contentMode: 'fit'
  }}
>
  <HeatMapChart
    marks={[
      { x: "+", y: "+", value: 125 },
      { x: "+", y: "-", value: 10 },
      { x: "-", y: "-", value: 80 },
      { x: "-", y: "+", value: 1 },
    ]}
  />
</Chart>
```

## 属性说明

### `marks: Array<object>` **（必填）**

每个项表示热力图中的一个网格单元，包括其位置（X/Y 坐标）和用于计算颜色强度的数值。

#### 字段：

- `x: string`
  横轴坐标（例如某个分类或标签）。

- `y: string`
  纵轴坐标（例如另一分类或标签）。

- `value: number`
  该坐标点对应的数值，用于映射颜色的深浅。数值越大，颜色通常越深或越饱和。

- 继承自 `ChartMarkProps` 的其他样式属性：
  支持进一步的样式配置，包括：

  - `foregroundStyle`（前景颜色）
  - `opacity`（透明度）
  - `annotation`（注释）
  - `cornerRadius`（圆角）
  - `zIndex` 等

## 适用场景

`HeatMapChart` 适用于以下数据可视化需求：

- 展示相关性矩阵（correlation matrix）
- 分析两个分类维度之间的分布关系
- 可视化频率、密度或绩效指标的强弱分布

## 完整示例

```tsx
const data = [
  { positive: "+", negative: "+", num: 125 },
  { positive: "+", negative: "-", num: 10 },
  { positive: "-", negative: "-", num: 80 },
  { positive: "-", negative: "+", num: 1 },
]

<HeatMapChart
  marks={data.map(item => ({
    x: item.positive,
    y: item.negative,
    value: item.num,
  }))}
/>
```



---
url: /v2/zh/guide/Views/Charts/HeatMapChart/index_example.md
---

# 示例

```tsx
import { Chart, HeatMapChart, Navigation, NavigationStack, Script, VStack } from "scripting"

const data = [
  { positive: "+", negative: "+", num: 125 },
  { positive: "+", negative: "-", num: 10 },
  { positive: "-", negative: "-", num: 80 },
  { positive: "-", negative: "+", num: 1 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"HeatMapChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        aspectRatio={{
          value: 1,
          contentMode: 'fit'
        }}
      >
        <HeatMapChart
          marks={
            data.map(item => ({
              x: item.positive,
              y: item.negative,
              value: item.num,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/LineCategoryChart/index.md
---

# 分类折线图（LineCategoryChart）

`LineCategoryChart` 是一款用于展示多类别折线图的组件，支持在共享的标签轴上，对多个分类的数值趋势进行对比。每条折线代表一个分类，其在每个标签上的数值以点连接成线。

此图表非常适合可视化多个子类别（如产品线、部门、地区）在某些阶段、步骤或时间点上的对比和变化趋势。

***

## 示例场景

本示例展示了多个部门（如 `Production`、`Marketing`、`Finance`）的数值表现，并通过三条线分别代表不同的产品分类（`Gizmos`、`Gadgets`、`Widgets`）。

***

## 使用方式

```tsx
<LineCategoryChart
  labelOnYAxis={false}
  marks={[
    { label: "Production", value: 4000, category: "Gizmos" },
    { label: "Marketing", value: 2000, category: "Gizmos" },
    ...
  ]}
/>
```

***

## 属性说明

### `labelOnYAxis?: boolean`

- 如果为 `true`，标签（如 `"Production"`、`"Marketing"`）显示在 **Y 轴**，折线图将以 **横向** 展示。
- 默认为 `false`，标签显示在 **X 轴**，折线图以 **纵向** 展示。

***

### `marks: Array<object>` **（必填）**

每个数据项表示图表中的一个点，需包含以下字段：

- `label: string | Date`
  标签轴的值（例如：阶段、部门、月份），所有分类共享此轴。

- `value: number`
  此分类在该标签位置上的数值。

- `category: string`
  分类标识，相同分类的点将自动连接成一条折线。

此外还支持 `ChartMarkProps` 中的样式扩展字段，如：

- `foregroundStyle`（颜色）
- `symbol`（标记符号）
- `annotation`（注释）等

***

## 完整示例

```tsx
const data = [
  { label: "Production", value: 4000, category: "Gizmos" },
  { label: "Marketing", value: 2000, category: "Gizmos" },
  { label: "Finance", value: 2000.5, category: "Gizmos" },

  { label: "Production", value: 5000, category: "Gadgets" },
  { label: "Marketing", value: 1000, category: "Gadgets" },
  { label: "Finance", value: 3000, category: "Gadgets" },

  { label: "Production", value: 6000, category: "Widgets" },
  { label: "Marketing", value: 5000.9, category: "Widgets" },
  { label: "Finance", value: 5000, category: "Widgets" },
]

<LineCategoryChart
  labelOnYAxis={labelOnYAxis}
  marks={data}
/>
```

***

## 适用场景

`LineCategoryChart` 适合用于：

- 展示多个分类在各阶段的趋势对比
- 可视化结构化标签（如月份、部门、步骤）上的分类数据演变
- 比较多维业务指标（如营收、预算、产能等）的走势



---
url: /v2/zh/guide/Views/Charts/LineCategoryChart/index_example.md
---

# 示例

```tsx
import { Chart, LineCategoryChart, List, Navigation, NavigationStack, Script, Section, Toggle, useState } from "scripting"

const data = [
  { label: "Production", value: 4000, category: "Gizmos" },
  { label: "Production", value: 5000, category: "Gadgets" },
  { label: "Production", value: 6000, category: "Widgets" },
  { label: "Marketing", value: 2000, category: "Gizmos" },
  { label: "Marketing", value: 1000, category: "Gadgets" },
  { label: "Marketing", value: 5000.9, category: "Widgets" },
  { label: "Finance", value: 2000.5, category: "Gizmos" },
  { label: "Finance", value: 3000, category: "Gadgets" },
  { label: "Finance", value: 5000, category: "Widgets" },
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"LineCategoryChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart
        frame={{
          height: 300
        }}
      >
        <LineCategoryChart
          labelOnYAxis={labelOnYAxis}
          marks={data}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/LineChart/index.md
---

# 折线图（LineChart）

`LineChart`（折线图）组件用于在一组带标签的离散点之间绘制一条连续的折线，适合用于展示简单趋势、变化过程或阶段对比。
该组件的 API 与 `BarChart` 相同，适合用于单条折线的基础可视化。

***

## 示例场景

本示例展示了三种玩具形状（`Cube`、`Sphere`、`Pyramid`）的数量变化。用户可以通过切换 `labelOnYAxis` 控制折线图的横向或纵向布局。

***

## 使用示例

```tsx
<Chart>
  <LineChart
    labelOnYAxis={false}
    marks={[
      { label: "Cube", value: 5 },
      { label: "Sphere", value: 4 },
      { label: "Pyramid", value: 4 },
    ]}
  />
</Chart>
```

***

## 属性说明

### `labelOnYAxis?: boolean`

- 设置为 `true` 时，标签显示在 **Y 轴**，折线将以 **横向** 方式绘制。
- 默认为 `false`，标签显示在 **X 轴**，折线以 **纵向** 方式绘制。

***

### `marks: Array<object>` **（必填）**

每个标记代表图上的一个数据点，包含以下字段：

- `label: string | Date`
  点所对应的标签（如分类、时间点等）。

- `value: number`
  此标签下对应的数值。

- 也支持 `ChartMarkProps` 中的其他样式字段，例如：

  - `foregroundStyle`（颜色）
  - `symbol`（标记图形）
  - `annotation`（注释）
  - `cornerRadius`（圆角）
  - `opacity` 等

***

## 完整示例

```tsx
const toysData = [
  { type: "Cube", count: 5 },
  { type: "Sphere", count: 4 },
  { type: "Pyramid", count: 4 },
]

<LineChart
  marks={toysData.map(toy => ({
    label: toy.type,
    value: toy.count,
  }))}
/>
```

***

## 适用场景

`LineChart` 适用于以下情况：

- 展示标签序列下的基本趋势或阶段变化
- 表示单一维度随时间或分类的变化
- 构建清晰、简洁的折线可视化图表



---
url: /v2/zh/guide/Views/Charts/LineChart/index_example.md
---

# 示例

```tsx
import { Chart, LineChart, List, Navigation, NavigationStack, Script, Section, Toggle, useState, } from "scripting"

type ToyShape = {
  type: string
  count: number
}

const toysData: ToyShape[] = [
  {
    type: "Cube",
    count: 5,
  },
  {
    type: "Sphere",
    count: 4,
  },
  {
    type: "Pyramid",
    count: 4
  }
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"LineChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart>
        <LineChart
          labelOnYAxis={labelOnYAxis}
          marks={toysData.map(toy => ({
            label: toy.type,
            value: toy.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/Multiple Charts Example/index.md
---

# 多个图表示例

本示例展示了如何在同一个图表中结合多种图表类型（折线图、面积图、参考线图），并根据用户交互动态展示注解内容，打造具有交互性的可视化图表。

## 示例代码

```tsx
const data = [
  { sales: 1200, year: '2020', growth: 0.14, },
  { sales: 1400, year: '2021', growth: 0.16, },
  { sales: 2000, year: '2022', growth: 0.42, },
  { sales: 2500, year: '2023', growth: 0.25, },
  { sales: 3600, year: '2024', growth: 0.44, },
]

function Example() {
  const [chartSelection, setChartSelection] = useState<string | null>()
  const selectedItem = useMemo(() => {
    if (chartSelection == null) {
      return null
    }
    return data.find(item => item.year === chartSelection)
  }, [chartSelection])

  return <NavigationStack>
    <VStack
      navigationTitle={"Multiple Charts"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Text>
        Press and move on the chart to view the details.
      </Text>
      <Chart
        frame={{
          height: 300,
        }}
        chartXSelection={{
          value: chartSelection,
          onChanged: setChartSelection,
          valueType: "string"
        }}
      >
        <LineChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            symbol: "circle",
          }))}
        />
        <AreaChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            foregroundStyle: ["rgba(255,100,0,1)", "rgba(255,100,0,0.2)"]
          }))}
        />
        {selectedItem != null
          ? <RuleLineForLabelChart
            marks={[{
              label: selectedItem.year,
              foregroundStyle: { color: "gray", opacity: 0.5 },
              annotation: {
                position: "top",
                overflowResolution: {
                  x: "fit",
                  y: "disabled"
                },
                content: <ZStack
                  padding
                  background={
                    <RoundedRectangle
                      cornerRadius={4}
                      fill={"regularMaterial"}
                    />
                  }
                >
                  <Text
                    foregroundStyle={"white"}
                  >Sales: {selectedItem.sales}</Text>
                </ZStack>
              }
            }]}
          />
          : null}
      </Chart>
    </VStack>
  </NavigationStack>
}
```

## 总览

本示例中使用了以下组件：

- [`LineChart`](#折线图)：绘制离散点并以平滑曲线连接。
- [`AreaChart`](#面积图)：在曲线下方填充区域，增强视觉效果。
- [`RuleLineForLabelChart`](#标签参考线图)：在选中的标签位置绘制参考线并添加注解。
- `chartXSelection`：启用用户在图表上的交互选择。

***

## 数据格式

本示例使用的数据结构如下：

```ts
const data = [
  { sales: 1200, year: '2020', growth: 0.14 },
  { sales: 1400, year: '2021', growth: 0.16 },
  { sales: 2000, year: '2022', growth: 0.42 },
  { sales: 2500, year: '2023', growth: 0.25 },
  { sales: 3600, year: '2024', growth: 0.44 },
]
```

每条数据包含：

- `sales`：销售额，作为主要数值
- `year`：年份，用作 X 轴标签
- `growth`：增长率（本例未用于图表展示）

***

## 主要功能

### 图表选择功能

```tsx
chartXSelection={{
  value: chartSelection,
  onChanged: setChartSelection,
  valueType: "string"
}}
```

- 允许用户在图表上点击或拖动，选中某个横轴标签（`year`）。
- 使用 `setChartSelection` 设置当前选择项。

### 折线图（LineChart）

```tsx
<LineChart
  marks={data.map(item => ({
    label: item.year,
    value: item.sales,
    interpolationMethod: "catmullRom",
    symbol: "circle",
  }))}
/>
```

- 以圆形符号表示每个数据点，并用平滑曲线连接。
- 使用 `"catmullRom"` 插值方法使曲线更自然平滑。

### 面积图（AreaChart）

```tsx
<AreaChart
  marks={data.map(item => ({
    label: item.year,
    value: item.sales,
    interpolationMethod: "catmullRom",
    foregroundStyle: ["rgba(255,100,0,1)", "rgba(255,100,0,0.2)"]
  }))}
/>
```

- 覆盖在折线图之下的区域，增强趋势的视觉表达。
- 应用了从橙色不透明到透明的渐变填充。

### 标签参考线图（RuleLineForLabelChart）

```tsx
<RuleLineForLabelChart
  marks={[{
    label: selectedItem.year,
    foregroundStyle: { color: "gray", opacity: 0.5 },
    annotation: {
      position: "top",
      overflowResolution: { x: "fit", y: "disabled" },
      content: <ZStack
        padding
        background={<RoundedRectangle cornerRadius={4} fill={"regularMaterial"} />}
      >
        <Text foregroundStyle={"white"}>Sales: {selectedItem.sales}</Text>
      </ZStack>
    }
  }]}
/>
```

- 在用户选中的年份上绘制一条灰色参考线。
- 上方浮动注解展示销售额数据。
- 使用 `ZStack` 和 `RoundedRectangle` 构建注解背景样式。

***

## 交互流程

1. 用户触摸图表。
2. 系统根据触摸位置更新 `chartSelection`。
3. 使用 `useMemo` 查找对应的数据项。
4. 在相应位置绘制参考线。
5. 展示注解气泡显示详细数据（如 `Sales: 2500`）。

***

## 总结

通过本示例你可以学习如何：

- 在同一图表中组合多个图表（如折线图、面积图、参考线图）。
- 通过 `chartXSelection` 响应用户交互。
- 使用 `annotation` 显示动态注解内容。
- 利用渐变、透明度、圆角背景等样式增强展示效果。

该模式非常适合用于数据仪表盘、年度报告等需要交互性和可视化解释的数据展示场景。



---
url: /v2/zh/guide/Views/Charts/Multiple Charts Example/index_example.md
---

# 示例

```tsx
import { AreaChart, Chart, LineChart, Navigation, NavigationStack, RoundedRectangle, RuleLineForLabelChart, Script, Text, useMemo, useState, VStack, ZStack } from "scripting"

const data = [
  { sales: 1200, year: '2020', growth: 0.14, },
  { sales: 1400, year: '2021', growth: 0.16, },
  { sales: 2000, year: '2022', growth: 0.42, },
  { sales: 2500, year: '2023', growth: 0.25, },
  { sales: 3600, year: '2024', growth: 0.44, },
]

function Example() {
  const [chartSelection, setChartSelection] = useState<string | null>()
  const selectedItem = useMemo(() => {
    if (chartSelection == null) {
      return null
    }
    return data.find(item => item.year === chartSelection)
  }, [chartSelection])

  return <NavigationStack>
    <VStack
      navigationTitle={"Multiple Charts"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Text>
        Press and move on the chart to view the details.
      </Text>
      <Chart
        frame={{
          height: 300,
        }}
        chartXSelection={{
          value: chartSelection,
          onChanged: setChartSelection,
          valueType: "string"
        }}
      >
        <LineChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            symbol: "circle",
          }))}
        />
        <AreaChart
          marks={data.map(item => ({
            label: item.year,
            value: item.sales,
            interpolationMethod: "catmullRom",
            foregroundStyle: ["rgba(255,100,0,1)", "rgba(255,100,0,0.2)"]
          }))}
        />
        {selectedItem != null
          ? <RuleLineForLabelChart
            marks={[{
              label: selectedItem.year,
              foregroundStyle: { color: "gray", opacity: 0.5 },
              annotation: {
                position: "top",
                overflowResolution: {
                  x: "fit",
                  y: "disabled"
                },
                content: <ZStack
                  padding
                  background={
                    <RoundedRectangle
                      cornerRadius={4}
                      fill={"regularMaterial"}
                    />
                  }
                >
                  <Text
                    foregroundStyle={"white"}
                  >Sales: {selectedItem.sales}</Text>
                </ZStack>
              }
            }]}
          />
          : null}
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/PieChart/index.md
---

# 饼图（PieChart）

`PieChart`（饼图）组件用于以圆形扇区的方式展示各分类在整体中的占比。每一个扇区代表一个分类，其角度根据该分类对应数值在总值中的占比自动计算，适合用于展示比例、分布或市场份额等数据。

***

## 使用示例

```tsx
<PieChart
  marks={[
    { category: "Cachapa", value: 9631 },
    { category: "Crêpe", value: 6959 },
    { category: "Injera", value: 4891 },
    ...
  ]}
/>
```

***

## 属性说明

### `marks: Array<object>` **（必填）**

定义图表中每一个扇区的数据项。

每个数据项需包含以下字段：

- `category: string`
  分类标签，用于标识该扇区所代表的内容（例如产品名称、国家、类型等）。

- `value: number`
  数值，用于计算该分类所占的角度比例。所有值会被加总，并按比例生成各扇区。

- 支持继承 `ChartMarkProps` 中的可选样式属性，包括：

  - `foregroundStyle`（前景颜色样式）
  - `annotation`（注释或标签）
  - `opacity`（透明度）
  - `cornerRadius`（圆角）
  - `zIndex`（绘制层级）等

***

## 完整示例

```tsx
const data = [
  { name: "Cachapa", sales: 9631 },
  { name: "Crêpe", sales: 6959 },
  { name: "Injera", sales: 4891 },
  { name: "Jian Bing", sales: 2506 },
  { name: "American", sales: 1777 },
  { name: "Dosa", sales: 625 },
]

<PieChart
  marks={data.map(item => ({
    category: item.name,
    value: item.sales
  }))}
/>
```

***

## 适用场景

`PieChart` 适合用于：

- 展示固定分类的占比关系
- 表达销售构成、投票分布、市场份额等
- 可视化整体数据在不同部分间的拆分情况



---
url: /v2/zh/guide/Views/Charts/PieChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, PieChart, Script, VStack } from "scripting"

let data = [
  { name: "Cachapa", sales: 9631 },
  { name: "Crêpe", sales: 6959 },
  { name: "Injera", sales: 4891 },
  { name: "Jian Bing", sales: 2506 },
  { name: "American", sales: 1777 },
  { name: "Dosa", sales: 625 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"PieChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <PieChart
          marks={
            data.map(item => ({
              category: item.name,
              value: item.sales,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}


async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/PointCategoryChart/index.md
---

# 分类点状图（PointCategoryChart）

`PointCategoryChart`（分类点图）组件用于在二维平面上绘制带有分类信息的数据点，并支持通过颜色、图形符号或符号大小来区分不同分类。适用于展示分组散点图、调查数据、或多分类指标对比等可视化场景。

***

## 使用示例

```tsx
<PointCategoryChart
  representsDataUsing="foregroundStyle"
  marks={[
    { category: "Apple", x: 10, y: 42 },
    { category: "Apple", x: 20, y: 37 },
    { category: "Orange", x: 30, y: 62 },
    ...
  ]}
/>
```

***

## 属性说明

### `marks: Array<object>` **（必填）**

每个标记表示图表上的一个数据点，需包含以下字段：

- `x: number`
  横轴数值（例如年龄、时间、评分等）。

- `y: number`
  纵轴数值（例如数量、比例、次数等）。

- `category: string`
  分类标识。不同分类的数据点会通过图形、颜色或大小加以区分。

- 支持继承 `ChartMarkProps` 的其他样式属性，包括：

  - `foregroundStyle`（颜色）
  - `symbol`（点形状）
  - `symbolSize`（点大小）
  - `annotation`（注释）
  - `opacity`、`offset`、`zIndex` 等

***

### `representsDataUsing?: "foregroundStyle" | "symbol" | "symbolSize"`

用于控制图表如何视觉区分不同分类的数据点：

- `"foregroundStyle"`：通过颜色区分分类
- `"symbol"`：通过不同形状的符号（如圆形、方形）区分分类
- `"symbolSize"`：通过符号大小表现分类或数值差异

> 该属性是 `foregroundStyleBy`、`symbolBy` 或 `symbolSizeBy` 的简化替代方案。

***

## 完整示例

```tsx
const favoriteFruitsData = [
  { fruit: "Apple", age: 10, count: 42 },
  { fruit: "Apple", age: 20, count: 37 },
  ...
]

<PointCategoryChart
  representsDataUsing="symbol"
  marks={favoriteFruitsData.map(item => ({
    category: item.fruit,
    x: item.age,
    y: item.count,
  }))}
/>
```

你可以通过 `<Picker>` 控件动态选择 `representsDataUsing` 的显示方式，以改变分类的可视化方式。

***

## 适用场景

`PointCategoryChart` 适合用于以下场景：

- 多分类数据在二维坐标中的对比展示
- 可视化多维调查数据或打分结果
- 通过符号特征突出分类差异性
- 构建具有视觉分组效果的散点图



---
url: /v2/zh/guide/Views/Charts/PointCategoryChart/index_example.md
---

# 示例

```tsx
import { Chart, List, Navigation, NavigationStack, Picker, PointCategoryChart, Script, Text, useState, VStack } from "scripting"

const favoriteFruitsData = [
  { fruit: 'Apple', age: 10, count: 42 },
  { fruit: 'Apple', age: 20, count: 37 },
  { fruit: 'Apple', age: 30, count: 11 },

  { fruit: 'Bananer', age: 10, count: 23 },
  { fruit: 'Bananer', age: 20, count: 58 },
  { fruit: 'Bananer', age: 30, count: 79 },

  { fruit: 'Orange', age: 10, count: 36 },
  { fruit: 'Orange', age: 20, count: 24 },
  { fruit: 'Orange', age: 30, count: 62 },
]

function Example() {
  const [representsDataUsing, setRepresentsDataUsing] = useState<string>('foregroundStyle')
  const options: string[] = [
    'foregroundStyle',
    'symbol',
    'symbolSize'
  ]

  return <NavigationStack>
    <List
      navigationTitle={"PointCategoryChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Picker
        title={"representsDataUsing"}
        value={representsDataUsing}
        onChanged={setRepresentsDataUsing}
        pickerStyle={"menu"}
      >
        {options.map(option =>
          <Text tag={option}>{option}</Text>
        )}
      </Picker>
      <Chart
        frame={{
          height: 300
        }}
      >
        <PointCategoryChart
          representsDataUsing={representsDataUsing as any}
          marks={favoriteFruitsData.map(item => ({
            category: item.fruit,
            x: item.age,
            y: item.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/PointChart/index.md
---

# 点状图（PointChart）

`PointChart`（点图）组件用于在二维坐标系中绘制一组独立的数值点，即经典的散点图。每个点由一个 `(x, y)` 数值对表示，可通过样式属性进一步自定义其外观。

该组件适用于可视化两个连续变量之间的关系、分布或数值测量结果。

***

## 使用示例

```tsx
<PointChart
  marks={[
    { x: 0, y: 2 },
    { x: 1, y: 3 },
    { x: 2, y: 4 },
    { x: 3, y: 3 },
    { x: 4, y: 6 },
  ]}
/>
```

***

## 属性说明

### `marks: Array<object>` **（必填）**

定义要绘制的所有点。每个点包含以下字段：

- `x: number`
  点在 X 轴上的位置。

- `y: number`
  点在 Y 轴上的位置。

可选地，您还可以通过 `ChartMarkProps` 提供更多自定义属性：

- `symbol`：点的形状（如圆形、方形等）
- `foregroundStyle`：点的颜色
- `symbolSize`：点的大小
- 其他属性如 `opacity`（透明度）、`annotation`（注释）、`offset`（偏移）、`zIndex` 等

***

## 完整示例

```tsx
const data = [
  { x: 0, y: 2 },
  { x: 1, y: 3 },
  { x: 2, y: 4 },
  { x: 3, y: 3 },
  { x: 4, y: 6 },
]

<PointChart marks={data} />
```

上述示例将在坐标系中绘制 5 个点，构成一个基础的散点图。

***

## 适用场景

`PointChart` 适合以下场景：

- 显示两个连续变量之间的关系（如相关性）
- 表示实验数据、坐标点或数值测量结果
- 创建简洁的散点图，可叠加注释或符号样式



---
url: /v2/zh/guide/Views/Charts/PointChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, PointChart, Script, VStack } from "scripting"

const data = [
  { x: 0, y: 2 },
  { x: 1, y: 3 },
  { x: 2, y: 4 },
  { x: 3, y: 3 },
  { x: 4, y: 6 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"PointChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}>
        <PointChart
          marks={data}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/RangeAreaChart/index.md
---

# 范围面积图（RangeAreaChart）

`RangeAreaChart` 是一种范围区域图表组件，用于展示每个数据点的值区间，通常包括 `start` 和 `end` 值。它适合用来可视化温度范围、置信区间、最大值与最小值等。

***

## 使用示例

```tsx
<RangeAreaChart
  marks={[
    { label: "Jan", start: 0, end: 4 },
    { label: "Feb", start: 2, end: 6 },
    ...
  ]}
/>
```

***

## 属性（Props）

### `marks: Array<object>` **(必填)**

每个 `mark` 定义一个范围区间。

- `label: string | Date`
  对应 X 轴的标签，例如月份、类别名称或时间点。

- `start: number`
  范围的起始值（下界）。

- `end: number`
  范围的结束值（上界）。

- _(可选)_ 支持 `ChartMarkProps` 中的通用属性：

  - `foregroundStyle` – 区域的填充颜色
  - `opacity`、`interpolationMethod`、`annotation` 等

***

### `interpolationMethod?: string`

指定图表区域在点之间的插值方式。
例如，`'catmullRom'` 会生成光滑的曲线。

***

## 完整示例

```tsx
const weatherData = [
  { month: "Jan", min: 0, max: 4 },
  { month: "Feb", min: 2, max: 6 },
  ...
]

<RangeAreaChart
  marks={weatherData.map(item => ({
    label: item.month,
    start: item.min,
    end: item.max,
    interpolationMethod: "catmullRom"
  }))}
/>
```

这个示例以平滑曲线的形式绘制了每个月的温度范围。

***

## 适用场景

`RangeAreaChart` 特别适用于以下场景：

- 显示温度等物理量的时间范围变化
- 可视化统计中的置信区间
- 展示股票价格的最小/最大波动区间
- 表达预测结果的不确定性范围等



---
url: /v2/zh/guide/Views/Charts/RangeAreaChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, RangeAreaChart, Script, VStack } from "scripting"

const weatherData = [
  { month: 'Jan', min: 0, max: 4 },
  { month: 'Feb', min: 2, max: 6 },
  { month: 'Mar', min: 3, max: 8 },
  { month: 'Apr', min: 5, max: 10 },
  { month: 'May', min: 7, max: 14 },
  { month: 'Jun', min: 10, max: 25 },
  { month: 'Jul', min: 15, max: 30 },
  { month: 'Aug', min: 20, max: 33 },
  { month: 'Sep', min: 24, max: 35 },
  { month: 'Oct', min: 18, max: 30 },
  { month: 'Nov', min: 10, max: 23 },
  { month: 'Dec', min: 5, max: 10 },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"RangeAreaChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <RangeAreaChart
          marks={weatherData.map(item => ({
            label: item.month,
            start: item.min,
            end: item.max,
            interpolationMethod: 'catmullRom'
          }))}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/RectAreaChart/index.md
---

# 矩形面积图（RectAreaChart）

`RectAreaChart` 组件用于在二维图表中绘制矩形区域，适合用来突出显示特定区域、数据分布、容差区间或标注感兴趣的范围。可与其他图表（如 `PointChart`）叠加使用以增强可视化效果。

***

## 使用示例

```tsx
<RectAreaChart
  marks={[
    { xStart: 2.5, xEnd: 3.5, yStart: 4.5, yEnd: 5.5 },
    { xStart: 1.0, xEnd: 2.0, yStart: 1.0, yEnd: 2.0 },
  ]}
/>
```

***

## 属性（Props）

### `marks: Array<object>` **(必填)**

每个 `mark` 定义一个矩形区域，包含以下字段：

- `xStart: number`
  矩形在 X 轴上的起始值。

- `xEnd: number`
  矩形在 X 轴上的结束值。

- `yStart: number`
  矩形在 Y 轴上的起始值。

- `yEnd: number`
  矩形在 Y 轴上的结束值。

#### 可选通用属性（继承自 `ChartMarkProps`）：

- `opacity` – 设置矩形的透明度。
- `foregroundStyle` – 设置矩形的填充颜色或样式。
- `annotation` – 为该区域添加注释或标签。

***

## 完整示例

```tsx
const data = [
  { x: 5, y: 5 },
  { x: 2.5, y: 2.5 },
  { x: 3, y: 3 },
]

<RectAreaChart
  marks={data.map(item => ({
    xStart: item.x - 0.25,
    xEnd: item.x + 0.25,
    yStart: item.y - 0.25,
    yEnd: item.y + 0.25,
    opacity: 0.2,
  }))}
//>

<PointChart marks={data} />
```

此示例在每个点的周围绘制了一个半透明的矩形区域，表示误差范围或聚集区。

***

## 应用场景

- 在散点图上突出显示数据密集区域。
- 可视化特定值域范围或容差带。
- 表示测量误差或预测区间。
- 叠加图层展示用户关注区域。



---
url: /v2/zh/guide/Views/Charts/RectAreaChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, PointChart, RectAreaChart, Script, VStack } from "scripting"

const data = [
  { x: 5, y: 5 },
  { x: 2.5, y: 2.5 },
  { x: 3, y: 3 },
]

function Example() {
  return <NavigationStack>
    <VStack
      navigationTitle={"RectAreaChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <RectAreaChart
          marks={
            data.map(item => ({
              xStart: item.x - 0.25,
              xEnd: item.x + 0.25,
              yStart: item.y - 0.25,
              yEnd: item.y + 0.25,
              opacity: 0.2,
            }))
          }
        />

        <PointChart
          marks={data}
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/RectChart/index.md
---

# 矩形图（RectChart）

`RectChart` 是一个矩形条形图组件，用于可视化基于标签的数值数据。其用法与 `BarChart` 类似，使用相同的 `BarChartProps` 接口。

***

## 示例

```tsx
<RectChart
  labelOnYAxis={false}
  marks={[
    { label: "Cube", value: 5 },
    { label: "Sphere", value: 4 },
    { label: "Pyramid", value: 4 },
  ]}
/>
```

***

## 属性说明

### `labelOnYAxis`（可选）

- **类型：** `boolean`
- **默认值：** `false`
- **说明：**
  若设置为 `true`，标签将显示在 Y 轴上，图表将以横向条形展示；若为 `false`，标签位于 X 轴，显示为纵向条形。

***

### `marks`（必填）

- **类型：**
  `Array<{ label: string | Date; value: number; unit?: CalendarComponent } & ChartMarkProps>`
- **说明：**
  指定每个矩形条的标签和值。

#### 每个 mark 对象包含：

- `label`: 类别标签（如 "Cube"），用于坐标轴显示。
- `value`: 数值，决定矩形条的高度或宽度。
- `unit`: _(可选)_ 时间单位（如为时间序列数据时使用）。

此外，还可以使用继承自 `ChartMarkProps` 的可视属性，如：

- `foregroundStyle`: 设置颜色样式
- `cornerRadius`: 设置圆角
- `annotation`: 添加标注
- `opacity`: 设置透明度

***

## 完整示例

```tsx
const toysData = [
  { type: "Cube", count: 5 },
  { type: "Sphere", count: 4 },
  { type: "Pyramid", count: 4 },
]

<RectChart
  labelOnYAxis={true}
  marks={toysData.map(toy => ({
    label: toy.type,
    value: toy.count,
  }))}
/>
```

***

## 适用场景

- 分类数据的可视化对比
- 报表或仪表盘中的数量展示
- 替代传统柱状图的简洁矩形展示风格



---
url: /v2/zh/guide/Views/Charts/RectChart/index_example.md
---

# 示例

```tsx
import { Chart, List, Navigation, NavigationStack, RectChart, Script, Section, Toggle, useState } from "scripting"

type ToyShape = {
  type: string
  count: number
}

const toysData: ToyShape[] = [
  {
    type: "Cube",
    count: 5,
  },
  {
    type: "Sphere",
    count: 4,
  },
  {
    type: "Pyramid",
    count: 4
  }
]

function Example() {
  const [labelOnYAxis, setLabelOnYAxis] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"RectChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"labelOnYAxis"}
          value={labelOnYAxis}
          onChanged={setLabelOnYAxis}
        />
      </Section>
      <Chart>
        <RectChart
          labelOnYAxis={labelOnYAxis}
          marks={toysData.map(toy => ({
            label: toy.type,
            value: toy.count,
          }))}
        />
      </Chart>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/RuleChart/index.md
---

# 标尺图（RuleChart）

`RuleChart` 用于展示每个分类项的数值范围或持续时间。每条规则表示一个起始值和结束值的跨度，适用于展示周期、持续时间或数值范围的可视化数据。

***

## 示例

```tsx
<RuleChart
  labelOnYAxis
  marks={[
    { label: "Trees", start: 1, end: 10 },
    { label: "Grass", start: 3, end: 11 },
    { label: "Weeds", start: 4, end: 12 },
  ]}
/>
```

***

## 属性（Props）

### `labelOnYAxis`（可选）

- **类型：** `boolean`
- **默认值：** `false`
- **说明：**
  若设置为 `true`，图表会将分类标签放置在 Y 轴，并以横向方式展示每条规则（水平规则）。若为 `false`，则标签在 X 轴，规则为垂直方向。

***

### `marks`（必填）

- **类型：**

  ```ts
  Array<{
    label: string | Date;
    start: number;
    end: number;
    unit?: CalendarComponent;
  } & ChartMarkProps>
  ```
- **说明：**
  用于定义每条规则的起止范围。

#### 每项 mark 包含以下字段：

- `label`：分类标签或时间单位（如 `"Trees"` 或一个 `Date`）。
- `start`：规则的起始数值。
- `end`：规则的结束数值。
- `unit`：（可选）时间单位，如 `.month`、`.day`，用于表示基于时间的规则范围。

也可结合 `ChartMarkProps` 使用，支持以下自定义样式：

- `foregroundStyle` — 设置颜色或样式
- `annotation` — 添加标注标签
- `opacity` — 控制透明度

***

## 完整示例

```tsx
const data = [
  { startMonth: 1, numMonths: 9, source: "Trees" },
  { startMonth: 12, numMonths: 1, source: "Trees" },
  { startMonth: 3, numMonths: 8, source: "Grass" },
  { startMonth: 4, numMonths: 8, source: "Weeds" },
]

<RuleChart
  labelOnYAxis
  marks={data.map(item => ({
    start: item.startMonth,
    end: item.startMonth + item.numMonths,
    label: item.source,
  }))}
/>
```

***

## 适用场景

- 展示活动周期或生长季节（如花粉季）
- 显示任务或项目的起止时间
- 比较不同类别的数据范围



---
url: /v2/zh/guide/Views/Charts/RuleChart/index_example.md
---

# 示例

```tsx
import { Chart, Navigation, NavigationStack, RuleChart, Script, VStack } from "scripting"

const data = [
  { startMonth: 1, numMonths: 9, source: "Trees" },
  { startMonth: 12, numMonths: 1, source: "Trees" },
  { startMonth: 3, numMonths: 8, source: "Grass" },
  { startMonth: 4, numMonths: 8, source: "Weeds" },
]

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"RuleChart"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Chart
        frame={{
          height: 300
        }}
      >
        <RuleChart
          labelOnYAxis
          marks={
            data.map(item => ({
              start: item.startMonth,
              end: item.startMonth + item.numMonths,
              label: item.source,
            }))
          }
        />
      </Chart>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Charts/RuleLineForLabelChart.md
---

# 标签线图（RuleLineForLabelChart）

`RuleLineForLabelChart` 用于在图表中根据标签（或日期）位置绘制垂直或水平的参考线。通常与其他图表类型（如 `BarChart` 或 `LineChart`）配合使用，用于高亮特定的分类或时间点。

***

## 类型定义

```ts
declare const RuleLineForLabelChart: FunctionComponent<{
  /**
   * 是否在 Y 轴显示标签。如果为 true，则参考线将水平绘制。默认为 false（垂直绘制）。
   */
  labelOnYAxis?: boolean;

  /**
   * 参考线标记数组，每个标记表示在哪个标签或日期处绘制参考线。
   */
  marks: Array<{
    /**
     * 要绘制参考线的位置，可以是字符串标签或 Date 类型。
     */
    label: string | Date;

    /**
     * 可选，仅在 label 为 Date 类型时有效，指定日期单位（如 'month', 'day'）。
     */
    unit?: CalendarComponent;
  } & ChartMarkProps>;
}>;
```

***

## 属性说明

| 属性名            | 类型        | 说明                                         |
| -------------- | --------- | ------------------------------------------ |
| `labelOnYAxis` | `boolean` | 是否在 Y 轴绘制标签。为 `true` 时参考线为 **水平线**，默认为垂直线。 |
| `marks`        | `Array`   | 包含多个参考线定义的数组，每个参考线可以包含样式配置，如颜色、不透明度等。      |

每个 `marks` 项支持以下属性：

- `label`：要绘制参考线的位置（字符串或日期）。
- `unit`：可选，仅用于日期类型。
- `foregroundStyle`：可选，线条颜色。
- `opacity`：可选，线条透明度。
- `lineStyle`：可选，自定义虚线样式（如 `[3, 2]` 表示3个点的实线和2个点的空格交替）。

***

## 示例：在柱状图中标记关键分类

```tsx
import {
  Chart,
  RuleLineForLabelChart,
  BarChart,
  Navigation,
  NavigationStack,
  Script,
  VStack
} from "scripting"

const data = [
  { label: "Q1", value: 1500 },
  { label: "Q2", value: 2300 },
  { label: "Q3", value: 1800 },
  { label: "Q4", value: 2700 },
]

const referenceLines = [
  { label: "Q2", foregroundStyle: "blue", lineStyle: { dash: [3, 2] } },
  { label: "Q4", foregroundStyle: "red", opacity: 0.5 },
]

function Example() {
  return (
    <NavigationStack>
      <VStack
        navigationTitle="带参考线的柱状图"
        navigationBarTitleDisplayMode="inline"
      >
        <Chart frame={{ height: 300 }}>
          <BarChart marks={data} />
          <RuleLineForLabelChart marks={referenceLines} />
        </Chart>
      </VStack>
    </NavigationStack>
  )
}

async function run() {
  await Navigation.present({ element: <Example /> })
  Script.exit()
}

run()
```

***

## 典型用途

- 在时间轴中高亮关键事件或时间点。
- 在分类图中划分视觉区域。
- 表示特殊标签、阈值或比较基准。



---
url: /v2/zh/guide/Views/Charts/RuleLineForValueChart.md
---

# 值线图（RuleLineForValueChart）

`RuleLineForValueChart` 组件用于在图表上绘制一条或多条参考线（水平或垂直），基于指定的数值位置。常用于标示阈值、目标线或参考线，增强图表的可读性与数据对比。

***

## 使用示例

```tsx
<Chart>
  <RuleLineForValueChart
    marks={[
      { value: 50 },
      { value: 75, lineStyle: { dash: [2, 4] } },
    ]}
  />
</Chart>
```

上面的示例会绘制两条规则线：

- 在值为 `50` 的位置绘制一条实线
- 在值为 `75` 的位置绘制一条虚线，样式为 2 点实线 + 4 点间隔

***

## 参数说明

### `labelOnYAxis`（可选）

- **类型：** `boolean`
- **默认值：** `false`
- **说明：**
  是否在 Y 轴显示标签：

  - 若设为 `true`，线条将 **垂直显示**，标签显示在 Y 轴。
  - 若设为 `false`，线条将 **水平显示**，标签显示在 X 轴。

***

### `marks`（必填）

- **类型：**

  ```ts
  Array<{
    value: number;
  } & ChartMarkProps>
  ```
- **说明：**
  用于定义所有参考线的位置和样式。

#### `value`

- 要绘制规则线的数值位置。

#### 附加属性（继承 `ChartMarkProps`）：

你可以通过这些属性进一步自定义每条线的外观：

- `foregroundStyle`：设置颜色或渐变
- `opacity`：设置线条透明度
- `lineStyle`：设置线条样式（如虚线）

***

## 使用场景

- 标注统计阈值（如平均值、中位数）
- 标示上下限、控制范围
- 显示目标线、指标值

***

## 总结

`RuleLineForValueChart` 是一个简洁的叠加图组件，能够帮助你在任意图表中标注关键数值，使图表更加直观易读。它可以与其他图表类型（如 `BarChart`、`LineChart`、`PointChart` 等）搭配使用，提升数据展示的专业度与清晰度。



---
url: /v2/zh/guide/Views/ConcentricRectangle.md
---

# 同心圆矩形（ConcentricRectangle）

`ConcentricRectangle` 是 iOS 26+ 引入的一种**同心矩形（Concentric Rectangle）形状视图**，用于创建具有“向内递进圆角”特性的矩形结构。
该形状特别适合用于：

- 现代玻璃风格按钮
- 卡片容器背景
- 交互裁剪区域（命中测试形状）
- 玻璃过渡动画遮罩
- 动态层级 UI 结构

在 Scripting 中，`ConcentricRectangle` 既可以作为一个**独立 Shape 视图渲染**，也可以作为：

- `clipShape`
- `background`
- `contentShape`

中的**专用形状类型使用**。

***

## 一、ConcentricRectangle 基本定义

```ts
type ConcentricRectangleProps = ShapeProps & ConcentricRectangleShape

/**
 * A concentric rectangle aligned inside the frame of the view containing it.
 * @available iOS 26+.
 */
declare const ConcentricRectangle: FunctionComponent<ConcentricRectangleProps>
```

### 说明

- `ConcentricRectangle` 是一个标准 `Shape` 组件
- 同时支持：

  - 填充（fill）
  - 描边（stroke）
  - 路径裁剪（trim）
  - 复杂角样式控制（ConcentricRectangleShape）
- 该视图始终在其父视图的 `frame` 内部进行布局与渲染
- 仅支持 iOS 26 及以上系统

***

## 二、角样式系统：EdgeCornerStyle

`ConcentricRectangle` 的核心能力来自其角样式系统 `EdgeCornerStyle`，用于描述单个角的行为方式。

```ts
type EdgeCornerStyle =
  | {
      style: "fixed"
      radius: number
    }
  | {
      style: "concentric"
      minimum: number
    }
  | "concentric"
```

***

### 1. 固定圆角模式（fixed）

```ts
{
  style: "fixed"
  radius: number
}
```

用于创建传统固定半径圆角矩形。

参数说明：

| 参数       | 说明            |
| -------- | ------------- |
| `radius` | 固定圆角半径，单位为 pt |

该模式适合传统静态卡片、按钮等场景。

***

### 2. 同心递进圆角模式（concentric）

```ts
{
  style: "concentric"
  minimum: number
}
```

用于创建随尺寸递进变化的“同心圆角效果”。

参数说明：

| 参数        | 说明                       |
| --------- | ------------------------ |
| `minimum` | 最小内层圆角半径，系统会根据实际尺寸自动向外递进 |

该模式适用于：

- 玻璃按钮
- 动态尺寸卡片
- 层级叠加组件
- 动态动画遮罩

***

### 3. 简写模式

```ts
"concentric"
```

等价于：

```ts
{
  style: "concentric"
  minimum: 系统默认最小值
}
```

适用于无需手动控制最小值的快速使用场景。

***

## 三、ConcentricRectangleShape（角分布规则）

`ConcentricRectangleShape` 用于描述 **每个角是否统一控制，或分别控制**。
该类型支持 7 种结构组合模式。

***

### 1. 全角统一模式（最常用）

```ts
{
  corners: EdgeCornerStyle
  isUniform?: boolean
}
```

参数说明：

| 参数          | 说明                |
| ----------- | ----------------- |
| `corners`   | 应用于全部角的样式         |
| `isUniform` | 是否强制完全一致，默认 false |

示例：

```tsx
<ConcentricRectangle
  corners={{
    style: "concentric",
    minimum: 8
  }}
  fill="red"
/>
```

***

### 2. 四个角完全独立定义

```ts
{
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 不规则异形卡片
- 特殊边角 UI
- 半圆角容器

***

### 3. 底部统一角

```ts
{
  uniformBottomCorners?: EdgeCornerStyle
  topLeadingCorner?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 上直角，下圆角卡片
- 底部弹出面板背景

***

### 4. 顶部统一角

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  bottomLeadingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

适用于：

- 顶部弹窗
- 顶部玻璃标题栏

***

### 5. 顶部与底部统一组合

```ts
{
  uniformTopCorners?: EdgeCornerStyle
  uniformBottomCorners?: EdgeCornerStyle
}
```

***

### 6. 左侧统一角

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  topTrailingCorner?: EdgeCornerStyle
  bottomTrailingCorner?: EdgeCornerStyle
}
```

***

### 7. 左右统一组合

```ts
{
  uniformLeadingCorners?: EdgeCornerStyle
  uniformTrailingCorners?: EdgeCornerStyle
}
```

***

## 四、通用 Shape 属性（ShapeProps）

```ts
type ShapeProps = {
  trim?: {
    from: number
    to: number
  }

  fill?: ShapeStyle | DynamicShapeStyle

  stroke?: ShapeStyle | DynamicShapeStyle | {
    shapeStyle: ShapeStyle | DynamicShapeStyle
    strokeStyle: StrokeStyle
  }
}
```

***

### 1. trim（路径裁剪）

```ts
trim={{
  from: 0.0,
  to: 0.5
}}
```

用于路径绘制动画、环形裁剪、渐进描边等效果。

***

### 2. fill（填充）

```ts
fill="red"
fill="ultraThinMaterial"
```

支持：

- 纯色
- 动态材质
- 渐变样式

***

### 3. stroke（描边）

```ts
stroke="blue"

stroke={{
  shapeStyle: "blue",
  strokeStyle: {
    lineWidth: 2
  }
}}
```

***

## 五、ConcentricRectangle 在 View Modifiers 中的使用

### 1. 作为 clipShape 使用

```ts
clipShape?: Shape | "concentricRect" | ({
  type: "concentricRect"
} & ConcentricRectangleShape)
```

示例：

```tsx
<VStack
  clipShape={{
    type: "concentricRect",
    corners: {
      style: "concentric",
      minimum: 10
    }
  }}
/>
```

用于：

- 裁剪真实内容显示区域
- 玻璃过渡遮罩
- 动态蒙版

***

### 2. 作为 background 使用

```ts
background?: ShapeStyle | DynamicShapeStyle | {
  style: ShapeStyle | DynamicShapeStyle
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
} | VirtualNode | {
  content: VirtualNode
  alignment: Alignment
}
```

示例：

```tsx
<VStack
  background={{
    style: "ultraThinMaterial",
    shape: {
      type: "concentricRect",
      corners: "concentric"
    }
  }}
/>
```

***

### 3. 作为 contentShape 使用（命中测试区域）

```ts
contentShape?: Shape | {
  kind: ContentShapeKinds
  shape: Shape | "concentricRect" | ({
    type: "concentricRect"
  } & ConcentricRectangleShape)
}
```

用于控制点击、悬停、拖拽等交互命中区域。

***

## 六、完整示例解析

示例代码：

```tsx
<ZStack
  frame={{
    width: 300,
    height: 200
  }}
  containerShape={{
    type: "rect",
    cornerRadius: 32
  }}
>
  <ConcentricRectangle
    corners={{
      style: "concentric",
      minimum: 8
    }}
    fill="red"
  />
</ZStack>
```

该示例实现了：

- 外部容器为固定圆角矩形
- 内部使用同心递进圆角矩形
- 内外形成层级差异与视觉纵深感
- 红色填充用于强调 ConcentricRectangle 的实际形态

***

## 七、设计与实现注意事项

1. `minimum` 不应超过实际高度或宽度的一半
2. 同心圆角更适合与：

   - `glass`
   - `material`
   - `blur`
   - `opacity`
     等视觉效果配合使用
3. 作为 `contentShape` 使用时，仅影响点击区域，不影响视觉裁剪
4. 作为 `clipShape` 使用时，会真实裁剪子视图渲染内容



---
url: /v2/zh/guide/Views/Controls/ColorPicker/index.md
---

# 颜色选择器

`ColorPicker` 组件提供了一个系统颜色选择器 UI，允许用户选择颜色，并通过 `onChanged` 事件将选择的颜色传递回应用。该组件支持以下格式的颜色：

- 关键字颜色（例如：`green`, `red`, `blue` 等）
- 十六进制颜色字符串（例如：`#FF5733` 或 `#333`）
- CSS rgba 字符串（例如：`rgba(255,0,0,1)`）

***

## `ColorPickerProps`

`ColorPickerProps` 是 `ColorPicker` 组件的属性类型，它可以通过以下两种方式定义：

### 1. 使用 `title` 属性

- **`title`** (`string`): 为颜色选择器提供一个标题，描述颜色选择器的用途或提供指导信息。

### 2. 使用 `children` 属性

- **`children`** (`VirtualNode | undefined | null | (VirtualNode | undefined | null)[]` | `VirtualNode`): 提供一个自定义视图来描述所选颜色的用途。系统的颜色选择器 UI 会根据此视图的文本来设置标题。如果不使用 `children`，则可以仅使用 `title`。

### 其他属性

- **`value`** (`Color`): 当前选定的颜色值。可以是关键字颜色、十六进制颜色字符串或 RGBA 字符串。

- **`onChanged`** (`(value: Color) => void`): 颜色变化时的回调函数。当用户选择颜色时会调用此回调，并传递新的颜色值。

- **`supportsOpacity`** (`boolean`, 可选): 如果设置为 `true`，则允许调整选定颜色的透明度。默认为 `true`。

### 示例代码

```tsx
import { ColorPicker, useState } from 'scripting'

const MyComponent = () => {
  const [color, setColor] = useState<Color>('#FF5733')

  return (
    <ColorPicker
      title="Pick a Color"
      value={color}
      onChanged={setColor}
    />
  )
}
```

### 说明

在上面的示例中：

- `ColorPicker` 组件的 `title` 被设置为 `"Pick a Color"`，提示用户选择颜色。
- 初始颜色值是 `#FF5733`。
- `onChanged` 回调会在颜色更改时触发，更新 `color` 状态。

### 可选的透明度支持

如果你希望支持调整颜色的透明度，可以通过设置 `supportsOpacity` 属性来启用此功能：

```tsx
<ColorPicker
  title="Pick a Color"
  value={color}
  onChanged={setColor}
  supportsOpacity={true}
/>
```

## `Color` 类型

`Color` 类型用于定义颜色的各种格式，包括：

- **关键字颜色**: 如 `"red"`, `"green"`, `"blue"` 等。
- **十六进制字符串**: 如 `"#FF5733"`。
- **CSS rgba 字符串**: 如 `rgba(255, 0, 0, 0.5)`。

### 示例

```tsx
const color: Color = 'rgba(255, 0, 0, 0.5)'
```



---
url: /v2/zh/guide/Views/Controls/ColorPicker/index_example.md
---

# 示例

```tsx
import { Color, ColorPicker, Navigation, NavigationStack, Script, Text, useState, VStack } from "scripting"

function Example() {
  const [value, setValue] = useState<Color>('blue')

  return <NavigationStack>
    <VStack
      navigationTitle={"Color Picker"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <ColorPicker
        value={value}
        onChanged={setValue}
      >
        <Text>Current color: {value}</Text>
      </ColorPicker>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Controls/ContentUnavailableView/index.md
---

# 内容不可用视图

`ContentUnavailableView` 是一个 UI 组件，用于在应用内容不可用时向用户展示一个视图。它通常会显示标题、可选的描述内容以及操作区，用以清晰地告知用户内容缺失或尚未准备好。此组件适用于如列表等场景，当没有数据展示时，提供明确的提示。

## 属性

### 通用属性

您可以为 `ContentUnavailableView` 组件传递两种结构的属性：

1. **基于字符串的属性：**
   - `title` (string): 显示的主标题，通常描述不可用的内容。
   - `systemImage` (string): 一个系统图标，用来直观表示内容不可用。这个图标有助于用户理解当前的状态。
   - `description` (string, 可选): 一个简短的文本描述，进一步说明不可用内容。如果不需要，可以省略。

2. **基于 `VirtualNode` 的属性：**
   - `label` (VirtualNode): 一个虚拟节点，通常是 `Text` 或其他 UI 组件，用来描述不可用内容的标签。
   - `description` (VirtualNode | null, 可选): 一个虚拟节点，通常是 `Text` 组件，用于提供更详细的不可用内容描述。如果不需要描述，可以将其设置为 `null`。
   - `actions` (虚拟节点数组 | null, 可选): 一个可选的操作按钮或链接列表。这些操作可以是按钮、链接或其他组件，也可以设置为 `null`，如果没有操作需求。

## 示例用法

### 1. 使用字符串的简单示例

```tsx
function View({documents}: {documents: {name: string}[]}) {
  return (
    <NavigationStack>
      <List
        overlay={
          documents.length > 0
            ? undefined
            : <ContentUnavailableView
                title="暂无文档"
                systemImage="tray.fill"
              />
        }
      >
        {documents.map(item => (
          <Text>{item.name}</Text>
        ))}
      </List>
    </NavigationStack>
  )
}
```

在此示例中，当文档列表为空时，`ContentUnavailableView` 会显示一个标题“暂无文档”以及一个系统图标 `"tray.fill"`。

### 2. 使用 `VirtualNode` 的高级示例

```tsx
function View({documents}: {documents: {name: string}[]}) {
  return (
    <NavigationStack>
      <List
        overlay={
          documents.length > 0
            ? undefined
            : <ContentUnavailableView
                label={<Text>暂无可用文档</Text>}
                description={<Text>请稍后检查，文档将会在更新后显示。</Text>}
                actions={[<Button onClick={handleRefresh}>刷新</Button>]}
              />
        }
      >
        {documents.map(item => (
          <Text>{item.name}</Text>
        ))}
      </List>
    </NavigationStack>
  )
}
```

在这个例子中，`ContentUnavailableView` 使用虚拟节点作为标签和描述，此外，还添加了一个刷新按钮作为操作。

## 注意事项

- 您可以根据需要选择使用基于字符串的属性或基于虚拟节点的属性，后者适用于更动态的内容展示。
- 该组件灵活，能够在列表、堆栈和其他复杂布局中使用。

## API 详情

- **`title`** 和 **`systemImage`**: 提供一种简单的方式来显示不可用内容，使用字符串标题和系统图标。
- **`label`** 和 **`description`**: 使用虚拟节点可以更灵活地定制标签和描述内容。
- **`actions`**: 可选操作，允许您添加按钮或链接，引导用户执行操作，如刷新内容或跳转到其他页面。

该组件非常适合用在内容可能暂时不可用的场景，能够清晰、一致地向用户展示提示信息。



---
url: /v2/zh/guide/Views/Controls/ContentUnavailableView/index_example.md
---

# 示例

```tsx
import { useState, List, ContentUnavailableView, Button, Text, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [list, setList] = useState<string[]>([])

  return <NavigationStack>
    <List
      navigationTitle={"ContentUnavailableView"}
      navigationBarTitleDisplayMode={"inline"}
      overlay={
        list.length ? undefined
          : <ContentUnavailableView
            title="No data"
            systemImage="tray.fill"
          />
      }
      toolbar={{
        bottomBar: [
          <Button
            title="Add"
            action={() => {
              setList(list => {
                let newList = [
                  (Math.random() * 1000 | 0).toString(),

                  ...list
                ]
                return newList
              })
            }}
          />,
          <Button
            title="Clear"
            action={() => {
              setList([])
            }}
          />
        ]
      }}
    >
      {list.map(name => <Text>{name}</Text>)}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Controls/DatePicker/index.md
---

# 日期、时间选择器

`DatePicker` 是一个用于选择日期（以及可选的时间）的 UI 组件，支持通过多种显示方式（如日历、滚轮、文本等）进行交互。它允许用户根据自己的需求选择特定的日期，并根据组件配置决定是否包括时间选择。此组件特别适合需要日期和时间输入的场景，例如选择事件的开始日期或任务的截止日期。

## 参数

### `DatePickerProps` 类型

- **`title`** (必选)：`string`

  设置日期选择器的标题，通常用于描述选择的目的，例如“选择日期”。

- **`children`** (可选)：`(VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode`

  用于渲染自定义的子视图内容。如果没有自定义内容，则无需传递此属性。

- **`value`** (必选)：`number`

  表示当前选定日期的时间戳（毫秒数）。该值会传递给 `onChanged` 事件处理器。

- **`onChanged`** (必选)：`(value: number) => void`

  当日期值发生变化时调用的回调函数，参数是新的时间戳。

- **`startDate`** (可选)：`number`

  设置可选日期范围的起始日期时间戳。用户只能选择该日期之后的日期。

- **`endDate`** (可选)：`number`

  设置可选日期范围的结束日期时间戳。用户只能选择该日期之前的日期。

- **`displayedComponents`** (可选)：`DatePickerComponents[]`

  一个可选的数组，指定用户能够查看和编辑的日期组件。默认值是 `['hourAndMinute', 'date']`，表示同时显示日期和时间（小时和分钟）。如果需要显示秒数（仅在 watchOS 可用），可以选择 `['hourMinuteAndSecond']`。

### `DatePickerComponents` 类型

该类型定义了日期选择器中可能显示的组件：

- **`date`**：显示日、月和年，基于当前区域设置。
- **`hourAndMinute`**：显示小时和分钟，基于当前区域设置。
- **`hourMinuteAndSecond`**：仅在 watchOS 上可用，显示小时、分钟和秒数，基于当前区域设置。

### `DatePickerStyle` 类型

定义了 `DatePicker` 组件的样式类型。支持以下选项：

- **`automatic`**：默认样式，自动选择合适的显示方式。
- **`compact`**：紧凑样式，以文本格式显示各个日期组件。
- **`graphical`**：图形样式，显示一个可互动的日历或时钟。
- **`wheel`**：滚轮样式，每个日期组件显示为一个可以滚动的列。
- **`field`**：仅在 macOS 上可用，显示为可编辑的文本字段。
- **`stepperField`**：仅在 macOS 上可用，显示为可编辑的文本字段，旁边带有步进器，可增加或减少选中的日期组件。

## 示例代码

以下是 `DatePicker` 组件的示例使用代码：

```tsx
<DatePicker
  title="选择日期和时间"
  value={new Date().getTime()}
  onChanged={(newDate) => console.log('新日期:', newDate)}
  startDate={new Date('2024-01-01').getTime()}
  endDate={new Date('2024-12-31').getTime()}
  displayedComponents={['date', 'hourAndMinute']}
  datePickerStyle="wheel"
/>
```

## 用法说明

`DatePicker` 组件可以通过 `displayedComponents` 属性控制显示的内容。默认情况下，它会显示日期和时间（小时和分钟），但您可以根据需求定制其显示组件。例如，在 `watchOS` 设备上，您可以选择显示小时、分钟和秒数。

选择器的外观和交互方式可以通过 `datePickerStyle` 属性进一步定制。不同的样式提供不同的用户体验，您可以根据平台和用户需求选择最合适的样式。

## 注意事项

- `startDate` 和 `endDate` 用于限定用户可选择的日期范围，确保用户只能选择有效的日期。
- `displayedComponents` 属性的设置需要根据您的需求进行调整。如果不需要时间选择，您可以仅显示日期组件。
- `DatePicker` 支持在不同平台上提供不同的体验（例如，`stepperField` 仅在 macOS 上可用），请确保根据平台调整样式选项。



---
url: /v2/zh/guide/Views/Controls/DatePicker/index_example.md
---

# 示例

```tsx
import { DatePicker, DatePickerComponents, DatePickerStyle, HStack, Image, List, Navigation, NavigationStack, Picker, Script, Section, Spacer, Text, Toggle, useMemo, useState, } from "scripting"

const oneDay = 1000 * 60 * 60 * 24

 function Example() {
  const [date, setDate] = useState(() => Date.now())
  const [startDateEnabled, setStartDateEnabled] = useState(false)
  const [endDateEnabled, setEndDateEnabled] = useState(false)
  const startDate = useMemo(() => Date.now() - oneDay * 7, [])
  const endDate = useMemo(() => Date.now() + oneDay * 7, [])
  const components = useMemo<DatePickerComponents[]>(() => [
    'date',
    'hourAndMinute'
  ], [])
  const [displayedComponents, setDisplayedComponents] = useState<DatePickerComponents[]>([
    'date', 'hourAndMinute'
  ])
  const datePickerStyles = useMemo<DatePickerStyle[]>(() => [
    'compact',
    'graphical',
    'wheel',
  ], [])
  const [selectedStyle, setSelectedStyle] = useState<DatePickerStyle>('graphical')

  return <NavigationStack>
    <List
      navigationTitle={"DatePicker"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section>
        <Toggle
          title={"Use startDate"}
          value={startDateEnabled}
          onChanged={setStartDateEnabled}
        />

        <Toggle
          title={"Use endDate"}
          value={endDateEnabled}
          onChanged={setEndDateEnabled}
        />
        {components.map(name =>
          <HStack
            contentShape={'rect'}
            onTapGesture={() => {
              if (displayedComponents.includes(name)) {
                if (displayedComponents.length > 1) {
                  setDisplayedComponents(displayedComponents.filter(e => e !== name))
                }
              } else {
                setDisplayedComponents([name, ...displayedComponents])
              }
            }}
          >
            <Text>Display: {name}</Text>
            <Spacer />
            {displayedComponents.includes(name)
              ? <Image
                systemName={"checkmark"}
                foregroundStyle={"systemBlue"}
              />
              : undefined}
          </HStack>
        )}

        <Picker
          title={"DatePicker Style"}
          value={selectedStyle}
          onChanged={setSelectedStyle as any}
          pickerStyle={'menu'}
        >
          {datePickerStyles.map(style =>
            <Text tag={style}>{style}</Text>
          )}
        </Picker>
      </Section>

      <DatePicker
        title={"DatePicker"}
        value={date}
        onChanged={setDate}
        startDate={startDateEnabled ? startDate : undefined}
        endDate={endDateEnabled ? endDate : undefined}
        displayedComponents={displayedComponents}
        datePickerStyle={selectedStyle}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Controls/Gauge/index.md
---

# 仪表盘

`Gauge` 组件是一个用于显示当前值与指定容量之间关系的视图，类似于汽车上的油表。`Gauge` 组件可以根据配置，显示当前值、显示范围以及描述该量表目的的标签。适用于展示有限容量内的当前值，如进度、水平或数量。

## 属性

### `value` (必选)

- **类型**：`number`
- **描述**：要在量表中显示的当前值。该值应当在 `min` 和 `max` 属性指定的范围内。

### `label` (必选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述量表的目的或意义。例如，可以使用此属性显示量表的描述性文字，如“电池电量”或“温度”等。

### `min` (可选)

- **类型**：`number`
- **描述**：量表的最小有效值，默认为 `0`。表示量表的下限。

### `max` (可选)

- **类型**：`number`
- **描述**：量表的最大有效值，默认为 `1`。表示量表的上限。

### `currentValueLabel` (可选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述当前量表值。例如，可以在量表旁边显示当前值的文本标签。

### `minValueLabel` (可选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述量表的下限。例如，可以在量表的最小值位置显示“0”或“最小”标签。

### `maxValueLabel` (可选)

- **类型**：`VirtualNode`
- **描述**：一个视图元素，描述量表的上限。例如，可以在量表的最大值位置显示“100”或“最大”标签。

### `gaugeStyle` (可选)

- **类型**：`GaugeStyle`
- **描述**：量表的显示风格。此属性可以控制量表的外观样式，有以下几种可选值：
  - **`automatic`**：当前上下文中量表的默认样式。
  - **`accessoryCircular`**：显示一个开放的圆环，环上有一个标记，指示量表的当前值。
  - **`accessoryCircularCapacity`**：显示一个闭合的圆环，部分填充，表示量表的当前值。
  - **`circular`**：**仅适用于 watchOS**，显示一个开放的圆环，环上有一个标记，指示量表的当前值。
  - **`linearCapacity`**：显示一个条形图，随着量表的当前值增加，从左到右填充。
  - **`accessoryLinear`**：显示一个条形图，条形上有一个标记，指示量表的当前值。
  - **`accessoryLinearCapacity`**：显示一个条形图，随着量表的当前值增加，从左到右填充。
  - **`linear`**：**仅适用于 watchOS**，显示一个条形图，条形上有一个标记，指示量表的当前值。

## 示例代码

```tsx
<Gauge
  value={0.7}
  label={<Text>Battery Level</Text>}
  min={0}
  max={1}
  currentValueLabel={<Text>70%</Text>}
  minValueLabel={<Text>0%</Text>}
  maxValueLabel={<Text>100%</Text>}
  gaugeStyle="accessoryCircular"
/>
```

## 使用场景

`Gauge` 组件非常适合以下几种场景：

- 显示进度条（如任务进度、下载进度等）。
- 展示设备状态（如电池电量、信号强度等）。
- 显示性能指标（如温度、湿度、CPU 使用率等）。

通过自定义 `label` 和 `currentValueLabel` 等属性，`Gauge` 组件可以灵活适配不同的显示需求，帮助用户清晰了解当前状态。

## 注意事项

- `value` 属性的值应位于 `min` 和 `max` 之间，否则会导致显示异常。
- 如果未传递 `min` 和 `max` 属性，量表会默认显示在 `[0, 1]` 范围内。
- 使用不同的 `gaugeStyle` 可以显著改变量表的外观。根据设备和使用场景选择适当的样式，以提高用户体验。



---
url: /v2/zh/guide/Views/Controls/Gauge/index_example.md
---

# 示例

```tsx
import { Gauge, List, Navigation, NavigationStack, Script, Section, Text } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Gauge"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>accessoryCircular</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>0 100</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryCircular"}
          tint={"systemGreen"}
        />
      </Section>

      <Section
        header={
          <Text>accessoryCircularCapacity</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryCircularCapacity"}
        />
      </Section>

      <Section
        header={
          <Text>linearCapacity</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"linearCapacity"}
        />
      </Section>

      <Section
        header={
          <Text>accessoryLinear</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryLinear"}
        />
      </Section>
      <Section
        header={
          <Text>accessoryLinearCapacity</Text>
        }
      >
        <Gauge
          value={0.4}
          label={<Text>Battery Level</Text>}
          currentValueLabel={<Text>40%</Text>}
          gaugeStyle={"accessoryLinearCapacity"}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Controls/Picker/index.md
---

# 选择器

`Picker` 组件用于从一组互斥的选项中进行选择。它支持不同的显示样式，并允许用户选择单个值。可以通过设置 `value` 和 `onChanged` 属性来控制选项的值和改变事件。

## 类型定义

- `PickerValue`: 选择值的类型，支持 `number` 或 `string`。
- `PickerProps<T extends PickerValue>`: `Picker` 组件的属性类型，其中：
  - `value`: 当前选中的值，可以是 `number` 或 `string`，可选。
  - `onChanged`: 当选择的值发生变化时调用的函数，参数为选中的值（`T`）。
  - `children`: 选项视图，每个子元素都必须使用 `tag` 属性来标记其值，可以是一个 `JSX.Element` 或多个 `JSX.Element` 的数组。
  - `title`: 字符串类型，表示选择项的描述标题，仅在某些情况下使用。
  - `systemImage`: 系统图标的名称，仅在某些情况下使用。
  - `label`: 用于描述选择项的 `JSX.Element` 视图，仅在某些情况下使用。

## 组件功能

`Picker` 组件通过设置 `value` 和 `onChanged` 来管理用户的选择。`value` 是当前选择的值，`onChanged` 是一个回调函数，当用户更改选择时被调用。`children` 提供了选项的视图，允许使用多种不同的布局来展示选项。每个 `children` 元素必须使用 `tag` 属性来标记其值，例如 `<Text tag={1}>Option 1</Text>`。

## Picker 样式

`Picker` 组件支持以下几种样式，用于调整组件的呈现方式：

- `automatic`: 默认样式，基于 `Picker` 上下文自动决定样式。
- `inline`: 将每个选项与当前容器中的其他视图并排显示。
- `menu`: 以菜单形式展示选项，通常通过按钮点击展开，或者在更大菜单中作为子菜单。
- `navigationLink`: 通过导航链接形式呈现，点击后会展示一个 `List` 样式的选择器视图。
- `palette`: 将选项呈现为一行紧凑的元素。
- `segmented`: 将选项以分段控制样式显示。
- `wheel`: 通过可滚动的轮盘展示选项，显示当前选择项和若干邻近选项。

## 示例

以下是如何使用 `Picker` 组件的示例：

### 示例 1：数字类型的 Picker

```tsx
import { Picker, Text, useState } from 'scripting'

const MyPicker = () => {
  const [selectedValue, setSelectedValue] = useState<number>(1)

  return (
    <Picker
      value={selectedValue}
      onChanged={(newValue) => setSelectedValue(newValue)}
      pickerStyle="inline"
    >
      <Text tag={1}>Option 1</Text>
      <Text tag={2}>Option 2</Text>
      <Text tag={3}>Option 3</Text>
    </Picker>
  )
}
```

### 示例 2：字符串类型的 Picker

```tsx
import { Picker, Text, useState } from 'scripting'

const MyPicker = () => {
  const [selectedValue, setSelectedValue] = useState<string>("Option 1")

  return (
    <Picker
      value={selectedValue}
      onChanged={(newValue) => setSelectedValue(newValue)}
      pickerStyle="segmented"
    >
      <Text tag="Option 1">Option 1</Text>
      <Text tag="Option 2">Option 2</Text>
      <Text tag="Option 3">Option 3</Text>
    </Picker>
  )
}
```

### 示例 3：带标题和系统图标的 Picker

```tsx
import { Picker, Text, useState } from 'scripting'

const MyPicker = () => {
  const [selectedValue, setSelectedValue] = useState<string>("Option 1")

  return (
    <Picker
      value={selectedValue}
      onChanged={(newValue) => setSelectedValue(newValue)}
      pickerStyle="menu"
      title="Choose an option"
      systemImage="star"
    >
      <Text tag="Option 1">Option 1</Text>
      <Text tag="Option 2">Option 2</Text>
      <Text tag="Option 3">Option 3</Text>
    </Picker>
  )
}
```

## `Picker` 组件的常用场景

1. **表单选择项**：可以用于表单中的单选项，帮助用户从一组预定义的选项中做出选择。
2. **设置界面**：在应用设置中，`Picker` 可以用于选择颜色、主题、语言等选项。
3. **导航选项**：在更复杂的界面中，`Picker` 还可以作为多层菜单的选择工具。

## 注意事项

- 每个 `Picker` 的 `children` 元素必须使用 `tag` 属性来标记其对应的值，例如 `<Text tag={1}>Option 1</Text>`。
- `value` 和 `onChanged` 必须配合使用，确保在用户更改选择时能够正确响应。
- `pickerStyle` 提供了多种样式，选择适合的样式可以提升用户体验。

### 相关 API

- `JSX.Element`: 用于定义视图元素的基本结构，`Picker` 组件的 `children` 属性依赖此类型。
- `useState`: 用于管理选中值的状态。



---
url: /v2/zh/guide/Views/Controls/Picker/index_example.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Picker, PickerStyle, Script, Section, Text, useMemo, useState, } from "scripting"

function Example() {
  const [value, setValue] = useState<number>(0)
  const options = useMemo<PickerStyle[]>(() => [
    'automatic',
    'inline',
    'menu',
    'navigationLink',
    'palette',
    'segmented',
    'wheel'
  ], [])
  const users = useMemo<string[]>(() => [
    "Jobs", "Elon", "Zack", "Joe"
  ], [])

  return <NavigationStack>
    <List
      navigationTitle={"Picker"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {options.map((style) =>
        <Section
          header={
            <Text>Picker: {style}</Text>}
        >
          <Picker
            title={"Picker: " + style}
            pickerStyle={style}
            value={value}
            onChanged={setValue}
          >
            {users.map((user, index) =>
              <Text
                tag={index}
              >{user}</Text>
            )}
          </Picker>
        </Section>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Controls/ProgressView/index.md
---

# 进度视图

`ProgressView` 是一个用于表示任务或操作进度的 UI 组件。它可以显示确定性（百分比完成）和不确定性（正在进行或未进行）的进度状态。此外，它还提供了可自定义的进度视图样式，包括线性和圆形表示。

你可以使用 `ProgressView` 来显示各种任务的进度，例如下载文件、完成某个过程或等待某个事件。该组件还可以显示附加的细节，如任务描述和当前进度。

## 使用方法

### 组件声明

`ProgressView` 组件接受两种可能的属性集，具体取决于你想表示的是基于时间的区间还是一般的进度任务。这些属性通过 `ProgressViewProps` 类型定义，可能是以下之一：

- `TimerIntervalProgressViewProps`
- `NormalProgressViewProps`

你可以通过绑定 `value` 和 `total` 属性来表示进度，从而创建一个确定性进度视图。此外，组件还支持通过 `progressViewStyle` 属性来自定义样式。

### 示例：基于时间区间的进度视图

```tsx
<ProgressView
  timerFrom={startTimestamp}
  timerTo={endTimestamp}
  countsDown={true}
  label={<Text>任务进行中</Text>}
  currentValueLabel={<Text>50% 完成</Text>}
/>
```

### 示例：普通进度视图

```tsx
<ProgressView
  value={0.5}
  total={1.0}
  title="加载中"
  label={<Text>文件下载中</Text>}
  currentValueLabel={<Text>50% 完成</Text>}
/>
```

## 属性

### `TimerIntervalProgressViewProps`

- **`timerFrom`** (`number`):\
  任务进度区间的起始时间戳（以毫秒为单位）。此值用于计算进度视图中已过去的时间。

- **`timerTo`** (`number`):\
  任务进度区间的结束时间戳（以毫秒为单位）。此值表示进度视图的结束点。

- **`countsDown`** (`boolean`, 可选，默认值: `true`):\
  如果设置为 `true`，进度视图会从 `timerFrom` 倒计时至 `timerTo`。如果设置为 `false`，则表示进度会从 `timerFrom` 增长至 `timerTo`。

- **`label`** (`VirtualNode`, 可选):\
  一个虚拟节点，用于提供任务的描述或附加信息。这可以是一个文本标签或其他类型的视图。

- **`currentValueLabel`** (`VirtualNode`, 可选):\
  一个虚拟节点，描述任务的当前进度值。例如，这可以显示当前的完成百分比。

### `NormalProgressViewProps`

- **`value`** (`number`, 可选):\
  任务当前的进度值，范围为 `0.0` 到 `total` 之间，表示任务完成的百分比。如果为 `nil`，则视图为不确定性进度。

- **`total`** (`number`, 可选，默认值: `1.0`):\
  完成任务所需的总进度值。当 `value` 等于 `total` 时，任务完成。默认值为 `1.0`。

- **`title`** (`string`, 可选):\
  正在进行的任务的标题或名称。

- **`label`** (`VirtualNode`, 可选):\
  描述任务进度的虚拟节点，类似于 `TimerIntervalProgressViewProps` 中的 `label` 属性。

- **`currentValueLabel`** (`VirtualNode`, 可选):\
  显示当前进度值的虚拟节点，类似于 `TimerIntervalProgressViewProps` 中的 `currentValueLabel` 属性。

### `CommonViewProps`

- **`progressViewStyle`** (`ProgressViewStyle`, 可选):\
  用于此视图的进度视图样式。可用样式包括：
  - **`automatic`**: 根据当前上下文自动选择的默认样式。
  - **`circular`**: 使用圆形进度条样式，表示活动的部分完成。在 macOS 之外的平台，圆形样式可能会显示为不确定性指示器。
  - **`linear`**: 使用水平条形样式来显示任务的进度。

### `ProgressViewStyle`

- **`linear`**: 使用水平条形来表示进度。
- **`circular`**: 使用圆形进度条来表示任务的部分完成。在 macOS 之外的平台，通常用于不确定性进度。
- **`automatic`**: 默认样式，自动根据上下文选择进度视图样式。

## 注意事项

- `ProgressView` 会根据提供的 `TimerIntervalProgressViewProps` 或 `NormalProgressViewProps` 中的值自动调整显示方式。
- 如果同时提供了 `value` 和 `total`，则视为确定性进度。如果其中任意一个为 `nil`，则视为不确定性进度。
- 你可以通过 `label` 和 `currentValueLabel` 属性自定义 UI，传递任何类型的视图，包括文本、图片或自定义组件。
- `progressViewStyle` 属性用于自定义进度视图的视觉样式。默认情况下，使用 `automatic` 样式，但你可以根据需要选择 `linear` 或 `circular`。

## 示例

### 确定性进度（包含 value 和 total）

```tsx
<ProgressView
  value={0.75}
  total={1.0}
  title="任务进度"
  label={<Text>任务已完成 75%</Text>}
  currentValueLabel={<Text>75%</Text>}
  progressViewStyle="linear"
/>
```

### 不确定性进度（没有 value）

```tsx
<ProgressView
  title="加载中"
  label={<Text>正在加载文件...</Text>}
  progressViewStyle="circular"
/>
```

## 结论

`ProgressView` 是一个灵活且易于使用的 UI 组件，支持确定性和不确定性进度状态。它允许通过线性或圆形进度指示器展示进度，并且支持自定义任务细节和视觉样式。使用 `ProgressView`，你可以在各种场景中有效地展示任务的进度。



---
url: /v2/zh/guide/Views/Controls/ProgressView/index_example.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, ProgressView, Script, Section, Text, useState, } from "scripting"

function Example() {
  const [timerFrom] = useState(() => Date.now())
  const timerTo = timerFrom + 1000 * 60

  return <NavigationStack>
    <List
      navigationTitle={"ProgressView"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>circular</Text>
        }
      >
        <ProgressView
          progressViewStyle={'circular'}
        />
      </Section>

      <Section
        header={
          <Text>linear</Text>
        }
      >
        <ProgressView
          progressViewStyle={'linear'}
          total={100}
          value={50}
          label={<Text>Progress 50%</Text>}
          currentValueLabel={<Text>50</Text>}
        />
      </Section>

      <Section
        header={
          <Text>TimerInterval</Text>
        }
      >
        <ProgressView
          progressViewStyle={'linear'}
          timerFrom={timerFrom}
          timerTo={timerTo}
          countsDown={false}
          label={<Text>Workout</Text>}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Controls/Slider/index.md
---

# 滑块控件

`Slider` 组件允许用户从一个有限的线性范围内选择一个值。可以通过设置最小值、最大值、步长和当前值来配置滑动条，支持自定义标签用于描述最小值、最大值及滑动条本身。这个组件还支持处理值的变化和编辑状态的回调。

## SliderProps 类型

`SliderProps` 是 `Slider` 组件的属性类型，包含以下字段：

- **min** (`number`):
  - 设置滑动条的最小值。
  - **必选**。

- **max** (`number`):
  - 设置滑动条的最大值。
  - **必选**。

- **step** (`number`):
  - 设置滑动条上每次有效值之间的间隔。
  - **可选**，默认为 `1`。

- **value** (`number`):
  - 设置当前选中的值。
  - **必选**，必须在 `min` 和 `max` 之间。

- **onChanged** (`(value: number) => void`):
  - 一个回调函数，用于监听滑动条的值变化。
  - **必选**，每次值变化时会被调用。

- **onEditingChanged** (`(value: boolean) => void`):
  - 一个可选回调函数，当滑动条的编辑状态发生变化时会被调用。
  - `value` 为 `true` 时表示滑动条正在被编辑，`false` 表示编辑已结束。

- **label** (`VirtualNode`):
  - 一个可选视图，用于描述滑动条的目的。即使某些滑动条样式不会显示该标签，系统仍然会用于可访问性目的（例如，VoiceOver）。
  - **可选**。

- **minValueLabel** (`VirtualNode`):
  - 一个可选视图，用于描述滑动条的最小值。
  - **可选**，仅在 `SliderWithRangeValueLabelProps` 模式下使用。

- **maxValueLabel** (`VirtualNode`):
  - 一个可选视图，用于描述滑动条的最大值。
  - **可选**，仅在 `SliderWithRangeValueLabelProps` 模式下使用。

## SliderWithRangeValueLabelProps 类型

`SliderWithRangeValueLabelProps` 是用于描述滑动条的附加信息的属性类型。它包括：

- **label** (`VirtualNode`):
  - 用于描述滑动条目的标签。

- **minValueLabel** (`VirtualNode`):
  - 用于描述最小值的标签。

- **maxValueLabel** (`VirtualNode`):
  - 用于描述最大值的标签。

## 使用示例

以下是一个使用 `Slider` 组件的简单示例：

```tsx
import { Slider } from 'scripting'

const ExampleSlider = () => {
  const [value, setValue] = useState(50)

  const handleChange = (newValue: number) => {
    setValue(newValue)
  }

  return (
    <Slider
      min={0}
      max={100}
      value={value}
      onChanged={handleChange}
      label={<Text>调整音量</Text>}
      minValueLabel={<Text>0</Text>}
      maxValueLabel={<Text>100</Text>}
    />
  )
}
```

在此示例中，`Slider` 组件配置了一个从 `0` 到 `100` 的滑动条，默认值为 `50`。标签和最小、最大值标签分别描述了滑动条的目的和范围。

## 注意事项

- `Slider` 组件的 `min` 和 `max` 必须设置为数值，且 `value` 必须在这个范围内。
- 当用户调整滑动条时，`onChanged` 回调会触发，传入新的值。
- 如果使用 `SliderWithRangeValueLabelProps`，则必须为 `minValueLabel` 和 `maxValueLabel` 提供合适的视图元素。

## 小结

`Slider` 组件是一个功能强大的 UI 控件，适用于需要用户选择数值的场景。通过灵活的属性和回调，可以实现许多自定义行为，尤其是在需要提供最小、最大值说明或标签的场景中。



---
url: /v2/zh/guide/Views/Controls/Slider/index_example.md
---

# 示例

```tsx
import { useState, Slider, Text, VStack, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [value, setValue] = useState(15)

  return <NavigationStack>
    <VStack
      navigationTitle={"Slider"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Slider
        min={0}
        max={100}
        value={value}
        onChanged={setValue}
        label={<Text>{value}</Text>}
        minValueLabel={<Text>0</Text>}
        maxValueLabel={<Text>100</Text>}
      />
      <Text>Current value: {value}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Controls/Stepper/index.md
---

# 步进器

`Stepper` 是一个用于执行递增和递减操作的控件。它允许用户通过点击“+”或“-”按钮来增加或减少数值。该组件也支持触发编辑状态变化的回调函数。

## 属性

### 1. `title`（可选，字符串）

- **描述**：指定步进器的标题，通常用于说明步进器的目的。
- **类型**：`string`
- **示例**：
  ```tsx
  <Stepper 
    title="Adjust Volume" 
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement} 
  />
  ```

### 2. `children`（可选，虚拟节点）

- **描述**：用于描述步进器的目的的视图内容。可以使用多个子视图来构建控件的外观。此属性和 `title` 属性为互斥关系，只能选择其一。
- **类型**：`(VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode`
- **示例**：
  ```tsx
  <Stepper
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement}
  >
    <Text>Adjust Volume</Text>
  </Stepper>
  ```

### 3. `onIncrement`（必选，回调函数）

- **描述**：当用户点击或触摸“+”按钮时，执行此函数。
- **类型**：`() => void`
- **示例**：
  ```tsx
  const handleIncrement = () => {
    console.log("Incremented");
  }

  <Stepper 
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement} 
  />
  ```

### 4. `onDecrement`（必选，回调函数）

- **描述**：当用户点击或触摸“-”按钮时，执行此函数。
- **类型**：`() => void`
- **示例**：
  ```tsx
  const handleDecrement = () => {
    console.log("Decremented")
  }

  <Stepper onIncrement={handleIncrement} onDecrement={handleDecrement} />
  ```

### 5. `onEditingChanged`（可选，回调函数）

- **描述**：当编辑开始和结束时调用的函数。例如，在 iOS 上，用户长按步进器的增减按钮时，会触发 `onEditingChanged` 回调函数，表示编辑状态的变化。
- **类型**：`(value: boolean) => void`
- **示例**：
  ```tsx
  const handleEditingChanged = (isEditing: boolean) => {
    console.log("Editing started:", isEditing)
  }

  <Stepper 
    onIncrement={handleIncrement} 
    onDecrement={handleDecrement} 
    onEditingChanged={handleEditingChanged} 
  />
  ```

## 示例代码

以下是一个完整的示例，展示了如何使用 `Stepper` 组件：

```tsx
const handleIncrement = () => {
  console.log("Volume increased")
}

const handleDecrement = () => {
  console.log("Volume decreased")
}

const handleEditingChanged = (isEditing: boolean) => {
  console.log("Editing started:", isEditing)
}

<Stepper
  title="Volume Control"
  onIncrement={handleIncrement}
  onDecrement={handleDecrement}
  onEditingChanged={handleEditingChanged}
/>
```

## 注意事项

- `title` 和 `children` 属性是互斥的。只能使用一个来描述步进器的目的。
- `onEditingChanged` 回调函数是可选的，只在支持编辑状态的情况下触发，例如长按按钮时。

## 小结

`Stepper` 控件提供了一个简单的接口来实现递增和递减操作，支持在用户交互时触发回调。通过配置 `title` 或 `children` 属性来指定控件的目的，并且可以使用 `onIncrement` 和 `onDecrement` 函数定义按钮点击后的行为。



---
url: /v2/zh/guide/Views/Controls/Stepper/index_example.md
---

# 示例

```tsx
import { useState, useMemo, Color, Stepper, Text, VStack, RoundedRectangle, HStack, Spacer, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [value, setValue] = useState(0)
  const colors = useMemo<Color[]>(() => ['blue', 'red', 'green', 'purple'], [])
  const color = colors[value]

  function incrementStep() {
    if (value + 1 >= colors.length) {
      setValue(0)
    } else {
      setValue(value + 1)
    }
  }

  function decrementStep() {
    if (value - 1 < 0) {
      setValue(colors.length - 1)
    } else {
      setValue(value - 1)
    }
  }

  return <NavigationStack>
    <VStack
      navigationTitle={"Stepper"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Stepper
        title={"Stepper"}
        onIncrement={incrementStep}
        onDecrement={decrementStep}
      />
      <HStack>
        <Text>Value: {value}</Text>
        <Spacer />
        <RoundedRectangle
          fill={color}
          cornerRadius={4}
          frame={{
            width: 120,
            height: 30
          }}
        />
      </HStack>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Controls/Toggle/index.md
---

# 切换开关

`Toggle` 组件是 Scripting 应用中的一种视图控件，允许用户在“开启”和“关闭”状态之间切换。它支持多种配置选项，以适应不同的使用场景，包括用户交互处理器、自动化的意图支持以及用于显示的自定义选项。

***

## ToggleProps

`ToggleProps` 类型定义了 `Toggle` 组件的配置选项。

### 属性

#### **value**

- **类型**: `boolean`
- **描述**: 指示当前切换状态是“开启”(`true`)还是“关闭”(`false`)。
- **是否必需**: 是

***

#### **onChanged**

- **类型**: `(value: boolean) => void`
- **描述**: 当切换状态更改时调用的处理函数。它接收新的状态值（`true` 或 `false`）作为参数。
- **是否必需**: 是（如果未提供 `intent`）。

***

#### **intent**

- **类型**: `AppIntent<any>`
- **描述**: 当切换状态更改时执行的 `AppIntent`。仅适用于 `Widget` 或 `LiveActivity` 上下文。
- **是否必需**: 是（如果未提供 `onChanged`）。

***

#### **title**

- **类型**: `string`
- **描述**: 描述此切换目的的一段简短字符串。
- **可选**: 是，与 `children` 互斥。

***

#### **systemImage**

- **类型**: `string`
- **描述**: 显示在切换旁边的图像资源名称，通常用于增强描述。
- **可选**: 是，仅当提供了 `title` 时可用。

***

#### **children**

- **类型**: `(VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode`
- **描述**: 描述切换目的的自定义视图，提供比 `title` 更灵活的替代方案。
- **可选**: 是，与 `title` 互斥。

***

## ToggleStyle

定义 `Toggle` 的外观和行为。可以通过 `CommonViewProps` 中的 `toggleStyle` 属性进行配置。

### 选项

- **`'automatic'`**: 根据上下文自动选择最合适的样式。
- **`'switch'`**: 将切换显示为传统的开关。
- **`'button'`**: 将切换显示为按钮。

***

## CommonViewProps

`CommonViewProps` 提供了用于自定义 `Toggle` 的附加选项。

### 属性

#### **toggleStyle**

- **类型**: `'automatic' | 'switch' | 'button'`
- **描述**: 指定切换的外观和行为。如果未设置，则默认为 `'automatic'`。
- **可选**: 是

***

## 使用示例

### 示例 1: 带状态更改处理器的基础切换

```tsx
import { Toggle } from 'scripting'

function MyComponent() {
  const [isEnabled, setIsEnabled] = useState(false)

  return (
    <Toggle 
      value={isEnabled} 
      onChanged={newValue => setIsEnabled(newValue)} 
      title="启用通知" 
      systemImage="bell"
    />
  )
}
```

***

### 示例 2: 带有 AppIntent 的切换

```tsx
import { Toggle, } from 'scripting'
import { SomeToggleIntent } from "./app_intents"

function MyWidget() {
  const checked = getCheckedState()
  return (
    <Toggle 
        value={checked} 
        intent={SomeToggleIntent(checked)} 
        title="执行操作" 
        systemImage="action"
    />
  )
}
```

有关 `AppIntent` 的更多信息，请参阅 `Interactive Widget and LiveActivity` 文档。

***

### 示例 3: 带有自定义视图的切换

```tsx
import { Toggle, View } from 'scripting'

function MyComponent() {
  const [isEnabled, setIsEnabled] = useState(false)

  return (
    <Toggle 
      value={isEnabled} 
      onChanged={newValue => setIsEnabled(newValue)}
    >
      <View>
        <Text>启用功能</Text>
        <Image imageUrl="https://example.com/feature-icon.png" />
      </View>
    </Toggle>
  )
}
```

***

### 示例 4: 带有 `toggleStyle` 的切换

```tsx
import { Toggle } from 'scripting'

function StyledToggle() {
  const [isActive, setIsActive] = useState(false)

  return (
    <Toggle 
      value={isActive} 
      onChanged={newValue => setIsActive(newValue)} 
      title="样式切换" 
      toggleStyle="button"
    />
  )
}
```

***

通过本指南，开发者可以充分利用 `Toggle` 组件的功能，轻松创建动态且交互性强的 UI 体验，提升 Scripting 应用的开发效率。



---
url: /v2/zh/guide/Views/Controls/Toggle/index_example.md
---

# 示例

```tsx
import { useState, VStack, Toggle, Text, Navigation, Script, NavigationStack } from "scripting"

function Example() {
  const [on, setOn] = useState(false)

  return <NavigationStack>
    <VStack
      navigationTitle={"Toggle"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Toggle
        title={"Toggle Switch"}
        value={on}
        onChanged={setOn}
      />
      <Text>Current: {on ? 'on' : 'off'}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Dialog/index.md
---

# 对话框

`Dialog` 模块提供了一组用于展示对话框的快捷方法，包括提示框（Alert）、确认框（Confirm）、输入框（Prompt）和操作表（Action Sheet）。可用于在脚本执行过程中与用户进行交互。

***

## 模块：`Dialog`

***

### ▸ `Dialog.alert(options: { message: string, title?: string, buttonLabel?: string }): Promise<void>`

显示一个简单的提示框，包含一段信息和一个确认按钮。用户点击按钮后，Promise 会被 resolve。

#### 参数说明

- `message` (`string`)：提示的主要内容，**必填**。
- `title?` (`string`)：对话框标题，可选。
- `buttonLabel?` (`string`)：按钮文本，默认为 `"OK"`。

#### 返回值

- `Promise<void>`：用户点击按钮后 resolve。

#### 示例

```ts
await Dialog.alert({
  title: '提示',
  message: '操作已成功完成。',
  buttonLabel: '知道了'
})
```

***

### ▸ `Dialog.confirm(options: { message: string, title?: string, cancelLabel?: string, confirmLabel?: string }): Promise<boolean>`

显示一个确认框，包含“确认”和“取消”两个按钮。返回值表示用户是否确认。

#### 参数说明

- `message` (`string`)：确认信息内容，**必填**。
- `title?` (`string`)：标题，可选。
- `cancelLabel?` (`string`)：取消按钮文本，默认值为 `"Cancel"`。
- `confirmLabel?` (`string`)：确认按钮文本，默认值为 `"OK"`。

#### 返回值

- `Promise<boolean>`：用户点击确认返回 `true`，点击取消返回 `false`。

#### 示例

```ts
const confirmed = await Dialog.confirm({
  title: '删除文件',
  message: '确定要删除这个文件吗？',
  cancelLabel: '取消',
  confirmLabel: '删除'
})

if (confirmed) {
  // 执行删除操作
}
```

***

### ▸ `Dialog.prompt(options: {...}): Promise<string | null>`

显示一个输入框对话界面，允许用户输入文字。返回用户输入的字符串，或在取消时返回 `null`。

#### 参数说明

- `title` (`string`)：输入框标题，**必填**。
- `message?` (`string`)：辅助说明信息。
- `defaultValue?` (`string`)：默认输入值。
- `obscureText?` (`boolean`)：是否隐藏输入内容（如密码）。
- `selectAll?` (`boolean`)：是否自动选中全部默认内容。
- `placeholder?` (`string`)：输入框的占位提示文本。
- `cancelLabel?` (`string`)：取消按钮文本。
- `confirmLabel?` (`string`)：确认按钮文本。
- `keyboardType?` (`KeyboardType`)：输入键盘类型（如数字、邮箱等）。

#### 返回值

- `Promise<string | null>`：用户输入的文本，或取消时为 `null`。

#### 示例

```ts
const name = await Dialog.prompt({
  title: '请输入姓名',
  placeholder: '例如：李雷',
  defaultValue: '张三',
  confirmLabel: '提交',
  cancelLabel: '取消'
})

if (name != null) {
  console.log(`你好，${name}`)
}
```

***

### ▸ `Dialog.actionSheet(options: {...}): Promise<number | null>`

展示一个操作表（Action Sheet），可包含多个选项按钮。点击某个按钮返回该按钮的索引，点击取消返回 `null`。

#### 参数说明

- `title` (`string`)：标题，**必填**。
- `message?` (`string`)：提示信息，可选。
- `cancelButton?` (`boolean`)：是否显示取消按钮，默认值为 `true`。
- `actions` (`{ label: string, destructive?: boolean }[]`)：操作项数组，`destructive` 表示是否为破坏性操作（红色高亮）。

#### 返回值

- `Promise<number | null>`：返回所点击操作的索引，或用户取消时返回 `null`。

#### 示例

```ts
const index = await Dialog.actionSheet({
  title: '是否删除此图片？',
  actions: [
    { label: '删除', destructive: true },
    { label: '保留' }
  ]
})

if (index === 0) {
  // 用户选择删除
} else if (index === 1) {
  // 用户选择保留
} else {
  // 用户点击了取消
}
```

***

## 方法概览

| 方法名           | 用途         | 返回值类型                      |   |
| ------------- | ---------- | -------------------------- | - |
| `alert`       | 显示提示框      | `Promise<void>`            |   |
| `confirm`     | 显示确认框      | `Promise<boolean>`         |   |
| `prompt`      | 显示文字输入框    | `Promise<string  \| null>` |   |
| `actionSheet` | 显示多个选项的操作表 | `Promise<number  \| null>` |   |



---
url: /v2/zh/guide/Views/Dialog/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Dialog"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Button
        title={"Dialog.alert"}
        action={async () => {
          await Dialog.alert({
            message: "This is message",
            title: "Alert",
          })
          console.log("Alert dismissed")
        }}
      />

      <Button
        title={"Dialog.prompt"}
        action={async () => {
          const result = await Dialog.prompt({
            title: "Rename script",
            placeholder: "Enter script name",
          })

          Dialog.alert({
            message: result == null
              ? "You cancel the prompt"
              : "The new script name is: " + result
          })
        }}
      />

      <Button
        title={"Dialog.actionSheet"}
        action={async () => {
          const selectedIndex = await Dialog.actionSheet({
            title: "Are you sure to delete this script?",
            message: "This operation cannot be undone.",
            cancelButton: true,
            actions: [
              {
                label: "Delete",
                destructive: true,
              }
            ]
          })

          if (selectedIndex === 0) {
            Dialog.alert({
              message: "The script is deleted."
            })
          }
        }}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Displaying text/index.md
---

# 显示文本

`Text` 组件用于在 Scripting 应用中显示一行或多行只读文本。它支持纯文本、富文本（Markdown）以及丰富的文本样式。

***

## **类型定义**

### `TextProps`

定义了可传递给 `Text` 组件的属性。`TextProps` 类型有三种可能的结构：

1. **纯文本属性**
   - `children`（可选）：
     - 类型：`null | string | number | boolean | Array<string | number | boolean | undefined | null>`
     - 描述：以纯文本形式渲染的内容，可以是单个值或值的数组。
   - 示例：
     ```tsx
     <Text>简单的纯文本</Text>
     ```

2. **Markdown 文本属性**
   - `attributedString`（可选）：
     - 类型：`string`
     - 描述：指定 Markdown 格式的文本内容。
   - 示例：
     ```tsx
     <Text attributedString="**加粗** _斜体_ [链接](https://example.com)" />
     ```

3. **富文本属性**
   - `styledText`（可选）：
     - 类型：`StyledText`
     - 描述：指定具有自定义样式和属性的富文本内容。
   - 示例：
     ```tsx
     const richText: StyledText = {
       font: "title",
       bold: true,
       underlineStyle: "single",
       underlineColor: "#0000FF",
       content: "丰富样式的文本"
     }
     <Text styledText={richText} />
     ```

***

### `UnderlineStyle`

定义了富文本可用的下划线样式：

- `"byWord"`：逐字下划线。
- `"double"`：双线下划线。
- `"patternDash"`：虚线下划线。
- `"patternDashDot"`：点划线下划线。
- `"patternDashDotDot"`：双点划线下划线。
- `"patternDot"`：点状下划线。
- `"single"`：单线下划线。
- `"thick"`：加粗下划线。

***

### `StyledText`

定义了富文本样式的结构：

- `font`（可选）：指定字体名称，例如：`"title"`、`"body"`。
- `fontDesign`（可选）：自定义字体设计，例如：`"serif"`、`"monospaced"`。
- `fontWeight`（可选）：调整字体粗细，例如：`"light"`、`"bold"`。
- `italic`（可选）：添加斜体样式，类型：`boolean`。
- `bold`（可选）：添加加粗样式，类型：`boolean`。
- `baselineOffset`（可选）：调整文本基线位置，类型：`number`。
- `kerning`（可选）：调整字符间距，类型：`number`。
- `monospaced`（可选）：使用等宽字体，类型：`boolean`。
- `monospacedDigit`（可选）：确保数字字符宽度一致，类型：`boolean`。
- `underlineColor`（可选）：下划线颜色，类型：`Color`。
- `underlineStyle`（可选）：下划线样式，类型：`UnderlineStyle`。
- `strokeColor`（可选）：文本描边颜色，类型：`Color`。
- `strokeWidth`（可选）：文本描边宽度，类型：`number`。
- `strikethroughColor`（可选）：删除线颜色，类型：`Color`。
- `strikethroughStyle`（可选）：删除线样式，类型：`UnderlineStyle`。
- `foregroundColor`（可选）：文本颜色，类型：`Color`。
- `backgroundColor`（可选）：文本背景颜色，类型：`Color`。
- `content`（必填）：指定文本内容，可以是字符串或字符串与 `StyledText` 对象的数组。
- `link`（可选）：为文本添加超链接，类型：`string`。
- `onTapGesture`（可选）：文本被点击时执行的函数，类型：`() => void`。

***

## **`Text` 组件**

### **描述**

一个视图组件，用于显示一行或多行只读文本。内容可以通过 `TextProps` 中的属性进行样式化。

### **示例用法**

1. **纯文本**
   ```tsx
   <Text font="title">
     你好，世界！
   </Text>
   ```

2. **Markdown 文本**
   ```tsx
   <Text attributedString="这是 **加粗**、_斜体_ 和一个 [链接](https://example.com)。" />
   ```

3. **富文本**
   ```tsx
   const richText: StyledText = {
     font: "body",
     bold: true,
     underlineStyle: "single",
     underlineColor: "#00FF00",
     foregroundColor: "#FF0000",
     content: [
       "部分 1，",
       {
         content: "样式",
         italic: true,
         strokeColor: "#0000FF",
         strokeWidth: 2
       },
       "，部分 2"
     ]
   }

   <Text styledText={richText} />
   ```

***

## 注意事项

- **默认字体**：如果未指定 `font` 属性，将使用系统默认字体。
- **性能**：对于动态或频繁更新的内容，确保 `styledText` 对象是不可变的，以避免不必要的重新渲染。
- **点击手势**：在 `StyledText` 中使用 `onTapGesture` 属性为文本添加交互功能。



---
url: /v2/zh/guide/Views/Displaying text/index_example.md
---

# 示例

```tsx
import { Label, List, Markdown, Navigation, NavigationStack, Script, Section, Text, VStack } from "scripting"

function View() {
  return <NavigationStack>
    <List>
      <Section title={"Text"}>
        <VStack>
          <Text
            font={"title"}
            foregroundStyle={"systemRed"}
          >
            Title
          </Text>
          <Text
            font={"body"}
            foregroundStyle={"systemBlue"}
          >Hello Scripting!</Text>
          <Text
            foregroundStyle={"systemGreen"}
            font={"footnote"}
            italic
          >
            This is a footnote.
          </Text>
        </VStack>
      </Section>

      <Section title="AttributedString">
        <Text
          attributedString={`This is regular text.
* This is **bold** text, this is *italic* text, and this is ***bold, italic*** text.
~~A strikethrough example~~
\`Monospaced works too\`
Visit Apple: [click here](https://apple.com)`}
        />
      </Section>

      <Section title={"Label"}>
        <Label
          title={"Hello world"}
          systemImage={"globe"}
        />
      </Section>

      <Section title={"Markdown"}>
        <Markdown
          content={`
# Scripting App
Run your *ideas* quickly **with** scripts.
      `}
        />
      </Section>

      <Section title={"RichText"}>
        <Text
          font={16}
          styledText={{
            content: [
              "I agree the ",
              {
                content: "Terms",
                foregroundColor: "systemOrange",
                underlineColor: "systemBlue",
                bold: true,
                onTapGesture: () => {
                  Dialog.alert({
                    message: "OK!"
                  })
                }
              }
            ]
          }}
        />
      </Section>

    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Editor.md
---

# 编辑器

一个强大的代码编辑器，既可以通过编程方式控制，也可以嵌入自定义视图中展示。编辑器支持语法高亮、读写访问以及完整的生命周期管理，主要通过 `EditorController` 类和 `Editor` 组件来实现。

***

## EditorController

### 概述

`EditorController` 用于管理一个编辑器实例。你可以配置初始内容、监听用户修改、展示或隐藏编辑器，并在不再使用时释放资源。

### 构造函数

用于创建一个新的编辑器控制器实例。

**参数说明**：

- `content`（可选）：编辑器的初始文本内容。
- `ext`（可选）：文件扩展名，用于指定语法高亮语言。支持的类型包括 `tsx`、`ts`、`js`、`jsx`、`txt`、`md`、`css`、`html` 和 `json`。
- `readOnly`（可选）：是否启用只读模式，默认为 `false`。

***

### 属性说明

#### `ext`

只读属性，表示初始化时提供的文件扩展名，用于决定使用哪种语法高亮。

#### `content`

一个字符串，表示当前编辑器的文本内容。可以直接修改该值以更新编辑器内容。

#### `onContentChanged`

可选回调函数，在用户修改内容后大约 **100 毫秒** 被调用。该函数不会在每次输入时立即触发，适合用于防抖、自动保存等逻辑。

***

### 方法说明

#### `present(options?)`

以模态方式展示编辑器。

**参数说明**：

- `navigationTitle`（可选）：设置编辑器的顶部标题。
- `scriptName`（可选）：用于覆盖默认的 `Script.name`，默认为 `"Temporary Script"`。
- `fullscreen`（可选）：是否全屏显示编辑器，默认为 `false`。

**返回值**：返回一个 `Promise`，在编辑器被关闭时完成。

***

#### `dismiss()`

关闭当前展示的编辑器界面。注意，这不会销毁控制器实例，因此可以稍后再次调用 `present()`。

**返回值**：返回一个 `Promise`，在编辑器关闭后完成。

***

#### `dispose()`

释放控制器占用的资源。**必须在不再使用控制器时调用此方法**，以防止内存泄漏。一旦调用该方法，控制器将无法再次使用。

***

## Editor 组件

`Editor` 是一个 React 风格的组件，用于在 UI 中内联渲染编辑器。通常与 `EditorController` 实例搭配使用。

**属性说明**：

- `controller`：编辑器控制器实例，用于管理内容和状态。
- `scriptName`（可选）：用于指定当前编辑器的脚本名称。
- `showAccessoryView` (可选): 当键盘可见时是否显示附件视图。这对于显示“左移”、“右移”、“删除”、“关闭键盘”等按钮非常有用。默认为 false。当编辑器在屏幕上完全可见时（例如，当编辑器是屏幕上唯一的视图时），建议将其设置为 true。

***

### 示例代码

```tsx
function MyEditor() {
  const controller = useMemo(() => {
    return new EditorController({
      content: `const text = "Hello, World!"`,
      ext: "ts",
      readOnly: false,
    })
  }, [])
  
  useEffect(() => {
    return () => {
      // 组件卸载时释放资源
      controller.dispose()
    }
  }, [controller])

  return (
    <Editor
      controller={controller}
      scriptName="My Script"
      showAccessoryView
    />
  )
}
```



---
url: /v2/zh/guide/Views/EnvironmentValuesReader.md
---

`EnvironmentValuesReader` 是 Scripting 提供的一个组件，用于读取 SwiftUI 风格的环境值（Environment Values）。
它允许脚本在视图层级中访问当前环境的上下文信息，例如颜色模式、尺寸类别、是否正在搜索、是否被呈现、编辑模式等。

该组件的定位与 SwiftUI 中的 `@Environment` 类似，但设计上更加明确：
**你必须指定要读取的 environment keys，系统仅在渲染时读取这些值并传入回调函数。**

***

# EnvironmentValues 类型

```ts
type EnvironmentValues = {
    colorScheme: ColorScheme;
    colorSchemeContrast: ColorSchemeContrast;
    displayScale: number;
    horizontalSizeClass: UserInterfaceSizeClass | null;
    verticalSizeClass: UserInterfaceSizeClass | null;
    dismiss: () => void;
    dismissSearch: () => void;
    editMode: EditMode | null;
    widgetRenderingMode: WidgetRenderingMode;
    showsWidgetContainerBackground: boolean;
    isSearching: boolean;
    isPresented: boolean;
    activityFamily: "small" | "medium";
    tabViewBottomAccessoryPlacement: 'expanded' | 'inline';
};
```

以下为每个字段的说明：

***

## 字段说明

### 1. colorScheme

类型：`ColorScheme`
说明：当前系统的颜色模式，例如 `light` 或 `dark`。

***

### 2. colorSchemeContrast

类型：`ColorSchemeContrast`
说明：颜色对比度模式，例如 `standard`、`increased`。

***

### 3. displayScale

类型：`number`
说明：设备屏幕的像素缩放比例，例如 **2.0**, **3.0**。

***

### 4. horizontalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：横向尺寸类别，可用于响应式布局。
可能值：`compact` / `regular`。

***

### 5. verticalSizeClass

类型：`UserInterfaceSizeClass | null`
说明：纵向尺寸类别，行为同上。

***

### 6. dismiss

类型：`() => void`
说明：用于关闭当前呈现的界面，等价于 SwiftUI 的 `dismiss()`。

***

### 7. dismissSearch

类型：`() => void`
说明：关闭当前的搜索 UI（如果 `searchable` 处于激活状态）。

***

### 8. editMode

类型：`EditMode | null`
说明：当前视图是否处于编辑模式（例如 List 的编辑状态）。

***

### 9. widgetRenderingMode

类型：`WidgetRenderingMode`
说明：Widget 渲染模式，例如 `fullColor`、`accented` 等。

***

### 10. showsWidgetContainerBackground

类型：`boolean`
说明：指示 widget 是否显示系统容器背景。

***

### 11. isSearching

类型：`boolean`
说明：当前 view 是否处于搜索状态（来自 `searchable`）。

***

### 12. isPresented

类型：`boolean`
说明：当前 view 是否已呈现，和 `onAppear` 回调不同，不像 `onAppear` 会多次触发。

***

### 13. activityFamily

类型：`"small" | "medium"`
说明：当前LiveActivity的尺寸，同 SwiftUI 中的 `activityFamily`，用于根据些大小渲染 LiveActivity UI。

***

### 14. tabViewBottomAccessoryPlacement

类型：`'expanded' | 'inline'`
说明：当前 TabView 的底部辅助栏的显示方式，同 SwiftUI 中的 `tabViewBottomAccessoryPlacement`。

# EnvironmentValuesReader 组件

```ts
type EnvironmentValuesReaderProps = {
    /**
     * The keys to read from the environment values.
     */
    keys: Array<keyof EnvironmentValues>;
    /**
     * The callback function to render the children, it will be called with the environment values.
     */
    children: (values: EnvironmentValues) => VirtualNode;
};
```

***

# Props 说明

## keys

类型：`Array<keyof EnvironmentValues>`
说明：指定需要读取的 environment key 列表。

只有指定的 key 才会被 read 并传入 children。

***

## children(values)

类型：`(values: EnvironmentValues) => VirtualNode`
说明：用于渲染子节点的回调。
系统会收集你请求的 environment key，并将其值合并成一个对象传入。

***

# 组件定义

```ts
declare const EnvironmentValuesReader: FunctionComponent<EnvironmentValuesReaderProps>;
```

***

# 使用示例

## 示例：读取 colorScheme 和 displayScale

```tsx
import { EnvironmentValuesReader, Text, VStack } from "scripting"

function View() {
  return <EnvironmentValuesReader
    keys={["colorScheme", "displayScale"]}
  >
    {(env) => {
      return <VStack>
        <Text>Color Scheme: {env.colorScheme}</Text>
        <Text>Scale: {env.displayScale}</Text>
      </VStack>
    }}
  </EnvironmentValuesReader>
}
```

***

## 示例：读取 dismiss

```tsx
<EnvironmentValuesReader keys={["dismiss"]}>
  {(env) => {
    return <Button
      title="Close"
      action={() => env.dismiss()}
    />
  }}
</EnvironmentValuesReader>
```

***

## 示例：根据 sizeClass 动态布局

```tsx
<EnvironmentValuesReader keys={["horizontalSizeClass"]}>
  {(env) => {
    const compact = env.horizontalSizeClass === "compact"
    return compact ? <Text>Compact Layout</Text> : <Text>Regular Layout</Text>
  }}
</EnvironmentValuesReader>
```

***

# 使用注意事项

1. **必须显式指定 keys**，否则不会读取任何 environment 值。
2. 每次所指定的 environment key 发生变化时，`children()` 会重新渲染。
3. `dismiss` 和 `dismissSearch` 是实际可调用的操作，与 SwiftUI 一致。
4. environment 的来源来自父视图树，包括 `Navigation`, `searchable`, `editMode`, `Widget` 等组件。
5. 未在 keys 中声明的字段不会出现在 values 对象中。
6. 不用于替代全局状态，适用于读取系统环境或父组件传递的上下文信息。



---
url: /v2/zh/guide/Views/GeometryReader.md
---

`GeometryReader` 是 Scripting 中与 SwiftUI 等效的几何布局读取组件。
它能够在视图构建阶段提供当前容器的尺寸、边距、安全区域和角落内边距等信息，使开发者可以根据环境动态布局内容。

当你需要根据父容器的大小进行自适应布局（响应式布局）时，`GeometryReader` 是非常重要的工具。

***

# GeometryProxy

当 `GeometryReader` 构建其子内容时，会将一个 `GeometryProxy` 实例传递给 `children` 回调。开发者可以使用此对象访问与当前容器相关的布局信息。

```ts
interface GeometryProxy {
  readonly size: Size;
  readonly safeAreaInsets: {
      leading: number;
      top: number;
      trailing: number;
      bottom: number;
  };
  /**
   * Requires iOS 26.0+.
   */
  readonly containerCornerInsets: {
      bottomLeading: Size;
      bottomTrailing: Size;
      topLeading: Size;
      topTrailing: Size;
  } | null;
}
```

***

# GeometryProxy 属性说明

## 1. size

```ts
readonly size: Size
```

当前容器在布局时的实际尺寸。

### Size 结构

```ts
type Size = {
  width: number
  height: number
}
```

### 示例

```tsx
proxy.size.width
proxy.size.height
```

用于动态计算子视图布局，例如宽高比、自适应排版等。

***

## 2. safeAreaInsets

```ts
readonly safeAreaInsets: {
  leading: number
  top: number
  trailing: number
  bottom: number
}
```

当前视图所处环境中的安全区域内边距，包括顶部、底部、左右侧的避让区域。
通常用于避免内容被刘海、Home Indicator 等遮挡。

### 示例用途：

- 内容距离屏幕底部安全区域以上对齐
- 自定义导航栏、工具栏时避免被遮挡
- 实现与设备 UI 边界一致的响应式布局

***

## 3. containerCornerInsets（iOS 26.0+）

```ts
readonly containerCornerInsets: {
  bottomLeading: Size
  bottomTrailing: Size
  topLeading: Size
  topTrailing: Size
} | null
```

该属性仅在 **iOS 26+** 提供，并在设备或容器具有物理圆角偏移时报告每个角落的内边距。

### 用途

- 为圆角窗口、Stage Manager 或分屏环境适配布局
- 在容器圆角内做精确的 UI 对齐

如果平台不支持，则为 `null`。

***

# GeometryReader

```ts
type GeometryReaderProps = {
  children: (proxy: GeometryProxy) => VirtualNode;
};
declare const GeometryReader: FunctionComponent<GeometryReaderProps>;
```

## Props 说明

| 属性名      | 类型                                      | 必须 | 说明                                     |
| -------- | --------------------------------------- | -- | -------------------------------------- |
| children | `(proxy: GeometryProxy) => VirtualNode` | 是  | 构建内容的回调函数，传入 `GeometryProxy` 用于读取布局信息。 |

***

# 工作机制

1. GeometryReader 占据父布局中的位置，并在布局阶段获取当前容器的尺寸与安全区域信息。
2. 将 `GeometryProxy` 注入给 `children(proxy)` 回调。
3. 回调返回的内容将根据读取的信息动态布局。

与 SwiftUI 一样，`GeometryReader` 默认会扩展到可用空间。

***

# 示例：居中布局

```tsx
import { GeometryReader, Text, VStack } from "scripting"

function View() {
  return <GeometryReader>
    {(proxy) => {
      return <VStack
        frame={{
          width: proxy.size.width,
          height: proxy.size.height,
          alignment: "center"
        }}
      >
        <Text>Hello Geometry</Text>
        <Text>
          width: {proxy.size.width}
        </Text>
        <Text>
          height: {proxy.size.height}
        </Text>
      </VStack>
    }}
  </GeometryReader>
}
```

***

# 示例：根据安全区域调整布局

```tsx
<GeometryReader>
  {(proxy) => {
    return <VStack
      padding={{
        top: proxy.safeAreaInsets.top,
        bottom: proxy.safeAreaInsets.bottom
      }}
    >
      <Text>Content inside safe area.</Text>
    </VStack>
  }}
</GeometryReader>
```

***

# 示例（iOS 26+）：读取 containerCornerInsets

```tsx
<GeometryReader>
  {(proxy) => {
    const corners = proxy.containerCornerInsets
    return <Text>
      {corners == null
        ? "Corner insets not available"
        : `Top Leading Corner: ${corners.topLeading.width}, ${corners.topLeading.height}`
      }
    </Text>
  }}
</GeometryReader>
```

***

# 使用建议

- 在需要响应容器尺寸时使用 GeometryReader，例如图片缩放、动态布局、等比布局。
- 避免将大量复杂布局放入 GeometryReader 内，可能影响性能（同 SwiftUI）。



---
url: /v2/zh/guide/Views/Gestures.md
---

# 手势

Scripting 提供了与 SwiftUI 类似的完整手势系统，可为任意视图（如 `<VStack>`、`<HStack>`、`<Text>` 等）添加点击、长按、拖动、缩放、旋转等交互行为。
开发者既可以使用简化的 `onTapGesture` / `onLongPressGesture` / `onDragGesture` 等直接属性，也可以使用新的 `Gesture` 类接口和 `gesture` 修饰符，以获得更灵活的组合方式。

***

## 一、直接手势属性（简化用法）

这些属性提供最直接的交互绑定方式，适合快速使用场景。

***

### 1. `onTapGesture`

在识别到点击手势时执行指定操作。

#### 类型

```ts
onTapGesture?: (() => void) | {
  count: number
  perform: () => void
}
```

#### 参数

| 参数        | 类型           | 默认值 | 说明                |
| --------- | ------------ | --- | ----------------- |
| `count`   | `number`     | `1` | 点击次数（1 为单击，2 为双击） |
| `perform` | `() => void` | —   | 识别到点击后执行的操作       |

#### 示例

```tsx
// 单击触发
<VStack onTapGesture={() => console.log('点击了')} />

// 双击触发
<HStack
  onTapGesture={{
    count: 2,
    perform: () => console.log('双击了')
  }}
/>
```

***

### 2. `onLongPressGesture`

在识别到长按手势时执行操作，可监听按压状态。

#### 类型

```ts
onLongPressGesture?: (() => void) | {
  minDuration?: number
  maxDuration?: number
  perform: () => void
  onPressingChanged?: (state: boolean) => void
}
```

#### 参数

| 参数                  | 类型                         | 默认值     | 说明             |
| ------------------- | -------------------------- | ------- | -------------- |
| `minDuration`       | `number`                   | `500`   | 触发长按所需最短时间（毫秒） |
| `maxDuration`       | `number`                   | `10000` | 长按的最长持续时间（毫秒）  |
| `perform`           | `() => void`               | —       | 长按触发时执行的操作     |
| `onPressingChanged` | `(state: boolean) => void` | —       | 按下或松开时的状态回调    |

#### 示例

```tsx
// 基本用法
<VStack onLongPressGesture={() => console.log('长按触发')} />

// 自定义参数
<HStack
  onLongPressGesture={{
    minDuration: 800,
    maxDuration: 3000,
    perform: () => console.log('长按成功'),
    onPressingChanged: isPressing =>
      console.log(isPressing ? '正在按压' : '已松开')
  }}
/>
```

***

### 3. `onDragGesture`

为视图添加拖动交互，支持实时位置变化与拖动结束事件。

#### 类型

```ts
onDragGesture?: {
  minDistance?: number
  coordinateSpace?: 'local' | 'global'
  onChanged?: (details: DragGestureDetails) => void
  onEnded?: (details: DragGestureDetails) => void
}
```

#### 参数

| 参数                | 类型                                      | 默认值       | 说明           |
| ----------------- | --------------------------------------- | --------- | ------------ |
| `minDistance`     | `number`                                | `10`      | 触发拖动的最小距离（点） |
| `coordinateSpace` | `'local' \| 'global'`                   | `'local'` | 坐标系类型        |
| `onChanged`       | `(details: DragGestureDetails) => void` | —         | 拖动过程中回调      |
| `onEnded`         | `(details: DragGestureDetails) => void` | —         | 拖动结束时回调      |

#### `DragGestureDetails` 类型

```ts
type DragGestureDetails = {
  time: number
  location: Point
  startLocation: Point
  translation: Size
  velocity: Size
  predictedEndLocation: Point
  predictedEndTranslation: Size
}
```

| 字段                        | 说明                  |
| ------------------------- | ------------------- |
| `time`                    | 当前事件时间戳（毫秒）         |
| `location`                | 当前触摸位置 `{x, y}`     |
| `startLocation`           | 拖动起始位置              |
| `translation`             | 从开始拖动至当前的偏移量        |
| `velocity`                | 当前速度（points/second） |
| `predictedEndLocation`    | 预测结束位置              |
| `predictedEndTranslation` | 预测总偏移量              |

#### 示例

```tsx
<VStack
  onDragGesture={{
    minDistance: 5,
    coordinateSpace: 'global',
    onChanged: details => {
      console.log('当前坐标:', details.location)
      console.log('偏移量:', details.translation)
    },
    onEnded: details => {
      console.log('预测结束位置:', details.predictedEndLocation)
    }
  }}
/>
```

***

## 二、Gesture 类接口（高级用法）

若需要更复杂的组合或同时识别多个手势，可使用 `Gesture` 类与 `gesture` 修饰符。

所有手势均返回一个 `GestureInfo` 实例，通过 `.onChanged()` 与 `.onEnded()` 注册事件。

***

### 1. GestureInfo 类

```ts
class GestureInfo<Options, Value> {
  type: string
  options: Options
  onChanged(callback: (value: Value) => void): this
  onEnded(callback: (value: Value) => void): this
}
```

| 方法                     | 说明                  |
| ---------------------- | ------------------- |
| `.onChanged(callback)` | 手势状态变化时调用（如拖动中、缩放中） |
| `.onEnded(callback)`   | 手势结束时调用             |

#### 示例

```tsx
<Text
  gesture={
    TapGesture()
      .onEnded(() => console.log('点击结束'))
  }
/>
```

***

### 2. TapGesture（点击手势）

```ts
declare function TapGesture(count?: number): GestureInfo<number | undefined, void>
```

| 参数      | 类型       | 默认值 | 说明   |
| ------- | -------- | --- | ---- |
| `count` | `number` | `1` | 点击次数 |

#### 示例

```tsx
<Text
  gesture={
    TapGesture(2)
      .onEnded(() => console.log('双击了'))
  }
/>
```

***

### 3. LongPressGesture（长按手势）

```ts
declare function LongPressGesture(options?: LongPressGestureOptions): GestureInfo<LongPressGestureOptions, boolean>

type LongPressGestureOptions = {
  minDuration?: number
  maxDuration?: number
}
```

| 参数            | 默认值   | 说明               |
| ------------- | ----- | ---------------- |
| `minDuration` | 500   | 触发所需的最短时间（毫秒）    |
| `maxDuration` | 10000 | 手指移动前的最长持续时间（毫秒） |

#### 示例

```tsx
<Text
  gesture={
    LongPressGesture({ minDuration: 800 })
      .onChanged(() => console.log('正在长按'))
      .onEnded(() => console.log('长按完成'))
  }
/>
```

***

### 4. DragGesture（拖动手势）

```ts
declare function DragGesture(options?: DragGestureOptions): GestureInfo<DragGestureOptions, DragGestureDetails>

type DragGestureOptions = {
  minDistance?: number
  coordinateSpace?: 'local' | 'global'
}
```

#### 示例

```tsx
<VStack
  gesture={
    DragGesture({ coordinateSpace: 'global' })
      .onChanged(d => console.log('偏移', d.translation))
      .onEnded(d => console.log('速度', d.velocity))
  }
/>
```

***

### 5. MagnifyGesture（缩放手势）

```ts
declare function MagnifyGesture(minScaleDelta?: number | null): GestureInfo<number | null | undefined, MagnifyGestureValue>

type MagnifyGestureValue = {
  time: Date
  magnification: number
  startAnchor: Point
  startLocation: Point
  velocity: number
}
```

#### 示例

```tsx
<Text
  gesture={
    MagnifyGesture(0.05)
      .onChanged(v => console.log('缩放倍率', v.magnification))
      .onEnded(() => console.log('缩放结束'))
  }
/>
```

***

### 6. RotateGesture（旋转手势）

```ts
declare function RotateGesture(minAngleDelta?: Angle | null): GestureInfo<Angle | null | undefined, RotateGestureValue>

type RotateGestureValue = {
  rotation: AngleValue
  velocity: AngleValue
  startAnchor: Point
  time: Date
}

type AngleValue = {
  radians: number
  degrees: number
  magnitude: number
  animatableData: number
}
```

#### 示例

```tsx
<ZStack
  gesture={
    RotateGesture()
      .onChanged(v => console.log('旋转角度', v.rotation.degrees))
      .onEnded(() => console.log('旋转完成'))
  }
/>
```

***

## 三、手势修饰符（Gesture Modifiers）

以下属性可添加在任何视图上，用于控制手势识别行为。

```ts
type GesturesProps = {
  gesture?: GestureProps
  simultaneousGesture?: GestureProps
  highPriorityGesture?: GestureProps
  defersSystemGestures?: EdgeSet
}
```

***

### 1. `gesture`

为视图添加一个手势。

```tsx
<Text
  gesture={
    TapGesture()
      .onEnded(() => console.log('点击'))
  }
/>
```

***

### 2. `highPriorityGesture`

使该手势的识别优先于同视图上的其他手势。

```tsx
<Text
  highPriorityGesture={
    TapGesture(2)
      .onEnded(() => console.log('双击优先'))
  }
/>
```

***

### 3. `simultaneousGesture`

允许多个手势同时识别。

```tsx
<Text
  simultaneousGesture={
    LongPressGesture()
      .onEnded(() => console.log('长按'))
  }
  gesture={
    TapGesture()
      .onEnded(() => console.log('点击'))
  }
/>
```

***

### 4. `defersSystemGestures`

设置屏幕边缘的优先权，使自定义手势优先于系统手势（如返回手势）。

```tsx
<VStack defersSystemGestures="all">
  <Text>边缘手势优先</Text>
</VStack>
```

| 值              | 说明           |
| -------------- | ------------ |
| `'top'`        | 顶部边缘         |
| `'leading'`    | 左边缘（RTL 时为右） |
| `'trailing'`   | 右边缘          |
| `'bottom'`     | 底部边缘         |
| `'horizontal'` | 左右两侧         |
| `'vertical'`   | 上下两侧         |
| `'all'`        | 所有边缘         |

***

## 四、GestureMask（手势优先级控制）

定义当添加多个手势时的优先策略。

```ts
type GestureMask = "all" | "gesture" | "subviews" | "none"
```

| 值            | 说明              |
| ------------ | --------------- |
| `"all"`      | 启用所有手势（默认）      |
| `"gesture"`  | 仅启用当前手势，禁用子视图手势 |
| `"subviews"` | 启用子视图手势，禁用当前手势  |
| `"none"`     | 禁用所有手势          |

#### 示例

```tsx
<VStack
  gesture={{
    gesture: TapGesture().onEnded(() => console.log('Tapped')),
    mask: 'gesture'
  }}
>
  <Text>Tap me</Text>
</VStack>
```

***

## 五、总结对比表

| 手势类型 | 描述      | 对应类函数              | 直接属性                 | 常用回调                          |
| ---- | ------- | ------------------ | -------------------- | ----------------------------- |
| 点击   | 检测单击或多击 | `TapGesture`       | `onTapGesture`       | `.onEnded()`                  |
| 长按   | 检测持续按压  | `LongPressGesture` | `onLongPressGesture` | `.onChanged()` / `.onEnded()` |
| 拖动   | 检测移动轨迹  | `DragGesture`      | `onDragGesture`      | `.onChanged()` / `.onEnded()` |
| 缩放   | 双指缩放    | `MagnifyGesture`   | —                    | `.onChanged()` / `.onEnded()` |
| 旋转   | 双指旋转    | `RotateGesture`    | —                    | `.onChanged()` / `.onEnded()` |



---
url: /v2/zh/guide/Views/Image/index.md
---

# 图像

`Image` 组件用于展示图片，支持来自多种来源的图像，包括系统图标、网络图片、本地文件以及 `UIImage` 对象。同时，它还支持根据浅色 / 深色模式动态切换图片资源，并提供多个视图修饰符用于自定义图像的行为和外观。

***

## **类型定义**

### `ImageResizable`

定义图片的缩放方式：

- **`boolean` 类型**：

  - `true`: 启用默认缩放行为。
  - `false`: 禁用缩放。

- **`object` 类型**：

  - **`capInsets`** _(可选)_: `EdgeInsets`
    设置图片拉伸的边距，用于控制哪些区域被拉伸，哪些保持不变。

  - **`resizingMode`** _(可选)_: `ImageResizingMode`
    设置图片的拉伸模式，例如缩放（stretch）或平铺（tile）。

### `ImageScale`

设置图像在视图中的相对大小：

- `'large'`：较大尺寸
- `'medium'`：中等尺寸
- `'small'`：较小尺寸

### `DynamicImageSource<T>`

用于根据系统的浅色或深色模式动态切换图片资源：

```ts
type DynamicImageSource<T> = {
  dark: T
  light: T
}
```

可用于以下字段：

- `imageUrl`: 网络图片
- `filePath`: 本地图片
- `image`: `UIImage` 对象

***

## **图片来源参数类型**

### `SystemImageProps`

- **`systemName`** _(string, 必填)_
  系统图标名称。可在 [SF Symbols 官网](https://developer.apple.com/design/resources/#sf-symbols) 或 [SF Symbols Browser App](https://apps.apple.com/cn/app/sf-symbols-reference/id1491161336?l=en-GB) 中查看所有图标。

- **`variableValue`** _(number, 可选)_
  一个介于 `0.0` 到 `1.0` 之间的值，用于动态调整支持变量图标的外观。若图标不支持变量值，此项无效。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

### `NetworkImageProps`

- **`imageUrl`** _(string | DynamicImageSource\<string>, 必填)_
  图片的网络 URL 地址。支持使用 `DynamicImageSource` 实现浅色/深色模式下切换图片。

- **`placeholder`** _(VirtualNode, 可选)_
  图片加载完成前显示的占位视图。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

### `FileImageProps`

- **`filePath`** _(string | DynamicImageSource\<string>, 必填)_
  本地图片文件的路径。支持使用 `DynamicImageSource` 动态切换。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

### `UIImageProps`

- **`image`** _(UIImage | DynamicImageSource\<UIImage>, 必填)_
  一个 `UIImage` 对象。支持动态切换 `UIImage` 对象以适应浅色/深色模式。

- **`resizable`** _(ImageResizable, 可选)_
  设置图像的缩放方式。

***

## **通用视图修饰符（CommonViewProps）**

- **`scaleToFit`** _(boolean, 可选)_
  缩放图像以适配容器大小。

- **`scaleToFill`** _(boolean, 可选)_
  缩放图像以填满容器。

- **`aspectRatio`** _(object, 可选)_
  设置图像宽高比例：

  - **`value`** _(number 或 null, 可选)_：宽高比。为 null 时保持原始比例。
  - **`contentMode`** _(ContentMode, 必填)_：设置是适配（fit）还是填充（fill）。

- **`imageScale`** _(ImageScale, 可选)_
  设置图像缩放等级。可选值：`'large'`、`'medium'`、`'small'`

- **`foregroundStyle`** _(ShapeStyle | DynamicShapeStyle | object, 可选)_
  设置前景样式，可用于系统图标等：

  - **`primary`**：主前景颜色或样式
  - **`secondary`**：辅助前景样式
  - **`tertiary`** _(可选)_：第三前景样式

***

### 图像渲染行为（ImageRenderingBehaviorProps）

| 属性                            | 类型                                      | 默认值          | 说明                                           |
| ----------------------------- | --------------------------------------- | ------------ | -------------------------------------------- |
| `resizable`                   | `boolean \| object`                     | `false`      | 控制图像是否自适应尺寸（详见下方）                            |
| `renderingMode`               | `'original' \| 'template'`              | `'original'` | 设置图像渲染模式，`template` 可使用 `foregroundColor` 着色 |
| `interpolation`               | `'none' \| 'low' \| 'medium' \| 'high'` | `'medium'`   | 设置图像缩放时的插值质量                                 |
| `antialiased`                 | `boolean`                               | `false`      | 是否开启抗锯齿边缘渲染                                  |
| `widgetAccentedRenderingMode` | `WidgetAccentedRenderingMode`           | -            | 控制在 Widget 的强调模式下的图像渲染方式（仅 Widget 有效）        |

***

## **使用示例**

1. **根据浅色/深色模式切换网络图片**

```tsx
<Image
  imageUrl={{
    light: "https://example.com/image-light.png",
    dark: "https://example.com/image-dark.png"
  }}
  placeholder={<Text>加载中...</Text>}
/>
```

2. **本地图片动态切换**

```tsx
<Image
  filePath={{
    light: Path.join(Script.directory, "light.jpg"),
    dark: Path.join(Script.directory, "dark.jpg")
  }}
  resizable={true}
/>
```

3. **UIImage 动态切换**

```tsx
const lightImage = UIImage.fromFile('/path/light.png')
const darkImage = UIImage.fromFile('/path/dark.png')

<Image image={{ light: lightImage, dark: darkImage }} />
```

4. **系统图标，设置缩放和宽高比**

```tsx
<Image
  systemName="square.and.arrow.up.circle"
  scaleToFit={true}
  aspectRatio={{ value: 1.0, contentMode: "fit" }}
  imageScale="medium"
  foregroundStyle={{
    primary: "blue",
    secondary: "gray",
  }}
/>
```

***

## 注意事项

- 通过 `DynamicImageSource` 可以实现根据系统外观自动切换图片资源，适配浅色/深色主题。
- 可以组合使用 `scaleToFit`、`scaleToFill`、`aspectRatio` 等修饰符，灵活控制布局。
- `foregroundStyle` 可用于精细控制图标或图形的配色样式。
- 使用网络图片时请确保 URL 可访问；使用本地路径时确保文件存在。



---
url: /v2/zh/guide/Views/Image/index_example.md
---

# 示例

```tsx
import { Button, Image, List, Markdown, Navigation, NavigationStack, ProgressView, QRImage, Script, Section, Text, VStack } from "scripting"

function View() {
  const dismiss = Navigation.useDismiss()
  const url = "https://github.com"

  return <NavigationStack>
    <List
      navigationTitle={"Image"}
      toolbar={{
        topBarLeading: <Button
          title={"Close"}
          action={dismiss}
        />
      }}
    >

      <Section title={"Network Image"}>
        <Image
          imageUrl={'https://developer.apple.com/assets/elements/icons/swiftui/swiftui-96x96_2x.png'}
          resizable
          scaleToFit
          placeholder={<ProgressView
            progressViewStyle={'circular'}
          />}
        />
      </Section>

      <Section title={"SF Symbol"}>
        <Image
          systemName={"phone"}
          resizable
          scaleToFit
          frame={{
            width: 32,
            height: 32,
          }}
          foregroundStyle={"systemGreen"}
        />
      </Section>

      <Section title={"Local Image"}>
        <Markdown
          content={`\`\`\`tsx
<Image
  filePath={Path.join(Script.directory, "test.jpg")}
/>
\`\`\``}
        />
      </Section>

      <Section title={"QR Code Image"}>
        <VStack>
          <Text>URL: {url}</Text>
          <QRImage
            data={url}
          />
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/FlowLayout.md
---

# 流式布局组件(FlowLayout)

`FlowLayout` 是一种流式布局组件，用于按照水平方向依次排列子视图，当空间不足时会自动换行至下一行。适用于展示一组大小不一的元素，如标签、按钮、图标列表等。

***

## 导入方式

```ts
import { FlowLayout } from "scripting"
```

***

## 属性（Props）

### `spacing?: number`

元素之间的间距（水平与垂直间距），单位为像素。

- 默认值：`8`
- 类型：`number`

用于设置每个子元素之间的间距，若不指定则使用默认间距。

### `children?: VirtualNode | (VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[]`

要显示的子元素集合。

- 支持单个子节点或多个节点
- `undefined` 和 `null` 类型的子元素会被忽略
- 可传入嵌套数组（常见于使用 `map` 渲染）

***

## 示例

### 基本用法

```ts
import { FlowLayout, Text } from "scripting"

export default function Example() {
  return (
    <FlowLayout spacing={12}>
      <Text>标签一</Text>
      <Text>标签二</Text>
      <Text>标签三</Text>
      <Text>标签四</Text>
    </FlowLayout>
  )
}
```

### 搭配数组渲染

```ts
const tags = ["Apple", "Orange", "Banana", "Pear", "Grape"]

export default function TagsExample() {
  return (
    <FlowLayout spacing={6}>
      {tags.map(tag => <Text>{tag}</Text>)}
    </FlowLayout>
  )
}
```

### 使用默认间距

```ts
<FlowLayout>
  <Text>A</Text>
  <Text>B</Text>
  <Text>C</Text>
</FlowLayout>
```

***

## 使用场景示例

适用于以下布局需求：

- 标签集合展示（Tag Cloud）
- 动态宽度按钮组
- 图标/头像流式排列
- 自适应内容容器



---
url: /v2/zh/guide/Views/Layout/Grid/index.md
---

# 网格布局（Grid）

**Scripting 应用**中的 `Grid` 组件提供了一个灵活的容器，用于将子视图排列为二维网格布局。它支持自定义对齐、间距以及嵌套子组件，从而创建美观的布局。

***

### `Grid` 组件

一个容器视图，用于将其他视图排列为二维布局。

### 导入路径

```ts
import { Grid, GridRow } from 'scripting'
```

***

### 类型：`GridProps`

| 属性                  | 类型                                                                                            | 默认值      | 描述                                                                        |
| ------------------- | --------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------- |
| `alignment`         | `Alignment`                                                                                   | `center` | 子视图在每个网格单元格中的对齐方式。可选值包括 `leading`（靠左对齐）、`center`（居中对齐）或 `trailing`（靠右对齐）。 |
| `horizontalSpacing` | `number`                                                                                      | 平台默认值    | 每个单元格之间的水平距离（以点为单位）。如果未设置，则为平台定义的默认值。                                     |
| `verticalSpacing`   | `number`                                                                                      | 平台默认值    | 每个单元格之间的垂直距离（以点为单位）。如果未设置，则为平台定义的默认值。                                     |
| `children`          | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | N/A      | 要在网格中排列的子组件或节点。                                                           |

***

### `GridRow` 组件

`Grid` 的子组件，表示网格布局中的水平行。使用 `GridRow` 可水平分组并对齐网格中的子视图。

***

### 类型：`GridRowProps`

| 属性          | 类型                                                                                            | 默认值      | 描述                                                           |
| ----------- | --------------------------------------------------------------------------------------------- | -------- | ------------------------------------------------------------ |
| `alignment` | `VerticalAlignment`                                                                           | `center` | 将内容在行内垂直对齐。可选值包括 `top`（顶部对齐）、`center`（居中对齐）或 `bottom`（底部对齐）。 |
| `children`  | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | N/A      | 要在行内水平排列的子组件或节点。                                             |

***

## 使用示例

以下示例展示了如何使用 `Grid` 和 `GridRow` 组件创建包含行、文本、图像和分隔符的布局。

```tsx
<Grid
  alignment="center"
  horizontalSpacing={10}
  verticalSpacing={15}
>
  <GridRow alignment="center">
    <Text>Hello</Text>
    <Image systemName="globe" />
  </GridRow>
  <Divider />
  <GridRow alignment="bottom">
    <Image systemName="hand.wave" />
    <Text>World</Text>
  </GridRow>
</Grid>
```

**输出布局**

- **第一行：** 包含一个 `Text` 元素（“Hello”）和一个显示 `globe` 图标的 `Image`，垂直居中对齐。
- **分隔符：** 分隔两行。
- **第二行：** 包含一个显示 `wave` 图标的 `Image` 和一个 `Text` 元素（“World”），垂直底部对齐。

***

### 属性详细说明

1. **Grid: Alignment（对齐）**
   - 设置每个单元格内内容的对齐方式。
   - 可选值：
     - `leading`：内容对齐到单元格的起始位置。
     - `center`：内容居中对齐（默认值）。
     - `trailing`：内容对齐到单元格的结束位置。
   - 示例：
     ```tsx
     <Grid alignment="leading">
       <GridRow>
         <Text>Aligned to start</Text>
       </GridRow>
     </Grid>
     ```

2. **GridRow: Alignment（行对齐）**
   - 设置每行内容的垂直对齐方式。
   - 可选值：
     - `top`：内容对齐到行顶部。
     - `center`：内容垂直居中（默认值）。
     - `bottom`：内容对齐到行底部。
   - 示例：
     ```tsx
     <Grid>
       <GridRow alignment="top">
         <Text>Top-aligned</Text>
       </GridRow>
       <GridRow alignment="bottom">
         <Text>Bottom-aligned</Text>
       </GridRow>
     </Grid>
     ```

3. **水平和垂直间距**
   - 自定义单元格和行之间的间距。
   - 示例：
     ```tsx
     <Grid horizontalSpacing={5} verticalSpacing={20}>
       <GridRow>
         <Text>Item 1</Text>
         <Text>Item 2</Text>
       </GridRow>
     </Grid>
     ```

4. **Children（子组件）**
   - 接受任意组合的 `VirtualNode` 组件，包括 `Text`、`Image`、`GridRow` 和自定义组件。
   - 支持嵌套数组或空值，以便灵活创建动态布局。

***

## 嵌套组件

`Grid` 和 `GridRow` 组件可与其他支持的 UI 元素无缝结合使用：

- **`Divider`：** 在行之间添加视觉分隔。
- **`Text`、`Image` 和自定义组件：** 可将任意支持的 UI 组件作为 `GridRow` 的子元素。

***

## 图像示例

以下示例展示了输出布局的图像：

![Grid 示例](https://docs-assets.developer.apple.com/published/f20954fd2b30390306220984d444d0cf/Grid-2-iOS@2x.png)

此布局对应前述示例，显示了两行内容及一个分隔符。

***

## 注意事项

- **默认间距：** 水平和垂直间距值针对 iOS 进行了优化，但可根据具体设计需求进行自定义。
- **对齐选项：** 将 `Grid` 的单元格对齐与 `GridRow` 的垂直对齐结合使用，实现精确的布局控制。
- **动态布局：** `Grid` 和 `GridRow` 的灵活性使其适用于具有可变内容的响应式设计。

欢迎尝试使用不同的子组件和间距配置，创建适合您 UI 的定制设计！



---
url: /v2/zh/guide/Views/Layout/Grid/index_example.md
---

# 示例

```tsx
import { Divider, ForEach, Grid, GridRow, Image, List, Navigation, NavigationStack, Rectangle, Script, Section, Text, Toggle, useState, VStack } from "scripting"

function Example() {
  const [gridCellUnsizedAxes, setGridCellUnsizedAxes] = useState(false)

  return <NavigationStack>
    <List
      navigationTitle={"Grid"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>Grid</Text>
        }
      >
        <Grid>
          <GridRow>
            <Text>Hello</Text>
            <Image systemName={"globe"} />
          </GridRow>
          <GridRow>
            <Image systemName={"hand.wave"} />
            <Text>World</Text>
          </GridRow>
        </Grid>
      </Section>

      <Section
        header={<Text>Grid Divider</Text>}
      >
        <VStack>
          <Toggle
            title={"gridCellUnsizedAxes"}
            value={gridCellUnsizedAxes}
            onChanged={setGridCellUnsizedAxes}
          />
          <Grid>
            <GridRow>
              <Text>Hello</Text>
              <Image systemName={"globe"} />
            </GridRow>
            <Divider
              gridCellUnsizedAxes={gridCellUnsizedAxes
                ? 'horizontal'
                : undefined}
            />
            <GridRow>
              <Image systemName={"hand.wave"} />
              <Text>World</Text>
            </GridRow>
          </Grid>
        </VStack>
      </Section>

      <Section
        header={
          <Text>Column count, cell spacing, alignment</Text>
        }
      >
        <Grid
          alignment={"bottom"}
          verticalSpacing={1}
          horizontalSpacing={1}
        >
          <GridRow>
            <Text>Row 1</Text>
            <ForEach
              count={2}
              itemBuilder={index =>
                <Rectangle
                  fill={"red"}
                  key={index.toString()}
                />
              }
            />
          </GridRow>
          <GridRow>
            <Text>Row 2</Text>
            <ForEach
              count={5}
              itemBuilder={index =>
                <Rectangle
                  fill={"green"}
                  key={index.toString()}
                />
              }
            />
          </GridRow>
          <GridRow>
            <Text>Row 3</Text>
            <ForEach
              count={5}
              itemBuilder={index =>
                <Rectangle
                  fill={"blue"}
                  key={index.toString()}
                />
              }
            />
          </GridRow>
        </Grid>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/HStack/index.md
---

# 水平布局（HStack）

在Scripting应用中，`HStack` 组件提供了一种方便的方法，用于以灵活的对齐和间距选项水平排列视图。此组件是创建需要子视图并排布局的关键工具。

***

## `HStackProps`

### 属性

1. **`alignment`** (可选)
   - **类型**: `VerticalAlignment`
   - **描述**: 指定堆栈中子视图的垂直对齐方式。每个子视图都会根据相同的垂直屏幕坐标对齐。
   - **默认值**: `"center"`
   - **可选值**:
     - `"top"`: 将子视图对齐到顶部边缘。
     - `"center"`: 将子视图对齐到垂直中心。
     - `"bottom"`: 将子视图对齐到底部边缘。
     - `"firstTextBaseline"`: 根据文本的第一个基线对齐子视图。
     - `"lastTextBaseline"`: 根据文本的最后一个基线对齐子视图。
   - **示例**:
     ```tsx
     <HStack alignment="top">
       <Text>Item 1</Text>
       <Text>Item 2</Text>
     </HStack>
     ```

2. **`spacing`** (可选)
   - **类型**: `number`
   - **描述**: 指定相邻子视图之间的间距。如果未提供，堆栈将自动使用默认间距。
   - **默认值**: `undefined`（使用默认间距）
   - **示例**:
     ```tsx
     <HStack spacing={15}>
       <Text>Item 1</Text>
       <Text>Item 2</Text>
     </HStack>
     ```

3. **`children`** (可选)
   - **类型**:
     ```ts
     (VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode | undefined
     ```
   - **描述**: 指定要排列在堆栈中的子视图。可以接受单个子视图、多个子视图或嵌套数组的子视图。
   - **示例**:
     ```tsx
     <HStack>
       <Text>Item 1</Text>
       <Text>Item 2</Text>
       <Text>Item 3</Text>
     </HStack>
     ```

***

## `VerticalAlignment`

`VerticalAlignment` 是一个枚举类型，用于指定子视图在 `HStack` 中的垂直对齐方式。

### 可选值：

- **`"top"`**: 将子视图对齐到顶部边缘。
- **`"center"`**: 将子视图对齐到垂直中心轴。
- **`"bottom"`**: 将子视图对齐到底部边缘。
- **`"firstTextBaseline"`**: 根据文本内容的第一个基线对齐子视图。
- **`"lastTextBaseline"`**: 根据文本内容的最后一个基线对齐子视图。

***

## **`HStack` 组件**

### 描述

`HStack` 组件是一个布局容器，用于将其子视图排列成一条水平线。它提供了垂直对齐选项以及指定子视图之间间距的功能。

### 语法

```tsx
<HStack alignment="center" spacing={10}>
  {children}
</HStack>
```

### 示例 1：基础水平堆栈

```tsx
function Example1() {
  return (
    <HStack>
      <Text>Item 1</Text>
      <Text>Item 2</Text>
      <Text>Item 3</Text>
    </HStack>
  )
}
```

### 示例 2：自定义间距和对齐方式

```tsx
function Example2() {
  return (
    <HStack alignment="bottom" spacing={20}>
      <Text>Aligned Bottom</Text>
      <Text>With Spacing</Text>
    </HStack>
  )
}
```

### 示例 3：复杂的子视图

```tsx
function Example3() {
  return (
    <HStack spacing={10}>
      {[1, 2, 3].map((item) => (
        <Text key={item.toString()}>Item {item}</Text>
      ))}
    </HStack>
  )
}
```

### 注意事项:

- 确保传递给 `HStack` 的所有子组件都是有效的 `VirtualNode` 元素。
- 对于更复杂的布局，可以将 `HStack` 与其他组件如 `VStack` 或 `Spacer` 结合使用。

### 参见：

- `VStack` 用于垂直堆叠视图。
- `Spacer` 用于在堆栈中创建灵活的间距。
- `Text` 用于渲染文本内容。

***

### 图示

以下图示显示了在 `HStack` 中垂直对齐的效果：

![垂直对齐](https://docs-assets.developer.apple.com/published/a63aa800a94319cd283176a8b21bb7af/VerticalAlignment-1-iOS@2x.png)



---
url: /v2/zh/guide/Views/Layout/HStack/index_example.md
---

# 示例

```tsx
import { HStack, Navigation, NavigationStack, Script, Text } from "scripting"

function Example() {
  const list = [0, 1, 2, 3, 4]

  return <NavigationStack>
    <HStack
      navigationTitle={"HStack"}
      alignment={"top"}
      spacing={10}
    >
      {list.map((_, index) =>
        <Text>Item{index + 1}</Text>
      )}
    </HStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/LazyHGrid/index.md
---

# 惰性水平网格布局（LazyHGrid）

`LazyHGrid` 组件是 **Scripting** 应用用户界面库的一部分。它通过可自定义的大小和对齐选项将其子元素排列在网格布局中，仅根据需要创建和显示项目，从而为大型或动态数据集提供了性能优化。

***

## LazyHGrid

### 类型: `FunctionComponent<LazyHGridProps>`

`LazyHGrid` 将其子元素排列在一个水平扩展的网格中。与普通网格不同，它以懒加载方式加载和显示项目，仅在项目即将出现在屏幕上时创建它们。这使其非常适合处理包含大量或动态内容的网格。

***

## LazyHGridProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                    |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | --------------------------------------------------------------------- |
| `rows`        | `GridItem[]`                                                                                  | **必需**            | 定义网格中行的配置，包括其大小和对齐方式。                                                 |
| `alignment`   | `VerticalAlignment`                                                                           | `undefined`       | 控制网格在其父视图中的垂直对齐方式。                                                    |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 网格与其父视图中下一个项目之间的距离。                                                   |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图会固定在父滚动视图的边界内。                                                 |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在网格中显示的内容。接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## GridItem

定义网格中单行的属性。

| 属性          | 类型          | 默认值               | 描述                                |
| ----------- | ----------- | ----------------- | --------------------------------- |
| `alignment` | `Alignment` | `undefined`       | 指定在此行中放置每个子视图时使用的对齐方式。            |
| `spacing`   | `number`    | `undefined`（默认间距） | 此行与下一行之间的间距。                      |
| `size`      | `GridSize`  | **必需**            | 定义行的大小。可以是固定大小，也可以是基于内容的灵活/自适应大小。 |

***

## GridSize

定义网格布局中行或列的大小。

| 类型         | 属性                                           | 描述                                |
| ---------- | -------------------------------------------- | --------------------------------- |
| `number`   | _无_                                          | 行或列的固定大小。                         |
| `adaptive` | `min: number`, `max?: number \|'infinity'`   | 指定一个灵活大小，根据内容进行调整，带有最小值和可选的最大值限制。 |
| `flexible` | `min?: number`, `max?: number \| 'infinity'` | 指定一个动态调整的灵活大小，可以使用可选的最小值和最大值约束。   |

***

## PinnedScrollViews

定义网格中哪些视图会固定在父滚动视图的边界内：

- `'sectionHeaders'`：仅固定节标题
- `'sectionFooters'`：仅固定节页脚
- `'sectionHeadersAndFooters'`：同时固定节标题和页脚

***

## 示例用法

```tsx
import { LazyHGrid, Text } from 'scripting'

const Example = () => {
  const rows = [
    { size: 50 },
    { size: { type: 'adaptive', min: 30, max: 80 } },
    { size: { type: 'flexible', min: 20, max: 'infinity' } }
  ]
  
  return (
    <ScrollView
      axes="horizontal"
    >
      <LazyHGrid 
        rows={rows} 
        alignment="center" 
        spacing={12} 
      >
        <Text>项目 1</Text>
        <Text>项目 2</Text>
        <Text>项目 3</Text>
      </LazyHGrid>
    </ScrollView>
  )
}
```

### 说明：

- 定义了三个具有不同大小的行：
  - 一个大小为 50 的固定行
  - 一个最小大小为 30，最大大小为 80 的自适应行
  - 一个最小大小为 20，无最大大小的灵活行
- 网格在其父视图中垂直居中排列，项目之间的间距为 12 点

***

## 注意事项

- `LazyHGrid` 非常适合处理包含大量或动态内容的水平扩展网格布局
- 使用 `GridSize` 定义基于可用空间的灵活或自适应布局
- `pinnedViews` 属性确保关键视图（如标题或页脚）在滚动过程中始终可见

此 API 为基于网格的水平布局提供了灵活性和性能优化。



---
url: /v2/zh/guide/Views/Layout/LazyHGrid/index_example.md
---

# 示例

```tsx
import { Color, LazyHGrid, Navigation, NavigationStack, RoundedRectangle, Script, ScrollView, Text, useMemo, VStack } from "scripting"

function Example() {
  const colors = useMemo(() => {
    const colors: {
      name: string
      value: Color
    }[] = []

    const numToHex = (n: number) => {
      return n === 0 ? '00' : n.toString(16)
    }

    for (let r = 0x00; r <= 0xff; r += 0x11) {
      for (let g = 0x00; g <= 0xff; g += 0x11) {
        for (let b = 0x00; b <= 0xff; b += 0x11) {
          const name = `${numToHex(r)}${numToHex(g)}${numToHex(b)}`
          const value: Color = `#${name}`
          colors.push({
            name,
            value
          })
        }
      }
    }

    return colors
  }, [])

  return <NavigationStack>
    <ScrollView
      navigationTitle={"LazyHGrid"}
      navigationBarTitleDisplayMode={"inline"}
      axes={"horizontal"}
    >
      <LazyHGrid
        spacing={2}
        rows={[
          { size: 100 },
          { size: 100 },
          { size: 100 },
          { size: 100 },
        ]}
      >
        {colors.map((color) =>
          <VStack>
            <Text>
              {color.name}
            </Text>
            <RoundedRectangle
              fill={color.value}
              cornerRadius={4}
              frame={{
                width: 50,
                height: 50
              }}
            />
          </VStack>
        )}
      </LazyHGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/LazyHStack/index.md
---

# 惰性水平布局（LazyHStack）

`LazyHStack` 组件是 **Scripting** 应用程序用户界面库的一部分。它将其子元素排列在水平堆栈中，仅在需要时创建和显示元素，从而提高了处理大型数据集时的性能。

## LazyHStack

## 类型：`FunctionComponent<LazyHStackProps>`

`LazyHStack` 将其子元素按横向排列在一条线上。与普通的水平堆栈不同，它会懒加载和显示视图，仅在它们即将出现在屏幕上时才创建。这使其非常适合处理大型或动态数据的场景。

***

## LazyHStackProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                     |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | ---------------------------------------------------------------------- |
| `alignment`   | `VerticalAlignment`                                                                           | `undefined`       | 决定子元素在堆栈中的垂直对齐方式。所有子视图共享相同的垂直屏幕坐标。                                     |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 邻近子视图之间的间距。如果设置为 `undefined`，堆栈将使用默认的间距值。                              |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图在滚动过程中固定在滚动视图的边界内。                                              |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在堆栈中显示的内容。可接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## PinnedScrollViews

`PinnedScrollViews` 类型定义了哪些子视图可以在滚动时固定在滚动视图的边界内：

- `'sectionHeaders'`：仅固定节头部。
- `'sectionFooters'`：仅固定节尾部。
- `'sectionHeadersAndFooters'`：同时固定节头部和尾部。

***

## 使用示例

```tsx
import { LazyHStack, Text, ScrollView, Section } from 'scripting'

const Example = () => {
  return (
    <ScrollView
      axes="horizontal"
    >
      <LazyHStack
        alignment="center"
        spacing={10}
        pinnedViews="sectionHeaders"
      >
        {list.map(item =>
          <Section
            key={item.id}
            header={
              <Text>{item.title}</Text>
            }
          >
            <ItemView
              item={item}
            />
          </Section>
        )}
      </LazyHStack>
    </ScrollView>
  )
}
```

### 说明：

- 堆栈以 `10` 点的间距水平排列 `Section` 视图。
- `alignment` 属性使项目在堆栈中垂直居中。
- `pinnedViews` 属性确保节头部在滚动视图滚动时固定在顶部。

***

## 注意事项

- 懒加载通过仅在视图可见时创建视图来提高性能。
- 使用 `spacing` 调整项目之间的距离，使用 `alignment` 控制垂直对齐方式。
- `pinnedViews` 属性特别适用于类似表格的布局，其中头部或尾部需要在滚动时保持可见。

此 API 使您能够高效地处理水平增长的内容，同时提供布局和滚动行为的自定义选项。



---
url: /v2/zh/guide/Views/Layout/LazyHStack/index_example.md
---

# 示例

```tsx
import { ForEach, LazyHStack, Navigation, NavigationStack, Script, ScrollView, Text, VStack } from "scripting"

function Example() {

  return <NavigationStack>
    <VStack
      navigationTitle={"LazyHStack"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <ScrollView
        axes={"horizontal"}
      >
        <LazyHStack
          alignment={"top"}
          spacing={10}
        >
          <ForEach
            count={100}
            itemBuilder={index =>
              <Text
                padding
                background={"systemIndigo"}
                key={index.toString()}
              >Column {index}</Text>
            }
          />
        </LazyHStack>
      </ScrollView>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/LazyVGrid/index.md
---

# 惰性垂直网格布局（LazyVGrid）

`LazyVGrid` 组件是 **Scripting** 应用的用户界面库的一部分。它通过可自定义的大小和对齐选项将其子元素排列在网格布局中。组件仅根据需要创建和显示项目，从而为处理大型或动态数据集提供了性能优化。

***

## LazyVGrid

### 类型: `FunctionComponent<LazyVGridProps>`

`LazyVGrid` 将其子元素排列在一个垂直扩展的网格中。与普通网格不同，它以懒加载方式加载和显示项目，仅在项目即将出现在屏幕上时创建它们。这使其非常适合处理包含大量或动态内容的网格。

***

## LazyVGridProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                    |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | --------------------------------------------------------------------- |
| `columns`     | `GridItem[]`                                                                                  | **必需**            | 定义网格中列的配置，包括其大小和对齐方式。                                                 |
| `alignment`   | `HorizontalAlignment`                                                                         | `undefined`       | 控制网格在其父视图中的水平对齐方式。                                                    |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 相邻网格项之间的距离。如果设置为 `undefined`，网格将使用默认间距值。                              |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图会固定在父滚动视图的边界内。                                                 |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在网格中显示的内容。接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## GridItem

定义网格中单列的属性。

| 属性          | 类型          | 默认值               | 描述                                |
| ----------- | ----------- | ----------------- | --------------------------------- |
| `alignment` | `Alignment` | `undefined`       | 指定在此列中放置每个子视图时使用的对齐方式。            |
| `spacing`   | `number`    | `undefined`（默认间距） | 此列与下一列之间的间距。                      |
| `size`      | `GridSize`  | **必需**            | 定义列的大小。可以是固定大小，也可以是基于内容的灵活/自适应大小。 |

***

## GridSize

定义网格布局中行或列的大小。

| 类型         | 属性                                           | 描述                                |
| ---------- | -------------------------------------------- | --------------------------------- |
| `number`   | _无_                                          | 行或列的固定大小。                         |
| `adaptive` | `min: number`, `max?: number \| 'infinity'`  | 指定一个灵活大小，根据内容进行调整，带有最小值和可选的最大值限制。 |
| `flexible` | `min?: number`, `max?: number \| 'infinity'` | 指定一个动态调整的灵活大小，可以使用可选的最小值和最大值约束。   |

***

## PinnedScrollViews

定义网格中哪些视图会固定在父滚动视图的边界内：

- `'sectionHeaders'`：仅固定节标题
- `'sectionFooters'`：仅固定节页脚
- `'sectionHeadersAndFooters'`：同时固定节标题和页脚

***

## 示例用法

```tsx
import { LazyVGrid, Text } from 'scripting'

const Example = () => {
  const columns = [
    { size: 50 },
    { size: { type: 'adaptive', min: 40, max: 100 } },
    { size: { type: 'flexible', min: 30, max: 'infinity' } }
  ]

  return (
    <ScrollView>
      <LazyVGrid
        columns={columns}
        alignment="leading"
        spacing={16}
      >
        <Text>项目 1</Text>
        <Text>项目 2</Text>
        <Text>项目 3</Text>
      </LazyVGrid>
    </ScrollView>
  )
}
```

### 说明：

- 定义了三个具有不同大小的列：
  - 一个大小为 50 的固定列
  - 一个最小大小为 40，最大大小为 100 的自适应列
  - 一个最小大小为 30，无最大大小的灵活列
- 网格与其父视图的起始边对齐，项目之间的间距为 16 点

***

## 注意事项

- `LazyVGrid` 非常适合处理包含大量或动态内容的垂直扩展网格布局
- 使用 `GridSize` 定义基于可用空间的灵活或自适应布局
- `pinnedViews` 属性确保关键视图（如标题或页脚）在滚动过程中始终可见

此 API 为基于网格的垂直布局提供了灵活性和性能优化。



---
url: /v2/zh/guide/Views/Layout/LazyVGrid/index_example.md
---

# 示例

```tsx
import { Color, LazyVGrid, Navigation, NavigationStack, RoundedRectangle, Script, ScrollView, Text, useMemo, VStack } from "scripting"

function Example() {
  const colors = useMemo(() => {
    const colors: {
      name: string
      value: Color
    }[] = []

    const numToHex = (n: number) => {
      return n === 0 ? '00' : n.toString(16)
    }

    for (let r = 0x00; r <= 0xff; r += 0x11) {
      for (let g = 0x00; g <= 0xff; g += 0x11) {
        for (let b = 0x00; b <= 0xff; b += 0x11) {
          const name = `${numToHex(r)}${numToHex(g)}${numToHex(b)}`
          const value: Color = `#${name}`
          colors.push({
            name,
            value
          })
        }
      }
    }

    return colors
  }, [])

  return <NavigationStack>
    <ScrollView
      navigationTitle={"LazyVGrid"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <LazyVGrid
        spacing={2}
        columns={[
          { size: 100 },
          { size: 100 },
          { size: 100 },
          { size: 100 },
        ]}
      >
        {colors.map((color) =>
          <VStack>
            <Text>
              {color.name}
            </Text>
            <RoundedRectangle
              fill={color.value}
              cornerRadius={4}
              frame={{
                width: 50,
                height: 50
              }}
            />
          </VStack>
        )}
      </LazyVGrid>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/LazyVStack/index.md
---

# 惰性垂直布局（LazyVStack）

`LazyVStack` 组件是 **Scripting** 应用用户界面库的一部分。它将子元素排列在垂直堆叠中，仅根据需要创建和显示项目，从而为大型数据集提供了性能优化。

***

## LazyVStack

### 类型: `FunctionComponent<LazyVStackProps>`

`LazyVStack` 将其子元素排列成一个垂直扩展的线性布局。与普通垂直堆叠不同，它仅在视图即将出现在屏幕上时懒加载和显示内容。这使其非常适合处理列表或动态生成的大量内容。

***

## LazyVStackProps

| 属性            | 类型                                                                                            | 默认值               | 描述                                                                    |
| ------------- | --------------------------------------------------------------------------------------------- | ----------------- | --------------------------------------------------------------------- |
| `alignment`   | `HorizontalAlignment`                                                                         | `undefined`       | 确定子元素在堆叠中如何水平对齐。所有子视图共享相同的水平屏幕坐标。                                     |
| `spacing`     | `number`                                                                                      | `undefined`（默认间距） | 相邻子视图之间的距离。如果设置为 `undefined`，堆叠将使用默认间距值。                              |
| `pinnedViews` | `'sectionHeaders'` \| `'sectionFooters'` \| `'sectionHeadersAndFooters'`                      | `undefined`       | 指定哪些子视图在滚动期间固定在滚动视图的边界内。                                              |
| `children`    | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined`       | 要在堆叠中显示的内容。接受一个或多个 `VirtualNode` 元素，包括数组以及可选的 `null` 或 `undefined` 值。 |

***

## PinnedScrollViews

`PinnedScrollViews` 类型定义了哪些类型的子视图可以在滚动期间固定在滚动视图的边界内：

- `'sectionHeaders'`：仅固定节标题
- `'sectionFooters'`：仅固定节页脚
- `'sectionHeadersAndFooters'`：同时固定节标题和页脚

***

## 示例用法

```tsx
import { LazyVStack, Text, ScrollView, Section } from 'scripting'

const Example = () => {
  return (
    <ScrollView>
      <LazyVStack alignment="leading" spacing={12} pinnedViews="sectionHeaders">
        {list.map(item => 
          <Section
            key={item.id}
            header={
              <Text>{item.title}</Text>
            }
          >
            <ItemView
              item={item}
            />
          </Section>
        )}
      </LazyVStack>
    </ScrollView>
  )
}
```

### 说明：

- 堆叠以 `12` 点的间距将 `Section` 视图垂直排列
- `alignment` 属性将项目对齐到堆叠的起始边
- `pinnedViews` 属性确保节标题在滚动视图顶部保持固定状态

***

## 注意事项

- 懒加载确保仅在视图变得可见时创建视图，从而提高大型内容的性能
- 使用 `spacing` 控制项目之间的垂直距离，使用 `alignment` 自定义水平对齐
- `pinnedViews` 属性对于具有粘性标题或页脚的表格或列表布局特别有用

此 API 允许您高效管理垂直增长的内容，同时提供布局和滚动行为的定制选项。



---
url: /v2/zh/guide/Views/Layout/LazyVStack/index_example.md
---

# 示例

```tsx
import { HStack, LazyVStack, Navigation, NavigationStack, Script, ScrollView, Section, Spacer, Text, useMemo } from "scripting"

function Example() {
  const groups = useMemo(() => {
    const groups: {
      name: string
      items: number[]
    }[] = []

    for (let i = 1; i < 10; i++) {
      const list: {
        name: string
        items: number[]
      } = {
        name: "Group " + i,
        items: []
      }

      for (let j = 0; j < 10; j++) {
        list.items.push(i * 10 + j)
      }

      groups.push(list)
    }

    return groups
  }, [])

  return <NavigationStack>
    <ScrollView
      navigationTitle={"LazyVStack"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <LazyVStack
        alignment={"leading"}
        spacing={10}
        pinnedViews={"sectionHeaders"}
      >
        {groups.map(group =>
          <Section
            header={
              <HStack
                background={"purple"}
              >
                <Text>{group.name}</Text>
                <Spacer />
              </HStack>
            }
          >
            {group.items.map(item =>
              <Text>Row {item}</Text>
            )}
          </Section>
        )}
      </LazyVStack>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/VStack/index.md
---

# 垂直布局（VStack）

在Scripting 应用程序中，`VStack` 组件是一个布局视图，用于垂直排列其子视图。它提供了灵活的选项，用于调整子视图的对齐方式以及控制它们之间的间距。

***

## **`VStack` 组件**

### **类型声明**

```ts
declare const VStack: FunctionComponent<VStackProps>
```

### **描述**

`VStack` 组件会将其子视图垂直排列，非常适合创建垂直堆叠的布局。您可以根据设计需求，自定义子视图的对齐方式和它们之间的间距。

***

## **属性**

### `alignment` （可选）

- **类型**: `HorizontalAlignment`
- **默认值**: `"center"`
- **描述**: 确定堆栈中子视图的水平对齐方式。对齐方式指定了垂直排列的视图如何在水平方向上相互定位。
- **可接受的值**:
  - `"leading"`：将视图向左对齐。
  - `"center"`：将视图水平居中对齐。
  - `"trailing"`：将视图向右对齐。

#### **示例**

```tsx
<VStack alignment="leading">
  <Text>左对齐</Text>
  <Text>另一个项目</Text>
</VStack>
```

***

### `spacing` （可选）

- **类型**: `number | undefined`
- **默认值**: 如果未指定，则会根据子视图自动计算。
- **描述**: 设置相邻子视图之间的距离（像素）。使用 `undefined` 时，堆栈将自动确定最佳间距。

#### **示例**

```tsx
<VStack spacing={10}>
  <Text>项目 1</Text>
  <Text>项目 2</Text>
</VStack>
```

***

### `children` （可选）

- **类型**:
  ```ts
  (VirtualNode | undefined | null | (VirtualNode | undefined | null)[])[] | VirtualNode | undefined
  ```
- **描述**: 堆栈中显示的子元素。您可以传递单个元素、元素数组或 `undefined`/`null` 值。`null` 和 `undefined` 值会被忽略，从而支持动态布局。

#### **示例**

```tsx
<VStack>
  <Text>第一个项目</Text>
  <Image systemName="star" />
</VStack>
```

***

## **`HorizontalAlignment` 类型**

水平对齐控制了当视图在 `VStack` 中垂直排列时，如何在水平方向上相互定位。

### **类型声明**

```ts
type HorizontalAlignment = 'leading' | 'center' | 'trailing'
```

### **对齐选项**

- **`leading`**：将所有子视图与堆栈的左边缘对齐。
- **`center`**：将所有子视图水平居中对齐。
- **`trailing`**：将所有子视图与堆栈的右边缘对齐。

### **视觉指南**

以下是三种对齐选项的示例图：

![水平对齐](https://docs-assets.developer.apple.com/published/cb8ad6030a1ebcfee545d02f406500ee/HorizontalAlignment-1-iOS@2x.png)

***

## **使用示例**

```tsx
<VStack alignment="leading" spacing={10}>
  <Image systemName="globe" />
  <Text>左对齐项目</Text>
  <Text>另一个项目</Text>
</VStack>
```

### **解释**

1. **`alignment="leading"`**：将所有子视图左对齐。
2. **`spacing={10}`**：为每个子视图之间添加 10 像素的间距。
3. 包含两个子视图：
   - 一个显示系统图标的 `Image` 视图。
   - 两个显示标签项目的 `Text` 视图。

***

## **最佳实践**

1. 使用 `alignment` 来控制堆叠文本和图标的水平定位，以实现更好的视觉一致性。
2. 利用 `spacing` 创建间距合理、视觉美观的布局。
3. 动态或条件性地传递子元素时，无需担心 `null` 或 `undefined` 值。

通过本指南，您可以自信地使用 `VStack` 组件，在Scripting 应用项目中创建清晰的垂直堆叠布局。



---
url: /v2/zh/guide/Views/Layout/VStack/index_example.md
---

# 示例

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function Example() {
  const list = [0, 1, 2, 3, 4]

  return <NavigationStack>
    <VStack
      navigationTitle={"VStack"}
      alignment={"leading"}
      spacing={10}
    >
      {list.map((_, index) =>
        <Text>Item{index + 1}</Text>
      )}
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Layout/ZStack/index.md
---

# ZStack

`ZStack` 组件在 Scripting 应用中用于将子视图以层叠堆栈的形式排列。它支持通过预定义的对齐指南，在 x 和 y 轴上灵活地对齐这些图层。

***

## `ZStackProps`

`ZStack` 组件接受以下属性：

| 属性          | 类型                                                                                            | 默认值         | 描述                        |
| ----------- | --------------------------------------------------------------------------------------------- | ----------- | ------------------------- |
| `alignment` | `Alignment`（可选）                                                                               | `"center"`  | 决定子视图在 x 轴和 y 轴上的对齐方式。    |
| `children`  | `(VirtualNode \| undefined \| null \| (VirtualNode \| undefined \| null)[])[] \| VirtualNode` | `undefined` | 要在堆栈中显示的子组件。可以是单个节点或节点数组。 |

***

## `Alignment`

`Alignment` 类型定义了一组常用的对齐方式，用于堆叠视图。这些对齐方式结合了水平和垂直方向的对齐指南。下图展示了这些对齐方式：

![Alignment](https://docs-assets.developer.apple.com/published/09693fd98ab76356519a900fd33d9e7f/Alignment-1-iOS@2x.png)

### 支持的值：

| 值                             | 描述                      |
| ----------------------------- | ----------------------- |
| `"top"`                       | 将视图对齐到堆栈的顶部边缘。          |
| `"center"`                    | 在水平和垂直轴上将视图居中对齐。        |
| `"bottom"`                    | 将视图对齐到堆栈的底部边缘。          |
| `"leading"`                   | 将视图对齐到主边缘（在从左到右布局中为左侧）。 |
| `"trailing"`                  | 将视图对齐到尾边缘（在从左到右布局中为右侧）。 |
| `"bottomLeading"`             | 将视图对齐到左下角。              |
| `"bottomTrailing"`            | 将视图对齐到右下角。              |
| `"centerFirstTextBaseline"`   | 使用第一个文本基线在中心对齐视图。       |
| `"centerLastTextBaseline"`    | 使用最后一个文本基线在中心对齐视图。      |
| `"leadingFirstTextBaseline"`  | 使用第一个文本基线对齐到主边缘。        |
| `"leadingLastTextBaseline"`   | 使用最后一个文本基线对齐到主边缘。       |
| `"topLeading"`                | 将视图对齐到左上角。              |
| `"topTrailing"`               | 将视图对齐到右上角。              |
| `"trailingFirstTextBaseline"` | 使用第一个文本基线对齐到尾边缘。        |
| `"trailingLastTextBaseline"`  | 使用最后一个文本基线对齐到尾边缘。       |

***

## `ZStack` 组件

`ZStack` 是一个函数组件，用于将其子元素以层叠堆栈的形式排列。每个子元素的位置相对于 `alignment` 属性中定义的对齐方式。

### 导入组件

要使用 `ZStack` 组件，请确保从 Scripting 应用的 `scripting` 包中导入它：

```tsx
import { ZStack } from 'scripting'
```

***

## 示例用法

### 1. 基础示例

将子视图对齐到顶部：

```tsx
<ZStack alignment="top">
  <Image systemName="globe" />
  <Text>
    Hello world.
  </Text>
</ZStack>
```

### 2. 高级对齐

使用复杂的对齐方式（如 `bottomLeading`）定位子元素：

```tsx
<ZStack alignment="bottomLeading">
  <Rectangle fill="gray" />
  <Text>
    Bottom Leading Text
  </Text>
</ZStack>
```

### 3. 嵌套 `ZStack` 示例

将 `ZStack` 与其他布局组件结合以实现复杂布局：

```tsx
<ZStack alignment="center">
  <Rectangle fill="blue" />
  <ZStack alignment="topTrailing">
    <Image systemName="star" />
    <Text>
      Nested ZStack
    </Text>
  </ZStack>
</ZStack>
```

***

## 注意事项

- **性能考虑**：避免向 `ZStack` 添加过多的子视图，以免在复杂布局中导致潜在的性能瓶颈。
- **组合布局**：将 `ZStack` 与其他组件（如 `VStack` 和 `HStack`）结合使用，以创建灵活动态的用户界面。



---
url: /v2/zh/guide/Views/Layout/ZStack/index_example.md
---

# 示例

```tsx
import { Button, Circle, Color, List, Navigation, NavigationLink, NavigationStack, Rectangle, Script, Section, Text, VStack, ZStack } from "scripting"

function Example() {
  const colors: Color[] = [
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "purple",
  ]

  return <NavigationStack>
    <List
      navigationTitle={"ZStack"}
    >
      <Section
        header={
          <Text
            textCase={null}
          >ZStack</Text>
        }
      >
        <ZStack>
          {colors.map((color, index) =>
            <Rectangle
              fill={color}
              frame={{
                width: 100,
                height: 100,
              }}
              offset={{
                x: index * 10,
                y: index * 10
              }}
            />
          )}
        </ZStack>
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >background</Text>
        }
      >
        <Text
          background={{
            content: <Rectangle
              fill={"systemBlue"}
              frame={{
                width: 100,
                height: 50,
              }}
            />,
            alignment: "center",
          }}
        >Hello Scripting!</Text>
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >overlay</Text>
        }
      >
        <Circle
          fill={"yellow"}
          frame={{
            width: 100,
            height: 100,
          }}
          overlay={{
            content: <Rectangle
              fill={"blue"}
              frame={{
                width: 50,
                height: 50,
              }}
            />,
            alignment: "center"
          }}
        />
      </Section>

      <Section
        title={"containerBackground (iOS 18.0+)"}
      >
        <Button
          title={"Present"}
          action={() => {
            Navigation.present({
              element: <ContainerBackgroundExample />,
              modalPresentationStyle: "pageSheet"
            })
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

function ContainerBackgroundExample() {
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"containerBackground"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />,
      }}
    >
      <NavigationLink
        title={"Red Page"}
        destination={
          <VStack
            navigationContainerBackground={"red"}
            frame={{
              maxWidth: 'infinity',
              maxHeight: 'infinity'
            }}
          >
            <Text>A red page</Text>
          </VStack>
        }
      />
      <NavigationLink
        title={"Blue Page"}
        destination={
          <VStack
            navigationContainerBackground={"blue"}
            frame={{
              maxWidth: 'infinity',
              maxHeight: 'infinity'
            }}
          >
            <Text>A blue page</Text>
          </VStack>
        }
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })
  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Link.md
---

# 链接

`Link` 组件用于创建可点击的控件，点击后可跳转到指定的 URL。该组件可用于打开网页、App 内自定义 URL Scheme，或其他支持的链接类型。

> **注意**：如果在小组件中使用 `Link`，则会忽略 `widgetURL` 修饰符的设置。

### 属性说明

| 属性名        | 类型                        | 说明                      |
| ---------- | ------------------------- | ----------------------- |
| `url`      | `string`                  | 点击后要跳转的目标链接地址。          |
| `children` | `string` \| `VirtualNode` | 展示在链接中的内容，可以是纯文本或自定义布局。 |

### 示例

```tsx
<Link url={Script.createOpenURLScheme('Script A')}>
  打开脚本 A
</Link>

<Link url="https://example.com">
  <HStack>
    <Image
      systemName="globe"
      width={20}
      height={20}
      padding={{ trailing: 8 }}
    />
    <Text>打开链接</Text>
  </HStack>
</Link>
```

该组件支持使用纯文本作为子内容，也可以使用复杂的布局作为子节点。点击链接后，会根据 URL 类型打开相应的页面（如 Safari、其他 App 或自定义处理程序）。



---
url: /v2/zh/guide/Views/List/DisclosureGroup/index.md
---

# 展开组

`DisclosureGroup` 组件用于将相关内容组织为可展开/折叠的区域。它非常适合在列表中分组展示具有层级结构或可选显示的内容。

本示例展示如何创建一个顶层的 DisclosureGroup，以及如何嵌套子组来构建多层结构。同时结合按钮和切换开关（Toggle）进行交互控制。

***

## 概览

你将学习如何：

- 使用 `DisclosureGroup` 创建可折叠的内容区域
- 绑定展开状态到本地组件状态
- 嵌套多个 DisclosureGroup 以展示层级结构
- 与 `Toggle`、`Text`、`Button` 等其他视图组合使用

***

## 示例代码

### 1. 导入依赖模块

```tsx
import { Button, DisclosureGroup, List, Navigation, NavigationStack, Script, Text, Toggle, useState } from "scripting"
```

### 2. 定义组件状态

通过 `useState` 管理展开状态以及两个切换项的值：

```tsx
const [topExpanded, setTopExpanded] = useState(true)
const [oneIsOn, setOneIsOn] = useState(false)
const [twoIsOn, setTwoIsOn] = useState(true)
```

### 3. 使用 DisclosureGroup 构建界面

该界面包含一个 `List`，位于 `NavigationStack` 中。通过 `Button` 控制顶层 DisclosureGroup 的展开状态。组内包含多个切换项，并嵌套一个子组：

```tsx
return <NavigationStack>
  <List
    navigationTitle={"DislcosureGroup"}
    navigationBarTitleDisplayMode={"inline"}
  >
    <Button
      title={"Toggle expanded"}
      action={() => setTopExpanded(!topExpanded)}
    />
    <DisclosureGroup
      title={"Items"}
      isExpanded={topExpanded}
      onChanged={setTopExpanded}
    >
      <Toggle
        title={"Toggle 1"}
        value={oneIsOn}
        onChanged={setOneIsOn}
      />
      <Toggle
        title={"Toggle 2"}
        value={twoIsOn}
        onChanged={setTwoIsOn}
      />
      <DisclosureGroup
        title={"Sub-items"}
      >
        <Text>Sub-item 1</Text>
      </DisclosureGroup>
    </DisclosureGroup>
  </List>
</NavigationStack>
```

### 4. 展示页面并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键概念

- **DisclosureGroup**：一个可展开的容器视图，用于隐藏或显示内部内容。
- **isExpanded**：用于绑定展开状态，控制 DisclosureGroup 的展开或折叠。
- **onChanged**：当用户点击展开或折叠时触发的回调函数。
- **嵌套支持**：DisclosureGroup 支持嵌套使用，可构建多层内容。
- **组件组合**：可与 `Toggle`、`Text`、`Button` 等组件灵活组合，构建交互界面。

***

## 应用场景

- 将设置项分组管理，提升可读性
- 构建可展开的问答、功能列表或信息面板
- 显示具有层级结构的数据，如文件夹、分类、过滤器等

通过 DisclosureGroup，你可以在滚动列表中以清晰且用户友好的方式组织复杂或可选内容。



---
url: /v2/zh/guide/Views/List/DisclosureGroup/index_example.md
---

# 示例

```tsx
import { Button, DisclosureGroup, List, Navigation, NavigationStack, Script, Text, Toggle, useState } from "scripting"

function Example() {
  const [topExpanded, setTopExpanded] = useState(true)
  const [oneIsOn, setOneIsOn] = useState(false)
  const [twoIsOn, setTwoIsOn] = useState(true)

  return <NavigationStack>
    <List
      navigationTitle={"DislcosureGroup"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Button
        title={"Toggle expanded"}
        action={() => setTopExpanded(!topExpanded)}
      />
      <DisclosureGroup
        title={"Items"}
        isExpanded={topExpanded}
        onChanged={setTopExpanded}
      >
        <Toggle
          title={"Toggle 1"}
          value={oneIsOn}
          onChanged={setOneIsOn}
        />
        <Toggle
          title={"Toggle 2"}
          value={twoIsOn}
          onChanged={setTwoIsOn}
        />

        <DisclosureGroup
          title={"Sub-items"}
        >
          <Text>Sub-item 1</Text>
        </DisclosureGroup>
      </DisclosureGroup>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/List/Display data inside a row/index.md
---

# 在行中显示数据

本示例展示如何使用 `List` 组件，通过自定义的行布局来展示结构化数据。每一行显示一个人的姓名和电话号码，布局清晰，排版整洁，采用了 SwiftUI 风格的堆叠式组件。

## 概览

你将学到如何：

- 定义自定义的行组件（`PersonRowView`）
- 使用 `List` 展示数据集合
- 应用文本样式和系统图标
- 使用 `VStack` 和 `HStack` 进行布局排版

***

## 示例代码

### 1. 导入依赖并定义数据类型

```tsx
import { HStack, Label, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

type Person = {
  name: string
  phoneNumber: string
}
```

### 2. 创建行组件

`PersonRowView` 是用于渲染单行内容的组件。它使用纵向堆叠将姓名与电话号码分隔，并使用适当的字体样式和颜色来区分信息层级。

```tsx
function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}
```

### 3. 在导航堆栈中展示列表

使用 `NavigationStack` 和 `List` 来展示所有的行。你可以设置导航栏标题以说明视图内容。

```tsx
function Example() {
  const staff: Person[] = [
    {
      name: "Juan Chavez",
      phoneNumber: "(408) 555-4301",
    },
    {
      name: "Mei Chen",
      phoneNumber: "(919) 555-2481"
    }
  ]

  return <NavigationStack>
    <List
      navigationTitle={"Display data inside a row"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {staff.map(person =>
        <PersonRowView
          person={person}
        />
      )}
    </List>
  </NavigationStack>
}
```

### 4. 展示界面并退出脚本

使用 `Navigation.present` 弹出该页面视图，并在页面关闭后退出脚本。

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 总结

本示例展示了如何**在行中展示数据**，核心要点包括：

- 使用 `VStack` 和 `HStack` 构建布局结构
- 定义可复用的类型化行组件
- 使用 `List` 渲染结构化的数据集合
- 搭配图标和标签增强可读性和视觉效果

适用于联系人列表、搜索结果、记录信息等多种数据展示场景，支持灵活扩展与样式自定义。



---
url: /v2/zh/guide/Views/List/Display data inside a row/index_example.md
---

# 示例

```tsx
import { HStack, Label, List, Navigation, NavigationStack, Script, Text, VStack } from "scripting"

type Person = {
  name: string
  phoneNumber: string
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  const staff: Person[] = [
    {
      name: "Juan Chavez",
      phoneNumber: "(408) 555-4301",
    },
    {
      name: "Mei Chen",
      phoneNumber: "(919) 555-2481"
    }
  ]

  return <NavigationStack>
    <List
      navigationTitle={"Display data inside a row"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {staff.map(person =>
        <PersonRowView
          person={person}
        />
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/List/Editable List/index.md
---

# 可编辑列表

本示例展示如何在 Scripting 应用中使用 `List`、`ForEach` 和 `EditButton` 组件构建一个支持 **删除与排序操作** 的可编辑列表。

***

## 概览

你将学习如何：

- 使用 `ForEach` 渲染动态列表项
- 实现列表项的删除和拖动排序功能
- 使用 `EditButton` 启用编辑模式
- 通过 `useState` 管理列表的状态

***

## 示例代码

### 1. 导入所需模块

```tsx
import { Color, EditButton, ForEach, List, Navigation, NavigationStack, Script, Text, useState } from "scripting"
```

### 2. 定义组件状态

使用 `useState` 初始化颜色字符串数组作为列表数据：

```tsx
const [colors, setColors] = useState<Color[]>([
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "purple",
])
```

### 3. 处理删除操作

`onDelete` 方法根据传入的索引数组移除对应的列表项：

```tsx
function onDelete(indices: number[]) {
  setColors(colors.filter((_, index) => !indices.includes(index)))
}
```

### 4. 处理拖动排序操作

`onMove` 方法将被拖动的元素插入至目标位置：

```tsx
function onMove(indices: number[], newOffset: number) {
  const movingItems = indices.map(index => colors[index])
  const newColors = colors.filter((_, index) => !indices.includes(index))
  newColors.splice(newOffset, 0, ...movingItems)
  setColors(newColors)
}
```

### 5. 构建可编辑列表界面

主界面使用 `NavigationStack` 和 `List` 构建，并通过 `toolbar` 添加 `EditButton` 实现编辑模式：

```tsx
return <NavigationStack>
  <List
    navigationTitle={"Editable List"}
    navigationBarTitleDisplayMode={"inline"}
    toolbar={{
      confirmationAction: [
        <EditButton />,
      ]
    }}
  >
    <ForEach
      count={colors.length}
      itemBuilder={index =>
        <Text
          key={colors[index]} // 每项必须提供唯一 key
        >{colors[index]}</Text>
      }
      onDelete={onDelete}
      onMove={onMove}
    />
  </List>
</NavigationStack>
```

### 6. 启动视图并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

- **List**：用于展示可滚动的列表视图。
- **ForEach**：根据指定数量动态渲染子视图。
- **EditButton**：切换列表的编辑模式，支持删除和排序操作。
- **onDelete / onMove**：在用户删除或拖动项时调用的回调函数。
- **useState**：用于追踪和更新当前的列表数据。

***

## 注意事项

- `ForEach` 中的每个子项必须提供唯一的 `key`，以确保视图更新正常。
- 仅在编辑模式下才能进行删除和排序操作，需通过 `EditButton` 启用。

***

## 适用场景

- 可排序的任务列表或待办事项
- 支持编辑的设置项集合
- 根据用户输入动态更新的内容展示

该示例为你创建交互式脚本或工具提供了灵活的列表功能模板。



---
url: /v2/zh/guide/Views/List/Editable List/index_example.md
---

# 示例

```tsx
import { Color, EditButton, ForEach, List, Navigation, NavigationStack, Script, Text, useState } from "scripting"

function Example() {
  const [colors, setColors] = useState<Color[]>([
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "purple",
  ])

  function onDelete(indices: number[]) {
    setColors(colors.filter((_, index) => !indices.includes(index)))
  }

  function onMove(indices: number[], newOffset: number) {
    const movingItems = indices.map(index => colors[index])
    const newColors = colors.filter((_, index) => !indices.includes(index))
    newColors.splice(newOffset, 0, ...movingItems)
    setColors(newColors)
  }

  return <NavigationStack>
    <List
      navigationTitle={"Editable List"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        confirmationAction: [
          <EditButton />,
        ]
      }}
    >
      <ForEach
        count={colors.length}
        itemBuilder={index =>
          <Text
            key={colors[index]} // Must provide a unique key!!!
          >{colors[index]}</Text>
        }
        onDelete={onDelete}
        onMove={onMove}
      />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/List/List interaction/index.md
---

# 列表交互

本示例展示如何在 **Scripting** 应用中通过左右滑动手势为 `List` 列表项添加交互操作。借助 `leadingSwipeActions` 和 `trailingSwipeActions`，你可以实现诸如标记未读、删除、标记重点等常见功能。

***

## 概览

你将学会如何：

- 使用自定义单元格显示消息列表
- 为列表项添加左右滑动手势操作
- 配置滑动行为（例如禁止全滑触发）
- 结合 `Button`、`Label`、`Circle` 等组件构建交互界面

***

## 示例代码

### 1. 定义消息数据类型

```ts
type Message = {
  from: string
  content: string
  isUnread: boolean
}
```

### 2. 创建自定义消息单元格组件

使用 `HStack` 和 `VStack` 展示每条消息的状态指示点、发件人和内容。

```tsx
function MessageCell({
  message
}: {
  message: Message
}) {
  return <HStack>
    <Circle
      fill={message.isUnread ? "systemBlue" : "clear"}
      frame={{
        width: 16,
        height: 16,
      }}
    />
    <VStack alignment={"leading"}>
      <Text font={"headline"}>{message.from}</Text>
      <Text>{message.content}</Text>
    </VStack>
  </HStack>
}
```

### 3. 管理列表状态与操作

```tsx
const [messages, setMessages] = useState<Message[]>(...)

function toggleUnread(message: Message) {
  setMessages(messages.map(item =>
    item !== message ? item : { ...message, isUnread: !item.isUnread }
  ))
}

function deleteMessage(message: Message) {
  setMessages(messages.filter(item => item !== message))
}
```

### 4. 构建带滑动交互的列表视图

```tsx
return <NavigationStack>
  <List
    navigationTitle={"Messages"}
    navigationBarTitleDisplayMode={"inline"}
    listStyle={"inset"}
  >
    {messages.map(message =>
      <MessageCell
        message={message}
        leadingSwipeActions={{
          allowsFullSwipe: false,
          actions: [
            <Button
              action={() => toggleUnread(message)}
              tint={"systemBlue"}
            >
              {message.isUnread
                ? <Label title={"Read"} systemImage={"envelope.open"} />
                : <Label title={"Unread"} systemImage={"envelope.badge"} />
              }
            </Button>
          ]
        }}
        trailingSwipeActions={{
          actions: [
            <Button
              role={"destructive"}
              action={() => deleteMessage(message)}
            >
              <Label title={"Delete"} systemImage={"trash"} />
            </Button>,
            <Button
              action={() => {}}
              tint={"systemOrange"}
            >
              <Label title={"Flag"} systemImage={"flag"} />
            </Button>
          ]
        }}
      />
    )}
  </List>
</NavigationStack>
```

### 5. 展示页面并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键特性

- **leadingSwipeActions**：配置从主视图起始方向滑动（如从左向右）的操作。
- **trailingSwipeActions**：配置从主视图尾部方向滑动（如从右向左）的操作。
- **allowsFullSwipe**：设置为 `false` 时，禁止通过完全滑动直接触发第一个操作按钮。
- **Button 的 role 属性**：使用 `"destructive"` 等角色值，系统会为按钮应用相应的视觉样式（如删除按钮为红色）。
- **tint**：可自定义按钮颜色，以提升识别度与视觉分层。

***

## 适用场景

- **邮件/消息类脚本**：快速标记为已读/未读、删除、归档或加星。
- **任务清单**：滑动完成任务或移除待办事项。
- **自定义工具列表**：根据上下文为每项内容添加快捷操作。

通过滑动操作，可以为列表提供直观、高效的交互方式，提升用户体验与操作效率。



---
url: /v2/zh/guide/Views/List/List interaction/index_example.md
---

# 示例

```tsx
import { Button, Circle, HStack, Label, List, Navigation, NavigationStack, Script, Text, useState, VStack } from "scripting"

type Message = {
  from: string
  content: string
  isUnread: boolean
}

function MessageCell({
  message
}: {
  message: Message
}) {
  return <HStack>
    <Circle
      fill={message.isUnread ? "systemBlue" : "clear"}
      frame={{
        width: 16,
        height: 16,
      }}
    />
    <VStack
      alignment={"leading"}
    >
      <Text font={"headline"}>{message.from}</Text>
      <Text>{message.content}</Text>
    </VStack>
  </HStack>
}

function Example() {
  const [messages, setMessages] = useState<Message[]>(() => [
    {
      from: "Maria Ruiz",
      content: "If you have a list of messages, you can add an action to toggle a message as unread on a swipe from the leading edge, and actions to delete or flag messages on a trailing edge swipe.",
      isUnread: true,
    },
    {
      from: "Mei Chen",
      content: "Actions appear in the order you list them, starting from the swipe’s originating edge. In the example, the Delete action appears closest to the screen’s trailing edge",
      isUnread: true,
    },
    {
      from: "Maria Ruiz",
      content: "By default, the user can perform the first action for a given swipe direction with a full swipe. The user can perform both the toggle unread and delete actions with full swipes. You can opt out of this behavior for an edge by setting the allowsFullSwipe parameter to false.",
      isUnread: false,
    },
    {
      from: "Mei Chen",
      content: "When you set a role for a button using one of the values from the ButtonRole, system styles the button according to its role. In the example above, the delete action appears in red because it has the destructive role. If you want to set a different color, add the tint property to the button",
      isUnread: true,
    }
  ])

  function toggleUnread(message: Message) {
    setMessages(messages.map(item => item !== message ? item : {
      ...message,
      isUnread: !item.isUnread
    }))
  }

  function deleteMessage(message: Message) {
    setMessages(messages.filter(item => item !== message))
  }

  return <NavigationStack>
    <List
      navigationTitle={"Messages"}
      navigationBarTitleDisplayMode={"inline"}
      listStyle={"inset"}
    >
      {messages.map(message =>
        <MessageCell
          message={message}
          leadingSwipeActions={{
            allowsFullSwipe: false,
            actions: [
              <Button
                action={() => toggleUnread(message)}
                tint={"systemBlue"}
              >
                {message.isUnread
                  ? <Label title={"Read"} systemImage={"envelope.open"} />
                  : <Label title={"Unread"} systemImage={"envelope.badge"} />
                }
              </Button>
            ]
          }}
          trailingSwipeActions={{
            actions: [
              <Button
                role={"destructive"}
                action={() => deleteMessage(message)}
              >
                <Label title={"Delete"} systemImage={"trash"} />
              </Button>,
              <Button
                action={() => { }}
                tint={"systemOrange"}
              >
                <Label title={"Flag"} systemImage={"flag"} />
              </Button>
            ]
          }}
        />
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/List/List style/index.md
---

# 列表样式

通过该属性，你可以自定义 `List` 视图在 UI 中的行为和外观。

***

## 属性声明

```tsx
listStyle?: ListStyle;
```

### 描述

`listStyle` 属性定义了列表的视觉样式，允许你从多种预定义样式中选择合适的样式。

***

### 可接受的值

`listStyle` 属性接受以下字符串值：

- **`automatic`**：使用平台的默认列表行为和外观。
- **`bordered`**：以标准边框显示列表。
- **`carousel`**：将列表设置为类似于旋转木马的外观。
- **`elliptical`**：为列表提供椭圆形的样式。
- **`grouped`**：以分组格式显示列表。
- **`inset`**：为列表应用内嵌外观。
- **`insetGroup`**：结合内嵌和分组样式。
- **`plain`**：以简单样式显示列表，不添加额外的装饰。
- **`sidebar`**：将列表呈现为类似侧边栏的外观。

***

### 默认行为

如果未指定 `listStyle`，系统会根据平台选择默认样式。

***

## 使用示例

以下展示了如何在 TypeScript 代码中应用 `listStyle` 属性：

### 示例 1：简单列表样式 (Plain Style)

```tsx
<List
  listStyle="plain"
>
  <Text>项目 1</Text>
  <Text>项目 2</Text>
  <Text>项目 3</Text>
</List>
```

此示例创建了一个简单样式的列表。

***

### 示例 2：分组列表样式 (Grouped Style)

```tsx
<List
  listStyle="grouped"
>
  <Section header={
    <Text>水果</Text>
  }>
    <Text>苹果</Text>
    <Text>香蕉</Text>
  </Section>
  <Section header={
    <Text>蔬菜</Text>
  }>
    <Text>胡萝卜</Text>
    <Text>西兰花</Text>
  </Section>
</List>
```

此示例创建了一个分组样式的列表，每个分组有一个标题。

***

### 示例 3：侧边栏列表样式 (Sidebar Style)

```tsx
<List
  listStyle="sidebar"
>
  <Text>主页</Text>
  <Text>设置</Text>
  <Text>个人资料</Text>
</List>
```

此示例创建了一个类似于侧边栏的列表。

***

## 注意事项

- `listStyle` 属性直接映射到 SwiftUI 的 `listStyle` 修饰符。
- 确保传入的字符串值与上述预定义样式之一匹配，以避免运行时错误。

通过选择合适的 `listStyle`，你可以根据设计需求调整列表的外观，从而为用户提供更符合场景的视觉体验。



---
url: /v2/zh/guide/Views/List/List style/list_style.md
---

# 示例

```tsx
import { List, ListStyle, Navigation, NavigationStack, Picker, Script, Section, Text, useMemo, useState } from "scripting"

function Example() {
  const [listStyle, setListStyle] = useState<ListStyle>("automatic")
  const listStyleOptions = useMemo<ListStyle[]>(() => [
    "automatic",
    "bordered",
    "carousel",
    "elliptical",
    "grouped",
    "inset",
    "insetGroup",
    "plain",
    "sidebar",
  ], [])

  return <NavigationStack>
    <List
      navigationTitle={"List Style"}
      navigationBarTitleDisplayMode={"inline"}
      listStyle={listStyle}
    // listSectionSpacing={5} // apply for all sections
    >
      <Picker
        title={"ListStyle"}
        value={listStyle}
        onChanged={setListStyle as any}
        pickerStyle={"menu"}
      >
        {listStyleOptions.map(listStyle =>
          <Text tag={listStyle}>{listStyle}</Text>
        )}
      </Picker>

      <Section>
        <Text
          badge={10} // Use a badge to convey optional, supplementary information about a view
        >Recents</Text>
        <Text>Favorites</Text>
      </Section>

      <Section
        header={<Text>Colors</Text>}
        listItemTint={"systemBlue"}
      >
        <Text>Red</Text>
        <Text>Blue</Text>
      </Section>

      <Section
        header={<Text>Shapes</Text>}
      >
        <Text>Rectangle</Text>
        <Text>Circle</Text>
      </Section>

      <Section
        header={<Text>Borders</Text>}
        listSectionSpacing={10} // specify on an individual Section
      >
        <Text>Dashed</Text>
        <Text>Solid</Text>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/List/Refresable List/index.md
---

# 可刷新列表

将可滚动视图标记为 **可刷新**，允许用户下拉以触发异步的数据刷新操作。

## 类型

```ts
refreshable?: () => Promise<void>
```

***

## 概述

在如 `<List>` 这样的可滚动视图上使用 `refreshable` 修饰符，可以启用下拉刷新的交互行为。当用户在页面顶部下拉时，框架会调用你提供的异步处理函数。

在处理函数中，你可以执行异步操作（例如请求网络数据或更新本地状态），当该函数返回后，刷新指示器将自动隐藏。

此行为与 SwiftUI 的 [`refreshable`](https://developer.apple.com/documentation/swiftui/view/refreshable%28action:%29) 非常相似。

***

## 使用示例

```tsx
<List
  navigationTitle="可刷新列表"
  navigationBarTitleDisplayMode="inline"
  refreshable={refresh}
/>
```

### 完整示例

```tsx
function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 2000) // 模拟2秒刷新
    })
  }

  return <NavigationStack>
    <List
      navigationTitle="可刷新列表"
      navigationBarTitleDisplayMode="inline"
      refreshable={refresh}
    >
      <Section header={<Text textCase={null}>下拉即可刷新</Text>}>
        {data.map(item =>
          <Text>数字：{item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}
```

***

## 行为说明

- `refreshable` 必须返回一个 `Promise<void>`。只有在该 promise 被解析（`resolve`）后，刷新指示器才会消失。
- 在处理函数内部可以使用 `await` 进行异步操作：

  ```ts
  refreshable={async () => {
    const result = await fetchData()
    setData(result)
  }}
  ```
- 此修饰符 **仅适用于可滚动容器**（如 `<List>`）。
- 在刷新逻辑中应更新相关状态，以反映新的数据。
- 避免长时间运行或无反馈的任务，必须确保 promise 能被及时解析以防止界面卡住。

***

## 使用建议

- 保持刷新逻辑简洁高效。
- 始终在逻辑结束后调用 `resolve`。
- 开发时可使用延迟模拟加载动画：

  ```ts
  await new Promise(resolve => setTimeout(resolve, 1000))
  ```



---
url: /v2/zh/guide/Views/List/Refresable List/refreshable_list.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Script, Section, Text, useState } from "scripting"

function Example() {
  const [data, setData] = useState(generateRandomList)

  function generateRandomList() {
    const data: number[] = []
    const count = Math.ceil(Math.random() * 100 + 10)

    for (let i = 0; i < count; i++) {
      const num = Math.ceil(Math.random() * 1000)
      data.push(num)
    }

    return data
  }

  async function refresh() {
    return new Promise<void>(resolve => {
      setTimeout(() => {
        setData(generateRandomList())
        resolve()
      }, 1000 * 2)
    })
  }

  return <NavigationStack>
    <List
      navigationTitle={"Refreshable List"}
      navigationBarTitleDisplayMode={"inline"}
      refreshable={refresh}
    >
      <Section header={
        <Text textCase={null}>Pull down to refresh</Text>
      }>
        {data.map(item =>
          <Text>Number: {item}</Text>
        )}
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/List/Represent data hierarchy in sections/index.md
---

# 以分区表示数据层级

本示例展示如何在 **Scripting** 应用中使用 `Section` 组件，在 `List` 中清晰地组织层级化数据。通过将相关数据（例如员工列表）按部门分组，并为每个分组设置标题，可以更好地提升信息的可读性与结构性。

***

## 概览

你将学习如何：

- 使用 `List` 和 `Section` 展示结构化数据
- 根据部门将员工信息分组显示
- 创建可复用的行视图组件
- 将公司 → 部门 → 员工的层级数据结构转换为列表界面

***

## 数据模型

示例定义了一个公司层级结构，包含公司、部门和员工三层：

```ts
type Person = {
  name: string
  phoneNumber: string
}

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}
```

### 示例数据

```ts
const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        { name: "Juan Chavez", phoneNumber: "(408) 555-4301" },
        { name: "Mei Chen", phoneNumber: "(919) 555-2481" }
      ]
    },
    {
      name: "Engineering",
      staff: [
        { name: "Bill James", phoneNumber: "(408) 555-4450" },
        { name: "Anne Johnson", phoneNumber: "(417) 555-9311" }
      ]
    }
  ]
}
```

***

## 人员行组件

`PersonRowView` 是一个可复用组件，用于展示员工姓名和电话号码，采用垂直排版并添加辅助样式。

```tsx
function PersonRowView({ person }: { person: Person }) {
  return <VStack alignment={"leading"} spacing={3}>
    <Text font={"headline"} foregroundStyle={"label"}>{person.name}</Text>
    <HStack spacing={3} font={"subheadline"} foregroundStyle={"secondaryLabel"}>
      <Label title={person.phoneNumber} systemImage={"phone"} />
    </HStack>
  </VStack>
}
```

***

## 主视图布局

主界面使用 `NavigationStack` 包裹 `List`，每个部门对应一个 `Section`。部门名称作为区块标题，区块内通过 `PersonRowView` 渲染员工列表。

```tsx
function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Represent data hierarchy in sections"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <Section
          header={<Text>{department.name}</Text>}
        >
          {department.staff.map(person =>
            <PersonRowView person={person} />
          )}
        </Section>
      )}
    </List>
  </NavigationStack>
}
```

***

## 启动入口

脚本展示界面后，在关闭时退出脚本：

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

- **List**：用于构建可滚动的列表容器。
- **Section**：将列表按组分类，每组有标题和子项。
- **NavigationStack**：提供导航上下文与导航栏标题显示。
- **PersonRowView**：可复用组件，统一渲染员工数据格式。

***

## 适用场景

- 按部门、分类、地区等组织联系人或数据条目
- 展示有父子结构的数据，如清单、文件、配置项等
- 实现信息有序分组，提升用户的查阅与交互体验

通过在 `List` 中使用 `Section`，你可以构建清晰、分组合理的层级数据界面，使复杂内容一目了然，适合各类数据展示与信息架构设计。



---
url: /v2/zh/guide/Views/List/Represent data hierarchy in sections/index_example.md
---

# 示例

```tsx
import { HStack, Label, List, Navigation, NavigationStack, Script, Section, Text, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Represent data hierarchy in sections"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <Section
          header={
            <Text>{department.name}</Text>
          }
        >
          {department.staff.map(person =>
            <PersonRowView
              person={person}
            />
          )}
        </Section>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/List/Selectable List.md
---

# 可选择的列表

`List.selection` 用于为 `List` 组件提供**选择状态绑定能力**，用于实现列表的：

- 单选模式（Single Selection）
- 多选模式（Multiple Selection）
- 与编辑模式（`EditButton`）联动的批量选择行为

***

## 一、API 定义

```ts
type ListProps = {
  selection?: Observable<string | null> | Observable<string[]>
  ...
}

declare const List: FunctionComponent<ListProps>
```

***

## 二、selection 类型说明

`selection` 通过 `Observable` 的泛型类型自动区分选择模式：

| 模式 | Observable 类型                | 说明         |
| -- | ---------------------------- | ---------- |
| 单选 | `Observable<string \| null>` | 仅允许选中一个元素  |
| 多选 | `Observable<string[]>`       | 允许同时选中多个元素 |

***

## 三、selection 与 ForEach 的自动绑定规则

当 `List` 绑定 `selection` 时，`ForEach` 的 `data` **必须满足以下规则**：

```ts
ForEach 的 data 数组中，每一个元素都必须包含：

{
  id: string
}
```

系统行为规则如下：

1. `id` 会被自动作为该行的 **唯一选择标识**
2. 当用户点击某一行时：

   - 单选模式：`selected.value` 会被自动设置为该行的 `id`
   - 多选模式：该 `id` 会被自动加入或移出 `selected.value` 数组
3. 不需要手动在 `onTap` 中处理选中逻辑
4. `id` 必须唯一且稳定，否则会导致选择状态错乱或失效

***

## 四、单选模式（Single Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string | null>(null)
```

### 2. 使用示例

```tsx
function View() {
  const selected = useObservable<string | null>(null)

  const options = useObservable<{ id: string }[]>(() =>
    new Array(10).fill(0).map((_, i) => ({ id: i.toString() }))
  )

  return <NavigationStack>
    <List selection={selected}>
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

- `null`：当前没有选中任何项
- `"3"`：当前选中 `id === "3"` 的项

***

## 五、多选模式（Multiple Selection）

### 1. 定义方式

```tsx
const selected = useObservable<string[]>([])
```

### 2. 使用示例

```tsx
function View() {
  const dismiss = Navigation.useDismiss()
  const selected = useObservable<string[]>([])

  const options = useObservable<{ id: string }[]>(() =>
    new Array(30).fill(0).map((_, i) => ({
      id: i.toString() 
    }))
  )

  console.log(selected.value)

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />,
        topBarTrailing: <EditButton />
      }}
      selection={selected}
    >
      <ForEach
        data={options}
        builder={item =>
          <Text>{item.id}</Text>
        }
      />
    </List>
  </NavigationStack>
}
```

### 3. 状态说明

`selected.value` 始终为一个字符串数组，例如：

```ts
["2", "5", "8"]
```

表示当前有 3 项被同时选中。

***

## 六、selection 与 EditButton 的编辑模式行为

当 `List` 绑定了 `selection` 后：

1. `EditButton` 会自动启用选择编辑模式
2. 进入编辑模式后：

   - 单选：点击某一项即切换选中项
   - 多选：支持多项同时勾选
3. 退出编辑模式后：

   - `selected.value` 会被 **自动重置**

     - 单选模式重置为 `null`
     - 多选模式重置为空数组 `[]`

该行为与 SwiftUI 原生编辑模式保持一致。

***

## 七、selection 的程序化控制

除了用户交互以外，也可以通过代码主动修改选中状态。

### 单选模式

```ts
selected.setValue("5")
```

### 多选模式

```ts
selected.setValue(["1", "3", "7"])
```

设置后 UI 会自动同步对应的勾选状态。

***

## 八、selection 与 NavigationStack 的兼容性

`List.selection` 可以安全地在 `NavigationStack` 内使用，不会影响：

- 页面导航行为
- Toolbar 显示
- EditButton 编辑模式
- 页面返回逻辑

标准推荐结构如下：

```tsx
<NavigationStack>
  <List selection={selected}>
    ...
  </List>
</NavigationStack>
```

***

## 九、常见错误说明

### 1. selection 类型错误

错误：

```ts
const selected = useObservable<number | null>(null)
```

正确：

```ts
const selected = useObservable<string | null>(null)
```

目前 `selection` 仅支持 `string` 作为选择标识类型。

***

### 2. 多选模式初始化错误

错误：

```ts
const selected = useObservable<string[]>(null)
```

正确：

```ts
const selected = useObservable<string[]>([])
```

***

### 3. data 未包含 id:string

错误示例：

```tsx
const options = [{ name: "A" }, { name: "B" }]
```

该写法将导致：

- selection 无法正常工作
- 勾选状态丢失
- 列表复用异常

***

## 十、适用场景

`List.selection` 适用于以下场景：

- 单选设置项（主题、语言、偏好）
- 批量删除
- 批量导出
- 批量分享
- 文件管理器
- 通讯录选择
- 任务列表勾选



---
url: /v2/zh/guide/Views/List/Use list for navigations/index.md
---

# 使用列表进行导航

本示例展示如何在 **Scripting** 应用中使用 `List` 创建可导航的分层数据界面。通过 `DisclosureGroup` 将内容按部门分组，并结合 `NavigationLink` 实现点击跳转到人员详情页的功能。

***

## 概览

你将学习如何：

- 使用 `List` 显示部门和员工的目录结构
- 使用 `DisclosureGroup` 创建可展开的分组
- 使用 `NavigationLink` 跳转到详细视图
- 构建可复用的子视图组件来提升代码结构清晰度

***

## 数据结构

本示例使用嵌套结构模拟公司 → 部门 → 员工的信息层级：

```ts
type Person = {
  name: string
  phoneNumber: string
}

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}
```

### 示例数据

```ts
const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        { name: "Juan Chavez", phoneNumber: "(408) 555-4301" },
        { name: "Mei Chen", phoneNumber: "(919) 555-2481" }
      ]
    },
    {
      name: "Engineering",
      staff: [
        { name: "Bill James", phoneNumber: "(408) 555-4450" },
        { name: "Anne Johnson", phoneNumber: "(417) 555-9311" }
      ]
    }
  ]
}
```

***

## 视图组件

### `PersonRowView`

用于显示员工姓名与电话号码的组件，使用垂直堆叠排版。

```tsx
function PersonRowView({ person }: { person: Person }) {
  return <VStack alignment={"leading"} spacing={3}>
    <Text font={"headline"} foregroundStyle={"label"}>{person.name}</Text>
    <HStack spacing={3} font={"subheadline"} foregroundStyle={"secondaryLabel"}>
      <Label title={person.phoneNumber} systemImage={"phone"} />
    </HStack>
  </VStack>
}
```

### `PersonDetailView`

点击员工后跳转的详情页，展示详细信息。

```tsx
function PersonDetailView({ person }: { person: Person }) {
  return <VStack>
    <Text font={"title"} foregroundStyle={"label"}>{person.name}</Text>
    <HStack foregroundStyle={"secondaryLabel"}>
      <Label title={person.phoneNumber} systemImage={"phone"} />
    </HStack>
  </VStack>
}
```

***

## 主界面布局

根视图使用 `NavigationStack` 包裹 `List`，通过 `DisclosureGroup` 对部门分组，组内使用 `NavigationLink` 包裹员工信息，支持点击跳转详情页：

```tsx
function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Staff Directory"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <DisclosureGroup title={department.name}>
          {department.staff.map(person =>
            <NavigationLink
              destination={<PersonDetailView person={person} />}
            >
              <PersonRowView person={person} />
            </NavigationLink>
          )}
        </DisclosureGroup>
      )}
    </List>
  </NavigationStack>
}
```

***

## 启动视图并退出脚本

```tsx
async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

- **List**：用于展示可滚动的列表结构。
- **DisclosureGroup**：支持分组并可展开/折叠内容区域。
- **NavigationLink**：可点击的跳转组件，用于导航到目标视图。
- **NavigationStack**：用于包裹整个导航流程，提供导航上下文。

***

## 应用场景

- 构建组织架构、通讯录等分级导航界面
- 展示具有层级结构的数据，如公司目录、分类商品等
- 提供从列表快速跳转到详细信息的用户体验

本示例提供了一种结构清晰、功能完整的导航模式，适用于构建多级数据浏览和交互式信息展示的脚本页面。



---
url: /v2/zh/guide/Views/List/Use list for navigations/index_example.md
---

# 示例

```tsx
import { DisclosureGroup, HStack, Label, List, Navigation, NavigationLink, NavigationStack, Script, Text, VStack } from "scripting"

type Person = {
  name: string
  phoneNumber: string
}

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Staff Directory"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {companyA.departments.map(department =>
        <DisclosureGroup
          title={department.name}
        >
          {department.staff.map(person =>
            <NavigationLink
              destination={
                <PersonDetailView
                  person={person}
                />
              }
            >
              <PersonRowView
                person={person}
              />
            </NavigationLink>
          )}
        </DisclosureGroup>
      )}
    </List>
  </NavigationStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/LivePhotoView.md
---

# LivePhotoView

LivePhoto 表示一张 **系统级 Live Photo**，它由以下两部分组成：

- 一张高分辨率静态图片
- 一段与图片绑定的短视频（通常为 MOV）

在 Scripting 中，LivePhoto 是一个 **不可直接 new 的系统对象**，通常来源于：

- 照片选择器返回的结果
- 使用本地图片与视频文件动态构建

LivePhoto 的主要用途包括：

- 在界面中实时展示 Live Photo
- 读取并处理其底层资源（图片 / 视频）
- 将其拆解、重建或重新保存到系统相册

***

## LivePhoto 类

### LivePhoto.size

```
readonly size: Size
```

表示 Live Photo 的尺寸信息，对应其 **主图像（静态图片）** 的像素宽高。

该属性常用于：

- UI 布局约束
- 计算缩放比例
- 判断 Live Photo 的原始分辨率

***

### LivePhoto.getAssetResources()

```
getAssetResources(): Promise<{
  data: Data
  assetLocalIdentifier: string
  contentType: UTType
  originalFilename: string
  pixelHeight: number
  pixelWidth: number
}[]>
```

用于获取 Live Photo 的 **底层资源列表**。

一个 Live Photo 通常至少包含以下资源：

- 静态图片资源（JPEG / HEIC）
- 视频资源（QuickTime MOV）

返回数组中每一项代表一个资源，其字段含义如下：

- `data`
  资源的二进制数据，可直接用于写入文件、保存或传输

- `assetLocalIdentifier`
  Photos 框架中该资源的本地唯一标识

- `contentType`
  资源的统一类型标识（UTType），用于区分图片或视频类型

- `originalFilename`
  系统中该资源的原始文件名

- `pixelWidth` / `pixelHeight`
  该资源的实际像素尺寸

典型使用场景包括：

- 手动保存 Live Photo（避免中间临时文件）
- 将 Live Photo 拆解为独立的图片与视频
- 对 Live Photo 进行自定义导出或重建

***

### LivePhoto.from(options)

```
static from(options: {
  imagePath: string
  videoPath: string
  targetSize?: Size | null
  placeholderImage: UIImage | null
  contentMode?: "aspectFit" | "aspectFill"
  onResult: (result: LivePhoto | null, info: {
    error: string | null
    degraded: boolean | null
    cancelled: boolean | null
  }) => void
}): Promise<() => void>
```

用于 **从本地图片文件与视频文件异步构建 Live Photo**。

该方法的特点如下：

- 构建过程是异步的
- `onResult` 可能会被调用多次
- 支持降级结果（低质量预览）
- 支持主动取消请求

#### 参数说明

- `imagePath`
  静态图片文件路径，通常为 JPEG 或 HEIC

- `videoPath`
  与图片对应的视频文件路径，通常为 MOV

- `targetSize`
  指定返回 Live Photo 的目标尺寸
  传入 `null` 表示使用原始尺寸

- `placeholderImage`
  Live Photo 尚未加载完成时用于占位显示的 UIImage

- `contentMode`
  占位图的显示方式

  - `aspectFit`：完整显示，保持比例
  - `aspectFill`：填满区域，可能裁剪

- `onResult(result, info)`
  Live Photo 加载完成或状态更新时触发的回调

#### info 参数说明

- `error`
  构建失败时的错误信息

- `degraded`
  表示当前结果是否为低质量版本

- `cancelled`
  表示请求是否被取消

#### 返回值

该方法返回一个 Promise，成功后解析为一个 **可取消函数**：

```
() => void
```

调用该函数可立即取消 Live Photo 的加载过程。

***

## LivePhotoView 组件

LivePhotoView 是用于 **在界面中展示 Live Photo 的原生视图组件**，行为与系统 Photos App 中的 Live Photo 播放体验一致。

***

### LivePhotoViewProps

```
type LivePhotoViewProps = {
  livePhoto: Observable<LivePhoto | null>
}
```

#### livePhoto

- 类型：`Observable<LivePhoto | null>`
- 必填

该属性用于绑定当前要显示的 Live Photo。

设计为 `Observable` 的原因是：

- Live Photo 通常是异步获取的
- 允许在同一个视图中动态切换 Live Photo
- 便于与选择器、加载逻辑解耦

当 Observable 的值发生变化时，LivePhotoView 会自动更新显示内容。

***

## 使用示例说明

以下示例展示了一个典型使用流程：

- 用户选择一张 Live Photo
- 将 Live Photo 存入 Observable
- LivePhotoView 自动展示并播放该 Live Photo

```tsx
import { LivePhotoView, Button, useObservable } from "scripting"

function Example() {
  const livePhoto = useObservable<LivePhoto | null>(null)

  return <>
    <Button
      title="Set Live Photo"
      action={async () => {
        const lp = await getLivePhotoSomehow()
        livePhoto.setValue(lp)
      }}
    />

    <LivePhotoView
      livePhoto={livePhoto}
      frame={{ idealHeight: 300 }}
    />
  </>
}
```

### 核心流程说明

- 使用 `useObservable<LivePhoto | null>` 创建可观察状态
- 在用户选择 Live Photo 后，通过 `setValue` 更新状态
- LivePhotoView 自动响应状态变化并展示内容

LivePhotoView 不负责：

- Live Photo 的获取
- 权限处理
- 数据保存

它仅专注于 **展示与交互体验**。

***

## 设计原则与注意事项

- LivePhoto 是系统资源对象，生命周期由系统管理
- LivePhotoView 必须绑定 Observable，而不是直接传值
- 同一个 LivePhoto 实例可被多个 LivePhotoView 使用
- Live Photo 的加载与 UI 渲染解耦，推荐始终通过 Observable 驱动

***

## 总结

LivePhoto 相关能力在 Scripting 中主要由两部分组成：

- **LivePhoto 数据模型**
  用于表示、构建和解析系统 Live Photo

- **LivePhotoView 展示组件**
  用于以原生方式展示 Live Photo，并支持动态更新



---
url: /v2/zh/guide/Views/Markdown.md
---

# Markdown

`Markdown` 是一个用于渲染 Markdown 格式文本的视图组件，可在脚本的用户界面中显示富文本内容、代码块、文档说明等。它支持多种显示主题以及代码语法高亮样式，非常适合展示格式化文档、日志、开发说明等信息。

***

## 导入方式

```ts
import { Markdown } from 'scripting'
```

***

## 基本用法

```tsx
<Markdown content="# 你好\n这是一个 **Markdown** 视图。" />
```

***

## 参数说明（Props）

### `content: string` **(必填)**

要显示的 Markdown 格式文本内容。支持标准 Markdown 语法。

```tsx
<Markdown content="## 特性\n- 支持 **加粗**、*斜体* 和 `代码块`。" />
```

***

### `theme?: 'basic' | 'github' | 'docC'`

设置 Markdown 内容的整体主题风格，可选值包括：

- `'basic'`：简洁、通用的默认样式。
- `'github'`：GitHub 风格，适合开发文档或代码说明。
- `'docC'`：仿照 Apple DocC 的文档风格。

```tsx
<Markdown content="**Hello**" theme="docC" />
```

***

### `highlighterTheme?: 'midnight' | 'presentation' | 'sundellsColors' | 'sunset' | 'wwdc17' | 'wwdc18'`

设置 Markdown 中代码块的语法高亮主题。如果未设置，默认不使用高亮主题。

可选值包括：

- `'midnight'`
- `'presentation'`
- `'sundellsColors'`
- `'sunset'`
- `'wwdc17'`
- `'wwdc18'`

````tsx
<Markdown
  content="```js\nconsole.log('Hello')\n```"
  highlighterTheme="wwdc18"
/>
````

***

### `useDefaultHighlighterTheme?: boolean`

是否使用系统默认的语法高亮主题。启用后，系统会根据当前的浅色或深色模式自动切换主题。

> ⚠️ 如果设置了 `highlighterTheme`，此配置将被忽略。

````tsx
<Markdown
  content="```swift\nprint(\"你好\")\n```"
  useDefaultHighlighterTheme={true}
/>
````

***

### `scrollable?: boolean`

默认值：`true`

控制 Markdown 视图是否可滚动。如果希望将其嵌入到其他可滚动容器中，可设置为 `false`。

```tsx
<Markdown content="# 标题" scrollable={false} />
```

***

## 示例

```tsx
<Markdown
  content={`
# 欢迎使用 Scripting

以下是一个简单的示例：

\`\`\`ts
const hello = "world"
console.log(hello)
\`\`\`
  `}
  theme="github"
  highlighterTheme="sunset"
/>
```



---
url: /v2/zh/guide/Views/Menu/index.md
---

# 菜单

Scripting 提供的 `Menu` 是一个交互式菜单组件，用于展示一组操作项或子菜单。该组件可以作为操作容器，也支持嵌套结构，适合在工具栏、上下文菜单或紧凑布局中统一管理多个相关操作。

其行为类似于 SwiftUI 中的 `Menu`，支持纯文本标签和自定义视图标签，并可配置点击时的默认行为。

***

## 用途

使用 `Menu` 可以将多个相关操作整合为一个统一入口，提升界面整洁性与可用性。菜单中可以包含多个 `Button` 组件，也可以嵌套其他 `Menu` 实现多级菜单结构。

***

## 属性定义

```ts
type MenuProps = {
  primaryAction?: () => void
  children?: VirtualNode | (VirtualNode | undefined | null)[]
} & (
  | {
      title: string
      systemImage?: string
    }
  | {
      label: VirtualNode
    }
)
```

### 基础属性

| 属性名             | 类型                | 说明                                 |
| --------------- | ----------------- | ---------------------------------- |
| `primaryAction` | `() => void`（可选）  | 点击菜单本身时触发的主操作，不展开子菜单。适合设置默认行为。     |
| `children`      | `VirtualNode` 或数组 | 菜单的内容，通常是 `Button` 或嵌套的 `Menu` 组件。 |

### 标签配置（二选一）

开发者必须指定以下两种标签方式之一：

#### 方式一：`title` 与可选的 `systemImage`

| 属性名           | 类型           | 说明                      |
| ------------- | ------------ | ----------------------- |
| `title`       | `string`     | 菜单标题，描述菜单的操作内容。         |
| `systemImage` | `string`（可选） | SF Symbols 图标名称，显示在标题旁。 |

#### 方式二：`label` 自定义视图标签

| 属性名     | 类型            | 说明                   |
| ------- | ------------- | -------------------- |
| `label` | `VirtualNode` | 自定义菜单标签视图，可组合图标、文本等。 |

***

## 示例：基础菜单结构

```tsx
<Menu title="操作">
  <Button title="重命名" action={rename} />
  <Button title="删除" action={delete} />
  <Menu title="复制">
    <Button title="复制" action={copy} />
    <Button title="复制格式" action={copyFormatted} />
  </Menu>
</Menu>
```

在此示例中：

- 主菜单为 `"操作"`，包含两个按钮和一个嵌套的 `"复制"` 子菜单；
- 子菜单中继续包含两个按钮。

***

## 示例：使用 `primaryAction` 和图标

```tsx
<Menu
  title="更多"
  systemImage="ellipsis"
  primaryAction={() => console.log("点击菜单")}
>
  <Button title="设置" action={openSettings} />
  <Button title="帮助" action={openHelp} />
</Menu>
```

- 用户点击菜单图标将触发 `primaryAction`；
- 长按或展开菜单时，会展示其 `children` 内容。

***

## 示例：使用自定义标签

```tsx
<Menu
  label={
    <HStack>
      <Image systemName="gear" />
      <Text>选项</Text>
    </HStack>
  }
>
  <Button title="配置" action={configure} />
</Menu>
```

此示例使用 `HStack` 组合图标与文本作为菜单标签，适合在复杂场景下灵活布局。

***

## 开发提示

- `Menu` 常用于 `toolbar`、`contextMenu` 等需要组合多个操作的界面中；
- 可无限嵌套子菜单，构建多层级操作结构；
- 若操作不多且用户期望直接执行某一默认行为，可设置 `primaryAction`；
- 自定义 `label` 可用于图标+文本的混合样式，提升可视性与品牌一致性。



---
url: /v2/zh/guide/Views/Menu/index_example.md
---

# 示例

```tsx
import { Button, Group, List, Menu, Navigation, NavigationStack, Script, ScrollView, Section, Text, VStack } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Menu"}
      navigationBarTitleDisplayMode={"inline"}
    >

      <Section
        header={
          <Text>Menu</Text>
        }
      >
        <Menu
          title={"Open Menu"}
        >
          <Button
            title="Rename"
            action={() => console.log("Rename")}
          />
          <Button
            title="Delete"
            role={"destructive"}
            action={() => console.log("Delete")}
          />
          <Menu title="Copy">
            <Button
              title="Copy"
              action={() => console.log("Copy")}
            />
            <Button
              title="Copy Formated"
              action={() => console.log("Copy fomatted")}
            />
          </Menu>
        </Menu>
      </Section>

      <Section
        header={
          <Text>ContextMenu</Text>
        }
      >
        <Text
          foregroundStyle={"link"}
          contextMenu={{
            menuItems: <Group>
              <Button
                title="Add"
                action={() => {
                  // Add
                }}
              />
              <Button
                title="Delete"
                role="destructive"
                action={() => {
                  // Delete
                }}
              />
            </Group>
          }}
        >Long Press to open context menu</Text>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Modal presentaions/index.md
---

# 模态展示

Scripting App 提供了对 SwiftUI 风格的模态视图展示的支持。开发者可以通过向组件声明特定的属性，实现类似 `sheet`、`popover`、`fullScreenCover`、`alert` 和 `confirmationDialog` 的展示行为。这些展示是响应状态变化的，并支持多种配置项，以满足在不同屏幕尺寸和交互需求下的使用场景。

***

## Alert（警告弹窗）

当条件为真时，展示一个带标题、可选消息和操作按钮的警告弹窗。

```ts
alert?: {
  title: string
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
  actions: VirtualNode
  message?: VirtualNode
}
```

### 字段说明

- **`title`**：弹窗的标题文本。
- **`isPresented`**：控制弹窗是否显示的布尔值。
- **`onChanged`**：当 `isPresented` 状态变化时调用的回调函数。需要在用户关闭弹窗时将其更新为 `false`。
- **`actions`**：表示操作按钮的 `VirtualNode`。
- **`message`**（可选）：用于展示附加信息的 `VirtualNode`。

***

## Confirmation Dialog（确认对话框）

展示一个确认对话框，包含标题、可选消息和操作项。

```ts
confirmationDialog?: {
  title: string
  titleVisibility?: Visibility
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
  actions: VirtualNode
  message?: VirtualNode
}
```

### 字段说明

- **`title`**：对话框的标题。
- **`titleVisibility`**（可选）：标题是否显示，默认值为 `"automatic"`。
- **`isPresented`**：是否显示对话框。
- **`onChanged`**：用于更新 `isPresented` 状态的回调。
- **`actions`**：对话框操作项。
- **`message`**（可选）：附加消息内容。

```ts
type Visibility = "automatic" | "hidden" | "visible"
```

***

## Sheet（底部弹窗）

从底部弹出模态视图，通常用于展示中等重要性的内容。支持传入单个或多个配置项。

```ts
sheet?: ModalPresentation | ModalPresentation[]
```

***

## Full Screen Cover（全屏覆盖视图）

展示一个覆盖全屏的模态视图。可传入多个视图配置。

```ts
fullScreenCover?: ModalPresentation | ModalPresentation[]
```

***

## Popover（弹出菜单）

展示一个带箭头的弹出内容区域，通常用于 iPad 或大屏设备上。可设置适配策略及箭头位置。

```ts
popover?: PopoverPresentation | PopoverPresentation[]
```

### PopoverPresentation 类型定义

```ts
type PopoverPresentation = ModalPresentation & {
  arrowEdge?: Edge
  presentationCompactAdaptation?: PresentationAdaptation | {
    horizontal: PresentationAdaptation
    vertical: PresentationAdaptation
  }
}
```

#### 字段说明

- **`arrowEdge`**（可选）：弹出箭头指向的边，默认是 `"top"`。
- **`presentationCompactAdaptation`**（可选）：在紧凑环境下的展示适配策略。

```ts
type Edge = "top" | "bottom" | "leading" | "trailing"
```

***

## ModalPresentation（通用模态视图结构）

该类型被 `sheet`、`popover` 和 `fullScreenCover` 使用，定义了基础展示结构。

```ts
type ModalPresentation = {
  isPresented: boolean
  onChanged: (isPresented: boolean) => void
  content: VirtualNode
}
```

### 字段说明

- **`isPresented`**：控制是否展示模态视图。
- **`onChanged`**：模态视图关闭或显示时触发的状态更新回调。
- **`content`**：展示内容的 `VirtualNode`。

***

## PresentationAdaptation（展示适配策略）

指定在不同尺寸环境下的视图展示方式。

```ts
type PresentationAdaptation =
  | "automatic"
  | "fullScreenCover"
  | "none"
  | "popover"
  | "sheet"
```

- **`automatic`**：系统自动选择合适的展示方式。
- **`fullScreenCover`**：优先使用全屏覆盖。
- **`popover`**：优先使用弹出菜单形式。
- **`sheet`**：优先使用底部弹窗。
- **`none`**：尽量保持原始展示方式，不做适配。

***

## 示例用法

### 展示 Sheet

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  sheet={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    content: <VStack>
      <Text>Sheet 内容</Text>
      <Button title={"Dismiss"} action={() => setIsPresented(false)} />
    </VStack>
  }}
/>
```

### 展示 Popover

```tsx
<Button
  title={"Show Popover"}
  action={() => setIsPresented(true)}
  popover={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    presentationCompactAdaptation: "popover",
    content: <Text>Popover 内容</Text>,
    arrowEdge: "top",
  }}
/>
```

### 展示 Full Screen Cover

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  fullScreenCover={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    content: <VStack>
      <Text>全屏模态视图</Text>
    </VStack>
  }}
/>
```

### 配置 Sheet 高度

```tsx
sheet={{
  isPresented: isPresented,
  onChanged: setIsPresented,
  content: <VStack
    presentationDetents={[200, "medium", "large"]}
    presentationDragIndicator={"visible"}
  >
    <Text>可拖动调整高度的 Sheet</Text>
  </VStack>
}}
```

### 展示 Alert

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  alert={{
    isPresented: isPresented,
    onChanged: setIsPresented,
    title: "警告",
    message: <Text>一切正常</Text>,
    actions: <Button title={"OK"} action={() => {}} />
  }}
/>
```

### 展示 Confirmation Dialog

```tsx
<Button
  title={"Present"}
  action={() => setIsPresented(true)}
  confirmationDialog={{
    isPresented,
    onChanged: setIsPresented,
    title: "是否删除此图片？",
    actions: <Button title={"删除"} role={"destructive"} action={() => {}} />
  }}
/>
```



---
url: /v2/zh/guide/Views/Modal presentaions/index_example.md
---

# 示例

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, useState, VStack } from "scripting"

function SheetExample() {
  const [
    isPresented,
    setIsPresented
  ] = useState(false)

  return <Section
    header={
      <Text>Showing a sheet</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      sheet={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        content: <VStack
          presentationDragIndicator={"visible"}
        >
          <Text
            font={"title"}
            padding={50}
          >
            Sheet content
          </Text>
          <Button
            title={"Dismiss"}
            action={() => setIsPresented(false)}
          />
        </VStack>
      }}
    />
  </Section>
}

function PopoverExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Showing a popover</Text>
    }
  >
    <Button
      title={"Show Popover"}
      action={() => {
        setIsPresented(true)
      }}
      popover={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        presentationCompactAdaptation: "popover",
        content: <Text padding>Popover content</Text>,
        arrowEdge: "top",
      }}
    />
  </Section>
}

function FullScreenCoverExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Showing a full screen cover</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      fullScreenCover={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        content: <VStack
          onTapGesture={() => setIsPresented(false)}
          foregroundStyle={"white"}
          frame={{
            maxHeight: "infinity",
            maxWidth: "infinity",
          }}
          background={"blue"}
          ignoresSafeArea
        >
          <Text>A full-screen modal view.</Text>
          <Text>Tap to dismiss</Text>
        </VStack>
      }}
    />
  </Section>
}

function ConfiguringSheetHeightExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Configuring sheet height</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      sheet={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        content: <VStack
          presentationDragIndicator={"visible"}
          presentationDetents={[
            200, // fixed height
            "medium",
            "large"
          ]}
        >
          <Text
            font={"title"}
            padding={50}
          >
            Drag the indicator to resize the sheet height.
          </Text>
          <Button
            title={"Dismiss"}
            action={() => setIsPresented(false)}
          />
        </VStack>
      }}
    />
  </Section>
}

function PresentAlertExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Present a alert view</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => setIsPresented(true)}
      alert={{
        isPresented: isPresented,
        onChanged: setIsPresented,
        actions: <Button
          title={"OK"}
          action={() => { }}
        />,
        title: "Alert",
        message: <Text>Everything is OK</Text>
      }}
    />
  </Section>
}

function PresentConfirmationDialogExample() {
  const [isPresented, setIsPresented] = useState(false)

  return <Section
    header={
      <Text>Present a confirmation dialog</Text>
    }
  >
    <Button
      title={"Present"}
      action={() => {
        setIsPresented(true)
      }}
      confirmationDialog={{
        isPresented,
        onChanged: setIsPresented,
        title: "Do you want to delete this image?",
        actions: <Button
          title={"Delete"}
          role={"destructive"}
          action={() => {
            Dialog.alert({
              message: "The image has been deleted."
            })
          }}
        />
      }}
    />
  </Section>
}

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"Modal presentations"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <SheetExample />
      <ConfiguringSheetHeightExample />
      <FullScreenCoverExample />
      <PopoverExample />
      <PresentAlertExample />
      <PresentConfirmationDialogExample />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/NamespaceReader.md
---

# 命名空间读取器（NamespaceReader）

`NamespaceReader` 用于 **创建并管理一个几何动画命名空间（Namespace）**。
该命名空间是实现以下能力的**前提条件**：

- `matchedGeometryEffect`（组件级几何联动动画）
- `matchedTransitionSource`（页面级导航转场动画）
- `navigationTransition`（如 zoom 转场）

可以将 `NamespaceReader` 理解为：

> 一个“动画坐标系提供者”，用于告诉系统：哪些视图属于**同一组几何动画作用域**。

***

## 一、API 角色说明

`NamespaceReader` 并不是一个普通的 UI 组件，而是一个 **命名空间生成器**，用于：

- 创建一个全新的 `NamespaceID`
- 通过 render function 方式暴露给子视图使用
- 作为几何匹配动画系统的“分组边界”

它在 Scripting 中对应 SwiftUI 的：

- `@Namespace`
- `Namespace.ID`

***

## 二、基本使用方式

### 1. 最小用法结构

```tsx
<NamespaceReader>
  {namespace => (
    // 在这个作用域内
    // 使用 namespace 绑定 matchedGeometryEffect 或 matchedTransitionSource
  )}
</NamespaceReader>
```

说明：

- `NamespaceReader` 是一个 **函数式子节点组件**
- 其子节点必须是一个函数
- 该函数的参数 `namespace` 即为当前创建的命名空间实例

***

## 三、Namespace 的本质作用

### 1. 命名空间的真正含义

`namespace` 的本质作用是：

- 把一组“逻辑上可能互相关联的视图”
- 显式地声明为：

  > “它们允许进行几何匹配动画”

如果没有相同的 `namespace`：

- 即使两个视图的 `id` 完全一致
- 依然 **不会产生任何几何动画**

***

### 2. Namespace 的隔离能力

| 情况                       | 是否发生几何匹配 |
| ------------------------ | -------- |
| 相同 `id` + 相同 `namespace` | 会        |
| 相同 `id` + 不同 `namespace` | 不会       |
| 不同 `id` + 相同 `namespace` | 不会       |
| 不同 `id` + 不同 `namespace` | 不会       |

结论：

> **必须同时满足 `id` 与 `namespace` 完全一致，系统才会建立几何匹配关系。**

***

## 四、NamespaceReader 与几何动画系统的关系

### 1. 与 matchedGeometryEffect 的关系

- `matchedGeometryEffect` 依赖 `namespace` 建立“跨视图几何映射”
- `NamespaceReader` 是 `matchedGeometryEffect` 的 **前置条件**
- 没有 `NamespaceReader`：

  - `matchedGeometryEffect` 无法工作

***

### 2. 与 matchedTransitionSource 的关系

- 页面级转场动画依赖 `namespace` 来配对：

  - 转场源视图
  - 目标页面
- `NamespaceReader` 用于：

  - 在源页面生成 namespace
  - 并传递给目标页面作为统一坐标系统

***

## 五、最基础的 NamespaceReader 示例（组件级）

```tsx
const expanded = useObservable(false)

<NamespaceReader>
  {namespace => (
    <VStack>
      {!expanded.value && (
        <Circle
          matchedGeometryEffect={{
            id: "shape",
            namespace
          }}
          onTapGesture={() => {
            expanded.setValue(true)
          }}
        />
      )}

      {expanded.value && (
        <Circle
          frame={{ width: 200, height: 200 }}
          matchedGeometryEffect={{
            id: "shape",
            namespace,
            isSource: false
          }}
        />
      )}
    </VStack>
  )}
</NamespaceReader>
```

该示例中：

- `NamespaceReader` 负责创建动画坐标系
- 两个 `Circle` 因为：

  - `id` 相同
  - `namespace` 相同
    从而建立起几何联动关系

***

## 六、导航转场中的 NamespaceReader 典型结构

```tsx
<NamespaceReader>
  {namespace => (
    <NavigationLink
      destination={
        <DetailPage
          navigationTransition={{
            type: "zoom",
            namespace,
            sourceID: "cover"
          }}
        />
      }
    >
      <Image
        source="cover"
        matchedTransitionSource={{
          id: "cover",
          namespace
        }}
      />
    </NavigationLink>
  )}
</NamespaceReader>
```

该结构说明：

- `namespace` 由 `NamespaceReader` 生成
- 同时被：

  - 源视图使用
  - 目标页面使用
- 从而建立完整的页面级共享几何动画

***

## 七、命名空间的生命周期与作用范围

### 1. 生命周期

- `NamespaceReader` 每次创建：

  - 都会生成一个 **全新的 namespace**
- 该 namespace 的生命周期：

  - 仅存在于当前组件树
  - 随组件卸载而销毁

***

### 2. 作用范围

- namespace 只对其 render function 内部的视图生效
- 不可跨越组件树自动共享
- 如果需要跨组件共享：

  - 必须通过 props 显式传递 `namespace`

***

## 八、常见错误与排查要点

### 1. 动画完全不生效

请检查：

- 是否真的使用了 `NamespaceReader`
- 是否正确接收并传递了 `namespace`
- source 与 target 是否引用的是 **同一个 namespace 实例**

***

### 2. 动画偶尔失效、不稳定

常见原因：

- `NamespaceReader` 被条件渲染反复销毁与重建
- 每次重建都会生成新的 namespace
- 导致旧视图与新视图：

  - 实际上不在同一个动画坐标系中

建议：

- 将 `NamespaceReader` 放在 **稳定的父级节点**
- 避免在 `if / ternary` 结构中频繁切换

***

### 3. 多个 NamespaceReader 嵌套导致动画错乱

问题表现：

- id 相同
- 但实际 namespace 不同
- 系统无法建立匹配关系

排查思路：

- 确认 source 与 target 是否真的来自：

  - 同一个 `NamespaceReader` 实例

***

## 九、设计层面的使用建议

1. 一个独立动画区域使用一个 `NamespaceReader`
2. 不要为每一个视图都单独创建 `NamespaceReader`
3. 页面级动画：

   - NamespaceReader 应放在整个页面的根节点
4. 组件级动画：

   - NamespaceReader 应包裹同一个逻辑模块
5. 同一个 namespace 内：

   - 不要复用相同的 `id` 给不相关的视图

***

## 十、适用场景总结

适合使用 `NamespaceReader` 的场景：

- 卡片 → 详情页的共享元素动画
- Tab 指示器几何联动
- 图片放大预览
- 列表项 → 详情内容过渡
- 多视图间的空间连续动画

不需要使用 `NamespaceReader` 的场景：

- 普通 opacity / scale 动画
- 单视图内部的简单过渡
- 不涉及跨视图几何同步的动画



---
url: /v2/zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Collapsed split views.md
---

# 折叠分栏视图

```tsx
import { Navigation, NavigationSplitView, NavigationSplitViewColumn, Script, Text, useState, VStack } from "scripting"

function Example() {
  const [preferredColumn, setPreferredColumn] = useState<NavigationSplitViewColumn>("detail")

  return <NavigationSplitView
    preferredCompactColumn={{
      value: preferredColumn,
      onChanged: (value) => {
        console.log("preferredCompactColumn changed to", value)
        setPreferredColumn(value)
      }
    }}
    sidebar={
      <VStack
        navigationContainerBackground={"yellow"}
        frame={{
          maxWidth: "infinity",
          maxHeight: "infinity",
        }}
      >
        <Text>Yellow</Text>
      </VStack>
    }
  >
    <VStack
      navigationContainerBackground={"blue"}
      frame={{
        maxWidth: "infinity",
        maxHeight: "infinity",
      }}
    >
      <Text>Blue</Text>
    </VStack>
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Control column visibility.md
---

# 控制栏的可见性

```tsx
import { HStack, Label, List, Navigation, NavigationSplitView, NavigationSplitViewVisibility, Script, Text, useState, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

const companies: Company[] = [
  {
    name: "Company A",
    departments: [
      {
        name: "Sales",
        staff: [
          {
            name: "Juan Chavez",
            phoneNumber: "(408) 555-4301",
          },
          {
            name: "Mei Chen",
            phoneNumber: "(919) 555-2481",
          }
        ]
      },
      {
        name: "Engineering",
        staff: [
          {
            name: "Bill James",
            phoneNumber: "(408) 555-4450"
          },
          {
            name: "Anne Johnson",
            phoneNumber: "(417) 555-9311"
          }
        ]
      }
    ]
  },
  {
    name: "Company B",
    departments: [
      {
        name: "Human resources",
        staff: [
          {
            name: "Lily",
            phoneNumber: "(111) 555-5552"
          },
          {
            name: "Ross",
            phoneNumber: "(222) 666-8888"
          }
        ]
      },
      {
        name: "Sales",
        staff: [
          {
            name: "John",
            phoneNumber: "(1) 888-4444"
          }
        ]
      }
    ]
  }
]

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

 function Example() {
  const [columnVisibility, setColumnVisibility] = useState<NavigationSplitViewVisibility>("detailOnly")
  const [selectedPerson, setSelectedPerson] = useState<Person>()

  return <NavigationSplitView
    columnVisibility={{
      value: columnVisibility,
      onChanged: (value) => {
        console.log("columnVisibility changed to", value)
        setColumnVisibility(value)
      },
    }}
    sidebar={
      <List>
        {companyA.departments[0].staff.map(person =>
          <PersonRowView
            person={person}
            contentShape={"rect"}
            onTapGesture={() => {
              setSelectedPerson(person)
            }}
          />
        )}
      </List>
    }
  >
    {selectedPerson != null
      ? <PersonDetailView
        person={selectedPerson}
      />
      : <Text>Please select a person.</Text>
    }
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Three-column.md
---

# 三栏

```tsx
import { HStack, Label, List, Navigation, NavigationSplitView, Script, Section, Text, useState, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

const companies: Company[] = [
  {
    name: "Company A",
    departments: [
      {
        name: "Sales",
        staff: [
          {
            name: "Juan Chavez",
            phoneNumber: "(408) 555-4301",
          },
          {
            name: "Mei Chen",
            phoneNumber: "(919) 555-2481",
          }
        ]
      },
      {
        name: "Engineering",
        staff: [
          {
            name: "Bill James",
            phoneNumber: "(408) 555-4450"
          },
          {
            name: "Anne Johnson",
            phoneNumber: "(417) 555-9311"
          }
        ]
      }
    ]
  },
  {
    name: "Company B",
    departments: [
      {
        name: "Human resources",
        staff: [
          {
            name: "Lily",
            phoneNumber: "(111) 555-5552"
          },
          {
            name: "Ross",
            phoneNumber: "(222) 666-8888"
          }
        ]
      },
      {
        name: "Sales",
        staff: [
          {
            name: "John",
            phoneNumber: "(1) 888-4444"
          }
        ]
      }
    ]
  }
]

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  const [selectedCompany, setSelectedCompany] = useState<Company>()
  const [selectedPerson, setSelectedPerson] = useState<Person>()

  return <NavigationSplitView
    sidebar={
      <List>
        {companies.map(company =>
          <Text
            onTapGesture={() => {
              setSelectedCompany(company)
            }}
          >{company.name}</Text>
        )}
      </List>
    }
    content={
      selectedCompany != null
        ? <List>
          {selectedCompany.departments.map(department =>
            <Section
              header={<Text>{department.name}</Text>}
            >
              {department.staff.map(person =>
                <PersonRowView
                  person={person}
                  contentShape={"rect"}
                  onTapGesture={() => {
                    setSelectedPerson(person)
                  }}
                />
              )}
            </Section>
          )}
        </List>
        : <Text>Select a company</Text>
    }
  >
    {selectedPerson != null
      ? <PersonDetailView
        person={selectedPerson}
      /> :
      <Text>Select a person</Text>}
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Navigation/NavigationSplitView (for iPad)/Two-column.md
---

# 两栏

```tsx
import { HStack, Label, List, Navigation, NavigationSplitView, Script, Text, useState, VStack } from "scripting"

type Department = {
  name: string
  staff: Person[]
}

type Company = {
  name: string
  departments: Department[]
}

type Person = {
  name: string
  phoneNumber: string
}

const companyA: Company = {
  name: "Company A",
  departments: [
    {
      name: "Sales",
      staff: [
        {
          name: "Juan Chavez",
          phoneNumber: "(408) 555-4301",
        },
        {
          name: "Mei Chen",
          phoneNumber: "(919) 555-2481",
        }
      ]
    },
    {
      name: "Engineering",
      staff: [
        {
          name: "Bill James",
          phoneNumber: "(408) 555-4450"
        },
        {
          name: "Anne Johnson",
          phoneNumber: "(417) 555-9311"
        }
      ]
    }
  ]
}

function PersonRowView({
  person
}: {
  person: Person
}) {
  return <VStack
    alignment={"leading"}
    spacing={3}
  >
    <Text
      foregroundStyle={"label"}
      font={"headline"}
    >{person.name}</Text>
    <HStack
      spacing={3}
      foregroundStyle={"secondaryLabel"}
      font={"subheadline"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function PersonDetailView({
  person
}: {
  person: Person
}) {

  return <VStack>
    <Text
      font={"title"}
      foregroundStyle={"label"}
    >{person.name}</Text>
    <HStack
      foregroundStyle={"secondaryLabel"}
    >
      <Label
        title={person.phoneNumber}
        systemImage={"phone"}
      />
    </HStack>
  </VStack>
}

function Example() {
  const [selectedPerson, setSelectedPerson] = useState<Person>()

  return <NavigationSplitView
    sidebar={
      <List>
        {companyA.departments[0].staff.map(person =>
          <PersonRowView
            person={person}
            contentShape={"rect"}
            onTapGesture={() => {
              setSelectedPerson(person)
            }}
          />
        )}
      </List>
    }
  >
    {selectedPerson != null
      ? <PersonDetailView
        person={selectedPerson}
      />
      : <Text>Please select a person.</Text>
    }
  </NavigationSplitView>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Navigation/NavigationStack/NavigationStack with path.md
---

# NavigationStack 配合 path

`NavigationStack.path` 用于为 `NavigationStack` 提供**可观察的导航路径控制能力**，用于实现：

- 编程式导航（Programmatic Navigation）
- 多级页面堆栈控制
- 页面回退到指定层级或根视图
- 与 `NavigationDestination` 的动态页面映射联动

***

## 一、API 定义

```ts
type NavigationStackProps = {
  path?: Observable<string[]>
  ...
}

declare const NavigationStack: FunctionComponent<NavigationStackProps>
```

***

## 二、path 的类型与含义

```ts
path?: Observable<string[]>
```

`path` 是一个字符串数组的可观察对象，用于表示当前导航栈中的**页面路径序列**。

其语义规则如下：

- 每一个 `string` 表示一个页面标识
- 数组顺序表示页面入栈顺序
- 数组末尾元素表示当前显示的页面
- 数组为空表示回到根页面（Root）

示例说明：

```ts
[]
```

表示当前在根视图

```ts
["a"]
```

表示已导航到页面 `a`

```ts
["a", "b"]
```

表示先进入页面 `a`，再进入页面 `b`

***

## 三、基础使用示例

```tsx
function Page() {
  const path = useObservable<string[]>(["a"])

  return <NavigationStack
    path={path}
  >
    <VStack
      navigationTitle="Navigation Demo"
      navigationDestination={
        <NavigationDestination>
          {(page) =>
            <VStack>
              <Text>
                Current page:
                {page}
              </Text>
              {path.value.length > 1
                && <Button
                  title="Go to Root"
                  action={() => {
                    path.setValue([])
                  }}
                />}
            </VStack>
          }
        </NavigationDestination>
      }
    >
      <Button
        title="Show page a"
        action={() => {
          path.setValue(["a"])
        }}
      />
      <Button
        title="Show page b"
        action={() => {
          path.setValue(["b"])
        }}
      />
      <Button
        title="Show page a then b"
        action={() => {
          path.setValue(["a", "b"])
        }}
      />
    </VStack>
  </NavigationStack>
}
```

***

## 四、path 的工作机制说明

### 1. path 作为导航状态的唯一数据源

当 `NavigationStack` 绑定了 `path` 后：

- 当前页面层级将完全由 `path.value` 决定
- UI 导航状态将与 `path` 保持双向同步
- 不再依赖隐式的 Push / Pop 状态管理

***

### 2. 页面入栈规则

当执行：

```ts
path.setValue(["a"])
```

系统行为：

- 根页面入栈
- 跳转至页面 `a`

当执行：

```ts
path.setValue(["a", "b"])
```

系统行为：

- 先进入页面 `a`
- 再进入页面 `b`
- 当前显示页面为 `b`

***

### 3. 页面出栈与回到根页面

当执行：

```ts
path.setValue([])
```

系统行为：

- 清空整个导航路径
- 立即回到根页面

***

## 五、NavigationDestination 与 path 的关系

`NavigationDestination` 用于根据 `path` 中的当前值动态构建目标页面。

```tsx
<NavigationDestination>
  {(page) => ...}
</NavigationDestination>
```

其中：

- `page` 参数来自 `path.value` 的当前末尾元素
- 当 `path` 发生变化时：

  - `page` 会自动更新
  - 对应的页面内容会重新渲染

示例逻辑：

```ts
["a"]  -> page === "a"
["a","b"] -> page === "b"
```

***

## 六、通过按钮控制 path 进行导航

跳转到页面 `a`：

```ts
path.setValue(["a"])
```

跳转到页面 `b`：

```ts
path.setValue(["b"])
```

连续跳转两个页面：

```ts
path.setValue(["a", "b"])
```

返回根页面：

```ts
path.setValue([])
```

***

## 七、path 与手势返回的同步关系

当用户通过系统返回手势或导航栏返回按钮返回时：

- `path.value` 会自动同步更新
- 显示页面与 `path` 始终保持一致
- 不需要额外监听返回事件进行手动同步

***

## 八、path 的典型使用场景

`NavigationStack.path` 适用于以下场景：

- 深层页面跳转
- 跨页面编程式导航控制
- 统一的路由状态管理
- 脚本控制页面跳转
- 恢复上次浏览路径
- 多步骤流程（向导式界面）

***

## 九、常见错误说明

### 1. path 未初始化为空数组

错误：

```ts
const path = useObservable<string[]>(null)
```

正确：

```ts
const path = useObservable<string[]>([])
```

***

### 2. path 中的值类型错误

错误：

```ts
path.setValue([1, 2])
```

正确：

```ts
path.setValue(["1", "2"])
```

当前 `path` 仅支持 `string[]` 作为路径类型。

***

## 十、与不使用 path 的 NavigationStack 的区别

| 功能      | 不使用 path | 使用 path |
| ------- | -------- | ------- |
| 手动 Push | 支持       | 不建议     |
| 编程式跳转   | 不支持      | 支持      |
| 多层跳转    | 受限       | 完全支持    |
| 状态恢复    | 困难       | 简单      |
| 路由统一管理  | 不可控      | 完全可控    |



---
url: /v2/zh/guide/Views/Navigation/NavigationStack/Use with NavigationLink.md
---

# 与 NavigationLink 一起使用

```tsx
import { Color, List, Navigation, NavigationLink, NavigationStack, Script, Text, VStack } from "scripting"

function NavigationDetailView({
  color
}: {
  color: Color
}) {

  return <VStack
    navigationContainerBackground={color}
    frame={{
      maxWidth: "infinity",
      maxHeight: "infinity"
    }}
  >
    <Text>{color}</Text>
  </VStack>
}


function Example() {
  const colors: Color[] = [
    "red", "green", "blue", "orange", "purple"
  ]

  return <NavigationStack>
    <List
      navigationTitle={"NavigationStack with links"}
      navigationBarTitleDisplayMode={"inline"}
    >
      {colors.map(color =>
        <NavigationLink
          destination={
            <NavigationDetailView
              color={color}
            />
          }
        >
          <Text>Navigation to {color} view</Text>
        </NavigationLink>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Navigation/NavigationStack/Use with navigationDestination.md
---

# 与 navigationDestination 一起使用

```tsx
import { useState, Color, NavigationStack, List, Text, HStack, Spacer, Image, VStack, Navigation, Script } from "scripting"

function NavigationDetailView({
  color
}: {
  color: Color
}) {

  return <VStack
    navigationContainerBackground={color}
    frame={{
      maxWidth: "infinity",
      maxHeight: "infinity"
    }}
  >
    <Text>{color}</Text>
  </VStack>
}

function Example() {
  const colors: Color[] = [
    "red", "green", "blue", "orange", "purple"
  ]
  const [selectedColor, setSelectedColor] = useState<Color | null>()

  return <NavigationStack>
    <List
      navigationTitle={"With Navigation Destination"}
      navigationDestination={{
        isPresented: selectedColor != null,
        onChanged: value => {
          if (!value) {
            setSelectedColor(null)
          }
        },
        content: selectedColor != null
          ? <NavigationDetailView
            color={selectedColor}
          />
          : <Text>Select a color</Text>
      }}
    >
      {colors.map(color =>
        <HStack
          contentShape={"rect"}
          onTapGesture={() => {
            setSelectedColor(color)
          }}
        >
          <Text>Navigation to {color} view</Text>
          <Spacer />
          <Image
            systemName={"chevron.right"}
            foregroundStyle={"secondaryLabel"}
          />
        </HStack>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Navigation/TabView/TabView with badge.md
---

# 带徽章的 TabView

```tsx
import { Label, Navigation, Script, TabView, Text, useState } from "scripting"

function Example() {
  const [tabIndex, setTabIndex] = useState(0)

  return <TabView
    tabIndex={tabIndex}
    onTabIndexChanged={setTabIndex}
  >
    <ReceivedView
      tag={0}
      tabItem={
        <Label
          title={"Received"}
          systemImage={"tray.and.arrow.down.fill"}
        />
      }
      badge={2}
    />
    <SendView
      tag={1}
      tabItem={
        <Label
          title={"Send"}
          systemImage={"tray.and.arrow.up.fill"}
        />
      }
    />
    <AccountView
      tag={2}
      badge={"!"}
      tabItem={
        <Label
          title={"Account"}
          systemImage={"person.crop.circle.fill"}
        />
      }
    />
  </TabView>
}

function ReceivedView() {
  return <Text>Received view</Text>
}

function SendView() {
  return <Text>Send view</Text>
}

function AccountView() {
  return <Text>Account view</Text>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Navigation/TabView/TabView with multiple scrolling pages.md
---

# 包含多个可滚动页面的 TabView

```tsx
import { Color, Navigation, NavigationStack, Script, TabView, Text, VStack } from "scripting"

function Example() {
  const colors: Color[] = [
    "red",
    "green",
    "blue",
    "purple"
  ]

  return <NavigationStack>
    <VStack
      navigationTitle={"TabView"}
    >
      <TabView
        tabViewStyle={"page"}
        frame={{
          height: 200
        }}
      >
        {colors.map(color =>
          <ColorView
            color={color}
          />
        )}
      </TabView>
    </VStack>
  </NavigationStack>
}

function ColorView({
  color,
}: {
  color: Color
}) {
  return <VStack
    frame={{
      maxWidth: "infinity",
      maxHeight: "infinity"
    }}
    background={color}
  >
    <Text>{color}</Text>
  </VStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Navigation/TabView/TabView.md
---

Scripting 提供了与最新 iOS TabView 体系一致的 API：
通过 `TabView`、`Tab`、`TabSection` 组织界面结构，使应用能够在 iOS 18+ 环境下完整支持多标签视图、侧边栏标签、可定制布局等。

相比旧版本依赖 `tabItem` 修饰符的方式，新的结构更加灵活、分组更清晰，并能与 TabViewCustomization 等新特性无缝配合。

***

# 一、基础结构：TabView + Tab

在最基本的形式中，`TabView` 作为容器，内部包含多个 `Tab`。
每个 `Tab` 定义：

- 标签标题
- 图标
- 标识值（value）
- 角色（如 search）
- 对应的内容视图

示例：

```tsx
function RootView() {
  const selection = useObservable<number>(0)

  return (
    <TabView selection={selection}>
      <Tab
        title="首页"
        systemImage="house.fill"
        value={0}
      >
        <HomeView />
      </Tab>

      <Tab
        title="搜索"
        systemImage="magnifyingglass"
        value={1}
        role="search"
      >
        <SearchView />
      </Tab>

      <Tab
        title="设置"
        systemImage="gearshape.fill"
        value={2}
      >
        <SettingsView />
      </Tab>
    </TabView>
  )
}
```

要点：

- `selection` 通过 Observable 控制当前激活的标签
- `value` 必须与 `selection` 的泛型类型匹配（string 或 number）
- Search Tab 可使用 `role="search"` 与搜索相关行为联动

***

# 二、使用 TabSection 组织分组标签

当 Tab 数量较多、需要按功能分类、需要在侧边栏中显示复杂结构时，可以使用 `TabSection`。

结构关系为：

```
TabView
 ├─ TabSection
 │   ├─ Tab
 │   ├─ Tab
 │   └─ ...
 ├─ TabSection
 │   ├─ Tab
 │   └─ ...
```

## 1. 使用 title 作为分组标题

```tsx
<TabView selection={selection}>
  <TabSection title="收件箱">
    <Tab title="收件箱" systemImage="tray.fill" value="inbox">
      <InboxView />
    </Tab>
    <Tab title="已发送" systemImage="paperplane.fill" value="sent">
      <SentView />
    </Tab>
  </TabSection>

  <TabSection title="标签">
    <Tab title="重要" systemImage="star.fill" value="important">
      <ImportantView />
    </Tab>
  </TabSection>
</TabView>
```

## 2. 使用 header 作为自定义组头

如需显示图标、说明文字或复合内容，可用 `header`：

```tsx
<TabSection
  header={
    <HStack spacing={8}>
      <Image systemName="folder.fill" />
      <VStack>
        <Text fontWeight="bold">项目</Text>
        <Text fontSize={12} foregroundColor="secondary">
          最近打开的项目
        </Text>
      </VStack>
    </HStack>
  }
>
  <Tab title="项目 A" systemImage="doc.fill" value="projectA">
    <ProjectAView />
  </Tab>
</TabSection>
```

***

# 三、TabSection 的高级能力：布局、操作区、拖拽与可见性

`TabSection` 提供了丰富的分组级配置，让 Tab 分组的呈现方式更加灵活。

## 1. tabPlacement（标签位置策略）

支持：

- `automatic`
- `pinned`
- `sidebarOnly`

例如将某组仅显示在侧边栏：

```tsx
<TabSection title="标签" tabPlacement="sidebarOnly">
  <Tab title="重要" systemImage="star.fill" value="important">
    <ImportantView />
  </Tab>
</TabSection>
```

## 2. sectionActions（分组操作区）

为某一组提供额外操作按钮：

```tsx
<TabSection
  title="列表"
  sectionActions={
    <Button title="添加" systemImage="plus" action={addItem} />
  }
>
  ...
</TabSection>
```

## 3. 分组可见性与可定制行为

通过：

- `defaultVisibility`
- `customizationID`
- `customizationBehavior`
- `draggable`
- `dropDestination`

可以为每个分组提供：

- 默认显示策略
- 是否允许用户自定义排序或隐藏
- 是否可以拖动
- 外部拖拽数据的处理

例如：

```tsx
<TabSection
  title="文件"
  customizationID="file-section"
  customizationBehavior="reorderable"
  draggable="file-section"
  dropDestination={items => handleDrop(items)}
>
  ...
</TabSection>
```

***

# 四、TabView 级别的高级配置

TabView 本身提供了一系列属性，可用于构建高级 UI（iOS 18～26）。

包括：

- `tabBarMinimizeBehavior`
- `tabViewBottomAccessory`
- `tabViewSearchActivation`
- `tabViewCustomization`
- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

以下为每项能力的说明。

***

## 1. tabBarMinimizeBehavior（iOS 26.0+）

控制 TabBar 是否根据滚动方向自动最小化：

- `automatic`
- `never`
- `onScrollDown`
- `onScrollUp`

示例：

```tsx
<TabView
  selection={selection}
  tabBarMinimizeBehavior="onScrollDown"
>
  ...
</TabView>
```

***

## 2. tabViewBottomAccessory（iOS 26.0+）

为 TabView 添加底部附加视图，例如提示栏：

```tsx
<TabView
  selection={selection}
  tabViewBottomAccessory={
    <HStack>
      <Text>左右滑动切换标签</Text>
      <Spacer />
      <Button title="知道了" action={dismiss} />
    </HStack>
  }
>
  ...
</TabView>
```

***

## 3. tabViewSearchActivation（iOS 26.0+）

控制搜索 Tab 的激活方式：

- `automatic`
- `searchTabSelection`

与 `role="search"` 搭配使用：

```tsx
<TabView
  selection={selection}
  tabViewSearchActivation="searchTabSelection"
>
  ...
</TabView>
```

***

## 4. 侧边栏附属视图（iOS 18.0+）

包括：

- `tabViewSidebarHeader`
- `tabViewSidebarFooter`
- `tabViewSidebarBottomBar`

示例：

```tsx
<TabView
  selection={selection}
  tabViewSidebarHeader={<UserHeader />}
  tabViewSidebarFooter={<SettingsButton />}
  tabViewSidebarBottomBar={<UpgradeButton />}
>
  ...
</TabView>
```

***

# 五、TabViewCustomization：标签页可定制化体系（重点补充）

`TabViewCustomization` 是一个可序列化的状态对象，用于存储和恢复用户对 Tab 布局的自定义行为，包括：

- Tab 分组顺序
- 分组内部的 Tab 排序
- Tab 可见性（在 TabBar 与 Sidebar 中分别独立管理）
- 重置各种设置
- 持久化与恢复

它通常放在 TabView 根视图中，通过：

```tsx
tabViewCustomization={customizationState}
```

来注入。

## 1. 创建与加载 TabViewCustomization

创建方式通常是：

```tsx
const customization = useObservable<TabViewCustomization >(() => {
  const data = Storage.get('tab_customization')
  if (data) {
    return TabViewCustomization.fromData(data) ?? new TabViewCustomization()
  }
  return new TabViewCustomization()
})

useEffect(() => {
  const listener = (newValue: TabViewCustomization) => {
    const data = newValue.toData()
    if (data) {
      Storage.set('tab_customization', data)
    }
  }
  customization.subscribe(listener)
  return () => {
    customization.unsubscribe(listener)
  }
}, [])
```

如需创建一个新的空自定义对象，可使用：

```tsx
const customizationState = useObservable(() => new TabViewCustomization())
```

## 2. 保存自定义内容

你可以将用户调整后的 Tab 布局序列化保存：

```tsx
const data = customization.value?.toData()
Storage.set('tab_customization', data)
```

`toData()` 会将内部状态转换为可存储的 `Data` 对象。

## 3. 获取并操作分组（Section）

```ts
getSection(id: string): TabViewCustomizationSection | null
```

`TabSection` 通常带有 `customizationID`，这样就可以获取特定分组并操作它：

```tsx
const section = customization.value?.getSection('file-section')

section?.tabOrder        // 一个包含 tab ID 顺序的数组，或 null
section?.resetTabOrder() // 重置排序
```

场景示例：

- 用户将“文件”分组中的 Tab 重新排序
- 用户将某些 Tab 移动到“更多”区域
- 应用需要根据用户排序更新 UI

## 4. 获取并操作单个 Tab

```ts
getTab(id: string): TabViewCustomizationTab | null
```

可通过 Tab 的 `customizationID` 获取并调整其可见性：

```tsx
const tab = customization.value?.getTab('important-tab')

tab?.tabBarVisibility         // Visibility 类型
tab.sidebarVisibility = 'hidden'
```

适用场景：

- 控制 Tab 在 TabBar 或 Sidebar 中是否显示
- 用户可通过自定义界面操作 Tab 可见性
- 程序自动隐藏某些 Tab

## 5. 全局重置

```ts
resetSectionOrder(): void
resetVisibility(): void
```

通常用于：

- 点击“恢复默认布局”按钮
- 版本更新后清理已有布局逻辑

示例：

```tsx
<Button
  title="恢复默认"
  action={() => {
    customization.value?.resetSectionOrder()
    customization.value?.resetVisibility()
  }}
/>
```

***

# 六、与旧的 tabItem 写法的关系

此文档采用全新的结构化写法：

- TabView
- Tab
- TabSection
- TabViewCustomization

旧的 `tabItem` 写法仍可用于简单场景以及兼容iOS 17，但与侧边栏、Tab 分组、自定义布局等高级能力不兼容。
在复杂应用中，建议全面迁移到新的组件体系。



---
url: /v2/zh/guide/Views/Present views/Dismissing a presented view/index.md
---

# 关闭一个视图

此示例演示了如何使用 `Navigation.useDismiss` 钩子**以编程方式关闭已呈现的视图**。当你希望在用户交互（如点击按钮或文本标签）后关闭自定义视图时，这个方法非常有用。

***

## 目的

你将学会：

- 通过 `Navigation.useDismiss` 获取关闭视图的函数
- 调用该函数以关闭当前已呈现的视图
- 使用 `Script.exit` 安全退出脚本，以避免内存泄漏

***

## 示例代码

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {
  // 获取上下文中的 `dismiss` 函数
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle={"关闭视图"}
    >
      <Text
        foregroundStyle={'link'}
        onTapGesture={() => {
          dismiss()
        }}
      >点击关闭视图</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  // 避免内存泄漏
  Script.exit()
}

run()
```

***

## 关键概念

### `Navigation.useDismiss()`

该钩子返回当前视图上下文中的 `dismiss` 函数。调用它会关闭通过 `Navigation.present()` 呈现的视图。

### 使用场景

- 手动关闭一个已呈现的 UI 视图
- 用于表单提交、取消或导航控制逻辑中

### 示例用法

在示例中，渲染了一个可点击的 `Text`：

```tsx
<Text
  foregroundStyle={'link'}
  onTapGesture={() => {
    dismiss()
  }}
>
  点击关闭视图
</Text>
```

点击该文本会触发 `dismiss()`，从而关闭视图。

***

## 最佳实践

- 在 `Navigation.present()` 执行完成后，始终调用 `Script.exit()` 以避免内存泄漏
- 将视图包装在 `NavigationStack` 中，以支持标题栏和导航行为
- 确保 `useDismiss` 只在通过 `Navigation.present()` 呈现的组件树中使用

***

## 运行效果

此脚本会呈现一个简单视图，视图中包含一个链接样式的文本“**点击关闭视图**”。当用户点击该文本时，视图将被关闭。



---
url: /v2/zh/guide/Views/Present views/Dismissing a presented view/index_example.md
---

# 示例

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {
  // Access the `dismiss` function of the context.
  const dismiss = Navigation.useDismiss()

  return <NavigationStack>
    <VStack
      navigationTitle={"Dismiss a view"}
    >
      <Text
        foregroundStyle={'link'}
        onTapGesture={() => {
          dismiss()
        }}
      >Tap and dismiss</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  // Avoiding memory leaks.
  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Present views/Present a simple view/index.md
---

# 展示一个简单视图

本示例展示了如何使用 `Navigation.present` 在 Scripting 中展示一个基本的 UI 页面，同时演示了如何使用 `NavigationStack` 和 `navigationTitle` 设置导航标题。

***

## 示例功能

你将学习如何：

- 使用 `Navigation.present` 展示一个自定义页面
- 使用 `NavigationStack` 和 `VStack` 构建页面结构
- 设置导航栏标题（`navigationTitle`）

***

## 示例代码

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {

  return <NavigationStack>
    <VStack
      navigationTitle={"Present a simple view"}
    >
      <Text>Hello Scripting!</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  Script.exit()
}

run()
```

***

## 关键组件说明

### `Navigation.present(options)`

该方法用于展示一个完整页面的 UI 视图。它接收一个 `element` 参数，该参数是要展示的根组件。

```ts
await Navigation.present({
  element: <View />
})
```

### `NavigationStack`

导航堆栈容器组件，支持页面标题、导航栏按钮等功能。它必须作为页面结构的最外层容器使用，以启用导航行为。

### `VStack`

垂直方向布局容器，用于将子视图从上到下堆叠排列。在本例中，它包含一个 `Text` 组件。

### `navigationTitle`

在 `VStack` 上设置该属性可以设置页面的导航栏标题。

***

## 页面效果

该示例会展示一个标题为 **“Present a simple view”** 的页面，并在中央显示文本 **“Hello Scripting!”**。

***

## 注意事项

- 如果你的页面需要导航栏、标题、返回按钮等功能，请务必使用 `NavigationStack` 包裹视图。
- `Navigation.present` 弹出页面后，需在其完成后调用 `Script.exit()` 来确保资源正确释放，避免内存泄漏。



---
url: /v2/zh/guide/Views/Present views/Present a simple view/index_example.md
---

# 示例

```tsx
import { Navigation, NavigationStack, Script, Text, VStack } from "scripting"

function View() {

  return <NavigationStack>
    <VStack
      navigationTitle={"Present a simple view"}
    >
      <Text>Hello Scripting!</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <View />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/SVG.md
---

# SVG

`SVG` 是一个用于显示 SVG 矢量图像的视图组件，支持从以下三种来源加载 SVG 内容：

- **网络图片 URL**
- **本地文件路径**
- **内联 SVG 代码**

SVG 图像在显示时会作为位图进行渲染（不再支持矢量绘制）。你可以选择以模板图像的方式渲染，从而实现着色功能。

***

## 使用方式

```tsx
import { SVG } from 'scripting'
```

***

## Props（属性）

### 图像来源（3选1，必须指定一个）

| 属性         | 类型                                     | 说明                 |
| ---------- | -------------------------------------- | ------------------ |
| `url`      | `string \| DynamicImageSource<string>` | 从网络 URL 加载 SVG 图像  |
| `filePath` | `string \| DynamicImageSource<string>` | 从本地文件路径加载 SVG 图像   |
| `code`     | `string \| DynamicImageSource<string>` | 使用内联 SVG 字符串代码渲染图像 |

注意：以上三个属性**互斥**，只能设置其中一个。

***

### 图像渲染行为（ImageRenderingBehaviorProps）

| 属性                            | 类型                                      | 默认值          | 说明                                           |
| ----------------------------- | --------------------------------------- | ------------ | -------------------------------------------- |
| `resizable`                   | `boolean \| object`                     | `false`      | 控制图像是否自适应尺寸（详见下方）                            |
| `renderingMode`               | `'original' \| 'template'`              | `'original'` | 设置图像渲染模式，`template` 可使用 `foregroundColor` 着色 |
| `interpolation`               | `'none' \| 'low' \| 'medium' \| 'high'` | `'medium'`   | 设置图像缩放时的插值质量                                 |
| `antialiased`                 | `boolean`                               | `false`      | 是否开启抗锯齿边缘渲染                                  |
| `widgetAccentedRenderingMode` | `WidgetAccentedRenderingMode`           | -            | 控制在 Widget 的强调模式下的图像渲染方式（仅 Widget 有效）        |

***

### `resizable` 属性详细说明

| 类型                            | 含义                          |
| ----------------------------- | --------------------------- |
| `true`                        | 使用默认拉伸模式使图像适应容器大小           |
| `false`                       | 不对图像进行缩放                    |
| `{ capInsets, resizingMode }` | 设置切片边距和缩放模式（用于九宫格图像或复杂缩放需求） |

***

## 示例

### 从本地文件加载 SVG 并作为模板图像渲染

```tsx
<SVG
  filePath="/path/to/local/image.svg"
  resizable
  frame={{ width: 50, height: 50 }}
  renderingMode="template"
  foregroundColor="red"
/>
```

***

### 使用内联 SVG 代码渲染图像

```tsx
<SVG
  code={`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
    <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
  </svg>`}
  frame={{ width: 100, height: 100 }}
/>
```

***

## 注意事项

- `SVG` 图像现在统一以**位图方式渲染**，不再支持 `vectorDrawing` 属性。
- 若希望对图像进行着色，可设置 `renderingMode="template"` 并搭配 `foregroundColor`。
- 所有图像来源字段（`url`、`filePath`、`code`）只能设置一个，不能同时使用。



---
url: /v2/zh/guide/Views/Scroll views/index.md
---

# 可滚动视图

`ScrollView` 组件用于在可滚动区域中显示其内容。当用户执行滚动手势时，可视区域会随之更新。你可以通过 `axes` 属性控制滚动方向，支持垂直、水平或双向滚动。

## 类型定义

```ts
type ScrollViewProps = {
  axes?: AxisSet
  children?: VirtualNode | VirtualNode[] | (VirtualNode | undefined | null)[]
}
```

## 基本说明

- 滚动方向由 `axes` 属性控制。
- 内容通过 `children` 指定，通常使用如 `<VStack>`、`<HStack>` 等布局容器。
- 不支持缩放操作。

## 默认行为

- 默认滚动方向为 **垂直**。
- 滚动指示器根据平台默认行为自动显示，除非通过 modifier 显式设置。

## 示例

```tsx
<ScrollView>
  <VStack>
    {new Array(100).fill('').map((_, index) => (
      <Text>Row {index}</Text>
    ))}
  </VStack>
</ScrollView>
```

***

## ScrollView 修饰符说明

你可以使用以下视图修饰符配置滚动行为：

***

### `scrollIndicator`

控制滚动指示器的显示方式。

#### 类型定义

```ts
scrollIndicator?: ScrollScrollIndicatorVisibility | {
  visibility: ScrollScrollIndicatorVisibility
  axes: AxisSet
}
```

#### `ScrollScrollIndicatorVisibility` 可选值：

- `"automatic"`：遵循系统默认行为。
- `"visible"`：显示指示器，可能会自动隐藏。
- `"hidden"`：隐藏指示器，除非被系统强制显示。
- `"never"`：从不显示指示器。

#### 示例

```tsx
<ScrollView scrollIndicator="never">
  <VStack>{/* 内容 */}</VStack>
</ScrollView>
```

设置特定方向的指示器：

```tsx
<ScrollView
  scrollIndicator={{
    visibility: "hidden",
    axes: "vertical"
  }}
>
  <VStack>{/* 内容 */}</VStack>
</ScrollView>
```

***

### `scrollDisabled`

完全禁用滚动行为。

#### 类型定义

```ts
scrollDisabled?: boolean
```

#### 示例

```tsx
<ScrollView scrollDisabled>
  <Text>该滚动视图已被锁定。</Text>
</ScrollView>
```

***

### `scrollClipDisabled`

控制是否允许内容超出滚动视图边界显示。

#### 类型定义

```ts
scrollClipDisabled?: boolean
```

#### 示例

```tsx
<ScrollView scrollClipDisabled>
  {/* 内容可能会超出滚动区域边界 */}
</ScrollView>
```

***

### `scrollDismissesKeyboard`

指定滚动行为对软件键盘的影响。

#### 类型定义

```ts
scrollDismissesKeyboard?: ScrollDismissesKeyboardMode
```

#### 可选值

- `"automatic"`：根据上下文决定默认行为。
- `"immediately"`：滚动开始时立即关闭键盘。
- `"interactively"`：允许用户拖动关闭键盘。
- `"never"`：滚动不会影响键盘。

#### 示例

```tsx
<ScrollView scrollDismissesKeyboard="interactively">
  {/* 含有输入框的内容 */}
</ScrollView>
```

***

### `defaultScrollAnchor`

设置初始显示的内容锚点，或内容变化时保持该锚点对齐。

#### 类型定义

```ts
defaultScrollAnchor?: KeywordPoint | Point
```

#### `KeywordPoint` 关键词

如 `"top"`、`"bottom"`、`"leading"`、`"trailing"`、`"center"`、`"topLeading"`、`"bottomTrailing"` 等。

#### 示例

```tsx
<ScrollView defaultScrollAnchor="bottom">
  <VStack>
    {/* 新增内容会保持底部对齐 */}
  </VStack>
</ScrollView>
```

***

### `AxisSet`

定义滚动方向。

#### 类型定义

```ts
type AxisSet = 'vertical' | 'horizontal' | 'all'
```

#### 示例

```tsx
<ScrollView axes="horizontal">
  <HStack>{/* 横向滚动内容 */}</HStack>
</ScrollView>
```

***

### `scrollTargetLayout`

用于标记滚动区域中的主要布局容器，便于对齐与滚动控制。

#### 类型定义

```ts
scrollTargetLayout?: boolean
```

#### 示例

```tsx
<ScrollView axes="horizontal">
  <LazyHStack scrollTargetLayout>
    {items.map(item => <Text>{item.title}</Text>)}
  </LazyHStack>
</ScrollView>
```

***

### `scrollTargetBehavior`

定义滚动时如何对齐内容。

#### 类型定义

```ts
scrollTargetBehavior?: ScrollTargetBehavior
```

```ts
type ScrollTargetBehavior =
  | "paging"
  | "viewAligned"
  | "viewAlignedLimitAutomatic"
  | "viewAlignedLimitAlways"
  | "viewAlignedLimitNever"
  | "viewAlignedLimitAlwaysByFew"
  | "viewAlignedLimitAlwaysByOne"
```

#### 模式说明

- `"paging"`：分页滚动，以容器尺寸为单位。
- `"viewAligned"`：滚动时按视图边界对齐。
- `"viewAlignedLimitAutomatic"`：在紧凑横向环境下限制滚动数量，其他情况放开。
- `"viewAlignedLimitAlways"`：始终限制每次滚动的项目数量。
- `"viewAlignedLimitNever"`：不限制滚动范围。
- `"viewAlignedLimitAlwaysByFew"` _(仅 iOS 18.0+)_：每次滚动少量视图。
- `"viewAlignedLimitAlwaysByOne"` _(仅 iOS 18.0+)_：每次滚动一个视图。

#### 描述

用于配置内容滚动对齐策略，适用于横向滚动的列表、分页等场景。

***

### `scrollContentBackground`

指定滚动区域的默认背景是否显示。

#### 类型定义

```ts
scrollContentBackground?: Visibility
```

#### 可选值

- `"automatic"`：根据上下文自动决定是否显示背景。
- `"hidden"`：隐藏默认背景，可实现透明或自定义背景。
- `"visible"`：强制显示默认背景，即使已有自定义背景。

#### 示例

```tsx
<List scrollContentBackground="hidden">
  <Text>这里没有默认背景</Text>
</List>
```

***

## 总结

| 修饰符 / 属性                  | 说明                                      |
| ------------------------- | --------------------------------------- |
| `axes`                    | 设置滚动方向（`vertical`、`horizontal` 或 `all`） |
| `scrollIndicator`         | 控制滚动指示器的显示及滚动方向                         |
| `scrollDisabled`          | 设置为 `true` 时禁用滚动行为                      |
| `scrollClipDisabled`      | 允许内容超出滚动区域边界可见                          |
| `scrollDismissesKeyboard` | 滚动时控制是否关闭软件键盘                           |
| `defaultScrollAnchor`     | 设置初始锚点或内容变化时的锚点                         |
| `scrollTargetLayout`      | 标记布局容器为滚动对齐的目标区域                        |
| `scrollTargetBehavior`    | 设置内容滚动对齐方式（分页、视图对齐等）                    |
| `scrollContentBackground` | 控制是否显示默认背景（透明、自定义背景场景常用）                |



---
url: /v2/zh/guide/Views/Scroll views/index_example.md
---

# 示例

```tsx
import { Color, ForEach, HStack, KeywordPoint, Navigation, NavigationStack, Picker, RoundedRectangle, Script, ScrollView, Text, useState, VStack } from "scripting"

function Example() {
  const colors: Color[] = [
    "systemRed",
    "systemOrange",
    "systemYellow",
    "systemGreen",
    "systemBlue",
    "systemPurple",
    "systemIndigo",
    "systemPink",
  ]
  const [scrollAnchor, setScrollAnchor] = useState<KeywordPoint>("bottom")

  return <NavigationStack>
    <ScrollView
      navigationTitle={"ScrollView"}
      defaultScrollAnchor={scrollAnchor}
      navigationBarTitleDisplayMode={"inline"}
      key={scrollAnchor}
    >
      <VStack
        spacing={16}
        padding
      >
        <Picker
          title={"Default Scroll Anchor"}
          value={scrollAnchor}
          onChanged={setScrollAnchor as any}
          pickerStyle={"menu"}
        >
          <Text tag={"top"}>Top</Text>
          <Text tag={"center"}>Center</Text>
          <Text tag={"bottom"}>Bottom</Text>
        </Picker>

        <ScrollView
          axes={"horizontal"}
          frame={{
            height: 64
          }}
        >
          <HStack spacing={8}>
            <ForEach
              count={15}
              itemBuilder={index =>
                <RoundedRectangle
                  key={index.toString()}
                  fill={"systemIndigo"}
                  cornerRadius={6}
                  frame={{
                    width: 64,
                    height: 64,
                  }}
                  overlay={
                    <Text>{index}</Text>
                  }
                />
              }
            />
          </HStack>
        </ScrollView>

        <ForEach
          count={colors.length}
          itemBuilder={index => {
            const color = colors[index]
            return <RoundedRectangle
              key={color}
              fill={color}
              cornerRadius={16}
              frame={{
                height: 100
              }}
            />
          }}
        />
      </VStack>
    </ScrollView>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()


```



---
url: /v2/zh/guide/Views/ScrollViewReader.md
---

**ScrollViewReader** 组件，用于在脚本中获得对可滚动内容的编程化控制能力，使开发者能够在运行时滚动至任意视图位置，包括列表项、文本节点等。

ScrollViewReader 与 SwiftUI 的行为保持一致：
开发者通过一个回调函数获得一个 `ScrollViewProxy` 实例，并可以在任意时机调用 `scrollTo(id)` 控制滚动视图的位置。

***

# ScrollViewProxy

`ScrollViewProxy` 是提供滚动控制的代理对象，由 `ScrollViewReader` 在渲染期间自动注入。

```ts
interface ScrollViewProxy {
    scrollTo: (id: string | number, anchor?: KeywordPoint | Point) => void;
}
```

## 方法

### scrollTo(id, anchor?)

滚动到某个具有指定 `id` 的元素。
该 `id` 必须在可滚动内容内存在，并通过 `key` 配置。

#### 参数说明

| 参数     | 类型             | 必须       | 说明 |                                         |
| ------ | -------------- | -------- | -- | --------------------------------------- |
| id     | `string`       | `number` | 是  | 要滚动到的目标元素的唯一标识符。通常对应 `<View key="xxx">` |
| anchor | `KeywordPoint` | `Point`  | 否  | 滚动目标在可视区域中的对齐方式。可为字符串关键字或坐标点。           |

### KeywordPoint 类型

属于字符串关键字，常用：

- `'top'`
- `'center'`
- `'bottom'`

### Point 类型

用于精确控制滚动位置：

```ts
type Point = {
  x: number
  y: number
}
```

***

# ScrollViewReader

ScrollViewReader 用于包裹可滚动内容，并提供一个 `scrollViewProxy` 以控制内部滚动。

```ts
type ScrollViewReaderProps = {
    children: (scrollViewProxy: ScrollViewProxy) => VirtualNode
};
declare const ScrollViewReader: FunctionComponent<ScrollViewReaderProps>
```

## Props 说明

| 名称       | 类型                                        | 必须 | 说明                                          |
| -------- | ----------------------------------------- | -- | ------------------------------------------- |
| children | `(proxy: ScrollViewProxy) => VirtualNode` | 是  | 回调函数，将滚动代理传给开发者，并返回 ScrollView、List 等可滚动视图。 |

***

# 使用说明

1. **ScrollViewReader 必须包裹 List、ScrollView 等可滚动组件**。
2. **回调中的 proxy 只在视图构建阶段提供一次**，开发者可利用 `useRef` 保存。
3. 支持在动画中使用，例如 `withAnimation`。
4. 锚点可选，不传则使用默认对齐方式。
5. 所有 ScrollView 内部节点都可以使用 `key` 来作为 `scrollTo` 的目标。

***

# 基础示例

下面是一个完整的使用示例，包括滚动到指定元素以及使用动画的方式。

```tsx
import {
  Button,
  Navigation,
  NavigationStack,
  Script,
  Text,
  List,
  ScrollViewReader,
  ScrollView,
  VStack,
  useRef,
  ScrollViewProxy,
  withAnimation
} from "scripting"

function Item({ index }: { index: number }) {
  return <Text>
    Item - {index}
  </Text>
}

function View() {
  const dismiss = Navigation.useDismiss()
  const proxyRef = useRef<ScrollViewProxy>()

  return <NavigationStack>
    <VStack navigationTitle="ScrollViewReader">

      <ScrollViewReader>
        {(proxy) => {
          // 记录 proxy 实例，供按钮点击时使用
          proxyRef.current = proxy

          return <List>
            {new Array(100).fill(0).map((_, index) =>
              <Item
                key={index}
                index={index}
              />
            )}
            <Text key="bottom">
              Bottom
            </Text>
          </List>
        }}
      </ScrollViewReader>

      <Button
        title="跳转"
        action={() => {
          if (proxyRef.current == null) {
            console.log("no proxy found")
            return
          }

          const index = Math.random() * 100 | 0

          withAnimation(() => {
            proxyRef.current?.scrollTo(index, "bottom")
            // proxyRef.current?.scrollTo("bottom", "bottom")
          })
        }}
      />

    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present(<View />)
  Script.exit()
}

run()
```

***

# 关于 ID（key）匹配的说明

`scrollTo(id)` 依赖于内部节点的 `key` 属性。
以下配置都可作为滚动目标：

```tsx
<Text key="bottom">Bottom</Text>
```

`key` 与 SwiftUI 的 `.id()` 行为保持一致。

***

# 动画支持

ScrollViewReader 支持结合 `withAnimation` 来进行平滑滚动。例如：

```tsx
withAnimation(() => {
  proxy.scrollTo("target", "center")
})
```

在动画块中触发滚动，将获得平滑过渡。

***

# 注意事项

1. **必须在 ScrollViewReader 回调中记录 proxy**，否则外部无法访问。
2. **必须确保目标元素存在并有唯一 id**，否则无法滚到目标位置。
3. **不支持在 ScrollViewReader 外部渲染可滚动组件**。
4. **滚动行为与 SwiftUI 基本一致**，包括 anchor 对齐方式。



---
url: /v2/zh/guide/Views/Search/index.md
---

# 搜索

Scripting 支持与 SwiftUI 类似的搜索功能。你可以为列表等滚动视图添加搜索栏，控制搜索栏的显示位置、状态，监听输入变化，并动态显示搜索建议。

***

## `searchable`

为视图添加搜索栏，并将搜索文本与状态绑定。

### 类型

```ts
searchable?: {
  value: string
  onChanged: (value: string) => void
  placement?: SearchFieldPlacement
  prompt?: string
  presented?: {
    value: boolean
    onChanged: (value: boolean) => void
  }
}
```

### 参数说明

- `value`: 当前搜索输入的文本（受控状态）。
- `onChanged`: 每当用户输入发生变化时调用，传入新的搜索内容。
- `placement`: 控制搜索栏的显示位置（可选）。
- `prompt`: 搜索栏中的提示占位文本（可选）。
- `presented`: 控制搜索栏是否处于激活状态，可以主动打开或关闭搜索界面（可选）。

### 示例

```tsx
function SearchExample() {
  const [query, setQuery] = useState("")
  const [showSearch, setShowSearch] = useState(false)

  return (
    <List
      searchable={{
        value: query,
        onChanged: setQuery,
        placement: "navigationBarDrawer",
        prompt: "搜索项目",
        presented: {
          value: showSearch,
          onChanged: setShowSearch,
        }
      }}
    >
      <Text>当前搜索内容：{query}</Text>
    </List>
  )
}
```

### `SearchFieldPlacement` 可选值

| 值                                       | 描述                           |
| --------------------------------------- | ---------------------------- |
| `'automatic'`                           | 系统自动决定搜索栏位置（默认）。             |
| `'navigationBarDrawer'`                 | 在导航栏下方作为抽屉式显示。               |
| `'navigationBarDrawerAlwaysDisplay'`    | 始终显示抽屉搜索栏。                   |
| `'navigationBarDrawerAutomaticDisplay'` | 根据需要自动显示抽屉搜索栏。               |
| `'toolbar'`                             | 显示在工具栏中。                     |
| `'sidebar'`                             | 显示在侧边栏（适用于 iPad 或 macOS 风格）。 |

***

## `searchSuggestions`

设置搜索建议的内容区域，在用户输入时显示一组建议项。

### 类型

```ts
searchSuggestions?: VirtualNode
```

### 示例

```tsx
const suggestions = useMemo(() => [
  {
    label: "🍎 Apple",
    value: "Apple"
  },
  {
    label: "🍌 Bananer",
    value: "Bananer"
  }
], [])
const filteredSuggestions = useMemo(() => {
  if (!/\S+/.test(query)) {
    return suggestions
  }
  const q = query.toLowerCase()
  return suggestions.filter(s =>
    s.label.toLowerCase().includes(q) ||
    s.value.toLowerCase().includes(q))
}, [query, suggestions])

<List
  searchable={{
    value: query,
    onChanged: setQuery
  }}
  searchSuggestions={
    <>
      {filteredSuggestions.map(s =>
        <Text
          searchCompletion={s.value}
        >{s.label}</Text>
      )}
    </>
  }
/>
```

***

## `searchSuggestionsVisibility`

控制搜索建议的显示位置和是否可见。

### 类型

```ts
searchSuggestionsVisibility?: {
  visibility: 'visible' | 'hidden'
  placements: SearchSuggestionsPlacementSet
}
```

### `SearchSuggestionsPlacementSet` 可选值

| 值           | 描述                |
| ----------- | ----------------- |
| `'content'` | 在主内容区域中显示建议项。     |
| `'menu'`    | 在弹出菜单或下拉列表中显示建议项。 |
| `'all'`     | 同时适用于所有可用位置。      |

### 示例

```tsx
<List
  searchSuggestionsVisibility={{
    visibility: 'visible',
    placements: 'menu'
  }}
/>
```

***

## `searchCompletion`

将某个视图（如 `<Text>`）标记为可点击的搜索建议项，并指定点击后填入搜索框的值。

### 类型

```ts
searchCompletion?: string
```

### 示例

```tsx
<Text searchCompletion="Mango">🥭 芒果</Text>
```

当用户点击该建议项后，搜索栏将自动填入 `"Mango"`。

***

## 小结

| 修饰符                           | 功能说明               |
| ----------------------------- | ------------------ |
| `searchable`                  | 添加搜索栏，绑定搜索状态与行为。   |
| `searchSuggestions`           | 提供搜索建议项列表。         |
| `searchSuggestionsVisibility` | 控制建议项的显示位置和是否可见。   |
| `searchCompletion`            | 设置建议项点击后自动填入搜索栏的值。 |



---
url: /v2/zh/guide/Views/Search/index_example.md
---

# 示例

```tsx
import { List, Navigation, NavigationStack, Script, Text, useMemo, useState } from "scripting"

function Example() {
  const [searchText, setSearchText] = useState("")
  const languages = useMemo(() => [
    "Java",
    "Objective-C",
    "Swift",
    "Python",
    "JavaScript",
    "C++",
    "Ruby",
    "Lua"
  ], [])

  const filteredLanguages = useMemo(() => {
    if (searchText.length === 0) {
      return languages
    }

    const text = searchText.toLowerCase()

    return languages.filter(language =>
      language.toLowerCase().includes(text)
    )
  }, [searchText, languages])

  return <NavigationStack>
    <List
      navigationTitle={"Searchable List"}
      navigationBarTitleDisplayMode={"inline"}
      searchable={{
        value: searchText,
        onChanged: setSearchText,
      }}
    >
      {filteredLanguages.map(language =>
        <Text>{language}</Text>
      )}
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Shapes/index.md
---

# 形状

Scripting 提供了一套形状组件，用于绘制可缩放的矢量图形元素，包括矩形、圆形、椭圆、胶囊形、圆角矩形等。这些图形支持填充、描边、裁剪路径和尺寸控制，可广泛应用于信息展示、装饰背景、自定义进度视图等界面场景。

***

## 通用属性：`ShapeProps`

所有形状组件均支持以下属性，用于控制外观：

```ts
type ShapeProps = {
  trim?: {
    from: number
    to: number
  }
  fill?: ShapeStyle | DynamicShapeStyle
  stroke?: ShapeStyle | DynamicShapeStyle | {
    shapeStyle: ShapeStyle | DynamicShapeStyle
    strokeStyle: StrokeStyle
  }
  strokeLineWidth?: number // 已废弃
}
```

### 属性说明

| 属性名               | 类型                                 | 说明                                             |
| ----------------- | ---------------------------------- | ---------------------------------------------- |
| `trim`            | `{ from: number; to: number }`     | 裁剪图形路径，仅绘制部分路径。`from` 与 `to` 为 0～1 的小数。        |
| `fill`            | `ShapeStyle` 或 `DynamicShapeStyle` | 设置填充颜色或渐变。                                     |
| `stroke`          | 同 `fill`，或带 `strokeStyle` 的对象      | 设置描边颜色或渐变，支持自定义描边样式。                           |
| `strokeLineWidth` | `number`（已废弃）                      | 设置描边宽度。建议使用 `stroke.strokeStyle.lineWidth` 替代。 |

***

## 描边样式：`StrokeStyle`

你可以通过 `strokeStyle` 对象来自定义描边的线条细节：

```ts
type StrokeStyle = {
  lineWidth?: number
  lineCap?: 'butt' | 'round' | 'square'
  lineJoin?: 'bevel' | 'miter' | 'round'
  mitterLimit?: number
  dash?: number[]
  dashPhase?: number
}
```

### 描边样式参数说明

| 参数名           | 说明                                                   |
| ------------- | ---------------------------------------------------- |
| `lineWidth`   | 描边线条的宽度（单位：pt）。                                      |
| `lineCap`     | 线条端点样式，可选 `"butt"`（平头）、`"round"`（圆头）、`"square"`（方头）。 |
| `lineJoin`    | 拐角连接样式，可选 `"miter"`、`"round"`、`"bevel"`。             |
| `mitterLimit` | miter 样式拐角的最小限制（用于防止尖角过长）。                           |
| `dash`        | 虚线样式数组，定义实线和空白的交替长度。                                 |
| `dashPhase`   | 从虚线图案中的哪个位置开始绘制（偏移量）。                                |

***

## 支持的形状组件

### `Rectangle` 矩形

```tsx
<Rectangle
  fill="orange"
  stroke={{
    shapeStyle: "red",
    strokeStyle: {
      lineWidth: 3,
      lineJoin: "round"
    }
  }}
  frame={{ width: 100, height: 100 }}
/>
```

***

### `RoundedRectangle` 圆角矩形

```tsx
<RoundedRectangle
  fill="blue"
  cornerRadius={16}
  frame={{ width: 100, height: 100 }}
/>
```

支持统一圆角半径或尺寸：

```ts
type RoundedRectangleProps = ShapeProps & (
  | { cornerRadius: number }
  | { cornerSize: { width: number, height: number } }
) & {
  style?: RoundedCornerStyle // 默认为 continuous
}
```

***

### `UnevenRoundedRectangle` 不规则圆角矩形

支持为每个角设置不同的圆角半径：

```tsx
<UnevenRoundedRectangle
  fill="brown"
  topLeadingRadius={16}
  topTrailingRadius={0}
  bottomLeadingRadius={0}
  bottomTrailingRadius={16}
  frame={{ width: 100, height: 50 }}
/>
```

***

### `Circle` 圆形

```tsx
<Circle
  stroke="purple"
  strokeLineWidth={4}
  frame={{ width: 100, height: 100 }}
/>
```

***

### `Capsule` 胶囊形

```tsx
<Capsule
  fill="systemIndigo"
  frame={{ width: 100, height: 40 }}
/>
```

***

### `Ellipse` 椭圆

```tsx
<Ellipse
  fill="green"
  frame={{ width: 40, height: 100 }}
/>
```

***

## 使用建议

- 使用 `fill` 和 `stroke` 可分别设置填充与描边样式，支持纯色与渐变；
- 若需自定义描边样式（如虚线、线头、线角），应使用 `stroke.strokeStyle`；
- `strokeLineWidth` 已废弃，建议统一使用 `strokeStyle.lineWidth`；
- `trim` 属性可用于实现动画绘图、进度展示等场景；
- 所有形状组件均支持 `frame`、`padding`、`background` 等布局修饰符，适合与其他组件组合使用。



---
url: /v2/zh/guide/Views/Shapes/index_example.md
---

# 示例

```tsx
import { Capsule, Circle, Ellipse, List, Navigation, NavigationStack, Rectangle, RoundedRectangle, Script, Section, Text, UnevenRoundedRectangle, } from "scripting"

function Example() {

  return <NavigationStack>
    <List
      navigationTitle={"Shapes"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <Section
        header={
          <Text>Rectangle</Text>
        }
      >
        <Rectangle
          fill={"orange"}
          stroke={{
            shapeStyle: "red",
            strokeStyle: {
              lineWidth: 3,
            }
          }}
          frame={{
            width: 100,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>RoundedRectangle</Text>
        }
      >
        <RoundedRectangle
          fill={"blue"}
          cornerRadius={16}
          frame={{
            width: 100,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>Circle</Text>
        }
      >
        <Circle
          stroke={{
            shapeStyle: "purple",
            strokeStyle: {
              lineWidth: 4,
            }
          }}
          frame={{
            width: 100,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>Capsule</Text>
        }
      >
        <Capsule
          fill={"systemIndigo"}
          frame={{
            width: 100,
            height: 40,
          }}
        />
      </Section>

      <Section
        header={
          <Text>Ellipse</Text>
        }
      >
        <Ellipse
          fill={"green"}
          frame={{
            width: 40,
            height: 100,
          }}
        />
      </Section>

      <Section
        header={
          <Text>UnevenRoundedRectangle</Text>
        }
      >
        <UnevenRoundedRectangle
          fill={"brown"}
          topLeadingRadius={16}
          topTrailingRadius={0}
          bottomLeadingRadius={0}
          bottomTrailingRadius={16}
          frame={{
            width: 100,
            height: 50,
          }}
        />
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Text input/Keyboard.md
---

# 键盘

`Keyboard` API 与 `useKeyboardVisible` 钩子一起，可以在 Scripting 应用中与软件键盘交互。您可以检查键盘是否可见、隐藏键盘、监听键盘的可见性变化，并在函数组件中以响应式方式访问当前可见状态。

***

## 概述

`Keyboard` API 的功能包括：

1. 检查键盘当前是否可见。
2. 以编程方式隐藏键盘。
3. 监听键盘可见性变化。
4. 使用 `useKeyboardVisible` 钩子以响应式方式跟踪键盘的可见性。

***

## 模块：`Keyboard`

### 属性

- **`visible: boolean`**\
  一个只读属性，指示键盘当前是否可见。
  - `true`：键盘可见。
  - `false`：键盘隐藏。

***

### 方法

#### `Keyboard.hide(): void`

隐藏当前可见的键盘。

- **用法**：
  - 如果键盘已隐藏，此方法不会执行任何操作。
  - 通常用于以编程方式关闭键盘。

***

#### `Keyboard.addVisibilityListener(listener: (visible: boolean) => void): void`

添加一个监听器函数，当键盘的可见性发生变化时触发。

- **参数**：
  - `listener: (visible: boolean) => void`：一个回调函数，接收 `visible` 参数：
    - `true`：键盘变为可见。
    - `false`：键盘变为隐藏。

- **用法**：
  - 使用此方法在键盘出现或消失时执行自定义逻辑。

***

#### `Keyboard.removeVisibilityListener(listener: (visible: boolean) => void): void`

移除之前添加的可见性监听器。

- **参数**：
  - `listener: (visible: boolean) => void`：要移除的回调函数。必须与通过 `addVisibilityListener` 添加的函数一致。

***

## 钩子：`useKeyboardVisible`

### `useKeyboardVisible(): boolean`

一个钩子，用于访问当前键盘的可见状态。该钩子提供了一种响应式方式来跟踪键盘是否可见。

- **返回值**：
  - `true`：键盘当前可见。
  - `false`：键盘当前隐藏。

- **用法**：
  - 此钩子非常适合函数组件，根据键盘的可见状态有条件地渲染 UI 元素或执行逻辑。

***

## 示例用法

### 使用 `Keyboard.visible` 检查键盘可见性

```ts
if (Keyboard.visible) {
  console.log("键盘可见。")
} else {
  console.log("键盘隐藏。")
}
```

***

### 隐藏键盘

```ts
Keyboard.hide()
console.log("键盘已通过编程方式隐藏。")
```

***

### 添加和移除可见性监听器

```ts
// 定义监听器
function handleKeyboardVisibility(visible: boolean) {
  if (visible) {
    console.log("键盘现在可见。")
  } else {
    console.log("键盘现在隐藏。")
  }
}

// 添加监听器
Keyboard.addVisibilityListener(handleKeyboardVisibility)

// 移除监听器
Keyboard.removeVisibilityListener(handleKeyboardVisibility)
console.log("键盘可见性监听器已移除。")
```

***

### 在函数组件中使用 `useKeyboardVisible`

```tsx
import { useKeyboardVisible, VStack, Text } from 'scripting'

function KeyboardStatus() {
  const isKeyboardVisible = useKeyboardVisible()

  return (
    <VStack>
      {isKeyboardVisible ? (
        <Text>The keyboard is currently visible.</Text>
      ) : (
        <Text>The keyboard is currently hidden.</Text>
      )}
    </VStack>
  )
}
```

***

## 注意事项

1. **响应式状态与钩子**：在函数组件中使用 `useKeyboardVisible` 钩子，以简洁和响应式的方式跟踪键盘的可见性。
2. **静态状态与 `Keyboard.visible`**：使用 `Keyboard.visible` 属性进行快速的非响应式检查。
3. **事件监听器**：根据需要使用 `addVisibilityListener` 添加多个可见性监听器，并确保在不需要时移除它们以防止内存泄漏。
4. **以编程方式关闭键盘**：`Keyboard.hide()` 方法在提交表单或点击输入框外部以关闭键盘等场景中非常有用。



---
url: /v2/zh/guide/Views/Text input/SecureField/index.md
---

# 安全文本输入框（SecureField）

`SecureField` 是 Scripting 提供的安全文本输入框组件，用于输入密码或其他敏感信息。用户输入内容会被自动隐藏，不以明文显示，其行为与 SwiftUI 中的 `SecureField` 一致。

该组件适用于登录、注册、PIN 验证等需要保护用户隐私的场景。

***

## 属性定义

```ts
type SecureFieldProps = (
  | { title: string }
  | { label: VirtualNode }
) & {
  value: string
  onChanged: (value: string) => void
  prompt?: string
  autofocus?: boolean
  onFocus?: () => void
  onBlur?: () => void
}
```

### 属性说明

| 属性          | 类型                        | 说明                           |
| ----------- | ------------------------- | ---------------------------- |
| `title`     | `string`                  | 输入框的文本标签（与 `label` 二选一）。     |
| `label`     | `VirtualNode`             | 自定义标签视图节点（与 `title` 二选一）。    |
| `value`     | `string`                  | 当前输入的内容，需使用状态绑定更新。           |
| `onChanged` | `(value: string) => void` | 当输入内容发生变化时触发的回调函数。           |
| `prompt`    | `string`（可选）              | 输入框为空时显示的提示占位文字。             |
| `autofocus` | `boolean`（可选）             | 是否在渲染后自动聚焦该输入框，默认值为 `false`。 |
| `onFocus`   | `() => void`（可选）          | 输入框获取焦点时触发的回调。               |
| `onBlur`    | `() => void`（可选）          | 输入框失去焦点时触发的回调。               |

***

## 示例

```tsx
import { useState, VStack, SecureField } from "scripting"

function LoginForm() {
  const [password, setPassword] = useState("")

  return <VStack padding>
    <SecureField
      title="密码"
      value={password}
      onChanged={setPassword}
      prompt="请输入密码"
    />
  </VStack>
}
```

### 行为说明

- 输入内容将以安全方式隐藏，不会以明文显示；
- 可通过 `prompt` 提示用户输入；
- 绑定的状态变量（如 `password`）可用于后续认证逻辑。

***

## 注意事项

- `title` 与 `label` 必须二选一使用；
- 除了内容会被隐藏，其他行为与 `TextField` 基本一致；
- 支持自动聚焦和焦点事件监听，可用于配合用户交互逻辑；
- 非常适用于登录、注册、设置等需要密码输入的界面。



---
url: /v2/zh/guide/Views/Text input/SecureField/index_example.md
---

# 示例

```tsx
import { useState, SecureField, VStack, Text, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [password, setPassword] = useState('')

  return <NavigationStack>
    <VStack
      navigationTitle={"SecureField"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <SecureField
        title={"Password"}
        value={password}
        onChanged={setPassword}
        prompt={"Enter password"}
      />
      <Text>Password: {password}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/Text input/TextField/index.md
---

# 文本输入框（TextField）

Scripting 提供了与 SwiftUI 中 `TextField` 相似的文本输入框组件，支持声明式绑定、提示文字、焦点控制、滚动方向和行数限制等功能。

`TextField` 适用于用户信息填写、搜索、消息输入等各种输入场景，可灵活设置为单行或多行滚动输入。

***

## 属性定义

```ts
type TextFieldProps = (
  | { title: string }
  | { label: VirtualNode }
) & {
  value: string
  onChanged: (value: string) => void
  prompt?: string
  axis?: Axis
  autofocus?: boolean
  onFocus?: () => void
  onBlur?: () => void
}
```

### 属性说明

| 属性          | 类型                                 | 说明                                 |
| ----------- | ---------------------------------- | ---------------------------------- |
| `title`     | `string`                           | 作为输入框标签显示的标题字符串（与 `label` 二选一）。    |
| `label`     | `VirtualNode`                      | 自定义标签节点（与 `title` 二选一）。            |
| `value`     | `string`                           | 当前输入框内容，需使用状态绑定更新。                 |
| `onChanged` | `(value: string) => void`          | 输入内容变更时的回调函数。                      |
| `prompt`    | `string`（可选）                       | 输入框中的提示文本，占位提示用途。                  |
| `axis`      | `"horizontal"` \| `"vertical"`（可选） | 当内容溢出时的滚动方向。多行输入需设置为 `"vertical"`。 |
| `autofocus` | `boolean`（可选）                      | 是否自动聚焦该输入框。默认为 `false`。            |
| `onFocus`   | `() => void`（可选）                   | 输入框获得焦点时触发的回调。                     |
| `onBlur`    | `() => void`（可选）                   | 输入框失去焦点时触发的回调。                     |

***

## 示例一：可垂直滚动的多行输入框

```tsx
import { useState, VStack, TextField } from "scripting"

function ScrollableTextInput() {
  const [text, setText] = useState("")

  return <VStack padding>
    <TextField
      title="留言"
      value={text}
      onChanged={setText}
      prompt="请输入留言"
      axis="vertical"
      lineLimit={{ min: 3, max: 8 }}
    />
  </VStack>
}
```

### 行为说明：

- 输入框会自动扩展至 3～8 行的高度；
- 超过 8 行后内容将支持垂直滚动；
- 输入为空时显示 `prompt` 占位提示文字。

***

## 示例二：基础的单行输入框

```tsx
import { useState, VStack, TextField, Text } from "scripting"

function UsernameInput() {
  const [username, setUsername] = useState("")

  return <VStack padding>
    <TextField
      title="用户名"
      value={username}
      onChanged={setUsername}
      prompt="请输入用户名"
    />
    <Text>当前用户名：{username}</Text>
  </VStack>
}
```

***

## 使用说明

- `title` 和 `label` 必须二选一，不可同时设置；
- 设置 `axis="vertical"` 并结合 `lineLimit` 可启用多行输入及滚动行为；
- 可使用 `autofocus`、`onFocus`、`onBlur` 管理输入框的焦点交互；
- 搭配 `useState` 可实现实时响应的表单输入功能。



---
url: /v2/zh/guide/Views/Text input/TextField/index_example.md
---

# 示例

```tsx
import { useState, TextField, VStack, Text, NavigationStack, Navigation, Script } from "scripting"

function Example() {
  const [username, setUsername] = useState('')

  return <NavigationStack>
    <VStack
      navigationTitle={"TextField"}
    >
      <TextField
        title={"Username"}
        value={username}
        onChanged={setUsername}
        prompt={"Enter username"}
      />
      <Text>Username: {username}</Text>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()
```



---
url: /v2/zh/guide/Views/Time-based label views.md
---

# 时间标签视图

Scripting 提供了一组便捷的时间标签组件，封装了 SwiftUI 中 `Text` 的时间样式。这些组件支持在小组件和视图中显示实时更新的日期与时间格式，适用于加载动态数据、显示相对时间、计时器等多种应用场景。

***

## `DateLabel`

用于以不同格式展示一个时间戳。即使组件未运行，也可在小组件中显示持续更新的时间相关信息。

### 属性定义

```ts
type DateLabelProps = {
  timestamp: number
  style: 'date' | 'time' | 'timer' | 'relative' | 'offset'
}
```

- `timestamp`: 要显示的时间点，单位为毫秒（UNIX 时间戳）。

- `style`: 显示样式，可选值包括:
  - `"date"`: 以日期形式显示，例如 `"June 3, 2019"`
  - `"time"`: 仅显示时间，例如 `"11:23PM"`
  - `"timer"`: 以计时器形式实时更新，例如 `"2:32"`、`"36:59:01"`
  - `"relative"`: 以相对当前时间的形式显示，例如 `"2 hours, 23 minutes"`
  - `"offset"`: 显示相对当前时间的偏移，例如 `+2 hours`、`-3 months`

### 示例

```tsx
<DateLabel
  timestamp={Date.now()}
  style="date"
/>

<DateLabel
  timestamp={Date.now()}
  style="relative"
/>
```

***

## `DateRangeLabel`

用于显示两个时间点之间的本地化时间范围。

### 属性定义

```ts
type DateRangeLabelProps = {
  from: number
  to: number
}
```

| 属性     | 说明           |
| ------ | ------------ |
| `from` | 起始时间戳，单位为毫秒。 |
| `to`   | 结束时间戳，单位为毫秒。 |

### 示例

```tsx
<DateRangeLabel
  from={Date.now()}
  to={Date.now() + 1000 * 60}
/>
```

***

## `DateIntervalLabel`

用于显示两个时间点之间的时间区间，常用于表示日程或事件的开始与结束时间。

### 属性定义

```ts
type DateIntervalLabelProps = {
  from: number
  to: number
}
```

### 示例

```tsx
let fromDate = new Date()
fromDate.setHours(9)
fromDate.setMinutes(30)

let toDate = new Date()
toDate.setHours(15)
toDate.setMinutes(30)

<DateIntervalLabel
  from={fromDate.getTime()}
  to={toDate.getTime()}
/>
```

> 输出示例：`9:30 AM – 3:30 PM`

***

## `TimerIntervalLabel`

用于在指定的时间区间内显示一个实时运行的计时器，可设置是否倒计时、是否在特定时间暂停等。

### 属性定义

```ts
type TimerIntervalLabelProps = {
  from: number
  to: number
  pauseTime?: number
  countsDown?: boolean
  showsHours?: boolean
}
```

| 属性           | 说明                                      |
| ------------ | --------------------------------------- |
| `from`       | 计时器开始的时间戳（毫秒）。                          |
| `to`         | 计时器结束的时间戳（毫秒）。                          |
| `pauseTime`  | （可选）计时器在该时间点暂停。默认为 `undefined`，表示不暂停。   |
| `countsDown` | （可选）是否倒计时。默认为 `true`。                   |
| `showsHours` | （可选）当剩余时间超过 60 分钟时，是否显示小时部分。默认为 `true`。 |

### 示例

```tsx
<TimerIntervalLabel
  from={Date.now()}
  to={Date.now() + 1000 * 60 * 12}
  pauseTime={Date.now() + 1000 * 60 * 10}
/>
```

该示例表示一个从 12 分钟开始倒计时的计时器，在倒计至 10 分钟时暂停。



---
url: /v2/zh/guide/Views/Toolbars/index.md
---

# 工具栏

`toolbar` 属性用于为导航栏、底部工具栏或键盘附加区域添加自定义操作项。该机制参考了 SwiftUI 中的工具栏 API，允许开发者以声明式方式将按钮、控制组等元素精确地放置在界面的特定位置。

这套系统适用于提供主操作、上下文操作或增强文本输入时的交互体验。

***

## 定义

```ts
toolbar?: ToolBarProps
```

### ToolBarProps 类型定义

```ts
type ToolBarProps = {
  bottomBar?: VirtualNode | VirtualNode[]
  cancellationAction?: VirtualNode | VirtualNode[]
  confirmationAction?: VirtualNode | VirtualNode[]
  destructiveAction?: VirtualNode | VirtualNode[]
  keyboard?: VirtualNode | VirtualNode[]
  navigation?: VirtualNode | VirtualNode[]
  primaryAction?: VirtualNode | VirtualNode[]
  principal?: VirtualNode | VirtualNode[]
  topBarLeading?: VirtualNode | VirtualNode[]
  topBarTrailing?: VirtualNode | VirtualNode[]
}
```

***

## 放置位置说明

`ToolBarProps` 的每个字段都对应一个界面区域，可传入单个或多个 `VirtualNode` 元素进行展示。

- **`automatic`**（隐式）：由系统自动判断最佳放置位置（未在类型中显式声明）。
- **`bottomBar`**：放置于底部工具栏。
- **`cancellationAction`**：表示“取消”操作，通常用于模态界面中。
- **`confirmationAction`**：表示“确认”操作，通常用于模态界面中。
- **`destructiveAction`**：表示破坏性操作，系统可能使用红色等强调样式。
- **`keyboard`**：当键盘弹出时显示在键盘附加区域。
- **`navigation`**：用于导航行为（如返回或关闭）。
- **`primaryAction`**：表示当前上下文中的主要操作。
- **`principal`**：放置在导航栏中间区域。
- **`topBarLeading`**：放置于导航栏的前导位置（通常是左侧）。
- **`topBarTrailing`**：放置于导航栏的尾部位置（通常是右侧）。

***

## 示例

```tsx
<VStack
  navigationTitle={"Toolbars"}
  navigationBarTitleDisplayMode={"inline"}
  toolbar={{
    topBarTrailing: [
      <Button
        title={"选择"}
        action={() => {}}
      />,
      <ControlGroup
        label={
          <Button
            title={"添加"}
            systemImage={"plus"}
            action={() => {}}
          />
        }
        controlGroupStyle={"palette"}
      >
        <Button
          title={"新建"}
          systemImage={"plus"}
          action={() => {}}
        />
        <Button
          title={"导入"}
          systemImage={"square.and.arrow.down"}
          action={() => {}}
        />
      </ControlGroup>
    ],
    bottomBar: [
      <Button
        title={"新建子分类"}
        action={() => {}}
      />,
      <Button
        title={"添加分类"}
        action={() => {}}
      />
    ],
    keyboard: <HStack padding>
      <Spacer />
      <Button
        title={"完成"}
        action={() => {
          Keyboard.hide()
        }}
      />
    </HStack>
  }}
>
  <TextField
    title={"文本输入框"}
    value={text}
    onChanged={setText}
    textFieldStyle={"roundedBorder"}
    prompt={"点击输入框以显示键盘工具栏"}
  />
</VStack>
```

此示例展示了：

- 在顶部导航栏右侧添加了一个“选择”按钮和一个带“新建”“导入”按钮的控制组。
- 在底部工具栏添加了两个分类相关操作按钮。
- 在键盘区域右侧添加了一个“完成”按钮，可点击关闭键盘。

***

## 注意事项

- 所有工具栏项支持响应状态变化，UI 会自动刷新。
- `keyboard` 区域的内容仅在输入框聚焦、键盘弹出时显示。
- 推荐使用 `ControlGroup` 来组织功能相关的按钮，提升可读性和操作一致性。



---
url: /v2/zh/guide/Views/Toolbars/index_example.md
---

# 示例

```tsx
import { Button, ControlGroup, HStack, Navigation, NavigationStack, Script, Spacer, TextField, useState, VStack } from "scripting"

function Example() {
  const [text, setText] = useState("")

  return <NavigationStack>
    <VStack
      navigationTitle={"Toolbars"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        topBarTrailing: [
          <Button
            title={"Select"}
            action={() => { }}
          />,
          <ControlGroup
            label={
              <Button
                title={"Add"}
                systemImage={"plus"}
                action={() => { }}
              />
            }
            controlGroupStyle={"palette"}
          >
            <Button
              title={"New"}
              systemImage={"plus"}
              action={() => { }}
            />
            <Button
              title={"Import"}
              systemImage={"square.and.arrow.down"}
              action={() => { }}
            />
          </ControlGroup>
        ],
        bottomBar: [
          <Button
            title={"New Sub Category"}
            action={() => { }}
          />,
          <Button
            title={"Add category"}
            action={() => { }}
          />
        ],
        keyboard: <HStack
          padding
        >
          <Spacer />
          <Button
            title={"Done"}
            action={() => {
              Keyboard.hide()
            }}
          />
        </HStack>
      }}
      padding
    >
      <TextField
        title={"TextField"}
        value={text}
        onChanged={setText}
        textFieldStyle={"roundedBorder"}
        prompt={"Focus to show the keyboard toolbar"}
      />
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/VideoPreviewView.md
---

# 视频预览视图（VideoPreviewView）

`VideoPreviewView` 用于实时展示 `VideoRecorder` 当前相机会话的预览画面（camera preview）。
它是 UI 层组件，不负责录制控制逻辑；录制的准备、开始、暂停、恢复与停止由 `VideoRecorder` 负责。

`VideoPreviewView` 的核心职责是：将录制器内部的预览输出渲染到界面中，并支持通过通用 View props（如 `frame`、`aspectRatio` 等）进行布局。

***

## 组件定义

```ts
type VideoPreviewViewProps = {
  recorder: VideoRecorder
}

declare const VideoPreviewView: FunctionComponent<VideoPreviewViewProps>
```

***

## Props 说明

### recorder

```ts
recorder: VideoRecorder
```

绑定的 `VideoRecorder` 实例。`VideoPreviewView` 会从该实例获取预览画面来源。

#### 行为约定

- 当 `recorder.prepare()` 成功后，预览画面可用并开始更新。
- 当 `recorder.dispose()` 被调用后，预览画面停止并释放底层资源。
- `VideoPreviewView` 不会自动调用 `prepare()` 或自动开始录制。

***

## 与 VideoRecorder 状态的关系

`VideoPreviewView` 的显示效果通常与 `VideoRecorder.state` 对应如下（具体表现可能受系统行为影响）：

| Recorder 状态 | 预览表现           |
| ----------- | -------------- |
| `idle`      | 尚未准备，可能为空画面    |
| `preparing` | 正在准备中，画面可能尚不可用 |
| `ready`     | 预览可用           |
| `recording` | 正常实时预览         |
| `paused`    | 通常停留在暂停时的最后一帧  |
| `finishing` | 停止更新或逐步停止      |
| `finished`  | 不再更新           |
| `failed`    | 不可用            |

***

## 推荐用法与生命周期管理

建议将 `VideoRecorder` 作为页面级对象创建，并在页面卸载时调用 `dispose()` 释放资源。
同时，使用 `onStateChanged` 监听状态，以驱动 UI 文案、按钮可用性、错误提示等。

要点：

- `VideoRecorder` 建议通过 `useMemo` 创建，避免每次渲染重复构造。
- 在 `useEffect` 中绑定 `onStateChanged`，并在 cleanup 中调用 `dispose()`。
- 录制前必须 `await recorder.prepare()`。

***

## 完整示例

```tsx
function View() {
  // Access dismiss function.
  const dismiss = Navigation.useDismiss()
  const recorder = useMemo(() => {
    return new VideoRecorder({
      camera: {
        position: "front",
      },
      frameRate: 30,
      audioEnabled: true,
      orientation: "portrait",
      sessionPreset: "hd1280x720",
      videoCodec: "hevc"
    })
  }, [])
  const [state, setState] = useState<VideoRecorderState>("idle")

  useEffect(() => {
    recorder.onStateChanged = (state, details) => {
      setState(state)

      if (state === "failed") {
        Dialog.alert(details!)
      }
    }

    return () => {
      recorder.dispose()
    }
  }, [])

  return <NavigationStack>
    <List
      navigationTitle="Page Title"
      navigationBarTitleDisplayMode="inline"
      toolbar={{
        topBarLeading: <Button
          title="Done"
          action={dismiss}
        />
      }}
    >
      <Text>State: {state}</Text>

      <Button
        title="Start"
        action={async () => {
          await recorder.prepare()
          recorder.startRecording(
            Path.join(
              FileManager.documentsDirectory,
              "test.mov"
            )
          )
        }}
      />

      <Button
        title="Pause"
        action={() => {
          recorder.pauseRecording()
        }}
      />

      <Button
        title="Resume"
        action={() => {
          recorder.resumeRecording()
        }}
      />

      <Button
        title="Stop"
        action={async () => {
          await recorder.stopRecording()
        }}
      />

      <VideoPreviewView
        recorder={recorder}
        frame={{
          width: 300
        }}
        aspectRatio={{
          value: 3 / 4,
          contentMode: "fill"
        }}
      />
    </List>
  </NavigationStack>
}
```

***

## 布局与渲染建议

### 使用 frame 控制尺寸

`VideoPreviewView` 支持通过通用的 `frame` 属性约束宽高。例如：

- 仅指定 `width`：配合 `aspectRatio` 确定最终高度
- 指定 `width` + `height`：强制固定大小（可能导致裁剪或拉伸，取决于 aspect ratio 与 content mode）

### 使用 aspectRatio 控制比例与填充策略

示例：

```tsx
<VideoPreviewView
  recorder={recorder}
  aspectRatio={{ value: 3 / 4, contentMode: "fill" }}
/>
```

- `value`：宽高比
- `contentMode: "fill"`：按比例填充并裁剪
- 若你希望完整显示画面且允许留边，可使用 `contentMode: "fit"`（如果你们的通用 props 支持该值）

***

## 常见注意事项

### 必须 prepare 才能稳定显示预览

`VideoPreviewView` 绑定 `recorder` 并不意味着会自动启动会话。若未 `prepare()`：

- 预览可能为空
- 或短时间内不可用
- 不建议依赖隐式行为

最佳实践：在 Start 按钮中 `await recorder.prepare()` 后再 `startRecording()`，如示例所示。

### 释放资源

- 页面关闭或不再需要预览时，务必调用 `recorder.dispose()`。
- 建议使用 `useEffect` cleanup 释放，避免相机占用导致后续页面无法打开摄像头或耗电。

### 错误处理

当 `state === "failed"` 时，建议：

- 立即提示 `details`（如示例 `Dialog.alert(details!)`）
- 同时在 UI 上禁用录制按钮，或提供重试逻辑（例如 `await recorder.reset()` 后再 `prepare()`）

***

## 组件职责边界

- `VideoRecorder`：负责录制控制与状态机（prepare/start/pause/resume/stop/reset/dispose）
- `VideoPreviewView`：负责画面显示与 UI 布局（通过 `frame` / `aspectRatio` 等通用属性）



---
url: /v2/zh/guide/Views/View groupings/ControlGroup.md
---

# 控件组

```tsx
import { Button, ControlGroup, ControlGroupStyle, Label, List, Navigation, NavigationStack, Picker, Script, Text, useMemo, useState } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [style, setStyle] = useState<ControlGroupStyle>("palette")
  const styles = useMemo<ControlGroupStyle[]>(() => [
    'automatic',
    'compactMenu',
    'menu',
    'navigation',
    'palette'
  ], [])

  return <NavigationStack>
    <List
      navigationTitle={"ControlGroup"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />,
        confirmationAction: [
          <ControlGroup
            label={
              <Label
                title={"Plus"}
                systemImage={"plus"}
              />
            }
            controlGroupStyle={style}
          >
            <Button
              title={"Edit"}
              systemImage={"pencil"}
              action={() => { }}
            />
            <Button
              title={"Delete"}
              systemImage={"trash"}
              role={"destructive"}
              action={() => { }}
            />
          </ControlGroup>
        ]
      }}
    >
      <Picker
        title={"Control Group Style"}
        value={style}
        onChanged={setStyle as any}
      >
        {styles.map(style =>
          <Text tag={style}>{style}</Text>
        )}
      </Picker>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/View groupings/ForEach/index.md
---

`ForEach` 是 Scripting 中用于渲染可变数量子视图的组件，用于构建动态列表、可编辑列表，以及支持系统级的删除与移动行为。其设计参考 SwiftUI 的 `ForEach`，并与 Scripting 的 `Observable` 状态管理系统深度集成。

组件支持两种模式：

1. **旧版模式（已不推荐使用）**：`count + itemBuilder`
2. **推荐的现代模式**：`data: Observable<T[]> + builder`

***

# 1. 类型定义

## ForEachDeprecatedProps（已不推荐）

```ts
type ForEachDeprecatedProps = {
  count: number;
  itemBuilder: (index: number) => VirtualNode;
  onDelete?: (indices: number[]) => void;
  onMove?: (indices: number[], newOffset: number) => void;
};
```

### 参数说明

#### count: number

要渲染的元素数量，`itemBuilder` 将从 0 到 `count - 1` 依次构建每个子视图。

#### itemBuilder(index)

基于索引构建一个 `VirtualNode`。

#### onDelete(indices)

注册删除行为。
当 ForEach 放置在 `List` 中时，如果提供 `onDelete`，将启用系统级的滑动删除交互。
回调触发时，`List` 中对应的行已被移除，你必须在回调中同步删除数据源中的对应项目。

#### onMove(indices, newOffset)

注册移动行为，用于支持编辑状态下的拖动排序。
如希望禁用移动能力，可传入 `null`。

***

# 2. ForEachProps（推荐使用）

```ts
type ForEachProps<T extends { id: string }> =
  | ForEachDeprecatedProps
  | {
      data: Observable<T[]>;
      builder: (item: T, index: number) => VirtualNode;
      editActions?: "delete" | "move" | "all" | null;
    };
```

### 参数说明

#### data: Observable\<T\[]>

一个可观察数组，数组元素必须包含唯一的 `id: string` 字段。

使用 `Observable` 的好处：

- 当数组变动（增删改）时，会自动触发 SwiftUI 刷新
- 可以保留动画
- 更接近 SwiftUI 中 `ForEach($items)` 的使用体验
- 支持与 `List`、`NavigationStack` 等组件无缝联动

#### builder(item, index)

用于基于当前数组的每个元素构建对应的 VirtualNode。

**注意：必须为返回的子节点提供唯一的 key（通常使用 item.id）。**

#### editActions: "delete" | "move" | "all" | null

控制 ForEach 的可编辑能力：

| 值          | 含义            |
| ---------- | ------------- |
| `"delete"` | 仅启用删除         |
| `"move"`   | 仅启用移动（拖动排序）   |
| `"all"`    | 同时启用删除与移动     |
| `null`     | 不提供任何编辑能力（默认） |

当 `ForEach` 位于 `List` 内部时，编辑能力会自动映射到系统提供的交互方式。

***

# 3. ForEachComponent 接口

```ts
interface ForEachComponent {
  <T extends { id: string }>(props: ForEachProps<T>): VirtualNode;
}
```

`ForEach` 是一个泛型组件，接受带有 `id` 的任意数据类型。

***

# 4. 系统级删除交互示例

当 `ForEach` 放在 `List` 内部，并使用 `data + builder` 模式时，系统会自动启用 swipe-to-delete，只需正确提供 `id` 和编辑能力。

### 示例代码

```tsx
function View() {
  const fruits = useObservable(() =>
    ["Apple", "Bananer", "Papaya", "Mango"].map((name, index) => ({
      id: index.toString(),
      name,
    }))
  );

  return (
    <NavigationStack>
      <List
        navigationTitle="Fruits"
        toolbar={{
          topBarTrailing: <EditButton />,
        }}>
        <ForEach data={fruits} builder={(item, index) => <Text key={item.id}>{item.name}</Text>} />
      </List>
    </NavigationStack>
  );
}
```

***

# 5. 使用建议与最佳实践

### 1. 推荐使用 `data: Observable<T[]>` 方案

新版 API 更接近 SwiftUI 行为，拥有更好的性能与类型推断支持，且未来将接入更多 SwiftUI-style 的能力。

### 2. 每个元素必须拥有 `id: string`

这是确保 Diff 和动画正确工作的基础。

### 3. 必须为 builder 返回的节点提供 `key={item.id}`

否则可能导致:

- 动画不生效
- 列表渲染混乱
- 删除或移动行为出错

### 4. 若需要与编辑按钮联动，必须放置于 `List` 中

并设置 toolbar：

```tsx
toolbar={{
  topBarTrailing: <EditButton />
}}
```



---
url: /v2/zh/guide/Views/View groupings/ForEach/iterating.md
---

# 示例

```tsx
import { Button, Font, ForEach, List, Navigation, NavigationStack, Script, Section, Text, useObservable, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()

  const namedFonts = useObservable(() => {
    return [
      "largeTitle",
      "title",
      "headline",
      "body",
      "caption"
    ].map(e => ({
      id: e,
      name: e as Font
    }))
  })

  return <NavigationStack>
    <List
      navigationTitle={"Iterating"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        header={
          <Text
            textCase={null}
          >ForEach</Text>
        }
      >
        <ForEach
          data={namedFonts}
          builder={(namedFont) => {
            return <Text
              key={namedFont.id}
              font={namedFont.name}
            >{namedFont.name}</Text>
          }}
        />
      </Section>

      <Section
        header={
          <Text
            textCase={null}
          >Iterating in code block</Text>
        }
      >
        <VStack>
          {namedFonts.value.map(namedFont =>
            <Text
              font={namedFont.name}
            >{namedFont.name}</Text>
          )}
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/View groupings/Form.md
---

# 表单

```tsx
import { Button, Form, Navigation, NavigationStack, Picker, Script, Section, Text, Toggle, useState } from "scripting"

type NotifyMeAboutType = "directMessages" | "mentions" | "anything"
type ProfileImageSize = "large" | "medium" | "small"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [notifyMeAbout, setNotifyMeAbout] = useState<NotifyMeAboutType>("directMessages")
  const [playNotificationSounds, setPlayNotificationSounds] = useState(true)
  const [profileImageSize, setprofileImageSize] = useState<ProfileImageSize>("medium")
  const [sendReadReceipts, setSendReadReceipts] = useState(false)

  return <NavigationStack>
    <Form
      navigationTitle={"Form"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <Section
        header={<Text>Notifications</Text>}
      >
        <Picker
          title={"Notify Me About"}
          value={notifyMeAbout}
          onChanged={setNotifyMeAbout as any}
        >
          <Text
            tag={"directMessages"}
          >Direct Messages</Text>
          <Text
            tag={"mentions"}
          >Mentions</Text>
          <Text
            tag={"anything"}
          >Anything</Text>
        </Picker>

        <Toggle
          title={"Play notification sounds"}
          value={playNotificationSounds}
          onChanged={setPlayNotificationSounds}
        />
        <Toggle
          title={"Send read receipts"}
          value={sendReadReceipts}
          onChanged={setSendReadReceipts}
        />
      </Section>

      <Section
        header={<Text>User Profiles</Text>}
      >
        <Picker
          title={"Profile Image Size"}
          value={profileImageSize}
          onChanged={setprofileImageSize as any}
        >
          <Text
            tag={"large"}
          >Large</Text>
          <Text
            tag={"medium"}
          >Medium</Text>
          <Text
            tag={"small"}
          >Small</Text>
        </Picker>

        <Button
          title={"Clear Image Cache"}
          action={() => { }}
        />
      </Section>
    </Form>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/View groupings/Group.md
---

# Group

```tsx
import { Button, Group, List, Navigation, NavigationStack, Script, Section, Text, VStack } from "scripting"

function Example() {
  const dimiss = Navigation.useDismiss()

  return <NavigationStack>
    <List
      navigationTitle={"Group"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dimiss}
        />
      }}
    >
      <Section
        footer={
          <Text>Apply the headline font to all Text views</Text>
        }
      >
        <Group
          font={"headline"}
        >
          <Text>Scripting</Text>
          <Text>TypeScript</Text>
          <Text>TSX</Text>
        </Group>
      </Section>

      <Section
        footer={
          <Text>Group some views as a view</Text>
        }
      >
        <VStack>
          <Group
            foregroundStyle={"red"}
          >
            <Text>1</Text>
            <Text>2</Text>
            <Text>3</Text>
            <Text>4</Text>
            <Text>5</Text>
            <Text>6</Text>
            <Text>7</Text>
          </Group>
          <Text>8</Text>
        </VStack>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/View groupings/GroupBox.md
---

# GroupBox

```tsx
import { Button, GroupBox, Label, Navigation, NavigationStack, Script, ScrollView, Text, Toggle, useState, VStack } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [userAgreed, setUserAgreed] = useState(false)
  const agreementText = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."

  return <NavigationStack>
    <VStack
      navigationTitle={"GroupBox"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />
      }}
    >
      <GroupBox
        label={
          <Label
            title={"End-User Agreement"}
            systemImage={"building.columns"}
          />
        }
      >
        <ScrollView
          frame={{
            height: 100,
          }}
        >
          <Text>{agreementText}</Text>
        </ScrollView>
        <Toggle
          value={userAgreed}
          onChanged={setUserAgreed}
        >
          <Text>I agree to the above terms</Text>
        </Toggle>
      </GroupBox>
    </VStack>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/View groupings/Section.md
---

# Section

```tsx
import { Button, List, Navigation, NavigationStack, Script, Section, Text, useState } from "scripting"

function Example() {
  const dismiss = Navigation.useDismiss()
  const [isExpanded, setIsExpanded] = useState(true)

  return <NavigationStack>
    <List
      navigationTitle={"Section"}
      navigationBarTitleDisplayMode={"inline"}
      toolbar={{
        cancellationAction: <Button
          title={"Done"}
          action={dismiss}
        />,
      }}
    >
      <Section>
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>

      <Section
        header={<Text>Section with header</Text>}
      >
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>

      <Section
        footer={<Text>Section with footer</Text>}
      >
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>

      <Section
        header={
          <Text
            onTapGesture={() => setIsExpanded(!isExpanded)}
          >Collapsable Section</Text>
        }
        isExpanded={isExpanded}
        onChanged={setIsExpanded}
      >
        <Text>Row 1</Text>
        <Text>Row 2</Text>
        <Text>Row 3</Text>
        <Text>Row 4</Text>
      </Section>
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Views/WebView.md
---

# 网页视图

```tsx
import { Button, HStack, Image, List, Navigation, NavigationStack, Script, Section, Text, TextField, useMemo, useState, VStack, WebView } from "scripting"

function WebViewControllerExample() {
  const [logs, setLogs] = useState<{
    content: string
    error: boolean
  }[]>([])

  function addLog(content: string, error = false) {
    setLogs(logs => [...logs, { content, error }])
  }

  async function runCode() {
    setLogs([])
    const controller = new WebViewController()

    addLog("WebViewController created.")
    addLog("Start loading...")

    if (await controller.loadURL("https://github.com")) {
      addLog("Website is loaded.")
      addLog("Calling controller.evaluateJavaScript...")
      const title = await controller.evaluateJavaScript<string>("document.title")

      if (title != null) {
        addLog(`Title: ${title}`)
      } else {
        addLog("Failed to get the title.", true)
      }
    } else {
      addLog("Failed to load the website.", true)
    }

    controller.dispose()
    addLog("The controller is disposed.")
  }

  return <Section
    header={
      <Text>WebView controller</Text>
    }
  >
    <VStack
      frame={{
        maxWidth: "infinity"
      }}
      alignment={"leading"}
    >
      <Text font={"headline"}>This example will follow these steps:</Text>
      <VStack
        padding={{
          leading: 16
        }}
        spacing={16}
        foregroundStyle={"secondaryLabel"}
        alignment={"leading"}
      >
        <Text>Create a WebViewController instane</Text>
        <Text>Load https://github.com</Text>
        <Text>Call evaluateJavaScript and get the title of the website</Text>
      </VStack>
      <HStack
        alignment={"center"}
        frame={{
          maxWidth: "infinity"
        }}
      >
        <Button
          title={"Run"}
          action={runCode}
        />
      </HStack>

      <VStack
        alignment={"leading"}
        spacing={8}
      >
        {logs.map(log =>
          <Text
            font={"caption"}
            monospaced
            padding={{
              leading: 16
            }}
            foregroundStyle={log.error ? "systemRed" : "systemGreen"}
          >{log.content}</Text>
        )}
      </VStack>
    </VStack>
  </Section>
}

function PresentWebViewExample() {

  function run() {
    const controller = new WebViewController()
    controller.loadURL("https://github.com")

    controller.present({
      fullscreen: true,
      navigationTitle: "Github"
    }).then(() => {
      console.log("WebView is dismissed")
      controller.dispose()
    })
  }

  return <Section
    header={
      <Text>Present a WebView as a independent page</Text>
    }
  >
    <Button
      title={"Present"}
      action={run}
    />
  </Section>
}

function EmbedAWebViewExample() {
  const controller = useMemo(() => new WebViewController(), [])
  const [url, setUrl] = useState("")

  return <Section
    header={
      <Text>Embed a WebView</Text>
    }
  >
    <VStack>
      <HStack>
        <Button action={() => {
          controller.goBack()
        }}>
          <Image
            systemName={"arrow.left"}
          />
        </Button>
        <Button action={() => {
          controller.goForward()
        }}>
          <Image
            systemName={"arrow.right"}
          />
        </Button>
        <Button action={() => {
          controller.reload()
        }}>
          <Image
            systemName={"arrow.clockwise"}
          />
        </Button>
        <TextField
          title={"Website URL"}
          textFieldStyle={"roundedBorder"}
          value={url}
          onChanged={setUrl}
          keyboardType={"URL"}
          textInputAutocapitalization={"never"}
          frame={{
            maxWidth: "infinity"
          }}
        />
        <Button
          action={() => controller.loadURL(url)}
        >
          <Image
            systemName={"arrow.right.circle"}
          />
        </Button>
      </HStack>
      <WebView
        controller={controller}
        frame={{
          height: 400
        }}
      />
    </VStack>
  </Section>
}

function Example() {
  return <NavigationStack>
    <List
      navigationTitle={"WebView"}
      navigationBarTitleDisplayMode={"inline"}
    >
      <WebViewControllerExample />
      <PresentWebViewExample />
      <EmbedAWebViewExample />
    </List>
  </NavigationStack>
}

async function run() {
  await Navigation.present({
    element: <Example />
  })

  Script.exit()
}

run()

```



---
url: /v2/zh/guide/Widget/AccessoryWidgetBackground.md
---

# AccessoryWidgetBackground

一个自适应的背景视图，根据小组件当前的环境提供系统标准外观。

## 概述

`AccessoryWidgetBackground` 组件适用于配件类小组件（Accessory Widgets），如锁屏小组件或待机模式（StandBy）小组件。它会自动根据系统环境（如浅色/深色模式、透明度、系统主题）应用合适的背景样式，确保小组件与系统视觉风格一致。

通常你可以将此视图作为背景层，配合 `ZStack` 等布局使用，将自定义内容覆盖其上方，从而获得既美观又系统一致的外观。

## 示例

```tsx
import { AccessoryWidgetBackground, Text, ZStack } from "scripting"

function AccessoryView() {
  return (
    <ZStack>
      <AccessoryWidgetBackground />
      <Text font="caption">Weather</Text>
    </ZStack>
  )
}
```

在此示例中，`AccessoryWidgetBackground` 提供了系统适配的背景，`Text` 文本则显示在其上方。此布局非常适合锁屏小组件，确保内容在各种系统外观下保持清晰可读。

## 使用建议

- 通常应将 `AccessoryWidgetBackground` 放在 `ZStack` 的底层，以作为背景视图。
- 不建议对该组件直接设置颜色或样式，它会根据系统环境自动调整。
- 可与其他 SwiftUI 风格的组件结合使用，构建与原生系统一致的小组件外观。

## 兼容性

此组件主要用于配件类小组件，在普通视图中使用可能不会有任何视觉效果。建议仅在小组件开发中使用，以获得最佳系统一致性体验。



---
url: /v2/zh/guide/Widget/Animation for Widget and LiveActivity.md
---

# 在小组件和灵动岛中使用动画

这些API让你在小组件中播放动图或者使用位移和旋转动画。

## `AnimatedFrames` 组件

### 描述

`AnimatedFrames` 组件允许你通过提供的子视图来展示帧动画。这些子视图将按顺序循环显示，形成动画效果。你可以自定义动画的持续时间。

### 属性

- **`duration`**: `DurationInSeconds`\
  动画的持续时间，单位为秒。

- **`children`**: `VirtualNode[]`\
  一组视图，作为动画的每一帧。每个子视图在动画过程中依次显示。

### 示例

```tsx
<AnimatedFrames duration={4}>
  <Circle fill="red" frame={{width: 20, height: 20}} />
  <Circle fill="red" frame={{width: 25, height: 25}} />
  <Circle fill="red" frame={{width: 30, height: 30}} />
  <Circle fill="red" frame={{width: 35, height: 35}} />
</AnimatedFrames>
```

***

## `AnimatedGif` 组件

### 描述

`AnimatedGif` 组件用于在小组件中渲染一个 GIF 动图。你可以提供 GIF 文件的路径，并可选地设置动画的持续时间。

### 属性

- **`path`**: `string`\
  GIF 文件的路径。

- **`duration`**: `DurationInSeconds` _(可选)_\
  动画的持续时间，单位为秒。如果未提供，使用默认持续时间。

### 示例

```tsx
<AnimatedGif
  path={Path.join(Script.directory, "test.gif")}
  duration={4}
/>
```

***

## `SwingAnimation` 类型

### 描述

`SwingAnimation` 类型定义了视图在水平和垂直方向上的摇摆动画配置。

### 属性

- **`duration`**: `DurationInSeconds`\
  动画的持续时间，单位为秒。

- **`distance`**: `number`\
  视图在给定轴向上摇摆的距离。

***

## `ClockHandRotationEffectPeriod` 类型

### 描述

`ClockHandRotationEffectPeriod` 类型用于定义时钟指针旋转效果的周期。你可以使用预定义值如 `"hourHand"`、`"minuteHand"` 或 `"secondHand"`，也可以提供自定义的持续时间。

***

## `AnimatedImage` 组件

### 描述

`AnimatedImage` 组件用于在小组件中渲染一个动画图像。你可以使用 `SFSymbol` 或 `UIImage` 作为动画帧，并自定义动画的持续时间和内容模式（适应或填充）。

### 属性

- **`systemImages`**: `(string | { name: string; variableValue: number })[]` _(可选)_\
  一个包含 `SFSymbol` 名称和变量值的数组，用于显示作为动画帧的符号图像。

- **`images`**: `UIImage[]` _(可选)_\
  一个 `UIImage` 数组，用于显示作为动画帧的图像。

- **`contentMode`**: `ContentMode` _(可选)_\
  图像在父容器中的显示方式。默认为 `"fit"`。\
  可选值：`"fit"`、`"fill"`。

- **`duration`**: `DurationInSeconds`\
  动画的持续时间，单位为秒。

### 示例 (使用 `SFSymbol`)

```tsx
<AnimatedImage
  duration={6}
  systemImages={[
    {name: "chart.bar.fill", variableValue: 0},
    {name: "chart.bar.fill", variableValue: 0.3},
    {name: "chart.bar.fill", variableValue: 0.6},
    {name: "chart.bar.fill", variableValue: 1},
  ]}
  contentMode="fit"
/>
```

### 示例 (使用 `UIImage`)

```tsx
const image1 = Path.join(Script.directory, "image1.png")
const image2 = Path.join(Script.directory, "image2.png")

<AnimatedImage
  duration={4}
  images={[
    UIImage.fromFile(image1),
    UIImage.fromFile(image2),
  ]}
  contentMode="fill"
/>
```

***

## `CommonViewProps` 类型

### 描述

此类型定义了支持动画效果的视图的公共属性，包括摇摆动画和时钟指针旋转效果。

### 属性

- **`swingAnimation`**: `{ x?: SwingAnimation, y?: SwingAnimation }` _(可选)_\
  定义了视图在 X 轴和 Y 轴上的摇摆动画配置。每个轴向都可以有单独的动画设置：
  - **`x`**: 水平轴的动画配置。
  - **`y`**: 垂直轴的动画配置。

- **`clockHandRotationEffect`**: `ClockHandRotationEffectPeriod | { anchor: KeywordPoint | Point, period: ClockHandRotationEffectPeriod }` _(可选)_\
  定义模拟时钟指针的旋转效果。可以指定锚点（可选）和周期（例如，`"hourHand"`、`"minuteHand"`、`"secondHand"`），或者提供自定义的旋转持续时间。

### 示例 (摇摆动画)

```tsx
<Circle
  fill="systemRed"
  frame={{width: 50, height: 50}}
  swingAnimation={{
    x: {duration: 4, distance: 250},
    y: {duration: 2, distance: 50},
  }}
/>
```

### 示例 (时钟指针旋转效果)

```tsx
<Circle
  fill="systemBlue"
  frame={{width: 50, height: 50}}
  clockHandRotationEffect="minuteHand"
/>
```



---
url: /v2/zh/guide/Widget/Tinted Mode Adaptation Guide.md
---

# 小组件染色模式适配指南

iOS 18 引入了一种新的小组件渲染模式，称为 **accented 模式（强调色模式）**，它会使用系统定义的强调色对小组件的内容进行统一染色。为支持该行为，**Scripting** app 提供了三个视图修饰符：

- `widgetAccentable`
- `widgetAccentedRenderingMode`
- `widgetBackground`

这些修饰符让你可以精确控制小组件中哪些部分参与系统的染色逻辑，从而创建更具层次感和适配性的界面。

***

## `widgetAccentable`

### 说明

将视图及其所有子视图标记为 **accented group（强调组）** 的一部分。当小组件处于 **accented 渲染模式** 时，系统会分别为强调组与默认组应用不同的色调。染色过程仿照模板图像的方式 —— 系统会忽略你设置的颜色，仅使用视图的 alpha（透明度）进行渲染。

这个修饰符有助于在 tinted 小组件中实现清晰的层次分离效果。

### 用法示例

```tsx
<VStack>
  <Text
    widgetAccentable
    font="caption"
  >
    MON
  </Text>
  <Text font="title">
    6
  </Text>
</VStack>
```

说明：

- 第一个 `Text` 使用了 `widgetAccentable`，将被系统染色为强调色；
- 第二个 `Text` 属于默认组，通常被染为较浅的颜色。

***

## `widgetAccentedRenderingMode`（用于 `Image` 组件）

### 说明

控制 `Image` 在 **accented 模式** 下的渲染方式。可用于调整图像在染色模式下的外观处理。

### 可用模式

- `'accented'`：将图像加入强调组，使用强调色渲染。
- `'accentedDesaturated'`：将图像亮度转为 alpha 后使用强调色染色。
- `'desaturated'`：将图像亮度转为 alpha 后使用默认组色调染色。
- `'fullColor'`：保留图像原始颜色，不进行染色（仅适用于 iOS 系统图像）。

### 用法示例

```tsx
<Image
  filePath="/path/to/image.png"
  widgetAccentedRenderingMode="fullColor"
/>
```

该设置可确保图像保留完整颜色，适合用于品牌 Logo 或需要保持清晰度的图像内容。

***

## `widgetBackground`

### 说明

`widgetBackground` 修饰符用于在小组件中设置背景样式，**并自动适配 iOS 18 的 accented 模式**。当小组件处于 accented 模式时，该背景会**自动隐藏**，避免被系统强制染色为白色。

iOS 18 会忽略背景颜色，除非设置透明度（alpha）。使用 `widgetBackground` 可以放心地定义装饰性背景，而不必担心其在染色模式下显示异常。

### 支持格式

#### 纯色背景

```tsx
<Text widgetBackground="systemGray5">
  Hello
</Text>
```

#### 浅色/深色模式适配背景

```tsx
<Text
  widgetBackground={{
    light: "white",
    dark: "black"
  }}
>
  模式感知背景
</Text>
```

#### 带形状的背景

```tsx
<Text
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12,
      style: "continuous"
    }
  }}
>
  圆角背景
</Text>
```

> 提示：可用形状包括 `'rect'`、`'circle'`、`'capsule'`、`'ellipse'`、`'buttonBorder'`、`'containerRelative'`，也支持自定义圆角矩形。

### 特性说明

- 在 **accented 模式** 下，背景会被自动隐藏；
- 在 **默认或全彩模式** 下，背景正常显示；
- 与 `widgetAccentable` 配合使用，可实现分层布局，保持视觉清晰度。

***

## 系统行为说明（适用于 iOS 18+）

- 在 **accented 模式** 中，**所有颜色（包括背景）都会被忽略**，除非设置了 `alpha < 1`。例如纯色背景会被渲染为白色。
- 通过 **设置 alpha 值** 可实现视觉层级，例如 `alpha = 1` 会获得强烈染色效果，而 `alpha = 0.3` 更加柔和。
- **不要依赖具体颜色值** 来控制样式，在 accented 模式下颜色会被系统统一替换，应通过分组和透明度控制样式。
- **推荐使用 `widgetBackground` 代替 `background`**，以确保背景在 accented 模式下能够被正确隐藏。

***

## 示例

```tsx
<VStack
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12
    }
  }}
  spacing={4}
>
  <Image
    filePath="/path/to/icons/calendar.png"
    widgetAccentedRenderingMode="accentedDesaturated"
  />
  <Text widgetAccentable font="caption">
    MON
  </Text>
  <Text font="title">
    6
  </Text>
</VStack>
```

该布局：

- 设置了一个圆角灰色背景，仅在非 accented 模式下显示；
- 图标和星期标签加入了 **强调组**；
- 日期数字保留在 **默认组**；
- 即便系统进行染色，也能保持清晰的分层效果。

***

## 使用技巧

- 使用 `widgetAccentable` 精确标记需要染色的内容，避免误将整个小组件标记为强调组；
- 对于品牌图标等需要保留原色的图像，使用 `widgetAccentedRenderingMode="fullColor"`；
- 使用 `widgetBackground` 替代 `background`，以确保背景能在强调模式下正确处理；
- 为背景或视图设置透明度（如 `alpha < 1`）可保留层次感，避免全部被染为纯白。



---
url: /v2/zh/guide/Widget/Widget API.md
---

# 小组件 API

`Widget` 类提供了一组静态方法和属性，用于在 Scripting app 中创建、预览和刷新主屏幕小组件。通过此 API，可以渲染小组件 UI，访问用户配置参数，并控制小组件的刷新策略。

***

## 类：`Widget`

此类为静态类，不能实例化，所有成员均为静态。

***

### 静态属性

#### `Widget.family: WidgetFamily`

获取用户当前配置的小组件尺寸类型（即小组件的 family）。
常见取值包括：

- `"systemSmall"` – 小尺寸组件
- `"systemMedium"` – 中尺寸组件
- `"systemLarge"` – 大尺寸组件
- `"accessoryRectangular"` – 锁屏矩形组件
- `"accessoryCircular"` – 锁屏圆形组件

> **类型：** `WidgetFamily`

***

#### `Widget.displaySize: WidgetDisplaySize`

获取当前小组件的显示尺寸（单位为点）。根据小组件的 family 和设备分辨率决定具体大小。

> **类型：** `{ width: number; height: number }`

***

#### `Widget.parameter: string`

如果用户在主屏幕小组件中设置了 `参数` 字段，并通过点击该小组件打开并运行脚本，可以通过该属性访问该参数的值。
适用于根据不同用户配置动态渲染不同的小组件内容。

> **类型：** `string`

***

### 静态方法

#### `Widget.present(element: VirtualNode, reloadPolicy?: WidgetReloadPolicy): void`

用于在小组件上渲染 UI。传入一个 React 风格的 JSX 节点（即 VirtualNode）作为渲染内容。可选地传入刷新策略以控制 WidgetKit 请求新时间线的时机。

##### 参数说明

- `element` (`VirtualNode`) – 小组件 UI 的 JSX 树。
- `reloadPolicy` (`WidgetReloadPolicy`，可选) – 控制 WidgetKit 请求新时间线的策略，默认为 `atEnd`。

##### 示例

```tsx
function WidgetView() {
  return <VStack>
    <Image
      systemName="globe"
      resizable
      scaleToFit
      frame={{
        width: 28,
        height: 28
      }}
    />
    <Text>Hello Scripting!</Text>
  </VStack>
}

Widget.present(<WidgetView />, {
  policy: "after",
  date: new Date(Date.now() + 1000 * 60 * 5) // 5分钟后刷新
})
```

> **返回值：** `void`

***

#### `Widget.preview(options?: PreviewOptions): Promise<void>`

用于在 `index.tsx` 中预览小组件效果。可以为小组件配置不同参数选项，模拟其在不同参数下的外观。
此方法仅支持在 `index.tsx` 中调用，在 `widget.tsx` 或 `intent.tsx` 中不可用。

##### 参数说明

- `options`（可选）– 预览配置项。

```ts
interface PreviewOptions {
  family?: WidgetFamily
  parameters?: {
    options: Record<string, string> // 参数名到 JSON 字符串的映射
    default: string                 // 默认使用的参数键
  }
}
```

##### 示例

```tsx
const options = {
  "Param 1": JSON.stringify({ color: "red" }),
  "Param 2": JSON.stringify({ color: "blue" }),
}

await Widget.preview({
  family: "systemSmall",
  parameters: {
    options,
    default: "Param 1"
  }
})
console.log("Widget preview dismissed")
```

> **返回值：** `Promise<void>`
> 如果参数设置不正确，将抛出异常。

***

#### `Widget.reloadAll(): void`

请求 WidgetKit 重新加载所有由 Scripting 创建的小组件时间线。
在小组件依赖的数据变化时调用此方法可以立即触发刷新。

> **返回值：** `void`

***

## 相关类型

### `WidgetFamily`

表示小组件的尺寸类型：

```ts
type WidgetFamily =
  | "systemSmall"
  | "systemMedium"
  | "systemLarge"
  | "accessoryCircular"
  | "accessoryRectangular"
```

***

### `WidgetDisplaySize`

表示小组件当前的显示尺寸（单位：点）：

```ts
interface WidgetDisplaySize {
  width: number
  height: number
}
```

***

### `WidgetReloadPolicy`

定义小组件的刷新策略：

```ts
type WidgetReloadPolicy =
  | { policy: "atEnd" } // 时间线结束后刷新（默认）
  | { policy: "after", date: Date } // 指定时间之后刷新
```

***

## 使用说明

- `Widget.present` 应在 `widget.tsx` 中调用，用于定义和显示小组件实际内容。
- `Widget.preview` 仅用于 `index.tsx` 中测试和预览小组件，不会被系统实际渲染。
- 使用 `Widget.parameter` 时，若参数为结构化数据（如对象），需使用 `JSON.parse()` 解析。
- 脚本结束后应调用 `Script.exit()` 以确保小组件正常退出。

***

如需导出为 Markdown 文档或用于帮助中心，请告诉我，我可以为你生成格式化版本。



---
url: /v2/zh/guide/Widget/Widget Background in Tinted Mode.md
---

# 小组件色调模式背景

`widgetBackground` 是一个专用于**小组件**的视图修饰符，用于在不同的渲染模式下设置背景样式，特别是为适配 **iOS 18 的 tinted（强调色）模式**而设计。

## 功能说明

在 **tinted 模式**下，iOS 会将所有视图颜色（包括背景）渲染为白色，除非该视图使用了 `widgetAccentable` 标记。这可能会导致背景显示异常或视觉效果失真。

使用 `widgetBackground` 可以避免这种问题：

- **在 accented 模式下自动隐藏背景**，避免被系统渲染为纯白色；
- **在默认模式或全彩模式下正常显示背景**。

这样可以确保你的小组件在不同系统渲染环境下都具有良好的视觉一致性。

***

## 支持的背景设置方式

`widgetBackground` 支持以下几种格式：

### 1. **纯色背景（ShapeStyle）**

使用简单颜色作为背景：

```tsx
<Text widgetBackground="systemBlue">
  Hello
</Text>
```

***

### 2. **动态背景（DynamicShapeStyle）**

根据系统的浅色/深色模式动态切换背景样式：

```tsx
<Text
  widgetBackground={{
    light: "white",
    dark: "black"
  }}
>
  模式感知背景
</Text>
```

***

### 3. **带形状的背景样式**

使用指定的\*\*形状（Shape）\*\*配合填充样式，实现结构化的背景设计：

```tsx
<Text
  widgetBackground={{
    style: "systemGray6",
    shape: {
      type: "rect",
      cornerRadius: 12,
      style: "continuous"
    }
  }}
>
  圆角背景
</Text>
```

支持的形状包括：

- 预设形状：`'rect'`、`'circle'`、`'capsule'`、`'ellipse'`、`'buttonBorder'`、`'containerRelative'`
- 自定义圆角矩形：支持统一圆角、椭圆角尺寸、每个角独立设定

***

## 在 accented 模式下的行为

- **在 iOS 的 accented（tinted）模式下**：背景会被自动隐藏，以避免出现纯白色遮盖问题；
- **在默认或全彩渲染模式下**：背景将按设定正常显示。

此行为可有效避免系统渲染方式对 UI 布局和层级的干扰。

***

## 使用建议

- 仅在小组件中使用 `widgetBackground`，以避免在普通视图中出现不必要的隐藏行为；
- 不要使用背景传达重要信息，因为在 accented 模式下它可能会被隐藏；
- 搭配 `widgetAccentable` 使用，以精确控制哪些内容应参与系统色彩渲染，哪些内容应独立呈现。



---
url: /v2/zh/guide/Widget/Widget Quick Start.md
---

# 小组件快速入门

**Scripting** 是一款支持使用 TypeScript 和类 React 的 TSX 语法来创建 iOS 主屏幕小组件的应用。你可以在 `widget.tsx` 文件中使用受 SwiftUI 启发的组件定义小组件的界面。

***

## 1. 快速开始

### 第一步：创建脚本项目

1. 打开 **Scripting** 应用。
2. 创建一个新的脚本项目，并为你的小组件命名。

### 第二步：添加 `widget.tsx` 文件

1. 在项目中创建一个名为 `widget.tsx` 的文件。
2. 使用函数组件定义小组件的界面。
3. 从 `scripting` 包中导入所需组件和 API。

#### 示例：

```tsx
// widget.tsx
import { VStack, Text, Widget } from 'scripting'

function MyWidgetView() {
  return (
    <VStack>
      <Text>Hello world</Text>
    </VStack>
  )
}

Widget.present(<MyWidgetView />)
```

调用 `Widget.present()` 将该组件渲染为主屏幕小组件。

***

## 2. 获取小组件上下文

你可以通过 `Widget` API 提供的以下属性来适配布局和内容：

| 属性                   | 描述                                      |
| -------------------- | --------------------------------------- |
| `Widget.displaySize` | 小组件在运行时的实际像素尺寸。                         |
| `Widget.family`      | 小组件类型：`'small'`、`'medium'` 或 `'large'`。 |
| `Widget.parameter`   | 用户在主屏幕小组件设置中配置的自定义参数。                   |

使用这些属性可以根据小组件的尺寸或用户偏好动态调整内容和布局。

***

## 3. 添加到主屏幕

1. 将 **Scripting** 小组件添加到 iOS 主屏幕。
2. 长按该小组件并点击 **编辑小组件**。
3. 选择你创建的脚本，并根据需要配置 **参数**。

配置完成后，`widget.tsx` 中定义的组件将直接显示在主屏幕上。

***

## 4. 视图构建方式

使用受 SwiftUI 启发的内置组件（如 `VStack`、`HStack`、`Text`、`Image` 等）构建小组件界面。你也可以将逻辑与视图分离到多个文件中进行组织，通过模块导入使用。

***

## 5. 开发限制与最佳实践

### 小组件中 Hooks 不生效

虽然可以在代码中使用 `useState`、`useEffect` 等 React Hooks，但在小组件中这些 **不会生效**，因为小组件是 **一次性渲染** 的，没有持续的交互生命周期。避免依赖任何动态状态逻辑。

### 内存限制

iOS 对小组件有约 **30MB** 的内存限制。为了不超出限制：

- 避免渲染过多嵌套视图。
- 减少图像资源使用。
- 避免内存泄漏或长时间引用的数据。

如果渲染失败或显示空白，通常是内存问题导致的。

### 小组件上下文立即销毁

调用 `Widget.present(...)` 后，当前执行上下文会被 **立即销毁**，因此：

- 所有数据准备应在调用前完成。
- 避免在 `Widget.present` 之后编写逻辑，因为这些代码不会执行。
- 将小组件函数视为一次性 UI 渲染器。

***

## 6. 交互支持

尽管小组件大多是静态的，但可以通过 AppIntent 实现 **基础交互功能**：

- 使用 `<Button>` 或 `<Toggle>` 等组件触发 AppIntent。
- 更多详情可参考 **Interactive Widget 和 LiveActivity** 文档。

***

## 7. 视图兼容性

**并非所有 SwiftUI 视图都支持在小组件中使用。** 某些布局容器与特效不被支持。请参考 Apple 官方文档：[WidgetKit 中支持的 SwiftUI 视图](https://developer.apple.com/documentation/widgetkit/swiftui-views)。

***

## 8. 小组件预览限制

Scripting 应用内的小组件预览仅是 **近似效果**，与 iOS 主屏幕上的实际渲染在以下方面可能略有差异：

- 文字对齐
- 小组件尺寸
- 小组件圆角
- 布局行为

要确保布局准确，请 **始终在主屏幕上测试小组件**。

***

## 9. 刷新小组件

### 通用刷新方法

- 调用 `Widget.reloadAll()` 可立即刷新所有小组件（包括用户和开发者小组件）。
- 可在 AppIntent 或 `index.tsx` 中调用。
- 也可以使用 Scripting 应用中的 **刷新小组件** 按钮快速测试开发时的变更。

这有助于快速迭代布局或逻辑。

### 新增：用户小组件与开发者小组件

Scripting 支持两种类型的小组件（kind）：

| 类型                       | 说明                         |
| ------------------------ | -------------------------- |
| **User Widgets（用户小组件）**  | 用于普通用户在主屏幕上添加和使用的正式小组件。    |
| **Test Widgets（开发者小组件）** | 用于开发者在开发阶段进行调试和预览的测试版本小组件。 |

这两类小组件使用不同的 `kind`，互不影响，便于在开发时安全地进行刷新与测试。

### 新增刷新方法

| 方法                           | 描述                                                   |
| ---------------------------- | ---------------------------------------------------- |
| `Widget.reloadUserWidgets()` | 仅刷新 **用户小组件（User Widgets）**，不影响开发者测试用的 Test Widgets。 |
| `Widget.reloadTestWidgets()` | 仅刷新 **开发者小组件（Test Widgets）**，不会影响用户主屏幕上的正式小组件。       |

这两个方法的设计目的是为了隔离开发和用户使用场景。当你在开发阶段修改 `widget.tsx` 并调用 `Widget.reloadTestWidgets()` 时，只会刷新测试用的小组件，而用户的正式小组件不会受到任何干扰。

#### 示例：

```tsx
// 在开发环境中刷新测试小组件
await Widget.reloadTestWidgets()

// 在发布前刷新所有用户小组件
await Widget.reloadUserWidgets()
```

#### 使用建议：

- 开发阶段：推荐使用 **`Widget.reloadTestWidgets()`**。
- 发布或用户脚本更新后：推荐使用 **`Widget.reloadUserWidgets()`** 或 **`Widget.reloadAll()`**。

***

## 10. 文档与支持

- 查看 **Views 文档** 获取所有可用组件和修饰器的完整列表。
- 参考 **API 文档** 获取更高级的功能集成（如 Calendar、FileManager、AVPlayer 等）。

***

## 11. 使用 `Widget.preview` 进行开发预览

开发过程中，你可以使用 `Widget.preview()` 方法在 `index.tsx` 中预览小组件的布局效果和参数配置，无需返回主屏幕进行测试。

### 方法：`Widget.preview(options)`

该方法可在应用内模拟不同参数和尺寸的小组件展示，适用于 **开发调试阶段**，只能在 **`index.tsx` 环境中调用**（不能在 `widget.tsx` 或 `intent.tsx` 中使用）。

### 参数说明

| 属性                   | 类型                       | 描述                               |                 |                                  |
| -------------------- | ------------------------ | -------------------------------- | --------------- | -------------------------------- |
| `family`             | `'systemSmall'`          | `'systemMedium'`                 | `'systemLarge'` | 可选。预览的小组件尺寸，默认为 `'systemSmall'`。 |
| `parameters.options` | `Record<string, string>` | 参数选项的字典，键为参数名，值为可 JSON 解析的字符串内容。 |                 |                                  |
| `parameters.default` | `string`                 | 指定默认使用的参数名。                      |                 |                                  |

### 示例

```tsx
const options = {
  "Param 1": JSON.stringify({
    color: "red"
  }),
  "Param 2": JSON.stringify({
    color: "blue"
  }),
}

await Widget.preview({
  family: "systemSmall",
  parameters: {
    options,
    default: "Param 1"
  }
})
console.log("Widget preview dismissed")
```

该方法可用于测试小组件在不同输入参数下的视觉表现，例如颜色、内容或配置状态等。

### 注意事项

- 该方法 **必须在 `index.tsx` 中调用**，适用于测试脚本或开发工具页面。
- 如果参数格式不正确，将会抛出错误。
- 预览效果仍受 [第 8 节 小组件预览限制](#8-小组件预览限制) 所述的限制影响，建议最终在主屏幕测试确认。



---
url: /v2/zh/index.md
---

# Scripting

iOS 自动化工具

> by thomfang

[开始](/zh/guide/Quick Start) | [下载](https://apps.apple.com/app/apple-store/id6479691128)

## Features

- /home/custom.svg **高度自定义**: <div>· 封装大量原生API（如日历、通知、蓝牙...）<br>· 支持自定义小组件、控制中心小组件、灵动岛、自定义键盘、快捷指令、共享菜单...</div>
- /home/ai.svg **AI 集成**: <div>· 使用自己的API Key与各AI服务聊天<br>· 可调用自己的脚本工具、本地知识库、生成代码并运行，完成各种复杂任务</div>
- /home/search.svg **优秀的开发体验**: <div>· 提供 VS Code 开发脚手架，支持手机实时预览<br>· 内置多语言编辑器，尤其强化 TypeScript，支持自动补全、语法高亮与检查</div>



---
url: /v2/zh/privacy/policy.md
---

# 隐私政策

## 简介

欢迎使用 Scripting！您的隐私对我们非常重要。此《隐私政策》将解释在您使用我们的应用时，我们如何处理您的数据。

## 无数据收集

Scripting App 不会收集或存储任何个人数据。所有在应用中产生的活动和数据都仅保留在您的设备上。

## 自愿沟通

如果您选择通过电子邮件与我们联系，我们可能会接收并存储您提供的信息，例如您的姓名、电子邮件地址以及任何消息内容。这些信息仅用于回复您的询问，不会与第三方共享。

## 第三方集成

Scripting App 可能会与第三方服务进行交互，例如您的设备上的 Shortcuts app 或其他集成。通过这些集成共享的任何数据都完全由这些服务管理，我们不会对此进行收集。

当您使用第三方模型集成功能时，提供的 API Key 将存储在设备本地，仅用于向 AI 模型发送和接收有关您任务的请求。Scripting App 不会收集、传输或将 API Key 用于任何其他目的。

## 健康数据与 HealthKit

Scripting 提供了可选的接口，用于访问 Apple 的 HealthKit 框架，允许您编写的脚本在设备上读取和写入您的健康数据。我们尊重您的隐私，并已设计此功能以确保：

### 不存储或分析

Scripting 不会收集、传输、分析或存储您的任何 HealthKit 数据。所有健康相关操作均在您的设备内本地完成。

### 用户控制与同意

对健康数据的访问完全由您控制。每当脚本请求读取或写入 HealthKit 示例数据时，iOS 会提示您授权或拒绝。您始终拥有完全控制权，并可在系统“设置”中随时撤销访问权限。

### 仅限脚本访问

授予的 HealthKit 权限仅限于您在 Scripting 中运行的脚本。应用本身及其开发者无法在脚本之外访问您的健康数据。

### 透明度

任何使用 HealthKit API 的脚本都必须明确声明所需的数据类型。您可以在授权前查看这些请求，以确保您确切了解所涉及的健康指标。

## 数据安全

由于 Scripting App 不会收集或存储数据，因此不存在未经授权访问您的个人信息的风险。通过电子邮件自愿分享的任何数据将受到谨慎处理并安全存储。

## 隐私政策变更

我们可能会不时更新此《隐私政策》。任何更改都会发布在本页面上，并相应更新“最后更新”日期。

## 联系我们

如果您对本《隐私政策》有任何疑问或顾虑，请通过以下方式与我们联系：

电子邮件： [tilfon@live.com](mailto:tilfon@live.com)



---
url: /v2/zh/privacy/service.md
---

# 服务条款与EULA

## 总则

欢迎使用 Scripting 应用！在使用本应用之前，请仔细阅读本协议内容。本协议适用于所有使用本应用的用户，包括免费用户和 Scripting Pro 用户。

## 软件许可协议（EULA）

- **许可范围:** 您被授予一项非独占、不可转让的许可，仅用于个人用途。

- **知识产权:** 本应用的所有内容、设计及代码均为开发者所有，受法律保护。

- **禁止行为:** 您不得反向工程、修改或分发本应用。

- **终止条款:** 如您违反协议内容，我们保留终止您使用本应用的权利。

## 服务条款

- **服务描述:** 本应用提供脚本开发环境、高级功能（如自定义主题、代码模板等）。

- **订阅计划:**
  - **一次性购买:** 解锁所有功能，终身有效。

  - **月度与年度订阅:** 自动续订服务。

- **购买与确认:** 您可以通过您的 iTunes 账户确认购买 Scripting Pro 订阅。付款将在您确认购买后从您的 iTunes 账户中扣除。

- **取消订阅:** 您可以随时通过访问设备的 iTunes 账户设置来取消订阅。如果您希望停止自动续订，需在当前订阅周期结束的至少 24 小时之前取消订阅。如果未在此时间内取消，订阅将在到期后自动续订。

- **续订与费用:** 在当前订阅周期结束的 24 小时内，系统会自动续订，并从您的 iTunes 账户中扣除相应费用。续订费用与初始订阅费用相同，除非您已更改订阅计划。

- **免费订阅的注意事项:** 免费试用期结束后，订阅将自动续订为付费计划，费用将从您的 iTunes 账户中扣除。如果您在试用期内未取消订阅，则默认视为您接受订阅条款。

- **第三方模型集成:** Scripting App 充当外部 AI 模型的桥梁，完全依赖用户提供的 API Key 与这些服务（例如 OpenAI GPT）进行交互。所有与 AI 相关的交互均符合第三方模型提供商的使用条款。

- **隐私政策:** 详情请参阅我们的[隐私政策](/v2/zh/privacy/policy.md)。

## 责任限制

本应用按“现状”提供，开发者不对因使用本应用而产生的任何直接或间接损失负责。

## 争议解决与适用法律

- **适用法律:** 本协议适用您所在地区的法律。

- **争议解决:** 双方应本着友好协商的原则解决争议，协商不成时依法处理。

## 联系我们

如有疑问，请通过以下方式联系我们：

邮箱：[tilfon@live.com](mailto:tilfon@live.com)

网站: scripting.fun


